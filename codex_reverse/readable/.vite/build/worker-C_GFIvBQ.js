"use strict";

var mD = Object.create;
var QS = Object.defineProperty;
var AD = Object.getOwnPropertyDescriptor;
var gD = Object.getOwnPropertyNames;
var RD = Object.getPrototypeOf,
  ND = Object.prototype.hasOwnProperty;
var yD = (e, t, n, r) => {
  if ((t && typeof t == "object") || typeof t == "function")
    for (let o of gD(t))
      !ND.call(e, o) &&
        o !== n &&
        QS(e, o, {
          get: () => t[o],
          enumerable: !(r = AD(t, o)) || r.enumerable,
        });
  return e;
};
var Yl = (e, t, n) => (
  (n = e != null ? mD(RD(e)) : {}),
  yD(
    t || !e || !e.__esModule
      ? QS(n, "default", {
          value: e,
          enumerable: !0,
        })
      : n,
    e,
  )
);
const workerThreads = require("node:worker_threads"),
  path = require("path"),
  os2 = require("node:os"),
  path2 = require("node:path"),
  events = require("events"),
  childProcess = require("child_process"),
  fs = require("node:fs"),
  crypto = require("node:crypto"),
  childProcess2 = require("node:child_process"),
  buffer = require("node:buffer"),
  posix = require("path/posix"),
  stringDecoder = require("node:string_decoder"),
  util = require("node:util"),
  net = require("node:net");
require("crypto");
const fsPromises = require("node:fs/promises"),
  perfHooks = require("perf_hooks"),
  util2 = require("util"),
  url = require("url"),
  nodeModule = require("module"),
  tty = require("tty"),
  os3 = require("os"),
  workerThreads2 = require("worker_threads"),
  fs2 = require("fs"),
  diagnosticsChannel = require("node:diagnostics_channel"),
  events2 = require("node:events"),
  diagnosticsChannel2 = require("diagnostics_channel"),
  asyncHooks = require("async_hooks"),
  readline = require("node:readline"),
  http = require("node:http"),
  https = require("node:https"),
  stream = require("node:stream"),
  zlib = require("node:zlib"),
  tls = require("node:tls");
var jl = typeof document < "u" ? document.currentScript : null;
function cn(e) {
  const t = Object.create(null, {
    [Symbol.toStringTag]: {
      value: "Module",
    },
  });
  if (e) {
    for (const n in e)
      if (n !== "default") {
        const r = Object.getOwnPropertyDescriptor(e, n);
        Object.defineProperty(
          t,
          n,
          r.get
            ? r
            : {
                enumerable: !0,
                get: () => e[n],
              },
        );
      }
  }
  return ((t.default = e), Object.freeze(t));
}
const Yr = cn(path),
  Dt = cn(os2),
  Fb = cn(path2),
  GD = cn(util),
  Ao = cn(net),
  VD = cn(nodeModule),
  ou = cn(diagnosticsChannel),
  ql = cn(diagnosticsChannel2),
  su = cn(http),
  xD = cn(https),
  em = cn(tls);
var iu =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
      ? window
      : typeof global < "u"
        ? global
        : typeof self < "u"
          ? self
          : {};
function Qu(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default")
    ? e.default
    : e;
}
function Yb(e) {
  if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      var o = !1;
      try {
        o = this instanceof r;
      } catch {}
      return o
        ? Reflect.construct(t, arguments, this.constructor)
        : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else n = {};
  return (
    Object.defineProperty(n, "__esModule", {
      value: !0,
    }),
    Object.keys(e).forEach(function (r) {
      var o = Object.getOwnPropertyDescriptor(e, r);
      Object.defineProperty(
        n,
        r,
        o.get
          ? o
          : {
              enumerable: !0,
              get: function () {
                return e[r];
              },
            },
      );
    }),
    n
  );
}
var Wl = {},
  ur = {},
  Ni = {},
  yi = {},
  On = {},
  lr = {},
  dr = {},
  Oi = {},
  tm;
function $D() {
  return (
    tm ||
      ((tm = 1),
      Object.defineProperty(Oi, "__esModule", {
        value: !0,
      }),
      (Oi._globalThis = void 0),
      (Oi._globalThis = typeof globalThis == "object" ? globalThis : iu)),
    Oi
  );
}
var nm;
function BD() {
  return (
    nm ||
      ((nm = 1),
      (function (e) {
        var t =
            (dr && dr.__createBinding) ||
            (Object.create
              ? function (r, o, s, i) {
                  (i === void 0 && (i = s),
                    Object.defineProperty(r, i, {
                      enumerable: !0,
                      get: function () {
                        return o[s];
                      },
                    }));
                }
              : function (r, o, s, i) {
                  (i === void 0 && (i = s), (r[i] = o[s]));
                }),
          n =
            (dr && dr.__exportStar) ||
            function (r, o) {
              for (var s in r)
                s !== "default" &&
                  !Object.prototype.hasOwnProperty.call(o, s) &&
                  t(o, r, s);
            };
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          n($D(), e));
      })(dr)),
    dr
  );
}
var rm;
function HD() {
  return (
    rm ||
      ((rm = 1),
      (function (e) {
        var t =
            (lr && lr.__createBinding) ||
            (Object.create
              ? function (r, o, s, i) {
                  (i === void 0 && (i = s),
                    Object.defineProperty(r, i, {
                      enumerable: !0,
                      get: function () {
                        return o[s];
                      },
                    }));
                }
              : function (r, o, s, i) {
                  (i === void 0 && (i = s), (r[i] = o[s]));
                }),
          n =
            (lr && lr.__exportStar) ||
            function (r, o) {
              for (var s in r)
                s !== "default" &&
                  !Object.prototype.hasOwnProperty.call(o, s) &&
                  t(o, r, s);
            };
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          n(BD(), e));
      })(lr)),
    lr
  );
}
var Ci = {},
  om;
function jb() {
  return (
    om ||
      ((om = 1),
      Object.defineProperty(Ci, "__esModule", {
        value: !0,
      }),
      (Ci.VERSION = void 0),
      (Ci.VERSION = "1.9.0")),
    Ci
  );
}
var fr = {},
  sm;
function FD() {
  if (sm) return fr;
  ((sm = 1),
    Object.defineProperty(fr, "__esModule", {
      value: !0,
    }),
    (fr.isCompatible = fr._makeCompatibilityCheck = void 0));
  const e = jb(),
    t = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
  function n(r) {
    const o = new Set([r]),
      s = new Set(),
      i = r.match(t);
    if (!i) return () => !1;
    const a = {
      major: +i[1],
      minor: +i[2],
      patch: +i[3],
      prerelease: i[4],
    };
    if (a.prerelease != null)
      return function (d) {
        return d === r;
      };
    function c(f) {
      return (s.add(f), !1);
    }
    function l(f) {
      return (o.add(f), !0);
    }
    return function (d) {
      if (o.has(d)) return !0;
      if (s.has(d)) return !1;
      const u = d.match(t);
      if (!u) return c(d);
      const _ = {
        major: +u[1],
        minor: +u[2],
        patch: +u[3],
        prerelease: u[4],
      };
      return _.prerelease != null || a.major !== _.major
        ? c(d)
        : a.major === 0
          ? a.minor === _.minor && a.patch <= _.patch
            ? l(d)
            : c(d)
          : a.minor <= _.minor
            ? l(d)
            : c(d);
    };
  }
  return (
    (fr._makeCompatibilityCheck = n),
    (fr.isCompatible = n(e.VERSION)),
    fr
  );
}
var im;
function Wo() {
  if (im) return On;
  ((im = 1),
    Object.defineProperty(On, "__esModule", {
      value: !0,
    }),
    (On.unregisterGlobal = On.getGlobal = On.registerGlobal = void 0));
  const e = HD(),
    t = jb(),
    n = FD(),
    r = t.VERSION.split(".")[0],
    o = Symbol.for(`opentelemetry.js.api.${r}`),
    s = e._globalThis;
  function i(l, f, d, u = !1) {
    var _;
    const p = (s[o] =
      (_ = s[o]) !== null && _ !== void 0
        ? _
        : {
            version: t.VERSION,
          });
    if (!u && p[l]) {
      const E = new Error(
        `@opentelemetry/api: Attempted duplicate registration of API: ${l}`,
      );
      return (d.error(E.stack || E.message), !1);
    }
    if (p.version !== t.VERSION) {
      const E = new Error(
        `@opentelemetry/api: Registration of version v${p.version} for ${l} does not match previously registered API v${t.VERSION}`,
      );
      return (d.error(E.stack || E.message), !1);
    }
    return (
      (p[l] = f),
      d.debug(
        `@opentelemetry/api: Registered a global for ${l} v${t.VERSION}.`,
      ),
      !0
    );
  }
  On.registerGlobal = i;
  function a(l) {
    var f, d;
    const u = (f = s[o]) === null || f === void 0 ? void 0 : f.version;
    if (!(!u || !(0, n.isCompatible)(u)))
      return (d = s[o]) === null || d === void 0 ? void 0 : d[l];
  }
  On.getGlobal = a;
  function c(l, f) {
    f.debug(
      `@opentelemetry/api: Unregistering a global for ${l} v${t.VERSION}.`,
    );
    const d = s[o];
    d && delete d[l];
  }
  return ((On.unregisterGlobal = c), On);
}
var am;
function YD() {
  if (am) return yi;
  ((am = 1),
    Object.defineProperty(yi, "__esModule", {
      value: !0,
    }),
    (yi.DiagComponentLogger = void 0));
  const e = Wo();
  class t {
    constructor(o) {
      this._namespace = o.namespace || "DiagComponentLogger";
    }
    debug(...o) {
      return n("debug", this._namespace, o);
    }
    error(...o) {
      return n("error", this._namespace, o);
    }
    info(...o) {
      return n("info", this._namespace, o);
    }
    warn(...o) {
      return n("warn", this._namespace, o);
    }
    verbose(...o) {
      return n("verbose", this._namespace, o);
    }
  }
  yi.DiagComponentLogger = t;
  function n(r, o, s) {
    const i = (0, e.getGlobal)("diag");
    if (i) return (s.unshift(o), i[r](...s));
  }
  return yi;
}
var bi = {},
  Kl = {},
  cm;
function zp() {
  return (
    cm ||
      ((cm = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.DiagLogLevel = void 0),
          (function (t) {
            ((t[(t.NONE = 0)] = "NONE"),
              (t[(t.ERROR = 30)] = "ERROR"),
              (t[(t.WARN = 50)] = "WARN"),
              (t[(t.INFO = 60)] = "INFO"),
              (t[(t.DEBUG = 70)] = "DEBUG"),
              (t[(t.VERBOSE = 80)] = "VERBOSE"),
              (t[(t.ALL = 9999)] = "ALL"));
          })(e.DiagLogLevel || (e.DiagLogLevel = {})));
      })(Kl)),
    Kl
  );
}
var um;
function jD() {
  if (um) return bi;
  ((um = 1),
    Object.defineProperty(bi, "__esModule", {
      value: !0,
    }),
    (bi.createLogLevelDiagLogger = void 0));
  const e = zp();
  function t(n, r) {
    (n < e.DiagLogLevel.NONE
      ? (n = e.DiagLogLevel.NONE)
      : n > e.DiagLogLevel.ALL && (n = e.DiagLogLevel.ALL),
      (r = r || {}));
    function o(s, i) {
      const a = r[s];
      return typeof a == "function" && n >= i ? a.bind(r) : function () {};
    }
    return {
      error: o("error", e.DiagLogLevel.ERROR),
      warn: o("warn", e.DiagLogLevel.WARN),
      info: o("info", e.DiagLogLevel.INFO),
      debug: o("debug", e.DiagLogLevel.DEBUG),
      verbose: o("verbose", e.DiagLogLevel.VERBOSE),
    };
  }
  return ((bi.createLogLevelDiagLogger = t), bi);
}
var lm;
function Ko() {
  if (lm) return Ni;
  ((lm = 1),
    Object.defineProperty(Ni, "__esModule", {
      value: !0,
    }),
    (Ni.DiagAPI = void 0));
  const e = YD(),
    t = jD(),
    n = zp(),
    r = Wo(),
    o = "diag";
  class s {
    constructor() {
      function a(f) {
        return function (...d) {
          const u = (0, r.getGlobal)("diag");
          if (u) return u[f](...d);
        };
      }
      const c = this,
        l = (
          f,
          d = {
            logLevel: n.DiagLogLevel.INFO,
          },
        ) => {
          var u, _, p;
          if (f === c) {
            const T = new Error(
              "Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation",
            );
            return (
              c.error((u = T.stack) !== null && u !== void 0 ? u : T.message),
              !1
            );
          }
          typeof d == "number" &&
            (d = {
              logLevel: d,
            });
          const E = (0, r.getGlobal)("diag"),
            h = (0, t.createLogLevelDiagLogger)(
              (_ = d.logLevel) !== null && _ !== void 0
                ? _
                : n.DiagLogLevel.INFO,
              f,
            );
          if (E && !d.suppressOverrideMessage) {
            const T =
              (p = new Error().stack) !== null && p !== void 0
                ? p
                : "<failed to generate stacktrace>";
            (E.warn(`Current logger will be overwritten from ${T}`),
              h.warn(
                `Current logger will overwrite one already registered from ${T}`,
              ));
          }
          return (0, r.registerGlobal)("diag", h, c, !0);
        };
      ((c.setLogger = l),
        (c.disable = () => {
          (0, r.unregisterGlobal)(o, c);
        }),
        (c.createComponentLogger = (f) => new e.DiagComponentLogger(f)),
        (c.verbose = a("verbose")),
        (c.debug = a("debug")),
        (c.info = a("info")),
        (c.warn = a("warn")),
        (c.error = a("error")));
    }
    static instance() {
      return (this._instance || (this._instance = new s()), this._instance);
    }
  }
  return ((Ni.DiagAPI = s), Ni);
}
var Ii = {},
  dm;
function qD() {
  if (dm) return Ii;
  ((dm = 1),
    Object.defineProperty(Ii, "__esModule", {
      value: !0,
    }),
    (Ii.BaggageImpl = void 0));
  class e {
    constructor(n) {
      this._entries = n ? new Map(n) : new Map();
    }
    getEntry(n) {
      const r = this._entries.get(n);
      if (r) return Object.assign({}, r);
    }
    getAllEntries() {
      return Array.from(this._entries.entries()).map(([n, r]) => [n, r]);
    }
    setEntry(n, r) {
      const o = new e(this._entries);
      return (o._entries.set(n, r), o);
    }
    removeEntry(n) {
      const r = new e(this._entries);
      return (r._entries.delete(n), r);
    }
    removeEntries(...n) {
      const r = new e(this._entries);
      for (const o of n) r._entries.delete(o);
      return r;
    }
    clear() {
      return new e();
    }
  }
  return ((Ii.BaggageImpl = e), Ii);
}
var Pi = {},
  fm;
function WD() {
  return (
    fm ||
      ((fm = 1),
      Object.defineProperty(Pi, "__esModule", {
        value: !0,
      }),
      (Pi.baggageEntryMetadataSymbol = void 0),
      (Pi.baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata"))),
    Pi
  );
}
var _m;
function qb() {
  if (_m) return ur;
  ((_m = 1),
    Object.defineProperty(ur, "__esModule", {
      value: !0,
    }),
    (ur.baggageEntryMetadataFromString = ur.createBaggage = void 0));
  const e = Ko(),
    t = qD(),
    n = WD(),
    r = e.DiagAPI.instance();
  function o(i = {}) {
    return new t.BaggageImpl(new Map(Object.entries(i)));
  }
  ur.createBaggage = o;
  function s(i) {
    return (
      typeof i != "string" &&
        (r.error(
          `Cannot create baggage metadata from unknown type: ${typeof i}`,
        ),
        (i = "")),
      {
        __TYPE__: n.baggageEntryMetadataSymbol,
        toString() {
          return i;
        },
      }
    );
  }
  return ((ur.baggageEntryMetadataFromString = s), ur);
}
var _r = {},
  pm;
function Ju() {
  if (pm) return _r;
  ((pm = 1),
    Object.defineProperty(_r, "__esModule", {
      value: !0,
    }),
    (_r.ROOT_CONTEXT = _r.createContextKey = void 0));
  function e(n) {
    return Symbol.for(n);
  }
  _r.createContextKey = e;
  class t {
    constructor(r) {
      const o = this;
      ((o._currentContext = r ? new Map(r) : new Map()),
        (o.getValue = (s) => o._currentContext.get(s)),
        (o.setValue = (s, i) => {
          const a = new t(o._currentContext);
          return (a._currentContext.set(s, i), a);
        }),
        (o.deleteValue = (s) => {
          const i = new t(o._currentContext);
          return (i._currentContext.delete(s), i);
        }));
    }
  }
  return ((_r.ROOT_CONTEXT = new t()), _r);
}
var Mi = {},
  Em;
function KD() {
  if (Em) return Mi;
  ((Em = 1),
    Object.defineProperty(Mi, "__esModule", {
      value: !0,
    }),
    (Mi.DiagConsoleLogger = void 0));
  const e = [
    {
      n: "error",
      c: "error",
    },
    {
      n: "warn",
      c: "warn",
    },
    {
      n: "info",
      c: "info",
    },
    {
      n: "debug",
      c: "debug",
    },
    {
      n: "verbose",
      c: "trace",
    },
  ];
  class t {
    constructor() {
      function r(o) {
        return function (...s) {
          if (console) {
            let i = console[o];
            if (
              (typeof i != "function" && (i = console.log),
              typeof i == "function")
            )
              return i.apply(console, s);
          }
        };
      }
      for (let o = 0; o < e.length; o++) this[e[o].n] = r(e[o].c);
    }
  }
  return ((Mi.DiagConsoleLogger = t), Mi);
}
var zl = {},
  hm;
function Wb() {
  return (
    hm ||
      ((hm = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.createNoopMeter =
            e.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC =
            e.NOOP_OBSERVABLE_GAUGE_METRIC =
            e.NOOP_OBSERVABLE_COUNTER_METRIC =
            e.NOOP_UP_DOWN_COUNTER_METRIC =
            e.NOOP_HISTOGRAM_METRIC =
            e.NOOP_GAUGE_METRIC =
            e.NOOP_COUNTER_METRIC =
            e.NOOP_METER =
            e.NoopObservableUpDownCounterMetric =
            e.NoopObservableGaugeMetric =
            e.NoopObservableCounterMetric =
            e.NoopObservableMetric =
            e.NoopHistogramMetric =
            e.NoopGaugeMetric =
            e.NoopUpDownCounterMetric =
            e.NoopCounterMetric =
            e.NoopMetric =
            e.NoopMeter =
              void 0));
        class t {
          constructor() {}
          createGauge(_, p) {
            return e.NOOP_GAUGE_METRIC;
          }
          createHistogram(_, p) {
            return e.NOOP_HISTOGRAM_METRIC;
          }
          createCounter(_, p) {
            return e.NOOP_COUNTER_METRIC;
          }
          createUpDownCounter(_, p) {
            return e.NOOP_UP_DOWN_COUNTER_METRIC;
          }
          createObservableGauge(_, p) {
            return e.NOOP_OBSERVABLE_GAUGE_METRIC;
          }
          createObservableCounter(_, p) {
            return e.NOOP_OBSERVABLE_COUNTER_METRIC;
          }
          createObservableUpDownCounter(_, p) {
            return e.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
          }
          addBatchObservableCallback(_, p) {}
          removeBatchObservableCallback(_) {}
        }
        e.NoopMeter = t;
        class n {}
        e.NoopMetric = n;
        class r extends n {
          add(_, p) {}
        }
        e.NoopCounterMetric = r;
        class o extends n {
          add(_, p) {}
        }
        e.NoopUpDownCounterMetric = o;
        class s extends n {
          record(_, p) {}
        }
        e.NoopGaugeMetric = s;
        class i extends n {
          record(_, p) {}
        }
        e.NoopHistogramMetric = i;
        class a {
          addCallback(_) {}
          removeCallback(_) {}
        }
        e.NoopObservableMetric = a;
        class c extends a {}
        e.NoopObservableCounterMetric = c;
        class l extends a {}
        e.NoopObservableGaugeMetric = l;
        class f extends a {}
        ((e.NoopObservableUpDownCounterMetric = f),
          (e.NOOP_METER = new t()),
          (e.NOOP_COUNTER_METRIC = new r()),
          (e.NOOP_GAUGE_METRIC = new s()),
          (e.NOOP_HISTOGRAM_METRIC = new i()),
          (e.NOOP_UP_DOWN_COUNTER_METRIC = new o()),
          (e.NOOP_OBSERVABLE_COUNTER_METRIC = new c()),
          (e.NOOP_OBSERVABLE_GAUGE_METRIC = new l()),
          (e.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new f()));
        function d() {
          return e.NOOP_METER;
        }
        e.createNoopMeter = d;
      })(zl)),
    zl
  );
}
var Zl = {},
  Tm;
function zD() {
  return (
    Tm ||
      ((Tm = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.ValueType = void 0),
          (function (t) {
            ((t[(t.INT = 0)] = "INT"), (t[(t.DOUBLE = 1)] = "DOUBLE"));
          })(e.ValueType || (e.ValueType = {})));
      })(Zl)),
    Zl
  );
}
var pr = {},
  Sm;
function Kb() {
  return (
    Sm ||
      ((Sm = 1),
      Object.defineProperty(pr, "__esModule", {
        value: !0,
      }),
      (pr.defaultTextMapSetter = pr.defaultTextMapGetter = void 0),
      (pr.defaultTextMapGetter = {
        get(e, t) {
          if (e != null) return e[t];
        },
        keys(e) {
          return e == null ? [] : Object.keys(e);
        },
      }),
      (pr.defaultTextMapSetter = {
        set(e, t, n) {
          e != null && (e[t] = n);
        },
      })),
    pr
  );
}
var vi = {},
  Li = {},
  Di = {},
  wi = {},
  mm;
function ZD() {
  if (mm) return wi;
  ((mm = 1),
    Object.defineProperty(wi, "__esModule", {
      value: !0,
    }),
    (wi.NoopContextManager = void 0));
  const e = Ju();
  let t = class {
    active() {
      return e.ROOT_CONTEXT;
    }
    with(r, o, s, ...i) {
      return o.call(s, ...i);
    }
    bind(r, o) {
      return o;
    }
    enable() {
      return this;
    }
    disable() {
      return this;
    }
  };
  return ((wi.NoopContextManager = t), wi);
}
var Am;
function el() {
  if (Am) return Di;
  ((Am = 1),
    Object.defineProperty(Di, "__esModule", {
      value: !0,
    }),
    (Di.ContextAPI = void 0));
  const e = ZD(),
    t = Wo(),
    n = Ko(),
    r = "context",
    o = new e.NoopContextManager();
  class s {
    constructor() {}
    static getInstance() {
      return (this._instance || (this._instance = new s()), this._instance);
    }
    setGlobalContextManager(a) {
      return (0, t.registerGlobal)(r, a, n.DiagAPI.instance());
    }
    active() {
      return this._getContextManager().active();
    }
    with(a, c, l, ...f) {
      return this._getContextManager().with(a, c, l, ...f);
    }
    bind(a, c) {
      return this._getContextManager().bind(a, c);
    }
    _getContextManager() {
      return (0, t.getGlobal)(r) || o;
    }
    disable() {
      (this._getContextManager().disable(),
        (0, t.unregisterGlobal)(r, n.DiagAPI.instance()));
    }
  }
  return ((Di.ContextAPI = s), Di);
}
var Et = {},
  Ui = {},
  Xl = {},
  Ql = {},
  gm;
function zb() {
  return (
    gm ||
      ((gm = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.TraceFlags = void 0),
          (function (t) {
            ((t[(t.NONE = 0)] = "NONE"), (t[(t.SAMPLED = 1)] = "SAMPLED"));
          })(e.TraceFlags || (e.TraceFlags = {})));
      })(Ql)),
    Ql
  );
}
var Rm;
function Zp() {
  return (
    Rm ||
      ((Rm = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.INVALID_SPAN_CONTEXT =
            e.INVALID_TRACEID =
            e.INVALID_SPANID =
              void 0));
        const t = zb();
        ((e.INVALID_SPANID = "0000000000000000"),
          (e.INVALID_TRACEID = "00000000000000000000000000000000"),
          (e.INVALID_SPAN_CONTEXT = {
            traceId: e.INVALID_TRACEID,
            spanId: e.INVALID_SPANID,
            traceFlags: t.TraceFlags.NONE,
          }));
      })(Xl)),
    Xl
  );
}
var Nm;
function Xp() {
  if (Nm) return Ui;
  ((Nm = 1),
    Object.defineProperty(Ui, "__esModule", {
      value: !0,
    }),
    (Ui.NonRecordingSpan = void 0));
  const e = Zp();
  let t = class {
    constructor(r = e.INVALID_SPAN_CONTEXT) {
      this._spanContext = r;
    }
    spanContext() {
      return this._spanContext;
    }
    setAttribute(r, o) {
      return this;
    }
    setAttributes(r) {
      return this;
    }
    addEvent(r, o) {
      return this;
    }
    addLink(r) {
      return this;
    }
    addLinks(r) {
      return this;
    }
    setStatus(r) {
      return this;
    }
    updateName(r) {
      return this;
    }
    end(r) {}
    isRecording() {
      return !1;
    }
    recordException(r, o) {}
  };
  return ((Ui.NonRecordingSpan = t), Ui);
}
var ym;
function Zb() {
  if (ym) return Et;
  ((ym = 1),
    Object.defineProperty(Et, "__esModule", {
      value: !0,
    }),
    (Et.getSpanContext =
      Et.setSpanContext =
      Et.deleteSpan =
      Et.setSpan =
      Et.getActiveSpan =
      Et.getSpan =
        void 0));
  const e = Ju(),
    t = Xp(),
    n = el(),
    r = (0, e.createContextKey)("OpenTelemetry Context Key SPAN");
  function o(f) {
    return f.getValue(r) || void 0;
  }
  Et.getSpan = o;
  function s() {
    return o(n.ContextAPI.getInstance().active());
  }
  Et.getActiveSpan = s;
  function i(f, d) {
    return f.setValue(r, d);
  }
  Et.setSpan = i;
  function a(f) {
    return f.deleteValue(r);
  }
  Et.deleteSpan = a;
  function c(f, d) {
    return i(f, new t.NonRecordingSpan(d));
  }
  Et.setSpanContext = c;
  function l(f) {
    var d;
    return (d = o(f)) === null || d === void 0 ? void 0 : d.spanContext();
  }
  return ((Et.getSpanContext = l), Et);
}
var Xt = {},
  Om;
function Qp() {
  if (Om) return Xt;
  ((Om = 1),
    Object.defineProperty(Xt, "__esModule", {
      value: !0,
    }),
    (Xt.wrapSpanContext =
      Xt.isSpanContextValid =
      Xt.isValidSpanId =
      Xt.isValidTraceId =
        void 0));
  const e = Zp(),
    t = Xp(),
    n = /^([0-9a-f]{32})$/i,
    r = /^[0-9a-f]{16}$/i;
  function o(c) {
    return n.test(c) && c !== e.INVALID_TRACEID;
  }
  Xt.isValidTraceId = o;
  function s(c) {
    return r.test(c) && c !== e.INVALID_SPANID;
  }
  Xt.isValidSpanId = s;
  function i(c) {
    return o(c.traceId) && s(c.spanId);
  }
  Xt.isSpanContextValid = i;
  function a(c) {
    return new t.NonRecordingSpan(c);
  }
  return ((Xt.wrapSpanContext = a), Xt);
}
var Cm;
function Xb() {
  if (Cm) return Li;
  ((Cm = 1),
    Object.defineProperty(Li, "__esModule", {
      value: !0,
    }),
    (Li.NoopTracer = void 0));
  const e = el(),
    t = Zb(),
    n = Xp(),
    r = Qp(),
    o = e.ContextAPI.getInstance();
  let s = class {
    startSpan(c, l, f = o.active()) {
      if (!!l?.root) return new n.NonRecordingSpan();
      const u = f && (0, t.getSpanContext)(f);
      return i(u) && (0, r.isSpanContextValid)(u)
        ? new n.NonRecordingSpan(u)
        : new n.NonRecordingSpan();
    }
    startActiveSpan(c, l, f, d) {
      let u, _, p;
      if (arguments.length < 2) return;
      arguments.length === 2
        ? (p = l)
        : arguments.length === 3
          ? ((u = l), (p = f))
          : ((u = l), (_ = f), (p = d));
      const E = _ ?? o.active(),
        h = this.startSpan(c, u, E),
        T = (0, t.setSpan)(E, h);
      return o.with(T, p, void 0, h);
    }
  };
  Li.NoopTracer = s;
  function i(a) {
    return (
      typeof a == "object" &&
      typeof a.spanId == "string" &&
      typeof a.traceId == "string" &&
      typeof a.traceFlags == "number"
    );
  }
  return Li;
}
var bm;
function Qb() {
  if (bm) return vi;
  ((bm = 1),
    Object.defineProperty(vi, "__esModule", {
      value: !0,
    }),
    (vi.ProxyTracer = void 0));
  const e = Xb(),
    t = new e.NoopTracer();
  let n = class {
    constructor(o, s, i, a) {
      ((this._provider = o),
        (this.name = s),
        (this.version = i),
        (this.options = a));
    }
    startSpan(o, s, i) {
      return this._getTracer().startSpan(o, s, i);
    }
    startActiveSpan(o, s, i, a) {
      const c = this._getTracer();
      return Reflect.apply(c.startActiveSpan, c, arguments);
    }
    _getTracer() {
      if (this._delegate) return this._delegate;
      const o = this._provider.getDelegateTracer(
        this.name,
        this.version,
        this.options,
      );
      return o ? ((this._delegate = o), this._delegate) : t;
    }
  };
  return ((vi.ProxyTracer = n), vi);
}
var ki = {},
  Gi = {},
  Im;
function XD() {
  if (Im) return Gi;
  ((Im = 1),
    Object.defineProperty(Gi, "__esModule", {
      value: !0,
    }),
    (Gi.NoopTracerProvider = void 0));
  const e = Xb();
  let t = class {
    getTracer(r, o, s) {
      return new e.NoopTracer();
    }
  };
  return ((Gi.NoopTracerProvider = t), Gi);
}
var Pm;
function Jb() {
  if (Pm) return ki;
  ((Pm = 1),
    Object.defineProperty(ki, "__esModule", {
      value: !0,
    }),
    (ki.ProxyTracerProvider = void 0));
  const e = Qb(),
    t = XD(),
    n = new t.NoopTracerProvider();
  let r = class {
    getTracer(s, i, a) {
      var c;
      return (c = this.getDelegateTracer(s, i, a)) !== null && c !== void 0
        ? c
        : new e.ProxyTracer(this, s, i, a);
    }
    getDelegate() {
      var s;
      return (s = this._delegate) !== null && s !== void 0 ? s : n;
    }
    setDelegate(s) {
      this._delegate = s;
    }
    getDelegateTracer(s, i, a) {
      var c;
      return (c = this._delegate) === null || c === void 0
        ? void 0
        : c.getTracer(s, i, a);
    }
  };
  return ((ki.ProxyTracerProvider = r), ki);
}
var Jl = {},
  Mm;
function QD() {
  return (
    Mm ||
      ((Mm = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.SamplingDecision = void 0),
          (function (t) {
            ((t[(t.NOT_RECORD = 0)] = "NOT_RECORD"),
              (t[(t.RECORD = 1)] = "RECORD"),
              (t[(t.RECORD_AND_SAMPLED = 2)] = "RECORD_AND_SAMPLED"));
          })(e.SamplingDecision || (e.SamplingDecision = {})));
      })(Jl)),
    Jl
  );
}
var ed = {},
  vm;
function JD() {
  return (
    vm ||
      ((vm = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.SpanKind = void 0),
          (function (t) {
            ((t[(t.INTERNAL = 0)] = "INTERNAL"),
              (t[(t.SERVER = 1)] = "SERVER"),
              (t[(t.CLIENT = 2)] = "CLIENT"),
              (t[(t.PRODUCER = 3)] = "PRODUCER"),
              (t[(t.CONSUMER = 4)] = "CONSUMER"));
          })(e.SpanKind || (e.SpanKind = {})));
      })(ed)),
    ed
  );
}
var td = {},
  Lm;
function ew() {
  return (
    Lm ||
      ((Lm = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.SpanStatusCode = void 0),
          (function (t) {
            ((t[(t.UNSET = 0)] = "UNSET"),
              (t[(t.OK = 1)] = "OK"),
              (t[(t.ERROR = 2)] = "ERROR"));
          })(e.SpanStatusCode || (e.SpanStatusCode = {})));
      })(td)),
    td
  );
}
var Vi = {},
  xi = {},
  Er = {},
  Dm;
function tw() {
  if (Dm) return Er;
  ((Dm = 1),
    Object.defineProperty(Er, "__esModule", {
      value: !0,
    }),
    (Er.validateValue = Er.validateKey = void 0));
  const e = "[_0-9a-z-*/]",
    t = `[a-z]${e}{0,255}`,
    n = `[a-z0-9]${e}{0,240}@[a-z]${e}{0,13}`,
    r = new RegExp(`^(?:${t}|${n})$`),
    o = /^[ -~]{0,255}[!-~]$/,
    s = /,|=/;
  function i(c) {
    return r.test(c);
  }
  Er.validateKey = i;
  function a(c) {
    return o.test(c) && !s.test(c);
  }
  return ((Er.validateValue = a), Er);
}
var wm;
function nw() {
  if (wm) return xi;
  ((wm = 1),
    Object.defineProperty(xi, "__esModule", {
      value: !0,
    }),
    (xi.TraceStateImpl = void 0));
  const e = tw(),
    t = 32,
    n = 512,
    r = ",",
    o = "=";
  class s {
    constructor(a) {
      ((this._internalState = new Map()), a && this._parse(a));
    }
    set(a, c) {
      const l = this._clone();
      return (
        l._internalState.has(a) && l._internalState.delete(a),
        l._internalState.set(a, c),
        l
      );
    }
    unset(a) {
      const c = this._clone();
      return (c._internalState.delete(a), c);
    }
    get(a) {
      return this._internalState.get(a);
    }
    serialize() {
      return this._keys()
        .reduce((a, c) => (a.push(c + o + this.get(c)), a), [])
        .join(r);
    }
    _parse(a) {
      a.length > n ||
        ((this._internalState = a
          .split(r)
          .reverse()
          .reduce((c, l) => {
            const f = l.trim(),
              d = f.indexOf(o);
            if (d !== -1) {
              const u = f.slice(0, d),
                _ = f.slice(d + 1, l.length);
              (0, e.validateKey)(u) && (0, e.validateValue)(_) && c.set(u, _);
            }
            return c;
          }, new Map())),
        this._internalState.size > t &&
          (this._internalState = new Map(
            Array.from(this._internalState.entries()).reverse().slice(0, t),
          )));
    }
    _keys() {
      return Array.from(this._internalState.keys()).reverse();
    }
    _clone() {
      const a = new s();
      return ((a._internalState = new Map(this._internalState)), a);
    }
  }
  return ((xi.TraceStateImpl = s), xi);
}
var Um;
function rw() {
  if (Um) return Vi;
  ((Um = 1),
    Object.defineProperty(Vi, "__esModule", {
      value: !0,
    }),
    (Vi.createTraceState = void 0));
  const e = nw();
  function t(n) {
    return new e.TraceStateImpl(n);
  }
  return ((Vi.createTraceState = t), Vi);
}
var $i = {},
  km;
function ow() {
  if (km) return $i;
  ((km = 1),
    Object.defineProperty($i, "__esModule", {
      value: !0,
    }),
    ($i.context = void 0));
  const e = el();
  return (($i.context = e.ContextAPI.getInstance()), $i);
}
var Bi = {},
  Gm;
function sw() {
  if (Gm) return Bi;
  ((Gm = 1),
    Object.defineProperty(Bi, "__esModule", {
      value: !0,
    }),
    (Bi.diag = void 0));
  const e = Ko();
  return ((Bi.diag = e.DiagAPI.instance()), Bi);
}
var Hi = {},
  Fi = {},
  hr = {},
  Vm;
function iw() {
  if (Vm) return hr;
  ((Vm = 1),
    Object.defineProperty(hr, "__esModule", {
      value: !0,
    }),
    (hr.NOOP_METER_PROVIDER = hr.NoopMeterProvider = void 0));
  const e = Wb();
  let t = class {
    getMeter(r, o, s) {
      return e.NOOP_METER;
    }
  };
  return ((hr.NoopMeterProvider = t), (hr.NOOP_METER_PROVIDER = new t()), hr);
}
var xm;
function aw() {
  if (xm) return Fi;
  ((xm = 1),
    Object.defineProperty(Fi, "__esModule", {
      value: !0,
    }),
    (Fi.MetricsAPI = void 0));
  const e = iw(),
    t = Wo(),
    n = Ko(),
    r = "metrics";
  class o {
    constructor() {}
    static getInstance() {
      return (this._instance || (this._instance = new o()), this._instance);
    }
    setGlobalMeterProvider(i) {
      return (0, t.registerGlobal)(r, i, n.DiagAPI.instance());
    }
    getMeterProvider() {
      return (0, t.getGlobal)(r) || e.NOOP_METER_PROVIDER;
    }
    getMeter(i, a, c) {
      return this.getMeterProvider().getMeter(i, a, c);
    }
    disable() {
      (0, t.unregisterGlobal)(r, n.DiagAPI.instance());
    }
  }
  return ((Fi.MetricsAPI = o), Fi);
}
var $m;
function cw() {
  if ($m) return Hi;
  (($m = 1),
    Object.defineProperty(Hi, "__esModule", {
      value: !0,
    }),
    (Hi.metrics = void 0));
  const e = aw();
  return ((Hi.metrics = e.MetricsAPI.getInstance()), Hi);
}
var Yi = {},
  ji = {},
  qi = {},
  Bm;
function uw() {
  if (Bm) return qi;
  ((Bm = 1),
    Object.defineProperty(qi, "__esModule", {
      value: !0,
    }),
    (qi.NoopTextMapPropagator = void 0));
  let e = class {
    inject(n, r) {}
    extract(n, r) {
      return n;
    }
    fields() {
      return [];
    }
  };
  return ((qi.NoopTextMapPropagator = e), qi);
}
var Qt = {},
  Hm;
function lw() {
  if (Hm) return Qt;
  ((Hm = 1),
    Object.defineProperty(Qt, "__esModule", {
      value: !0,
    }),
    (Qt.deleteBaggage =
      Qt.setBaggage =
      Qt.getActiveBaggage =
      Qt.getBaggage =
        void 0));
  const e = el(),
    n = (0, Ju().createContextKey)("OpenTelemetry Baggage Key");
  function r(a) {
    return a.getValue(n) || void 0;
  }
  Qt.getBaggage = r;
  function o() {
    return r(e.ContextAPI.getInstance().active());
  }
  Qt.getActiveBaggage = o;
  function s(a, c) {
    return a.setValue(n, c);
  }
  Qt.setBaggage = s;
  function i(a) {
    return a.deleteValue(n);
  }
  return ((Qt.deleteBaggage = i), Qt);
}
var Fm;
function dw() {
  if (Fm) return ji;
  ((Fm = 1),
    Object.defineProperty(ji, "__esModule", {
      value: !0,
    }),
    (ji.PropagationAPI = void 0));
  const e = Wo(),
    t = uw(),
    n = Kb(),
    r = lw(),
    o = qb(),
    s = Ko(),
    i = "propagation",
    a = new t.NoopTextMapPropagator();
  class c {
    constructor() {
      ((this.createBaggage = o.createBaggage),
        (this.getBaggage = r.getBaggage),
        (this.getActiveBaggage = r.getActiveBaggage),
        (this.setBaggage = r.setBaggage),
        (this.deleteBaggage = r.deleteBaggage));
    }
    static getInstance() {
      return (this._instance || (this._instance = new c()), this._instance);
    }
    setGlobalPropagator(f) {
      return (0, e.registerGlobal)(i, f, s.DiagAPI.instance());
    }
    inject(f, d, u = n.defaultTextMapSetter) {
      return this._getGlobalPropagator().inject(f, d, u);
    }
    extract(f, d, u = n.defaultTextMapGetter) {
      return this._getGlobalPropagator().extract(f, d, u);
    }
    fields() {
      return this._getGlobalPropagator().fields();
    }
    disable() {
      (0, e.unregisterGlobal)(i, s.DiagAPI.instance());
    }
    _getGlobalPropagator() {
      return (0, e.getGlobal)(i) || a;
    }
  }
  return ((ji.PropagationAPI = c), ji);
}
var Ym;
function fw() {
  if (Ym) return Yi;
  ((Ym = 1),
    Object.defineProperty(Yi, "__esModule", {
      value: !0,
    }),
    (Yi.propagation = void 0));
  const e = dw();
  return ((Yi.propagation = e.PropagationAPI.getInstance()), Yi);
}
var Wi = {},
  Ki = {},
  jm;
function _w() {
  if (jm) return Ki;
  ((jm = 1),
    Object.defineProperty(Ki, "__esModule", {
      value: !0,
    }),
    (Ki.TraceAPI = void 0));
  const e = Wo(),
    t = Jb(),
    n = Qp(),
    r = Zb(),
    o = Ko(),
    s = "trace";
  class i {
    constructor() {
      ((this._proxyTracerProvider = new t.ProxyTracerProvider()),
        (this.wrapSpanContext = n.wrapSpanContext),
        (this.isSpanContextValid = n.isSpanContextValid),
        (this.deleteSpan = r.deleteSpan),
        (this.getSpan = r.getSpan),
        (this.getActiveSpan = r.getActiveSpan),
        (this.getSpanContext = r.getSpanContext),
        (this.setSpan = r.setSpan),
        (this.setSpanContext = r.setSpanContext));
    }
    static getInstance() {
      return (this._instance || (this._instance = new i()), this._instance);
    }
    setGlobalTracerProvider(c) {
      const l = (0, e.registerGlobal)(
        s,
        this._proxyTracerProvider,
        o.DiagAPI.instance(),
      );
      return (l && this._proxyTracerProvider.setDelegate(c), l);
    }
    getTracerProvider() {
      return (0, e.getGlobal)(s) || this._proxyTracerProvider;
    }
    getTracer(c, l) {
      return this.getTracerProvider().getTracer(c, l);
    }
    disable() {
      ((0, e.unregisterGlobal)(s, o.DiagAPI.instance()),
        (this._proxyTracerProvider = new t.ProxyTracerProvider()));
    }
  }
  return ((Ki.TraceAPI = i), Ki);
}
var qm;
function pw() {
  if (qm) return Wi;
  ((qm = 1),
    Object.defineProperty(Wi, "__esModule", {
      value: !0,
    }),
    (Wi.trace = void 0));
  const e = _w();
  return ((Wi.trace = e.TraceAPI.getInstance()), Wi);
}
var Wm;
function Pe() {
  return (
    Wm ||
      ((Wm = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.trace =
            e.propagation =
            e.metrics =
            e.diag =
            e.context =
            e.INVALID_SPAN_CONTEXT =
            e.INVALID_TRACEID =
            e.INVALID_SPANID =
            e.isValidSpanId =
            e.isValidTraceId =
            e.isSpanContextValid =
            e.createTraceState =
            e.TraceFlags =
            e.SpanStatusCode =
            e.SpanKind =
            e.SamplingDecision =
            e.ProxyTracerProvider =
            e.ProxyTracer =
            e.defaultTextMapSetter =
            e.defaultTextMapGetter =
            e.ValueType =
            e.createNoopMeter =
            e.DiagLogLevel =
            e.DiagConsoleLogger =
            e.ROOT_CONTEXT =
            e.createContextKey =
            e.baggageEntryMetadataFromString =
              void 0));
        var t = qb();
        Object.defineProperty(e, "baggageEntryMetadataFromString", {
          enumerable: !0,
          get: function () {
            return t.baggageEntryMetadataFromString;
          },
        });
        var n = Ju();
        (Object.defineProperty(e, "createContextKey", {
          enumerable: !0,
          get: function () {
            return n.createContextKey;
          },
        }),
          Object.defineProperty(e, "ROOT_CONTEXT", {
            enumerable: !0,
            get: function () {
              return n.ROOT_CONTEXT;
            },
          }));
        var r = KD();
        Object.defineProperty(e, "DiagConsoleLogger", {
          enumerable: !0,
          get: function () {
            return r.DiagConsoleLogger;
          },
        });
        var o = zp();
        Object.defineProperty(e, "DiagLogLevel", {
          enumerable: !0,
          get: function () {
            return o.DiagLogLevel;
          },
        });
        var s = Wb();
        Object.defineProperty(e, "createNoopMeter", {
          enumerable: !0,
          get: function () {
            return s.createNoopMeter;
          },
        });
        var i = zD();
        Object.defineProperty(e, "ValueType", {
          enumerable: !0,
          get: function () {
            return i.ValueType;
          },
        });
        var a = Kb();
        (Object.defineProperty(e, "defaultTextMapGetter", {
          enumerable: !0,
          get: function () {
            return a.defaultTextMapGetter;
          },
        }),
          Object.defineProperty(e, "defaultTextMapSetter", {
            enumerable: !0,
            get: function () {
              return a.defaultTextMapSetter;
            },
          }));
        var c = Qb();
        Object.defineProperty(e, "ProxyTracer", {
          enumerable: !0,
          get: function () {
            return c.ProxyTracer;
          },
        });
        var l = Jb();
        Object.defineProperty(e, "ProxyTracerProvider", {
          enumerable: !0,
          get: function () {
            return l.ProxyTracerProvider;
          },
        });
        var f = QD();
        Object.defineProperty(e, "SamplingDecision", {
          enumerable: !0,
          get: function () {
            return f.SamplingDecision;
          },
        });
        var d = JD();
        Object.defineProperty(e, "SpanKind", {
          enumerable: !0,
          get: function () {
            return d.SpanKind;
          },
        });
        var u = ew();
        Object.defineProperty(e, "SpanStatusCode", {
          enumerable: !0,
          get: function () {
            return u.SpanStatusCode;
          },
        });
        var _ = zb();
        Object.defineProperty(e, "TraceFlags", {
          enumerable: !0,
          get: function () {
            return _.TraceFlags;
          },
        });
        var p = rw();
        Object.defineProperty(e, "createTraceState", {
          enumerable: !0,
          get: function () {
            return p.createTraceState;
          },
        });
        var E = Qp();
        (Object.defineProperty(e, "isSpanContextValid", {
          enumerable: !0,
          get: function () {
            return E.isSpanContextValid;
          },
        }),
          Object.defineProperty(e, "isValidTraceId", {
            enumerable: !0,
            get: function () {
              return E.isValidTraceId;
            },
          }),
          Object.defineProperty(e, "isValidSpanId", {
            enumerable: !0,
            get: function () {
              return E.isValidSpanId;
            },
          }));
        var h = Zp();
        (Object.defineProperty(e, "INVALID_SPANID", {
          enumerable: !0,
          get: function () {
            return h.INVALID_SPANID;
          },
        }),
          Object.defineProperty(e, "INVALID_TRACEID", {
            enumerable: !0,
            get: function () {
              return h.INVALID_TRACEID;
            },
          }),
          Object.defineProperty(e, "INVALID_SPAN_CONTEXT", {
            enumerable: !0,
            get: function () {
              return h.INVALID_SPAN_CONTEXT;
            },
          }));
        const T = ow();
        Object.defineProperty(e, "context", {
          enumerable: !0,
          get: function () {
            return T.context;
          },
        });
        const m = sw();
        Object.defineProperty(e, "diag", {
          enumerable: !0,
          get: function () {
            return m.diag;
          },
        });
        const A = cw();
        Object.defineProperty(e, "metrics", {
          enumerable: !0,
          get: function () {
            return A.metrics;
          },
        });
        const g = fw();
        Object.defineProperty(e, "propagation", {
          enumerable: !0,
          get: function () {
            return g.propagation;
          },
        });
        const N = pw();
        (Object.defineProperty(e, "trace", {
          enumerable: !0,
          get: function () {
            return N.trace;
          },
        }),
          (e.default = {
            context: T.context,
            diag: m.diag,
            metrics: A.metrics,
            propagation: g.propagation,
            trace: N.trace,
          }));
      })(Wl)),
    Wl
  );
}
var C = Pe(),
  nd = {},
  zi = {};
const Jp = C.createContextKey("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
function zr(e) {
  return e.setValue(Jp, !0);
}
function Ew(e) {
  return e.deleteValue(Jp);
}
function Rn(e) {
  return e.getValue(Jp) === !0;
}
const hw = "=",
  op = ";",
  au = ",",
  rd = "baggage",
  Tw = 180,
  Sw = 4096,
  mw = 8192;
function Aw(e) {
  return e.reduce((t, n) => {
    const r = `${t}${t !== "" ? au : ""}${n}`;
    return r.length > mw ? t : r;
  }, "");
}
function gw(e) {
  return e.getAllEntries().map(([t, n]) => {
    let r = `${encodeURIComponent(t)}=${encodeURIComponent(n.value)}`;
    return (n.metadata !== void 0 && (r += op + n.metadata.toString()), r);
  });
}
function eI(e) {
  const t = e.split(op);
  if (t.length <= 0) return;
  const n = t.shift();
  if (!n) return;
  const r = n.indexOf(hw);
  if (r <= 0) return;
  const o = decodeURIComponent(n.substring(0, r).trim()),
    s = decodeURIComponent(n.substring(r + 1).trim());
  let i;
  return (
    t.length > 0 && (i = C.baggageEntryMetadataFromString(t.join(op))),
    {
      key: o,
      value: s,
      metadata: i,
    }
  );
}
function Rw(e) {
  const t = {};
  return (
    typeof e == "string" &&
      e.length > 0 &&
      e.split(au).forEach((n) => {
        const r = eI(n);
        r !== void 0 && r.value.length > 0 && (t[r.key] = r.value);
      }),
    t
  );
}
class tI {
  inject(t, n, r) {
    const o = C.propagation.getBaggage(t);
    if (!o || Rn(t)) return;
    const s = gw(o)
        .filter((a) => a.length <= Sw)
        .slice(0, Tw),
      i = Aw(s);
    i.length > 0 && r.set(n, rd, i);
  }
  extract(t, n, r) {
    const o = r.get(n, rd),
      s = Array.isArray(o) ? o.join(au) : o;
    if (!s) return t;
    const i = {};
    return s.length === 0 ||
      (s.split(au).forEach((c) => {
        const l = eI(c);
        if (l) {
          const f = {
            value: l.value,
          };
          (l.metadata && (f.metadata = l.metadata), (i[l.key] = f));
        }
      }),
      Object.entries(i).length === 0)
      ? t
      : C.propagation.setBaggage(t, C.propagation.createBaggage(i));
  }
  fields() {
    return [rd];
  }
}
class Nw {
  _monotonicClock;
  _epochMillis;
  _performanceMillis;
  constructor(t, n) {
    ((this._monotonicClock = n),
      (this._epochMillis = t.now()),
      (this._performanceMillis = n.now()));
  }
  now() {
    const t = this._monotonicClock.now() - this._performanceMillis;
    return this._epochMillis + t;
  }
}
function qa(e) {
  const t = {};
  if (typeof e != "object" || e == null) return t;
  for (const n in e) {
    if (!Object.prototype.hasOwnProperty.call(e, n)) continue;
    if (!yw(n)) {
      C.diag.warn(`Invalid attribute key: ${n}`);
      continue;
    }
    const r = e[n];
    if (!eE(r)) {
      C.diag.warn(`Invalid attribute value set for key: ${n}`);
      continue;
    }
    Array.isArray(r) ? (t[n] = r.slice()) : (t[n] = r);
  }
  return t;
}
function yw(e) {
  return typeof e == "string" && e !== "";
}
function eE(e) {
  return e == null ? !0 : Array.isArray(e) ? Ow(e) : nI(typeof e);
}
function Ow(e) {
  let t;
  for (const n of e) {
    if (n == null) continue;
    const r = typeof n;
    if (r !== t) {
      if (!t) {
        if (nI(r)) {
          t = r;
          continue;
        }
        return !1;
      }
      return !1;
    }
  }
  return !0;
}
function nI(e) {
  switch (e) {
    case "number":
    case "boolean":
    case "string":
      return !0;
  }
  return !1;
}
function rI() {
  return (e) => {
    C.diag.error(Cw(e));
  };
}
function Cw(e) {
  return typeof e == "string" ? e : JSON.stringify(bw(e));
}
function bw(e) {
  const t = {};
  let n = e;
  for (; n !== null; )
    (Object.getOwnPropertyNames(n).forEach((r) => {
      if (t[r]) return;
      const o = n[r];
      o && (t[r] = String(o));
    }),
      (n = Object.getPrototypeOf(n)));
  return t;
}
let oI = rI();
function Iw(e) {
  oI = e;
}
function tE(e) {
  try {
    oI(e);
  } catch {}
}
function Ct(e) {
  const t = process.env[e];
  if (t == null || t.trim() === "") return;
  const n = Number(t);
  if (isNaN(n)) {
    C.diag.warn(
      `Unknown value ${util2.inspect(t)} for ${e}, expected a number, using defaults`,
    );
    return;
  }
  return n;
}
function nE(e) {
  const t = process.env[e];
  if (!(t == null || t.trim() === "")) return t;
}
function Pw(e) {
  const t = process.env[e]?.trim().toLowerCase();
  return t == null || t === ""
    ? !1
    : t === "true"
      ? !0
      : (t === "false" ||
          C.diag.warn(
            `Unknown value ${util2.inspect(t)} for ${e}, expected 'true' or 'false', falling back to 'false' (default)`,
          ),
        !1);
}
function Mw(e) {
  return nE(e)
    ?.split(",")
    .map((t) => t.trim())
    .filter((t) => t !== "");
}
const vw = typeof globalThis == "object" ? globalThis : global,
  Wr = perfHooks.performance,
  Lw = "2.2.0";
var Tr = {},
  Sr = {},
  S = {},
  Zi = {},
  Km;
function sI() {
  if (Km) return Zi;
  ((Km = 1),
    Object.defineProperty(Zi, "__esModule", {
      value: !0,
    }),
    (Zi.createConstMap = void 0));
  function e(t) {
    let n = {};
    const r = t.length;
    for (let o = 0; o < r; o++) {
      const s = t[o];
      s && (n[String(s).toUpperCase().replace(/[-.]/g, "_")] = s);
    }
    return n;
  }
  return ((Zi.createConstMap = e), Zi);
}
var zm;
function Dw() {
  if (zm) return S;
  ((zm = 1),
    Object.defineProperty(S, "__esModule", {
      value: !0,
    }),
    (S.SEMATTRS_NET_HOST_CARRIER_ICC =
      S.SEMATTRS_NET_HOST_CARRIER_MNC =
      S.SEMATTRS_NET_HOST_CARRIER_MCC =
      S.SEMATTRS_NET_HOST_CARRIER_NAME =
      S.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE =
      S.SEMATTRS_NET_HOST_CONNECTION_TYPE =
      S.SEMATTRS_NET_HOST_NAME =
      S.SEMATTRS_NET_HOST_PORT =
      S.SEMATTRS_NET_HOST_IP =
      S.SEMATTRS_NET_PEER_NAME =
      S.SEMATTRS_NET_PEER_PORT =
      S.SEMATTRS_NET_PEER_IP =
      S.SEMATTRS_NET_TRANSPORT =
      S.SEMATTRS_FAAS_INVOKED_REGION =
      S.SEMATTRS_FAAS_INVOKED_PROVIDER =
      S.SEMATTRS_FAAS_INVOKED_NAME =
      S.SEMATTRS_FAAS_COLDSTART =
      S.SEMATTRS_FAAS_CRON =
      S.SEMATTRS_FAAS_TIME =
      S.SEMATTRS_FAAS_DOCUMENT_NAME =
      S.SEMATTRS_FAAS_DOCUMENT_TIME =
      S.SEMATTRS_FAAS_DOCUMENT_OPERATION =
      S.SEMATTRS_FAAS_DOCUMENT_COLLECTION =
      S.SEMATTRS_FAAS_EXECUTION =
      S.SEMATTRS_FAAS_TRIGGER =
      S.SEMATTRS_EXCEPTION_ESCAPED =
      S.SEMATTRS_EXCEPTION_STACKTRACE =
      S.SEMATTRS_EXCEPTION_MESSAGE =
      S.SEMATTRS_EXCEPTION_TYPE =
      S.SEMATTRS_DB_SQL_TABLE =
      S.SEMATTRS_DB_MONGODB_COLLECTION =
      S.SEMATTRS_DB_REDIS_DATABASE_INDEX =
      S.SEMATTRS_DB_HBASE_NAMESPACE =
      S.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC =
      S.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID =
      S.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT =
      S.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE =
      S.SEMATTRS_DB_CASSANDRA_TABLE =
      S.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL =
      S.SEMATTRS_DB_CASSANDRA_PAGE_SIZE =
      S.SEMATTRS_DB_CASSANDRA_KEYSPACE =
      S.SEMATTRS_DB_MSSQL_INSTANCE_NAME =
      S.SEMATTRS_DB_OPERATION =
      S.SEMATTRS_DB_STATEMENT =
      S.SEMATTRS_DB_NAME =
      S.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME =
      S.SEMATTRS_DB_USER =
      S.SEMATTRS_DB_CONNECTION_STRING =
      S.SEMATTRS_DB_SYSTEM =
      S.SEMATTRS_AWS_LAMBDA_INVOKED_ARN =
        void 0),
    (S.SEMATTRS_MESSAGING_DESTINATION_KIND =
      S.SEMATTRS_MESSAGING_DESTINATION =
      S.SEMATTRS_MESSAGING_SYSTEM =
      S.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES =
      S.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS =
      S.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT =
      S.SEMATTRS_AWS_DYNAMODB_COUNT =
      S.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS =
      S.SEMATTRS_AWS_DYNAMODB_SEGMENT =
      S.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD =
      S.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT =
      S.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE =
      S.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES =
      S.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES =
      S.SEMATTRS_AWS_DYNAMODB_SELECT =
      S.SEMATTRS_AWS_DYNAMODB_INDEX_NAME =
      S.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET =
      S.SEMATTRS_AWS_DYNAMODB_LIMIT =
      S.SEMATTRS_AWS_DYNAMODB_PROJECTION =
      S.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ =
      S.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY =
      S.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY =
      S.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS =
      S.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY =
      S.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES =
      S.SEMATTRS_HTTP_CLIENT_IP =
      S.SEMATTRS_HTTP_ROUTE =
      S.SEMATTRS_HTTP_SERVER_NAME =
      S.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED =
      S.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH =
      S.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED =
      S.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH =
      S.SEMATTRS_HTTP_USER_AGENT =
      S.SEMATTRS_HTTP_FLAVOR =
      S.SEMATTRS_HTTP_STATUS_CODE =
      S.SEMATTRS_HTTP_SCHEME =
      S.SEMATTRS_HTTP_HOST =
      S.SEMATTRS_HTTP_TARGET =
      S.SEMATTRS_HTTP_URL =
      S.SEMATTRS_HTTP_METHOD =
      S.SEMATTRS_CODE_LINENO =
      S.SEMATTRS_CODE_FILEPATH =
      S.SEMATTRS_CODE_NAMESPACE =
      S.SEMATTRS_CODE_FUNCTION =
      S.SEMATTRS_THREAD_NAME =
      S.SEMATTRS_THREAD_ID =
      S.SEMATTRS_ENDUSER_SCOPE =
      S.SEMATTRS_ENDUSER_ROLE =
      S.SEMATTRS_ENDUSER_ID =
      S.SEMATTRS_PEER_SERVICE =
        void 0),
    (S.DBSYSTEMVALUES_FILEMAKER =
      S.DBSYSTEMVALUES_DERBY =
      S.DBSYSTEMVALUES_FIREBIRD =
      S.DBSYSTEMVALUES_ADABAS =
      S.DBSYSTEMVALUES_CACHE =
      S.DBSYSTEMVALUES_EDB =
      S.DBSYSTEMVALUES_FIRSTSQL =
      S.DBSYSTEMVALUES_INGRES =
      S.DBSYSTEMVALUES_HANADB =
      S.DBSYSTEMVALUES_MAXDB =
      S.DBSYSTEMVALUES_PROGRESS =
      S.DBSYSTEMVALUES_HSQLDB =
      S.DBSYSTEMVALUES_CLOUDSCAPE =
      S.DBSYSTEMVALUES_HIVE =
      S.DBSYSTEMVALUES_REDSHIFT =
      S.DBSYSTEMVALUES_POSTGRESQL =
      S.DBSYSTEMVALUES_DB2 =
      S.DBSYSTEMVALUES_ORACLE =
      S.DBSYSTEMVALUES_MYSQL =
      S.DBSYSTEMVALUES_MSSQL =
      S.DBSYSTEMVALUES_OTHER_SQL =
      S.SemanticAttributes =
      S.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE =
      S.SEMATTRS_MESSAGE_COMPRESSED_SIZE =
      S.SEMATTRS_MESSAGE_ID =
      S.SEMATTRS_MESSAGE_TYPE =
      S.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE =
      S.SEMATTRS_RPC_JSONRPC_ERROR_CODE =
      S.SEMATTRS_RPC_JSONRPC_REQUEST_ID =
      S.SEMATTRS_RPC_JSONRPC_VERSION =
      S.SEMATTRS_RPC_GRPC_STATUS_CODE =
      S.SEMATTRS_RPC_METHOD =
      S.SEMATTRS_RPC_SERVICE =
      S.SEMATTRS_RPC_SYSTEM =
      S.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE =
      S.SEMATTRS_MESSAGING_KAFKA_PARTITION =
      S.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID =
      S.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP =
      S.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY =
      S.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY =
      S.SEMATTRS_MESSAGING_CONSUMER_ID =
      S.SEMATTRS_MESSAGING_OPERATION =
      S.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES =
      S.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES =
      S.SEMATTRS_MESSAGING_CONVERSATION_ID =
      S.SEMATTRS_MESSAGING_MESSAGE_ID =
      S.SEMATTRS_MESSAGING_URL =
      S.SEMATTRS_MESSAGING_PROTOCOL_VERSION =
      S.SEMATTRS_MESSAGING_PROTOCOL =
      S.SEMATTRS_MESSAGING_TEMP_DESTINATION =
        void 0),
    (S.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD =
      S.FaasDocumentOperationValues =
      S.FAASDOCUMENTOPERATIONVALUES_DELETE =
      S.FAASDOCUMENTOPERATIONVALUES_EDIT =
      S.FAASDOCUMENTOPERATIONVALUES_INSERT =
      S.FaasTriggerValues =
      S.FAASTRIGGERVALUES_OTHER =
      S.FAASTRIGGERVALUES_TIMER =
      S.FAASTRIGGERVALUES_PUBSUB =
      S.FAASTRIGGERVALUES_HTTP =
      S.FAASTRIGGERVALUES_DATASOURCE =
      S.DbCassandraConsistencyLevelValues =
      S.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL =
      S.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL =
      S.DBCASSANDRACONSISTENCYLEVELVALUES_ANY =
      S.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE =
      S.DBCASSANDRACONSISTENCYLEVELVALUES_THREE =
      S.DBCASSANDRACONSISTENCYLEVELVALUES_TWO =
      S.DBCASSANDRACONSISTENCYLEVELVALUES_ONE =
      S.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM =
      S.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM =
      S.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM =
      S.DBCASSANDRACONSISTENCYLEVELVALUES_ALL =
      S.DbSystemValues =
      S.DBSYSTEMVALUES_COCKROACHDB =
      S.DBSYSTEMVALUES_MEMCACHED =
      S.DBSYSTEMVALUES_ELASTICSEARCH =
      S.DBSYSTEMVALUES_GEODE =
      S.DBSYSTEMVALUES_NEO4J =
      S.DBSYSTEMVALUES_DYNAMODB =
      S.DBSYSTEMVALUES_COSMOSDB =
      S.DBSYSTEMVALUES_COUCHDB =
      S.DBSYSTEMVALUES_COUCHBASE =
      S.DBSYSTEMVALUES_REDIS =
      S.DBSYSTEMVALUES_MONGODB =
      S.DBSYSTEMVALUES_HBASE =
      S.DBSYSTEMVALUES_CASSANDRA =
      S.DBSYSTEMVALUES_COLDFUSION =
      S.DBSYSTEMVALUES_H2 =
      S.DBSYSTEMVALUES_VERTICA =
      S.DBSYSTEMVALUES_TERADATA =
      S.DBSYSTEMVALUES_SYBASE =
      S.DBSYSTEMVALUES_SQLITE =
      S.DBSYSTEMVALUES_POINTBASE =
      S.DBSYSTEMVALUES_PERVASIVE =
      S.DBSYSTEMVALUES_NETEZZA =
      S.DBSYSTEMVALUES_MARIADB =
      S.DBSYSTEMVALUES_INTERBASE =
      S.DBSYSTEMVALUES_INSTANTDB =
      S.DBSYSTEMVALUES_INFORMIX =
        void 0),
    (S.MESSAGINGOPERATIONVALUES_RECEIVE =
      S.MessagingDestinationKindValues =
      S.MESSAGINGDESTINATIONKINDVALUES_TOPIC =
      S.MESSAGINGDESTINATIONKINDVALUES_QUEUE =
      S.HttpFlavorValues =
      S.HTTPFLAVORVALUES_QUIC =
      S.HTTPFLAVORVALUES_SPDY =
      S.HTTPFLAVORVALUES_HTTP_2_0 =
      S.HTTPFLAVORVALUES_HTTP_1_1 =
      S.HTTPFLAVORVALUES_HTTP_1_0 =
      S.NetHostConnectionSubtypeValues =
      S.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA =
      S.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA =
      S.NETHOSTCONNECTIONSUBTYPEVALUES_NR =
      S.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN =
      S.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA =
      S.NETHOSTCONNECTIONSUBTYPEVALUES_GSM =
      S.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP =
      S.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD =
      S.NETHOSTCONNECTIONSUBTYPEVALUES_LTE =
      S.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B =
      S.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN =
      S.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA =
      S.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA =
      S.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA =
      S.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT =
      S.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A =
      S.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 =
      S.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA =
      S.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS =
      S.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE =
      S.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS =
      S.NetHostConnectionTypeValues =
      S.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN =
      S.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE =
      S.NETHOSTCONNECTIONTYPEVALUES_CELL =
      S.NETHOSTCONNECTIONTYPEVALUES_WIRED =
      S.NETHOSTCONNECTIONTYPEVALUES_WIFI =
      S.NetTransportValues =
      S.NETTRANSPORTVALUES_OTHER =
      S.NETTRANSPORTVALUES_INPROC =
      S.NETTRANSPORTVALUES_PIPE =
      S.NETTRANSPORTVALUES_UNIX =
      S.NETTRANSPORTVALUES_IP =
      S.NETTRANSPORTVALUES_IP_UDP =
      S.NETTRANSPORTVALUES_IP_TCP =
      S.FaasInvokedProviderValues =
      S.FAASINVOKEDPROVIDERVALUES_GCP =
      S.FAASINVOKEDPROVIDERVALUES_AZURE =
      S.FAASINVOKEDPROVIDERVALUES_AWS =
        void 0),
    (S.MessageTypeValues =
      S.MESSAGETYPEVALUES_RECEIVED =
      S.MESSAGETYPEVALUES_SENT =
      S.RpcGrpcStatusCodeValues =
      S.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED =
      S.RPCGRPCSTATUSCODEVALUES_DATA_LOSS =
      S.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE =
      S.RPCGRPCSTATUSCODEVALUES_INTERNAL =
      S.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED =
      S.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE =
      S.RPCGRPCSTATUSCODEVALUES_ABORTED =
      S.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION =
      S.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED =
      S.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED =
      S.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS =
      S.RPCGRPCSTATUSCODEVALUES_NOT_FOUND =
      S.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED =
      S.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT =
      S.RPCGRPCSTATUSCODEVALUES_UNKNOWN =
      S.RPCGRPCSTATUSCODEVALUES_CANCELLED =
      S.RPCGRPCSTATUSCODEVALUES_OK =
      S.MessagingOperationValues =
      S.MESSAGINGOPERATIONVALUES_PROCESS =
        void 0));
  const e = sI(),
    t = "aws.lambda.invoked_arn",
    n = "db.system",
    r = "db.connection_string",
    o = "db.user",
    s = "db.jdbc.driver_classname",
    i = "db.name",
    a = "db.statement",
    c = "db.operation",
    l = "db.mssql.instance_name",
    f = "db.cassandra.keyspace",
    d = "db.cassandra.page_size",
    u = "db.cassandra.consistency_level",
    _ = "db.cassandra.table",
    p = "db.cassandra.idempotence",
    E = "db.cassandra.speculative_execution_count",
    h = "db.cassandra.coordinator.id",
    T = "db.cassandra.coordinator.dc",
    m = "db.hbase.namespace",
    A = "db.redis.database_index",
    g = "db.mongodb.collection",
    N = "db.sql.table",
    O = "exception.type",
    I = "exception.message",
    b = "exception.stacktrace",
    w = "exception.escaped",
    L = "faas.trigger",
    j = "faas.execution",
    H = "faas.document.collection",
    x = "faas.document.operation",
    B = "faas.document.time",
    F = "faas.document.name",
    U = "faas.time",
    k = "faas.cron",
    Y = "faas.coldstart",
    oe = "faas.invoked_name",
    ae = "faas.invoked_provider",
    ne = "faas.invoked_region",
    P = "net.transport",
    M = "net.peer.ip",
    G = "net.peer.port",
    V = "net.peer.name",
    K = "net.host.ip",
    X = "net.host.port",
    v = "net.host.name",
    D = "net.host.connection.type",
    z = "net.host.connection.subtype",
    q = "net.host.carrier.name",
    ee = "net.host.carrier.mcc",
    te = "net.host.carrier.mnc",
    _e = "net.host.carrier.icc",
    se = "peer.service",
    ue = "enduser.id",
    Te = "enduser.role",
    ve = "enduser.scope",
    De = "thread.id",
    qe = "thread.name",
    Mt = "code.function",
    it = "code.namespace",
    at = "code.filepath",
    nt = "code.lineno",
    ss = "http.method",
    is = "http.url",
    as = "http.target",
    cs = "http.host",
    us = "http.scheme",
    ls = "http.status_code",
    ds = "http.flavor",
    fs = "http.user_agent",
    _s = "http.request_content_length",
    ps = "http.request_content_length_uncompressed",
    Es = "http.response_content_length",
    hs = "http.response_content_length_uncompressed",
    Ts = "http.server_name",
    Ss = "http.route",
    ms = "http.client_ip",
    As = "aws.dynamodb.table_names",
    gs = "aws.dynamodb.consumed_capacity",
    Rs = "aws.dynamodb.item_collection_metrics",
    Ns = "aws.dynamodb.provisioned_read_capacity",
    ys = "aws.dynamodb.provisioned_write_capacity",
    Os = "aws.dynamodb.consistent_read",
    Cs = "aws.dynamodb.projection",
    bs = "aws.dynamodb.limit",
    Is = "aws.dynamodb.attributes_to_get",
    Ps = "aws.dynamodb.index_name",
    Ms = "aws.dynamodb.select",
    vs = "aws.dynamodb.global_secondary_indexes",
    Ls = "aws.dynamodb.local_secondary_indexes",
    Ds = "aws.dynamodb.exclusive_start_table",
    ws = "aws.dynamodb.table_count",
    Us = "aws.dynamodb.scan_forward",
    ks = "aws.dynamodb.segment",
    Gs = "aws.dynamodb.total_segments",
    Vs = "aws.dynamodb.count",
    xs = "aws.dynamodb.scanned_count",
    $s = "aws.dynamodb.attribute_definitions",
    Bs = "aws.dynamodb.global_secondary_index_updates",
    Hs = "messaging.system",
    Fs = "messaging.destination",
    Ys = "messaging.destination_kind",
    js = "messaging.temp_destination",
    qs = "messaging.protocol",
    Ws = "messaging.protocol_version",
    Ks = "messaging.url",
    zs = "messaging.message_id",
    Zs = "messaging.conversation_id",
    Xs = "messaging.message_payload_size_bytes",
    Qs = "messaging.message_payload_compressed_size_bytes",
    Js = "messaging.operation",
    ei = "messaging.consumer_id",
    ti = "messaging.rabbitmq.routing_key",
    ni = "messaging.kafka.message_key",
    ri = "messaging.kafka.consumer_group",
    oi = "messaging.kafka.client_id",
    si = "messaging.kafka.partition",
    ii = "messaging.kafka.tombstone",
    ai = "rpc.system",
    ci = "rpc.service",
    ui = "rpc.method",
    li = "rpc.grpc.status_code",
    di = "rpc.jsonrpc.version",
    fi = "rpc.jsonrpc.request_id",
    _i = "rpc.jsonrpc.error_code",
    pi = "rpc.jsonrpc.error_message",
    Ei = "message.type",
    hi = "message.id",
    Ti = "message.compressed_size",
    Si = "message.uncompressed_size";
  ((S.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = t),
    (S.SEMATTRS_DB_SYSTEM = n),
    (S.SEMATTRS_DB_CONNECTION_STRING = r),
    (S.SEMATTRS_DB_USER = o),
    (S.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = s),
    (S.SEMATTRS_DB_NAME = i),
    (S.SEMATTRS_DB_STATEMENT = a),
    (S.SEMATTRS_DB_OPERATION = c),
    (S.SEMATTRS_DB_MSSQL_INSTANCE_NAME = l),
    (S.SEMATTRS_DB_CASSANDRA_KEYSPACE = f),
    (S.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = d),
    (S.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = u),
    (S.SEMATTRS_DB_CASSANDRA_TABLE = _),
    (S.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = p),
    (S.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = E),
    (S.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = h),
    (S.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = T),
    (S.SEMATTRS_DB_HBASE_NAMESPACE = m),
    (S.SEMATTRS_DB_REDIS_DATABASE_INDEX = A),
    (S.SEMATTRS_DB_MONGODB_COLLECTION = g),
    (S.SEMATTRS_DB_SQL_TABLE = N),
    (S.SEMATTRS_EXCEPTION_TYPE = O),
    (S.SEMATTRS_EXCEPTION_MESSAGE = I),
    (S.SEMATTRS_EXCEPTION_STACKTRACE = b),
    (S.SEMATTRS_EXCEPTION_ESCAPED = w),
    (S.SEMATTRS_FAAS_TRIGGER = L),
    (S.SEMATTRS_FAAS_EXECUTION = j),
    (S.SEMATTRS_FAAS_DOCUMENT_COLLECTION = H),
    (S.SEMATTRS_FAAS_DOCUMENT_OPERATION = x),
    (S.SEMATTRS_FAAS_DOCUMENT_TIME = B),
    (S.SEMATTRS_FAAS_DOCUMENT_NAME = F),
    (S.SEMATTRS_FAAS_TIME = U),
    (S.SEMATTRS_FAAS_CRON = k),
    (S.SEMATTRS_FAAS_COLDSTART = Y),
    (S.SEMATTRS_FAAS_INVOKED_NAME = oe),
    (S.SEMATTRS_FAAS_INVOKED_PROVIDER = ae),
    (S.SEMATTRS_FAAS_INVOKED_REGION = ne),
    (S.SEMATTRS_NET_TRANSPORT = P),
    (S.SEMATTRS_NET_PEER_IP = M),
    (S.SEMATTRS_NET_PEER_PORT = G),
    (S.SEMATTRS_NET_PEER_NAME = V),
    (S.SEMATTRS_NET_HOST_IP = K),
    (S.SEMATTRS_NET_HOST_PORT = X),
    (S.SEMATTRS_NET_HOST_NAME = v),
    (S.SEMATTRS_NET_HOST_CONNECTION_TYPE = D),
    (S.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = z),
    (S.SEMATTRS_NET_HOST_CARRIER_NAME = q),
    (S.SEMATTRS_NET_HOST_CARRIER_MCC = ee),
    (S.SEMATTRS_NET_HOST_CARRIER_MNC = te),
    (S.SEMATTRS_NET_HOST_CARRIER_ICC = _e),
    (S.SEMATTRS_PEER_SERVICE = se),
    (S.SEMATTRS_ENDUSER_ID = ue),
    (S.SEMATTRS_ENDUSER_ROLE = Te),
    (S.SEMATTRS_ENDUSER_SCOPE = ve),
    (S.SEMATTRS_THREAD_ID = De),
    (S.SEMATTRS_THREAD_NAME = qe),
    (S.SEMATTRS_CODE_FUNCTION = Mt),
    (S.SEMATTRS_CODE_NAMESPACE = it),
    (S.SEMATTRS_CODE_FILEPATH = at),
    (S.SEMATTRS_CODE_LINENO = nt),
    (S.SEMATTRS_HTTP_METHOD = ss),
    (S.SEMATTRS_HTTP_URL = is),
    (S.SEMATTRS_HTTP_TARGET = as),
    (S.SEMATTRS_HTTP_HOST = cs),
    (S.SEMATTRS_HTTP_SCHEME = us),
    (S.SEMATTRS_HTTP_STATUS_CODE = ls),
    (S.SEMATTRS_HTTP_FLAVOR = ds),
    (S.SEMATTRS_HTTP_USER_AGENT = fs),
    (S.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = _s),
    (S.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = ps),
    (S.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = Es),
    (S.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = hs),
    (S.SEMATTRS_HTTP_SERVER_NAME = Ts),
    (S.SEMATTRS_HTTP_ROUTE = Ss),
    (S.SEMATTRS_HTTP_CLIENT_IP = ms),
    (S.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = As),
    (S.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = gs),
    (S.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = Rs),
    (S.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = Ns),
    (S.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = ys),
    (S.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = Os),
    (S.SEMATTRS_AWS_DYNAMODB_PROJECTION = Cs),
    (S.SEMATTRS_AWS_DYNAMODB_LIMIT = bs),
    (S.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = Is),
    (S.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = Ps),
    (S.SEMATTRS_AWS_DYNAMODB_SELECT = Ms),
    (S.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = vs),
    (S.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = Ls),
    (S.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = Ds),
    (S.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = ws),
    (S.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = Us),
    (S.SEMATTRS_AWS_DYNAMODB_SEGMENT = ks),
    (S.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = Gs),
    (S.SEMATTRS_AWS_DYNAMODB_COUNT = Vs),
    (S.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = xs),
    (S.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = $s),
    (S.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = Bs),
    (S.SEMATTRS_MESSAGING_SYSTEM = Hs),
    (S.SEMATTRS_MESSAGING_DESTINATION = Fs),
    (S.SEMATTRS_MESSAGING_DESTINATION_KIND = Ys),
    (S.SEMATTRS_MESSAGING_TEMP_DESTINATION = js),
    (S.SEMATTRS_MESSAGING_PROTOCOL = qs),
    (S.SEMATTRS_MESSAGING_PROTOCOL_VERSION = Ws),
    (S.SEMATTRS_MESSAGING_URL = Ks),
    (S.SEMATTRS_MESSAGING_MESSAGE_ID = zs),
    (S.SEMATTRS_MESSAGING_CONVERSATION_ID = Zs),
    (S.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = Xs),
    (S.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = Qs),
    (S.SEMATTRS_MESSAGING_OPERATION = Js),
    (S.SEMATTRS_MESSAGING_CONSUMER_ID = ei),
    (S.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = ti),
    (S.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = ni),
    (S.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = ri),
    (S.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = oi),
    (S.SEMATTRS_MESSAGING_KAFKA_PARTITION = si),
    (S.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = ii),
    (S.SEMATTRS_RPC_SYSTEM = ai),
    (S.SEMATTRS_RPC_SERVICE = ci),
    (S.SEMATTRS_RPC_METHOD = ui),
    (S.SEMATTRS_RPC_GRPC_STATUS_CODE = li),
    (S.SEMATTRS_RPC_JSONRPC_VERSION = di),
    (S.SEMATTRS_RPC_JSONRPC_REQUEST_ID = fi),
    (S.SEMATTRS_RPC_JSONRPC_ERROR_CODE = _i),
    (S.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = pi),
    (S.SEMATTRS_MESSAGE_TYPE = Ei),
    (S.SEMATTRS_MESSAGE_ID = hi),
    (S.SEMATTRS_MESSAGE_COMPRESSED_SIZE = Ti),
    (S.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = Si),
    (S.SemanticAttributes = (0, e.createConstMap)([
      t,
      n,
      r,
      o,
      s,
      i,
      a,
      c,
      l,
      f,
      d,
      u,
      _,
      p,
      E,
      h,
      T,
      m,
      A,
      g,
      N,
      O,
      I,
      b,
      w,
      L,
      j,
      H,
      x,
      B,
      F,
      U,
      k,
      Y,
      oe,
      ae,
      ne,
      P,
      M,
      G,
      V,
      K,
      X,
      v,
      D,
      z,
      q,
      ee,
      te,
      _e,
      se,
      ue,
      Te,
      ve,
      De,
      qe,
      Mt,
      it,
      at,
      nt,
      ss,
      is,
      as,
      cs,
      us,
      ls,
      ds,
      fs,
      _s,
      ps,
      Es,
      hs,
      Ts,
      Ss,
      ms,
      As,
      gs,
      Rs,
      Ns,
      ys,
      Os,
      Cs,
      bs,
      Is,
      Ps,
      Ms,
      vs,
      Ls,
      Ds,
      ws,
      Us,
      ks,
      Gs,
      Vs,
      xs,
      $s,
      Bs,
      Hs,
      Fs,
      Ys,
      js,
      qs,
      Ws,
      Ks,
      zs,
      Zs,
      Xs,
      Qs,
      Js,
      ei,
      ti,
      ni,
      ri,
      oi,
      si,
      ii,
      ai,
      ci,
      ui,
      li,
      di,
      fi,
      _i,
      pi,
      Ei,
      hi,
      Ti,
      Si,
    ])));
  const mi = "other_sql",
    Ai = "mssql",
    gi = "mysql",
    Ri = "oracle",
    Dh = "db2",
    wh = "postgresql",
    Uh = "redshift",
    kh = "hive",
    Gh = "cloudscape",
    Vh = "hsqldb",
    xh = "progress",
    $h = "maxdb",
    Bh = "hanadb",
    Hh = "ingres",
    Fh = "firstsql",
    Yh = "edb",
    jh = "cache",
    qh = "adabas",
    Wh = "firebird",
    Kh = "derby",
    zh = "filemaker",
    Zh = "informix",
    Xh = "instantdb",
    Qh = "interbase",
    Jh = "mariadb",
    eT = "netezza",
    tT = "pervasive",
    nT = "pointbase",
    rT = "sqlite",
    oT = "sybase",
    sT = "teradata",
    iT = "vertica",
    aT = "h2",
    cT = "coldfusion",
    uT = "cassandra",
    lT = "hbase",
    dT = "mongodb",
    fT = "redis",
    _T = "couchbase",
    pT = "couchdb",
    ET = "cosmosdb",
    hT = "dynamodb",
    TT = "neo4j",
    ST = "geode",
    mT = "elasticsearch",
    AT = "memcached",
    gT = "cockroachdb";
  ((S.DBSYSTEMVALUES_OTHER_SQL = mi),
    (S.DBSYSTEMVALUES_MSSQL = Ai),
    (S.DBSYSTEMVALUES_MYSQL = gi),
    (S.DBSYSTEMVALUES_ORACLE = Ri),
    (S.DBSYSTEMVALUES_DB2 = Dh),
    (S.DBSYSTEMVALUES_POSTGRESQL = wh),
    (S.DBSYSTEMVALUES_REDSHIFT = Uh),
    (S.DBSYSTEMVALUES_HIVE = kh),
    (S.DBSYSTEMVALUES_CLOUDSCAPE = Gh),
    (S.DBSYSTEMVALUES_HSQLDB = Vh),
    (S.DBSYSTEMVALUES_PROGRESS = xh),
    (S.DBSYSTEMVALUES_MAXDB = $h),
    (S.DBSYSTEMVALUES_HANADB = Bh),
    (S.DBSYSTEMVALUES_INGRES = Hh),
    (S.DBSYSTEMVALUES_FIRSTSQL = Fh),
    (S.DBSYSTEMVALUES_EDB = Yh),
    (S.DBSYSTEMVALUES_CACHE = jh),
    (S.DBSYSTEMVALUES_ADABAS = qh),
    (S.DBSYSTEMVALUES_FIREBIRD = Wh),
    (S.DBSYSTEMVALUES_DERBY = Kh),
    (S.DBSYSTEMVALUES_FILEMAKER = zh),
    (S.DBSYSTEMVALUES_INFORMIX = Zh),
    (S.DBSYSTEMVALUES_INSTANTDB = Xh),
    (S.DBSYSTEMVALUES_INTERBASE = Qh),
    (S.DBSYSTEMVALUES_MARIADB = Jh),
    (S.DBSYSTEMVALUES_NETEZZA = eT),
    (S.DBSYSTEMVALUES_PERVASIVE = tT),
    (S.DBSYSTEMVALUES_POINTBASE = nT),
    (S.DBSYSTEMVALUES_SQLITE = rT),
    (S.DBSYSTEMVALUES_SYBASE = oT),
    (S.DBSYSTEMVALUES_TERADATA = sT),
    (S.DBSYSTEMVALUES_VERTICA = iT),
    (S.DBSYSTEMVALUES_H2 = aT),
    (S.DBSYSTEMVALUES_COLDFUSION = cT),
    (S.DBSYSTEMVALUES_CASSANDRA = uT),
    (S.DBSYSTEMVALUES_HBASE = lT),
    (S.DBSYSTEMVALUES_MONGODB = dT),
    (S.DBSYSTEMVALUES_REDIS = fT),
    (S.DBSYSTEMVALUES_COUCHBASE = _T),
    (S.DBSYSTEMVALUES_COUCHDB = pT),
    (S.DBSYSTEMVALUES_COSMOSDB = ET),
    (S.DBSYSTEMVALUES_DYNAMODB = hT),
    (S.DBSYSTEMVALUES_NEO4J = TT),
    (S.DBSYSTEMVALUES_GEODE = ST),
    (S.DBSYSTEMVALUES_ELASTICSEARCH = mT),
    (S.DBSYSTEMVALUES_MEMCACHED = AT),
    (S.DBSYSTEMVALUES_COCKROACHDB = gT),
    (S.DbSystemValues = (0, e.createConstMap)([
      mi,
      Ai,
      gi,
      Ri,
      Dh,
      wh,
      Uh,
      kh,
      Gh,
      Vh,
      xh,
      $h,
      Bh,
      Hh,
      Fh,
      Yh,
      jh,
      qh,
      Wh,
      Kh,
      zh,
      Zh,
      Xh,
      Qh,
      Jh,
      eT,
      tT,
      nT,
      rT,
      oT,
      sT,
      iT,
      aT,
      cT,
      uT,
      lT,
      dT,
      fT,
      _T,
      pT,
      ET,
      hT,
      TT,
      ST,
      mT,
      AT,
      gT,
    ])));
  const RT = "all",
    NT = "each_quorum",
    yT = "quorum",
    OT = "local_quorum",
    CT = "one",
    bT = "two",
    IT = "three",
    PT = "local_one",
    MT = "any",
    vT = "serial",
    LT = "local_serial";
  ((S.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = RT),
    (S.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = NT),
    (S.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = yT),
    (S.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = OT),
    (S.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = CT),
    (S.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = bT),
    (S.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = IT),
    (S.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = PT),
    (S.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = MT),
    (S.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = vT),
    (S.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = LT),
    (S.DbCassandraConsistencyLevelValues = (0, e.createConstMap)([
      RT,
      NT,
      yT,
      OT,
      CT,
      bT,
      IT,
      PT,
      MT,
      vT,
      LT,
    ])));
  const DT = "datasource",
    wT = "http",
    UT = "pubsub",
    kT = "timer",
    GT = "other";
  ((S.FAASTRIGGERVALUES_DATASOURCE = DT),
    (S.FAASTRIGGERVALUES_HTTP = wT),
    (S.FAASTRIGGERVALUES_PUBSUB = UT),
    (S.FAASTRIGGERVALUES_TIMER = kT),
    (S.FAASTRIGGERVALUES_OTHER = GT),
    (S.FaasTriggerValues = (0, e.createConstMap)([DT, wT, UT, kT, GT])));
  const VT = "insert",
    xT = "edit",
    $T = "delete";
  ((S.FAASDOCUMENTOPERATIONVALUES_INSERT = VT),
    (S.FAASDOCUMENTOPERATIONVALUES_EDIT = xT),
    (S.FAASDOCUMENTOPERATIONVALUES_DELETE = $T),
    (S.FaasDocumentOperationValues = (0, e.createConstMap)([VT, xT, $T])));
  const BT = "alibaba_cloud",
    HT = "aws",
    FT = "azure",
    YT = "gcp";
  ((S.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = BT),
    (S.FAASINVOKEDPROVIDERVALUES_AWS = HT),
    (S.FAASINVOKEDPROVIDERVALUES_AZURE = FT),
    (S.FAASINVOKEDPROVIDERVALUES_GCP = YT),
    (S.FaasInvokedProviderValues = (0, e.createConstMap)([BT, HT, FT, YT])));
  const jT = "ip_tcp",
    qT = "ip_udp",
    WT = "ip",
    KT = "unix",
    zT = "pipe",
    ZT = "inproc",
    XT = "other";
  ((S.NETTRANSPORTVALUES_IP_TCP = jT),
    (S.NETTRANSPORTVALUES_IP_UDP = qT),
    (S.NETTRANSPORTVALUES_IP = WT),
    (S.NETTRANSPORTVALUES_UNIX = KT),
    (S.NETTRANSPORTVALUES_PIPE = zT),
    (S.NETTRANSPORTVALUES_INPROC = ZT),
    (S.NETTRANSPORTVALUES_OTHER = XT),
    (S.NetTransportValues = (0, e.createConstMap)([
      jT,
      qT,
      WT,
      KT,
      zT,
      ZT,
      XT,
    ])));
  const QT = "wifi",
    JT = "wired",
    eS = "cell",
    tS = "unavailable",
    nS = "unknown";
  ((S.NETHOSTCONNECTIONTYPEVALUES_WIFI = QT),
    (S.NETHOSTCONNECTIONTYPEVALUES_WIRED = JT),
    (S.NETHOSTCONNECTIONTYPEVALUES_CELL = eS),
    (S.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = tS),
    (S.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = nS),
    (S.NetHostConnectionTypeValues = (0, e.createConstMap)([
      QT,
      JT,
      eS,
      tS,
      nS,
    ])));
  const rS = "gprs",
    oS = "edge",
    sS = "umts",
    iS = "cdma",
    aS = "evdo_0",
    cS = "evdo_a",
    uS = "cdma2000_1xrtt",
    lS = "hsdpa",
    dS = "hsupa",
    fS = "hspa",
    _S = "iden",
    pS = "evdo_b",
    ES = "lte",
    hS = "ehrpd",
    TS = "hspap",
    SS = "gsm",
    mS = "td_scdma",
    AS = "iwlan",
    gS = "nr",
    RS = "nrnsa",
    NS = "lte_ca";
  ((S.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = rS),
    (S.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = oS),
    (S.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = sS),
    (S.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = iS),
    (S.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = aS),
    (S.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = cS),
    (S.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = uS),
    (S.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = lS),
    (S.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = dS),
    (S.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = fS),
    (S.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = _S),
    (S.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = pS),
    (S.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = ES),
    (S.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = hS),
    (S.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = TS),
    (S.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = SS),
    (S.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = mS),
    (S.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = AS),
    (S.NETHOSTCONNECTIONSUBTYPEVALUES_NR = gS),
    (S.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = RS),
    (S.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = NS),
    (S.NetHostConnectionSubtypeValues = (0, e.createConstMap)([
      rS,
      oS,
      sS,
      iS,
      aS,
      cS,
      uS,
      lS,
      dS,
      fS,
      _S,
      pS,
      ES,
      hS,
      TS,
      SS,
      mS,
      AS,
      gS,
      RS,
      NS,
    ])));
  const yS = "1.0",
    OS = "1.1",
    CS = "2.0",
    bS = "SPDY",
    IS = "QUIC";
  ((S.HTTPFLAVORVALUES_HTTP_1_0 = yS),
    (S.HTTPFLAVORVALUES_HTTP_1_1 = OS),
    (S.HTTPFLAVORVALUES_HTTP_2_0 = CS),
    (S.HTTPFLAVORVALUES_SPDY = bS),
    (S.HTTPFLAVORVALUES_QUIC = IS),
    (S.HttpFlavorValues = {
      HTTP_1_0: yS,
      HTTP_1_1: OS,
      HTTP_2_0: CS,
      SPDY: bS,
      QUIC: IS,
    }));
  const PS = "queue",
    MS = "topic";
  ((S.MESSAGINGDESTINATIONKINDVALUES_QUEUE = PS),
    (S.MESSAGINGDESTINATIONKINDVALUES_TOPIC = MS),
    (S.MessagingDestinationKindValues = (0, e.createConstMap)([PS, MS])));
  const vS = "receive",
    LS = "process";
  ((S.MESSAGINGOPERATIONVALUES_RECEIVE = vS),
    (S.MESSAGINGOPERATIONVALUES_PROCESS = LS),
    (S.MessagingOperationValues = (0, e.createConstMap)([vS, LS])));
  const DS = 0,
    wS = 1,
    US = 2,
    kS = 3,
    GS = 4,
    VS = 5,
    xS = 6,
    $S = 7,
    BS = 8,
    HS = 9,
    FS = 10,
    YS = 11,
    jS = 12,
    qS = 13,
    WS = 14,
    KS = 15,
    zS = 16;
  ((S.RPCGRPCSTATUSCODEVALUES_OK = DS),
    (S.RPCGRPCSTATUSCODEVALUES_CANCELLED = wS),
    (S.RPCGRPCSTATUSCODEVALUES_UNKNOWN = US),
    (S.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = kS),
    (S.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = GS),
    (S.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = VS),
    (S.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = xS),
    (S.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = $S),
    (S.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = BS),
    (S.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = HS),
    (S.RPCGRPCSTATUSCODEVALUES_ABORTED = FS),
    (S.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = YS),
    (S.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = jS),
    (S.RPCGRPCSTATUSCODEVALUES_INTERNAL = qS),
    (S.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = WS),
    (S.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = KS),
    (S.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = zS),
    (S.RpcGrpcStatusCodeValues = {
      OK: DS,
      CANCELLED: wS,
      UNKNOWN: US,
      INVALID_ARGUMENT: kS,
      DEADLINE_EXCEEDED: GS,
      NOT_FOUND: VS,
      ALREADY_EXISTS: xS,
      PERMISSION_DENIED: $S,
      RESOURCE_EXHAUSTED: BS,
      FAILED_PRECONDITION: HS,
      ABORTED: FS,
      OUT_OF_RANGE: YS,
      UNIMPLEMENTED: jS,
      INTERNAL: qS,
      UNAVAILABLE: WS,
      DATA_LOSS: KS,
      UNAUTHENTICATED: zS,
    }));
  const ZS = "SENT",
    XS = "RECEIVED";
  return (
    (S.MESSAGETYPEVALUES_SENT = ZS),
    (S.MESSAGETYPEVALUES_RECEIVED = XS),
    (S.MessageTypeValues = (0, e.createConstMap)([ZS, XS])),
    S
  );
}
var Zm;
function ww() {
  return (
    Zm ||
      ((Zm = 1),
      (function (e) {
        var t =
            (Sr && Sr.__createBinding) ||
            (Object.create
              ? function (r, o, s, i) {
                  i === void 0 && (i = s);
                  var a = Object.getOwnPropertyDescriptor(o, s);
                  ((!a ||
                    ("get" in a
                      ? !o.__esModule
                      : a.writable || a.configurable)) &&
                    (a = {
                      enumerable: !0,
                      get: function () {
                        return o[s];
                      },
                    }),
                    Object.defineProperty(r, i, a));
                }
              : function (r, o, s, i) {
                  (i === void 0 && (i = s), (r[i] = o[s]));
                }),
          n =
            (Sr && Sr.__exportStar) ||
            function (r, o) {
              for (var s in r)
                s !== "default" &&
                  !Object.prototype.hasOwnProperty.call(o, s) &&
                  t(o, r, s);
            };
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          n(Dw(), e));
      })(Sr)),
    Sr
  );
}
var mr = {},
  R = {},
  Xm;
function Uw() {
  if (Xm) return R;
  ((Xm = 1),
    Object.defineProperty(R, "__esModule", {
      value: !0,
    }),
    (R.SEMRESATTRS_K8S_STATEFULSET_NAME =
      R.SEMRESATTRS_K8S_STATEFULSET_UID =
      R.SEMRESATTRS_K8S_DEPLOYMENT_NAME =
      R.SEMRESATTRS_K8S_DEPLOYMENT_UID =
      R.SEMRESATTRS_K8S_REPLICASET_NAME =
      R.SEMRESATTRS_K8S_REPLICASET_UID =
      R.SEMRESATTRS_K8S_CONTAINER_NAME =
      R.SEMRESATTRS_K8S_POD_NAME =
      R.SEMRESATTRS_K8S_POD_UID =
      R.SEMRESATTRS_K8S_NAMESPACE_NAME =
      R.SEMRESATTRS_K8S_NODE_UID =
      R.SEMRESATTRS_K8S_NODE_NAME =
      R.SEMRESATTRS_K8S_CLUSTER_NAME =
      R.SEMRESATTRS_HOST_IMAGE_VERSION =
      R.SEMRESATTRS_HOST_IMAGE_ID =
      R.SEMRESATTRS_HOST_IMAGE_NAME =
      R.SEMRESATTRS_HOST_ARCH =
      R.SEMRESATTRS_HOST_TYPE =
      R.SEMRESATTRS_HOST_NAME =
      R.SEMRESATTRS_HOST_ID =
      R.SEMRESATTRS_FAAS_MAX_MEMORY =
      R.SEMRESATTRS_FAAS_INSTANCE =
      R.SEMRESATTRS_FAAS_VERSION =
      R.SEMRESATTRS_FAAS_ID =
      R.SEMRESATTRS_FAAS_NAME =
      R.SEMRESATTRS_DEVICE_MODEL_NAME =
      R.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER =
      R.SEMRESATTRS_DEVICE_ID =
      R.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT =
      R.SEMRESATTRS_CONTAINER_IMAGE_TAG =
      R.SEMRESATTRS_CONTAINER_IMAGE_NAME =
      R.SEMRESATTRS_CONTAINER_RUNTIME =
      R.SEMRESATTRS_CONTAINER_ID =
      R.SEMRESATTRS_CONTAINER_NAME =
      R.SEMRESATTRS_AWS_LOG_STREAM_ARNS =
      R.SEMRESATTRS_AWS_LOG_STREAM_NAMES =
      R.SEMRESATTRS_AWS_LOG_GROUP_ARNS =
      R.SEMRESATTRS_AWS_LOG_GROUP_NAMES =
      R.SEMRESATTRS_AWS_EKS_CLUSTER_ARN =
      R.SEMRESATTRS_AWS_ECS_TASK_REVISION =
      R.SEMRESATTRS_AWS_ECS_TASK_FAMILY =
      R.SEMRESATTRS_AWS_ECS_TASK_ARN =
      R.SEMRESATTRS_AWS_ECS_LAUNCHTYPE =
      R.SEMRESATTRS_AWS_ECS_CLUSTER_ARN =
      R.SEMRESATTRS_AWS_ECS_CONTAINER_ARN =
      R.SEMRESATTRS_CLOUD_PLATFORM =
      R.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE =
      R.SEMRESATTRS_CLOUD_REGION =
      R.SEMRESATTRS_CLOUD_ACCOUNT_ID =
      R.SEMRESATTRS_CLOUD_PROVIDER =
        void 0),
    (R.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE =
      R.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE =
      R.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS =
      R.CLOUDPLATFORMVALUES_AZURE_AKS =
      R.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES =
      R.CLOUDPLATFORMVALUES_AZURE_VM =
      R.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK =
      R.CLOUDPLATFORMVALUES_AWS_LAMBDA =
      R.CLOUDPLATFORMVALUES_AWS_EKS =
      R.CLOUDPLATFORMVALUES_AWS_ECS =
      R.CLOUDPLATFORMVALUES_AWS_EC2 =
      R.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC =
      R.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS =
      R.CloudProviderValues =
      R.CLOUDPROVIDERVALUES_GCP =
      R.CLOUDPROVIDERVALUES_AZURE =
      R.CLOUDPROVIDERVALUES_AWS =
      R.CLOUDPROVIDERVALUES_ALIBABA_CLOUD =
      R.SemanticResourceAttributes =
      R.SEMRESATTRS_WEBENGINE_DESCRIPTION =
      R.SEMRESATTRS_WEBENGINE_VERSION =
      R.SEMRESATTRS_WEBENGINE_NAME =
      R.SEMRESATTRS_TELEMETRY_AUTO_VERSION =
      R.SEMRESATTRS_TELEMETRY_SDK_VERSION =
      R.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE =
      R.SEMRESATTRS_TELEMETRY_SDK_NAME =
      R.SEMRESATTRS_SERVICE_VERSION =
      R.SEMRESATTRS_SERVICE_INSTANCE_ID =
      R.SEMRESATTRS_SERVICE_NAMESPACE =
      R.SEMRESATTRS_SERVICE_NAME =
      R.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION =
      R.SEMRESATTRS_PROCESS_RUNTIME_VERSION =
      R.SEMRESATTRS_PROCESS_RUNTIME_NAME =
      R.SEMRESATTRS_PROCESS_OWNER =
      R.SEMRESATTRS_PROCESS_COMMAND_ARGS =
      R.SEMRESATTRS_PROCESS_COMMAND_LINE =
      R.SEMRESATTRS_PROCESS_COMMAND =
      R.SEMRESATTRS_PROCESS_EXECUTABLE_PATH =
      R.SEMRESATTRS_PROCESS_EXECUTABLE_NAME =
      R.SEMRESATTRS_PROCESS_PID =
      R.SEMRESATTRS_OS_VERSION =
      R.SEMRESATTRS_OS_NAME =
      R.SEMRESATTRS_OS_DESCRIPTION =
      R.SEMRESATTRS_OS_TYPE =
      R.SEMRESATTRS_K8S_CRONJOB_NAME =
      R.SEMRESATTRS_K8S_CRONJOB_UID =
      R.SEMRESATTRS_K8S_JOB_NAME =
      R.SEMRESATTRS_K8S_JOB_UID =
      R.SEMRESATTRS_K8S_DAEMONSET_NAME =
      R.SEMRESATTRS_K8S_DAEMONSET_UID =
        void 0),
    (R.TelemetrySdkLanguageValues =
      R.TELEMETRYSDKLANGUAGEVALUES_WEBJS =
      R.TELEMETRYSDKLANGUAGEVALUES_RUBY =
      R.TELEMETRYSDKLANGUAGEVALUES_PYTHON =
      R.TELEMETRYSDKLANGUAGEVALUES_PHP =
      R.TELEMETRYSDKLANGUAGEVALUES_NODEJS =
      R.TELEMETRYSDKLANGUAGEVALUES_JAVA =
      R.TELEMETRYSDKLANGUAGEVALUES_GO =
      R.TELEMETRYSDKLANGUAGEVALUES_ERLANG =
      R.TELEMETRYSDKLANGUAGEVALUES_DOTNET =
      R.TELEMETRYSDKLANGUAGEVALUES_CPP =
      R.OsTypeValues =
      R.OSTYPEVALUES_Z_OS =
      R.OSTYPEVALUES_SOLARIS =
      R.OSTYPEVALUES_AIX =
      R.OSTYPEVALUES_HPUX =
      R.OSTYPEVALUES_DRAGONFLYBSD =
      R.OSTYPEVALUES_OPENBSD =
      R.OSTYPEVALUES_NETBSD =
      R.OSTYPEVALUES_FREEBSD =
      R.OSTYPEVALUES_DARWIN =
      R.OSTYPEVALUES_LINUX =
      R.OSTYPEVALUES_WINDOWS =
      R.HostArchValues =
      R.HOSTARCHVALUES_X86 =
      R.HOSTARCHVALUES_PPC64 =
      R.HOSTARCHVALUES_PPC32 =
      R.HOSTARCHVALUES_IA64 =
      R.HOSTARCHVALUES_ARM64 =
      R.HOSTARCHVALUES_ARM32 =
      R.HOSTARCHVALUES_AMD64 =
      R.AwsEcsLaunchtypeValues =
      R.AWSECSLAUNCHTYPEVALUES_FARGATE =
      R.AWSECSLAUNCHTYPEVALUES_EC2 =
      R.CloudPlatformValues =
      R.CLOUDPLATFORMVALUES_GCP_APP_ENGINE =
      R.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS =
      R.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE =
      R.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN =
        void 0));
  const e = sI(),
    t = "cloud.provider",
    n = "cloud.account.id",
    r = "cloud.region",
    o = "cloud.availability_zone",
    s = "cloud.platform",
    i = "aws.ecs.container.arn",
    a = "aws.ecs.cluster.arn",
    c = "aws.ecs.launchtype",
    l = "aws.ecs.task.arn",
    f = "aws.ecs.task.family",
    d = "aws.ecs.task.revision",
    u = "aws.eks.cluster.arn",
    _ = "aws.log.group.names",
    p = "aws.log.group.arns",
    E = "aws.log.stream.names",
    h = "aws.log.stream.arns",
    T = "container.name",
    m = "container.id",
    A = "container.runtime",
    g = "container.image.name",
    N = "container.image.tag",
    O = "deployment.environment",
    I = "device.id",
    b = "device.model.identifier",
    w = "device.model.name",
    L = "faas.name",
    j = "faas.id",
    H = "faas.version",
    x = "faas.instance",
    B = "faas.max_memory",
    F = "host.id",
    U = "host.name",
    k = "host.type",
    Y = "host.arch",
    oe = "host.image.name",
    ae = "host.image.id",
    ne = "host.image.version",
    P = "k8s.cluster.name",
    M = "k8s.node.name",
    G = "k8s.node.uid",
    V = "k8s.namespace.name",
    K = "k8s.pod.uid",
    X = "k8s.pod.name",
    v = "k8s.container.name",
    D = "k8s.replicaset.uid",
    z = "k8s.replicaset.name",
    q = "k8s.deployment.uid",
    ee = "k8s.deployment.name",
    te = "k8s.statefulset.uid",
    _e = "k8s.statefulset.name",
    se = "k8s.daemonset.uid",
    ue = "k8s.daemonset.name",
    Te = "k8s.job.uid",
    ve = "k8s.job.name",
    De = "k8s.cronjob.uid",
    qe = "k8s.cronjob.name",
    Mt = "os.type",
    it = "os.description",
    at = "os.name",
    nt = "os.version",
    ss = "process.pid",
    is = "process.executable.name",
    as = "process.executable.path",
    cs = "process.command",
    us = "process.command_line",
    ls = "process.command_args",
    ds = "process.owner",
    fs = "process.runtime.name",
    _s = "process.runtime.version",
    ps = "process.runtime.description",
    Es = "service.name",
    hs = "service.namespace",
    Ts = "service.instance.id",
    Ss = "service.version",
    ms = "telemetry.sdk.name",
    As = "telemetry.sdk.language",
    gs = "telemetry.sdk.version",
    Rs = "telemetry.auto.version",
    Ns = "webengine.name",
    ys = "webengine.version",
    Os = "webengine.description";
  ((R.SEMRESATTRS_CLOUD_PROVIDER = t),
    (R.SEMRESATTRS_CLOUD_ACCOUNT_ID = n),
    (R.SEMRESATTRS_CLOUD_REGION = r),
    (R.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = o),
    (R.SEMRESATTRS_CLOUD_PLATFORM = s),
    (R.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = i),
    (R.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = a),
    (R.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = c),
    (R.SEMRESATTRS_AWS_ECS_TASK_ARN = l),
    (R.SEMRESATTRS_AWS_ECS_TASK_FAMILY = f),
    (R.SEMRESATTRS_AWS_ECS_TASK_REVISION = d),
    (R.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = u),
    (R.SEMRESATTRS_AWS_LOG_GROUP_NAMES = _),
    (R.SEMRESATTRS_AWS_LOG_GROUP_ARNS = p),
    (R.SEMRESATTRS_AWS_LOG_STREAM_NAMES = E),
    (R.SEMRESATTRS_AWS_LOG_STREAM_ARNS = h),
    (R.SEMRESATTRS_CONTAINER_NAME = T),
    (R.SEMRESATTRS_CONTAINER_ID = m),
    (R.SEMRESATTRS_CONTAINER_RUNTIME = A),
    (R.SEMRESATTRS_CONTAINER_IMAGE_NAME = g),
    (R.SEMRESATTRS_CONTAINER_IMAGE_TAG = N),
    (R.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = O),
    (R.SEMRESATTRS_DEVICE_ID = I),
    (R.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = b),
    (R.SEMRESATTRS_DEVICE_MODEL_NAME = w),
    (R.SEMRESATTRS_FAAS_NAME = L),
    (R.SEMRESATTRS_FAAS_ID = j),
    (R.SEMRESATTRS_FAAS_VERSION = H),
    (R.SEMRESATTRS_FAAS_INSTANCE = x),
    (R.SEMRESATTRS_FAAS_MAX_MEMORY = B),
    (R.SEMRESATTRS_HOST_ID = F),
    (R.SEMRESATTRS_HOST_NAME = U),
    (R.SEMRESATTRS_HOST_TYPE = k),
    (R.SEMRESATTRS_HOST_ARCH = Y),
    (R.SEMRESATTRS_HOST_IMAGE_NAME = oe),
    (R.SEMRESATTRS_HOST_IMAGE_ID = ae),
    (R.SEMRESATTRS_HOST_IMAGE_VERSION = ne),
    (R.SEMRESATTRS_K8S_CLUSTER_NAME = P),
    (R.SEMRESATTRS_K8S_NODE_NAME = M),
    (R.SEMRESATTRS_K8S_NODE_UID = G),
    (R.SEMRESATTRS_K8S_NAMESPACE_NAME = V),
    (R.SEMRESATTRS_K8S_POD_UID = K),
    (R.SEMRESATTRS_K8S_POD_NAME = X),
    (R.SEMRESATTRS_K8S_CONTAINER_NAME = v),
    (R.SEMRESATTRS_K8S_REPLICASET_UID = D),
    (R.SEMRESATTRS_K8S_REPLICASET_NAME = z),
    (R.SEMRESATTRS_K8S_DEPLOYMENT_UID = q),
    (R.SEMRESATTRS_K8S_DEPLOYMENT_NAME = ee),
    (R.SEMRESATTRS_K8S_STATEFULSET_UID = te),
    (R.SEMRESATTRS_K8S_STATEFULSET_NAME = _e),
    (R.SEMRESATTRS_K8S_DAEMONSET_UID = se),
    (R.SEMRESATTRS_K8S_DAEMONSET_NAME = ue),
    (R.SEMRESATTRS_K8S_JOB_UID = Te),
    (R.SEMRESATTRS_K8S_JOB_NAME = ve),
    (R.SEMRESATTRS_K8S_CRONJOB_UID = De),
    (R.SEMRESATTRS_K8S_CRONJOB_NAME = qe),
    (R.SEMRESATTRS_OS_TYPE = Mt),
    (R.SEMRESATTRS_OS_DESCRIPTION = it),
    (R.SEMRESATTRS_OS_NAME = at),
    (R.SEMRESATTRS_OS_VERSION = nt),
    (R.SEMRESATTRS_PROCESS_PID = ss),
    (R.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = is),
    (R.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = as),
    (R.SEMRESATTRS_PROCESS_COMMAND = cs),
    (R.SEMRESATTRS_PROCESS_COMMAND_LINE = us),
    (R.SEMRESATTRS_PROCESS_COMMAND_ARGS = ls),
    (R.SEMRESATTRS_PROCESS_OWNER = ds),
    (R.SEMRESATTRS_PROCESS_RUNTIME_NAME = fs),
    (R.SEMRESATTRS_PROCESS_RUNTIME_VERSION = _s),
    (R.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = ps),
    (R.SEMRESATTRS_SERVICE_NAME = Es),
    (R.SEMRESATTRS_SERVICE_NAMESPACE = hs),
    (R.SEMRESATTRS_SERVICE_INSTANCE_ID = Ts),
    (R.SEMRESATTRS_SERVICE_VERSION = Ss),
    (R.SEMRESATTRS_TELEMETRY_SDK_NAME = ms),
    (R.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = As),
    (R.SEMRESATTRS_TELEMETRY_SDK_VERSION = gs),
    (R.SEMRESATTRS_TELEMETRY_AUTO_VERSION = Rs),
    (R.SEMRESATTRS_WEBENGINE_NAME = Ns),
    (R.SEMRESATTRS_WEBENGINE_VERSION = ys),
    (R.SEMRESATTRS_WEBENGINE_DESCRIPTION = Os),
    (R.SemanticResourceAttributes = (0, e.createConstMap)([
      t,
      n,
      r,
      o,
      s,
      i,
      a,
      c,
      l,
      f,
      d,
      u,
      _,
      p,
      E,
      h,
      T,
      m,
      A,
      g,
      N,
      O,
      I,
      b,
      w,
      L,
      j,
      H,
      x,
      B,
      F,
      U,
      k,
      Y,
      oe,
      ae,
      ne,
      P,
      M,
      G,
      V,
      K,
      X,
      v,
      D,
      z,
      q,
      ee,
      te,
      _e,
      se,
      ue,
      Te,
      ve,
      De,
      qe,
      Mt,
      it,
      at,
      nt,
      ss,
      is,
      as,
      cs,
      us,
      ls,
      ds,
      fs,
      _s,
      ps,
      Es,
      hs,
      Ts,
      Ss,
      ms,
      As,
      gs,
      Rs,
      Ns,
      ys,
      Os,
    ])));
  const Cs = "alibaba_cloud",
    bs = "aws",
    Is = "azure",
    Ps = "gcp";
  ((R.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = Cs),
    (R.CLOUDPROVIDERVALUES_AWS = bs),
    (R.CLOUDPROVIDERVALUES_AZURE = Is),
    (R.CLOUDPROVIDERVALUES_GCP = Ps),
    (R.CloudProviderValues = (0, e.createConstMap)([Cs, bs, Is, Ps])));
  const Ms = "alibaba_cloud_ecs",
    vs = "alibaba_cloud_fc",
    Ls = "aws_ec2",
    Ds = "aws_ecs",
    ws = "aws_eks",
    Us = "aws_lambda",
    ks = "aws_elastic_beanstalk",
    Gs = "azure_vm",
    Vs = "azure_container_instances",
    xs = "azure_aks",
    $s = "azure_functions",
    Bs = "azure_app_service",
    Hs = "gcp_compute_engine",
    Fs = "gcp_cloud_run",
    Ys = "gcp_kubernetes_engine",
    js = "gcp_cloud_functions",
    qs = "gcp_app_engine";
  ((R.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = Ms),
    (R.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = vs),
    (R.CLOUDPLATFORMVALUES_AWS_EC2 = Ls),
    (R.CLOUDPLATFORMVALUES_AWS_ECS = Ds),
    (R.CLOUDPLATFORMVALUES_AWS_EKS = ws),
    (R.CLOUDPLATFORMVALUES_AWS_LAMBDA = Us),
    (R.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = ks),
    (R.CLOUDPLATFORMVALUES_AZURE_VM = Gs),
    (R.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = Vs),
    (R.CLOUDPLATFORMVALUES_AZURE_AKS = xs),
    (R.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = $s),
    (R.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = Bs),
    (R.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = Hs),
    (R.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = Fs),
    (R.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = Ys),
    (R.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = js),
    (R.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = qs),
    (R.CloudPlatformValues = (0, e.createConstMap)([
      Ms,
      vs,
      Ls,
      Ds,
      ws,
      Us,
      ks,
      Gs,
      Vs,
      xs,
      $s,
      Bs,
      Hs,
      Fs,
      Ys,
      js,
      qs,
    ])));
  const Ws = "ec2",
    Ks = "fargate";
  ((R.AWSECSLAUNCHTYPEVALUES_EC2 = Ws),
    (R.AWSECSLAUNCHTYPEVALUES_FARGATE = Ks),
    (R.AwsEcsLaunchtypeValues = (0, e.createConstMap)([Ws, Ks])));
  const zs = "amd64",
    Zs = "arm32",
    Xs = "arm64",
    Qs = "ia64",
    Js = "ppc32",
    ei = "ppc64",
    ti = "x86";
  ((R.HOSTARCHVALUES_AMD64 = zs),
    (R.HOSTARCHVALUES_ARM32 = Zs),
    (R.HOSTARCHVALUES_ARM64 = Xs),
    (R.HOSTARCHVALUES_IA64 = Qs),
    (R.HOSTARCHVALUES_PPC32 = Js),
    (R.HOSTARCHVALUES_PPC64 = ei),
    (R.HOSTARCHVALUES_X86 = ti),
    (R.HostArchValues = (0, e.createConstMap)([zs, Zs, Xs, Qs, Js, ei, ti])));
  const ni = "windows",
    ri = "linux",
    oi = "darwin",
    si = "freebsd",
    ii = "netbsd",
    ai = "openbsd",
    ci = "dragonflybsd",
    ui = "hpux",
    li = "aix",
    di = "solaris",
    fi = "z_os";
  ((R.OSTYPEVALUES_WINDOWS = ni),
    (R.OSTYPEVALUES_LINUX = ri),
    (R.OSTYPEVALUES_DARWIN = oi),
    (R.OSTYPEVALUES_FREEBSD = si),
    (R.OSTYPEVALUES_NETBSD = ii),
    (R.OSTYPEVALUES_OPENBSD = ai),
    (R.OSTYPEVALUES_DRAGONFLYBSD = ci),
    (R.OSTYPEVALUES_HPUX = ui),
    (R.OSTYPEVALUES_AIX = li),
    (R.OSTYPEVALUES_SOLARIS = di),
    (R.OSTYPEVALUES_Z_OS = fi),
    (R.OsTypeValues = (0, e.createConstMap)([
      ni,
      ri,
      oi,
      si,
      ii,
      ai,
      ci,
      ui,
      li,
      di,
      fi,
    ])));
  const _i = "cpp",
    pi = "dotnet",
    Ei = "erlang",
    hi = "go",
    Ti = "java",
    Si = "nodejs",
    mi = "php",
    Ai = "python",
    gi = "ruby",
    Ri = "webjs";
  return (
    (R.TELEMETRYSDKLANGUAGEVALUES_CPP = _i),
    (R.TELEMETRYSDKLANGUAGEVALUES_DOTNET = pi),
    (R.TELEMETRYSDKLANGUAGEVALUES_ERLANG = Ei),
    (R.TELEMETRYSDKLANGUAGEVALUES_GO = hi),
    (R.TELEMETRYSDKLANGUAGEVALUES_JAVA = Ti),
    (R.TELEMETRYSDKLANGUAGEVALUES_NODEJS = Si),
    (R.TELEMETRYSDKLANGUAGEVALUES_PHP = mi),
    (R.TELEMETRYSDKLANGUAGEVALUES_PYTHON = Ai),
    (R.TELEMETRYSDKLANGUAGEVALUES_RUBY = gi),
    (R.TELEMETRYSDKLANGUAGEVALUES_WEBJS = Ri),
    (R.TelemetrySdkLanguageValues = (0, e.createConstMap)([
      _i,
      pi,
      Ei,
      hi,
      Ti,
      Si,
      mi,
      Ai,
      gi,
      Ri,
    ])),
    R
  );
}
var Qm;
function kw() {
  return (
    Qm ||
      ((Qm = 1),
      (function (e) {
        var t =
            (mr && mr.__createBinding) ||
            (Object.create
              ? function (r, o, s, i) {
                  i === void 0 && (i = s);
                  var a = Object.getOwnPropertyDescriptor(o, s);
                  ((!a ||
                    ("get" in a
                      ? !o.__esModule
                      : a.writable || a.configurable)) &&
                    (a = {
                      enumerable: !0,
                      get: function () {
                        return o[s];
                      },
                    }),
                    Object.defineProperty(r, i, a));
                }
              : function (r, o, s, i) {
                  (i === void 0 && (i = s), (r[i] = o[s]));
                }),
          n =
            (mr && mr.__exportStar) ||
            function (r, o) {
              for (var s in r)
                s !== "default" &&
                  !Object.prototype.hasOwnProperty.call(o, s) &&
                  t(o, r, s);
            };
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          n(Uw(), e));
      })(mr)),
    mr
  );
}
var y = {},
  Jm;
function Gw() {
  if (Jm) return y;
  ((Jm = 1),
    Object.defineProperty(y, "__esModule", {
      value: !0,
    }),
    (y.ATTR_EXCEPTION_TYPE =
      y.ATTR_EXCEPTION_STACKTRACE =
      y.ATTR_EXCEPTION_MESSAGE =
      y.ATTR_EXCEPTION_ESCAPED =
      y.ERROR_TYPE_VALUE_OTHER =
      y.ATTR_ERROR_TYPE =
      y.DOTNET_GC_HEAP_GENERATION_VALUE_POH =
      y.DOTNET_GC_HEAP_GENERATION_VALUE_LOH =
      y.DOTNET_GC_HEAP_GENERATION_VALUE_GEN2 =
      y.DOTNET_GC_HEAP_GENERATION_VALUE_GEN1 =
      y.DOTNET_GC_HEAP_GENERATION_VALUE_GEN0 =
      y.ATTR_DOTNET_GC_HEAP_GENERATION =
      y.DB_SYSTEM_NAME_VALUE_POSTGRESQL =
      y.DB_SYSTEM_NAME_VALUE_MYSQL =
      y.DB_SYSTEM_NAME_VALUE_MICROSOFT_SQL_SERVER =
      y.DB_SYSTEM_NAME_VALUE_MARIADB =
      y.ATTR_DB_SYSTEM_NAME =
      y.ATTR_DB_STORED_PROCEDURE_NAME =
      y.ATTR_DB_RESPONSE_STATUS_CODE =
      y.ATTR_DB_QUERY_TEXT =
      y.ATTR_DB_QUERY_SUMMARY =
      y.ATTR_DB_OPERATION_NAME =
      y.ATTR_DB_OPERATION_BATCH_SIZE =
      y.ATTR_DB_NAMESPACE =
      y.ATTR_DB_COLLECTION_NAME =
      y.ATTR_CODE_STACKTRACE =
      y.ATTR_CODE_LINE_NUMBER =
      y.ATTR_CODE_FUNCTION_NAME =
      y.ATTR_CODE_FILE_PATH =
      y.ATTR_CODE_COLUMN_NUMBER =
      y.ATTR_CLIENT_PORT =
      y.ATTR_CLIENT_ADDRESS =
      y.ATTR_ASPNETCORE_USER_IS_AUTHENTICATED =
      y.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS =
      y.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE =
      y.ATTR_ASPNETCORE_ROUTING_MATCH_STATUS =
      y.ATTR_ASPNETCORE_ROUTING_IS_FALLBACK =
      y.ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED =
      y.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED =
      y.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER =
      y.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER =
      y.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED =
      y.ATTR_ASPNETCORE_RATE_LIMITING_RESULT =
      y.ATTR_ASPNETCORE_RATE_LIMITING_POLICY =
      y.ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE =
      y.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED =
      y.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED =
      y.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED =
      y.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED =
      y.ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT =
        void 0),
    (y.OTEL_STATUS_CODE_VALUE_ERROR =
      y.ATTR_OTEL_STATUS_CODE =
      y.ATTR_OTEL_SCOPE_VERSION =
      y.ATTR_OTEL_SCOPE_NAME =
      y.NETWORK_TYPE_VALUE_IPV6 =
      y.NETWORK_TYPE_VALUE_IPV4 =
      y.ATTR_NETWORK_TYPE =
      y.NETWORK_TRANSPORT_VALUE_UNIX =
      y.NETWORK_TRANSPORT_VALUE_UDP =
      y.NETWORK_TRANSPORT_VALUE_TCP =
      y.NETWORK_TRANSPORT_VALUE_QUIC =
      y.NETWORK_TRANSPORT_VALUE_PIPE =
      y.ATTR_NETWORK_TRANSPORT =
      y.ATTR_NETWORK_PROTOCOL_VERSION =
      y.ATTR_NETWORK_PROTOCOL_NAME =
      y.ATTR_NETWORK_PEER_PORT =
      y.ATTR_NETWORK_PEER_ADDRESS =
      y.ATTR_NETWORK_LOCAL_PORT =
      y.ATTR_NETWORK_LOCAL_ADDRESS =
      y.JVM_THREAD_STATE_VALUE_WAITING =
      y.JVM_THREAD_STATE_VALUE_TIMED_WAITING =
      y.JVM_THREAD_STATE_VALUE_TERMINATED =
      y.JVM_THREAD_STATE_VALUE_RUNNABLE =
      y.JVM_THREAD_STATE_VALUE_NEW =
      y.JVM_THREAD_STATE_VALUE_BLOCKED =
      y.ATTR_JVM_THREAD_STATE =
      y.ATTR_JVM_THREAD_DAEMON =
      y.JVM_MEMORY_TYPE_VALUE_NON_HEAP =
      y.JVM_MEMORY_TYPE_VALUE_HEAP =
      y.ATTR_JVM_MEMORY_TYPE =
      y.ATTR_JVM_MEMORY_POOL_NAME =
      y.ATTR_JVM_GC_NAME =
      y.ATTR_JVM_GC_ACTION =
      y.ATTR_HTTP_ROUTE =
      y.ATTR_HTTP_RESPONSE_STATUS_CODE =
      y.ATTR_HTTP_RESPONSE_HEADER =
      y.ATTR_HTTP_REQUEST_RESEND_COUNT =
      y.ATTR_HTTP_REQUEST_METHOD_ORIGINAL =
      y.HTTP_REQUEST_METHOD_VALUE_TRACE =
      y.HTTP_REQUEST_METHOD_VALUE_PUT =
      y.HTTP_REQUEST_METHOD_VALUE_POST =
      y.HTTP_REQUEST_METHOD_VALUE_PATCH =
      y.HTTP_REQUEST_METHOD_VALUE_OPTIONS =
      y.HTTP_REQUEST_METHOD_VALUE_HEAD =
      y.HTTP_REQUEST_METHOD_VALUE_GET =
      y.HTTP_REQUEST_METHOD_VALUE_DELETE =
      y.HTTP_REQUEST_METHOD_VALUE_CONNECT =
      y.HTTP_REQUEST_METHOD_VALUE_OTHER =
      y.ATTR_HTTP_REQUEST_METHOD =
      y.ATTR_HTTP_REQUEST_HEADER =
        void 0),
    (y.ATTR_USER_AGENT_ORIGINAL =
      y.ATTR_URL_SCHEME =
      y.ATTR_URL_QUERY =
      y.ATTR_URL_PATH =
      y.ATTR_URL_FULL =
      y.ATTR_URL_FRAGMENT =
      y.ATTR_TELEMETRY_SDK_VERSION =
      y.ATTR_TELEMETRY_SDK_NAME =
      y.TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS =
      y.TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT =
      y.TELEMETRY_SDK_LANGUAGE_VALUE_RUST =
      y.TELEMETRY_SDK_LANGUAGE_VALUE_RUBY =
      y.TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON =
      y.TELEMETRY_SDK_LANGUAGE_VALUE_PHP =
      y.TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS =
      y.TELEMETRY_SDK_LANGUAGE_VALUE_JAVA =
      y.TELEMETRY_SDK_LANGUAGE_VALUE_GO =
      y.TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG =
      y.TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET =
      y.TELEMETRY_SDK_LANGUAGE_VALUE_CPP =
      y.ATTR_TELEMETRY_SDK_LANGUAGE =
      y.SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS =
      y.SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS =
      y.SIGNALR_TRANSPORT_VALUE_LONG_POLLING =
      y.ATTR_SIGNALR_TRANSPORT =
      y.SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT =
      y.SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE =
      y.SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN =
      y.ATTR_SIGNALR_CONNECTION_STATUS =
      y.ATTR_SERVICE_VERSION =
      y.ATTR_SERVICE_NAME =
      y.ATTR_SERVER_PORT =
      y.ATTR_SERVER_ADDRESS =
      y.ATTR_OTEL_STATUS_DESCRIPTION =
      y.OTEL_STATUS_CODE_VALUE_OK =
        void 0),
    (y.ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT =
      "aspnetcore.diagnostics.exception.result"),
    (y.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED = "aborted"),
    (y.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED = "handled"),
    (y.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED = "skipped"),
    (y.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED = "unhandled"),
    (y.ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE =
      "aspnetcore.diagnostics.handler.type"),
    (y.ATTR_ASPNETCORE_RATE_LIMITING_POLICY =
      "aspnetcore.rate_limiting.policy"),
    (y.ATTR_ASPNETCORE_RATE_LIMITING_RESULT =
      "aspnetcore.rate_limiting.result"),
    (y.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED = "acquired"),
    (y.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER =
      "endpoint_limiter"),
    (y.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER = "global_limiter"),
    (y.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED =
      "request_canceled"),
    (y.ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED =
      "aspnetcore.request.is_unhandled"),
    (y.ATTR_ASPNETCORE_ROUTING_IS_FALLBACK = "aspnetcore.routing.is_fallback"),
    (y.ATTR_ASPNETCORE_ROUTING_MATCH_STATUS =
      "aspnetcore.routing.match_status"),
    (y.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE = "failure"),
    (y.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS = "success"),
    (y.ATTR_ASPNETCORE_USER_IS_AUTHENTICATED =
      "aspnetcore.user.is_authenticated"),
    (y.ATTR_CLIENT_ADDRESS = "client.address"),
    (y.ATTR_CLIENT_PORT = "client.port"),
    (y.ATTR_CODE_COLUMN_NUMBER = "code.column.number"),
    (y.ATTR_CODE_FILE_PATH = "code.file.path"),
    (y.ATTR_CODE_FUNCTION_NAME = "code.function.name"),
    (y.ATTR_CODE_LINE_NUMBER = "code.line.number"),
    (y.ATTR_CODE_STACKTRACE = "code.stacktrace"),
    (y.ATTR_DB_COLLECTION_NAME = "db.collection.name"),
    (y.ATTR_DB_NAMESPACE = "db.namespace"),
    (y.ATTR_DB_OPERATION_BATCH_SIZE = "db.operation.batch.size"),
    (y.ATTR_DB_OPERATION_NAME = "db.operation.name"),
    (y.ATTR_DB_QUERY_SUMMARY = "db.query.summary"),
    (y.ATTR_DB_QUERY_TEXT = "db.query.text"),
    (y.ATTR_DB_RESPONSE_STATUS_CODE = "db.response.status_code"),
    (y.ATTR_DB_STORED_PROCEDURE_NAME = "db.stored_procedure.name"),
    (y.ATTR_DB_SYSTEM_NAME = "db.system.name"),
    (y.DB_SYSTEM_NAME_VALUE_MARIADB = "mariadb"),
    (y.DB_SYSTEM_NAME_VALUE_MICROSOFT_SQL_SERVER = "microsoft.sql_server"),
    (y.DB_SYSTEM_NAME_VALUE_MYSQL = "mysql"),
    (y.DB_SYSTEM_NAME_VALUE_POSTGRESQL = "postgresql"),
    (y.ATTR_DOTNET_GC_HEAP_GENERATION = "dotnet.gc.heap.generation"),
    (y.DOTNET_GC_HEAP_GENERATION_VALUE_GEN0 = "gen0"),
    (y.DOTNET_GC_HEAP_GENERATION_VALUE_GEN1 = "gen1"),
    (y.DOTNET_GC_HEAP_GENERATION_VALUE_GEN2 = "gen2"),
    (y.DOTNET_GC_HEAP_GENERATION_VALUE_LOH = "loh"),
    (y.DOTNET_GC_HEAP_GENERATION_VALUE_POH = "poh"),
    (y.ATTR_ERROR_TYPE = "error.type"),
    (y.ERROR_TYPE_VALUE_OTHER = "_OTHER"),
    (y.ATTR_EXCEPTION_ESCAPED = "exception.escaped"),
    (y.ATTR_EXCEPTION_MESSAGE = "exception.message"),
    (y.ATTR_EXCEPTION_STACKTRACE = "exception.stacktrace"),
    (y.ATTR_EXCEPTION_TYPE = "exception.type"));
  const e = (n) => `http.request.header.${n}`;
  ((y.ATTR_HTTP_REQUEST_HEADER = e),
    (y.ATTR_HTTP_REQUEST_METHOD = "http.request.method"),
    (y.HTTP_REQUEST_METHOD_VALUE_OTHER = "_OTHER"),
    (y.HTTP_REQUEST_METHOD_VALUE_CONNECT = "CONNECT"),
    (y.HTTP_REQUEST_METHOD_VALUE_DELETE = "DELETE"),
    (y.HTTP_REQUEST_METHOD_VALUE_GET = "GET"),
    (y.HTTP_REQUEST_METHOD_VALUE_HEAD = "HEAD"),
    (y.HTTP_REQUEST_METHOD_VALUE_OPTIONS = "OPTIONS"),
    (y.HTTP_REQUEST_METHOD_VALUE_PATCH = "PATCH"),
    (y.HTTP_REQUEST_METHOD_VALUE_POST = "POST"),
    (y.HTTP_REQUEST_METHOD_VALUE_PUT = "PUT"),
    (y.HTTP_REQUEST_METHOD_VALUE_TRACE = "TRACE"),
    (y.ATTR_HTTP_REQUEST_METHOD_ORIGINAL = "http.request.method_original"),
    (y.ATTR_HTTP_REQUEST_RESEND_COUNT = "http.request.resend_count"));
  const t = (n) => `http.response.header.${n}`;
  return (
    (y.ATTR_HTTP_RESPONSE_HEADER = t),
    (y.ATTR_HTTP_RESPONSE_STATUS_CODE = "http.response.status_code"),
    (y.ATTR_HTTP_ROUTE = "http.route"),
    (y.ATTR_JVM_GC_ACTION = "jvm.gc.action"),
    (y.ATTR_JVM_GC_NAME = "jvm.gc.name"),
    (y.ATTR_JVM_MEMORY_POOL_NAME = "jvm.memory.pool.name"),
    (y.ATTR_JVM_MEMORY_TYPE = "jvm.memory.type"),
    (y.JVM_MEMORY_TYPE_VALUE_HEAP = "heap"),
    (y.JVM_MEMORY_TYPE_VALUE_NON_HEAP = "non_heap"),
    (y.ATTR_JVM_THREAD_DAEMON = "jvm.thread.daemon"),
    (y.ATTR_JVM_THREAD_STATE = "jvm.thread.state"),
    (y.JVM_THREAD_STATE_VALUE_BLOCKED = "blocked"),
    (y.JVM_THREAD_STATE_VALUE_NEW = "new"),
    (y.JVM_THREAD_STATE_VALUE_RUNNABLE = "runnable"),
    (y.JVM_THREAD_STATE_VALUE_TERMINATED = "terminated"),
    (y.JVM_THREAD_STATE_VALUE_TIMED_WAITING = "timed_waiting"),
    (y.JVM_THREAD_STATE_VALUE_WAITING = "waiting"),
    (y.ATTR_NETWORK_LOCAL_ADDRESS = "network.local.address"),
    (y.ATTR_NETWORK_LOCAL_PORT = "network.local.port"),
    (y.ATTR_NETWORK_PEER_ADDRESS = "network.peer.address"),
    (y.ATTR_NETWORK_PEER_PORT = "network.peer.port"),
    (y.ATTR_NETWORK_PROTOCOL_NAME = "network.protocol.name"),
    (y.ATTR_NETWORK_PROTOCOL_VERSION = "network.protocol.version"),
    (y.ATTR_NETWORK_TRANSPORT = "network.transport"),
    (y.NETWORK_TRANSPORT_VALUE_PIPE = "pipe"),
    (y.NETWORK_TRANSPORT_VALUE_QUIC = "quic"),
    (y.NETWORK_TRANSPORT_VALUE_TCP = "tcp"),
    (y.NETWORK_TRANSPORT_VALUE_UDP = "udp"),
    (y.NETWORK_TRANSPORT_VALUE_UNIX = "unix"),
    (y.ATTR_NETWORK_TYPE = "network.type"),
    (y.NETWORK_TYPE_VALUE_IPV4 = "ipv4"),
    (y.NETWORK_TYPE_VALUE_IPV6 = "ipv6"),
    (y.ATTR_OTEL_SCOPE_NAME = "otel.scope.name"),
    (y.ATTR_OTEL_SCOPE_VERSION = "otel.scope.version"),
    (y.ATTR_OTEL_STATUS_CODE = "otel.status_code"),
    (y.OTEL_STATUS_CODE_VALUE_ERROR = "ERROR"),
    (y.OTEL_STATUS_CODE_VALUE_OK = "OK"),
    (y.ATTR_OTEL_STATUS_DESCRIPTION = "otel.status_description"),
    (y.ATTR_SERVER_ADDRESS = "server.address"),
    (y.ATTR_SERVER_PORT = "server.port"),
    (y.ATTR_SERVICE_NAME = "service.name"),
    (y.ATTR_SERVICE_VERSION = "service.version"),
    (y.ATTR_SIGNALR_CONNECTION_STATUS = "signalr.connection.status"),
    (y.SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN = "app_shutdown"),
    (y.SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE = "normal_closure"),
    (y.SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT = "timeout"),
    (y.ATTR_SIGNALR_TRANSPORT = "signalr.transport"),
    (y.SIGNALR_TRANSPORT_VALUE_LONG_POLLING = "long_polling"),
    (y.SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS = "server_sent_events"),
    (y.SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS = "web_sockets"),
    (y.ATTR_TELEMETRY_SDK_LANGUAGE = "telemetry.sdk.language"),
    (y.TELEMETRY_SDK_LANGUAGE_VALUE_CPP = "cpp"),
    (y.TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET = "dotnet"),
    (y.TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG = "erlang"),
    (y.TELEMETRY_SDK_LANGUAGE_VALUE_GO = "go"),
    (y.TELEMETRY_SDK_LANGUAGE_VALUE_JAVA = "java"),
    (y.TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS = "nodejs"),
    (y.TELEMETRY_SDK_LANGUAGE_VALUE_PHP = "php"),
    (y.TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON = "python"),
    (y.TELEMETRY_SDK_LANGUAGE_VALUE_RUBY = "ruby"),
    (y.TELEMETRY_SDK_LANGUAGE_VALUE_RUST = "rust"),
    (y.TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT = "swift"),
    (y.TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS = "webjs"),
    (y.ATTR_TELEMETRY_SDK_NAME = "telemetry.sdk.name"),
    (y.ATTR_TELEMETRY_SDK_VERSION = "telemetry.sdk.version"),
    (y.ATTR_URL_FRAGMENT = "url.fragment"),
    (y.ATTR_URL_FULL = "url.full"),
    (y.ATTR_URL_PATH = "url.path"),
    (y.ATTR_URL_QUERY = "url.query"),
    (y.ATTR_URL_SCHEME = "url.scheme"),
    (y.ATTR_USER_AGENT_ORIGINAL = "user_agent.original"),
    y
  );
}
var Z = {},
  eA;
function Vw() {
  return (
    eA ||
      ((eA = 1),
      Object.defineProperty(Z, "__esModule", {
        value: !0,
      }),
      (Z.METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS =
        Z.METRIC_KESTREL_UPGRADED_CONNECTIONS =
        Z.METRIC_KESTREL_TLS_HANDSHAKE_DURATION =
        Z.METRIC_KESTREL_REJECTED_CONNECTIONS =
        Z.METRIC_KESTREL_QUEUED_REQUESTS =
        Z.METRIC_KESTREL_QUEUED_CONNECTIONS =
        Z.METRIC_KESTREL_CONNECTION_DURATION =
        Z.METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES =
        Z.METRIC_KESTREL_ACTIVE_CONNECTIONS =
        Z.METRIC_JVM_THREAD_COUNT =
        Z.METRIC_JVM_MEMORY_USED_AFTER_LAST_GC =
        Z.METRIC_JVM_MEMORY_USED =
        Z.METRIC_JVM_MEMORY_LIMIT =
        Z.METRIC_JVM_MEMORY_COMMITTED =
        Z.METRIC_JVM_GC_DURATION =
        Z.METRIC_JVM_CPU_TIME =
        Z.METRIC_JVM_CPU_RECENT_UTILIZATION =
        Z.METRIC_JVM_CPU_COUNT =
        Z.METRIC_JVM_CLASS_UNLOADED =
        Z.METRIC_JVM_CLASS_LOADED =
        Z.METRIC_JVM_CLASS_COUNT =
        Z.METRIC_HTTP_SERVER_REQUEST_DURATION =
        Z.METRIC_HTTP_CLIENT_REQUEST_DURATION =
        Z.METRIC_DOTNET_TIMER_COUNT =
        Z.METRIC_DOTNET_THREAD_POOL_WORK_ITEM_COUNT =
        Z.METRIC_DOTNET_THREAD_POOL_THREAD_COUNT =
        Z.METRIC_DOTNET_THREAD_POOL_QUEUE_LENGTH =
        Z.METRIC_DOTNET_PROCESS_MEMORY_WORKING_SET =
        Z.METRIC_DOTNET_PROCESS_CPU_TIME =
        Z.METRIC_DOTNET_PROCESS_CPU_COUNT =
        Z.METRIC_DOTNET_MONITOR_LOCK_CONTENTIONS =
        Z.METRIC_DOTNET_JIT_COMPILED_METHODS =
        Z.METRIC_DOTNET_JIT_COMPILED_IL_SIZE =
        Z.METRIC_DOTNET_JIT_COMPILATION_TIME =
        Z.METRIC_DOTNET_GC_PAUSE_TIME =
        Z.METRIC_DOTNET_GC_LAST_COLLECTION_MEMORY_COMMITTED_SIZE =
        Z.METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_SIZE =
        Z.METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_FRAGMENTATION_SIZE =
        Z.METRIC_DOTNET_GC_HEAP_TOTAL_ALLOCATED =
        Z.METRIC_DOTNET_GC_COLLECTIONS =
        Z.METRIC_DOTNET_EXCEPTIONS =
        Z.METRIC_DOTNET_ASSEMBLY_COUNT =
        Z.METRIC_DB_CLIENT_OPERATION_DURATION =
        Z.METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS =
        Z.METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS =
        Z.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION =
        Z.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE =
        Z.METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS =
        Z.METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES =
        Z.METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS =
          void 0),
      (Z.METRIC_SIGNALR_SERVER_CONNECTION_DURATION = void 0),
      (Z.METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS =
        "aspnetcore.diagnostics.exceptions"),
      (Z.METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES =
        "aspnetcore.rate_limiting.active_request_leases"),
      (Z.METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS =
        "aspnetcore.rate_limiting.queued_requests"),
      (Z.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE =
        "aspnetcore.rate_limiting.request.time_in_queue"),
      (Z.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION =
        "aspnetcore.rate_limiting.request_lease.duration"),
      (Z.METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS =
        "aspnetcore.rate_limiting.requests"),
      (Z.METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS =
        "aspnetcore.routing.match_attempts"),
      (Z.METRIC_DB_CLIENT_OPERATION_DURATION = "db.client.operation.duration"),
      (Z.METRIC_DOTNET_ASSEMBLY_COUNT = "dotnet.assembly.count"),
      (Z.METRIC_DOTNET_EXCEPTIONS = "dotnet.exceptions"),
      (Z.METRIC_DOTNET_GC_COLLECTIONS = "dotnet.gc.collections"),
      (Z.METRIC_DOTNET_GC_HEAP_TOTAL_ALLOCATED =
        "dotnet.gc.heap.total_allocated"),
      (Z.METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_FRAGMENTATION_SIZE =
        "dotnet.gc.last_collection.heap.fragmentation.size"),
      (Z.METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_SIZE =
        "dotnet.gc.last_collection.heap.size"),
      (Z.METRIC_DOTNET_GC_LAST_COLLECTION_MEMORY_COMMITTED_SIZE =
        "dotnet.gc.last_collection.memory.committed_size"),
      (Z.METRIC_DOTNET_GC_PAUSE_TIME = "dotnet.gc.pause.time"),
      (Z.METRIC_DOTNET_JIT_COMPILATION_TIME = "dotnet.jit.compilation.time"),
      (Z.METRIC_DOTNET_JIT_COMPILED_IL_SIZE = "dotnet.jit.compiled_il.size"),
      (Z.METRIC_DOTNET_JIT_COMPILED_METHODS = "dotnet.jit.compiled_methods"),
      (Z.METRIC_DOTNET_MONITOR_LOCK_CONTENTIONS =
        "dotnet.monitor.lock_contentions"),
      (Z.METRIC_DOTNET_PROCESS_CPU_COUNT = "dotnet.process.cpu.count"),
      (Z.METRIC_DOTNET_PROCESS_CPU_TIME = "dotnet.process.cpu.time"),
      (Z.METRIC_DOTNET_PROCESS_MEMORY_WORKING_SET =
        "dotnet.process.memory.working_set"),
      (Z.METRIC_DOTNET_THREAD_POOL_QUEUE_LENGTH =
        "dotnet.thread_pool.queue.length"),
      (Z.METRIC_DOTNET_THREAD_POOL_THREAD_COUNT =
        "dotnet.thread_pool.thread.count"),
      (Z.METRIC_DOTNET_THREAD_POOL_WORK_ITEM_COUNT =
        "dotnet.thread_pool.work_item.count"),
      (Z.METRIC_DOTNET_TIMER_COUNT = "dotnet.timer.count"),
      (Z.METRIC_HTTP_CLIENT_REQUEST_DURATION = "http.client.request.duration"),
      (Z.METRIC_HTTP_SERVER_REQUEST_DURATION = "http.server.request.duration"),
      (Z.METRIC_JVM_CLASS_COUNT = "jvm.class.count"),
      (Z.METRIC_JVM_CLASS_LOADED = "jvm.class.loaded"),
      (Z.METRIC_JVM_CLASS_UNLOADED = "jvm.class.unloaded"),
      (Z.METRIC_JVM_CPU_COUNT = "jvm.cpu.count"),
      (Z.METRIC_JVM_CPU_RECENT_UTILIZATION = "jvm.cpu.recent_utilization"),
      (Z.METRIC_JVM_CPU_TIME = "jvm.cpu.time"),
      (Z.METRIC_JVM_GC_DURATION = "jvm.gc.duration"),
      (Z.METRIC_JVM_MEMORY_COMMITTED = "jvm.memory.committed"),
      (Z.METRIC_JVM_MEMORY_LIMIT = "jvm.memory.limit"),
      (Z.METRIC_JVM_MEMORY_USED = "jvm.memory.used"),
      (Z.METRIC_JVM_MEMORY_USED_AFTER_LAST_GC =
        "jvm.memory.used_after_last_gc"),
      (Z.METRIC_JVM_THREAD_COUNT = "jvm.thread.count"),
      (Z.METRIC_KESTREL_ACTIVE_CONNECTIONS = "kestrel.active_connections"),
      (Z.METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES =
        "kestrel.active_tls_handshakes"),
      (Z.METRIC_KESTREL_CONNECTION_DURATION = "kestrel.connection.duration"),
      (Z.METRIC_KESTREL_QUEUED_CONNECTIONS = "kestrel.queued_connections"),
      (Z.METRIC_KESTREL_QUEUED_REQUESTS = "kestrel.queued_requests"),
      (Z.METRIC_KESTREL_REJECTED_CONNECTIONS = "kestrel.rejected_connections"),
      (Z.METRIC_KESTREL_TLS_HANDSHAKE_DURATION =
        "kestrel.tls_handshake.duration"),
      (Z.METRIC_KESTREL_UPGRADED_CONNECTIONS = "kestrel.upgraded_connections"),
      (Z.METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS =
        "signalr.server.active_connections"),
      (Z.METRIC_SIGNALR_SERVER_CONNECTION_DURATION =
        "signalr.server.connection.duration")),
    Z
  );
}
var Xi = {},
  tA;
function xw() {
  return (
    tA ||
      ((tA = 1),
      Object.defineProperty(Xi, "__esModule", {
        value: !0,
      }),
      (Xi.EVENT_EXCEPTION = void 0),
      (Xi.EVENT_EXCEPTION = "exception")),
    Xi
  );
}
var nA;
function pt() {
  return (
    nA ||
      ((nA = 1),
      (function (e) {
        var t =
            (Tr && Tr.__createBinding) ||
            (Object.create
              ? function (r, o, s, i) {
                  i === void 0 && (i = s);
                  var a = Object.getOwnPropertyDescriptor(o, s);
                  ((!a ||
                    ("get" in a
                      ? !o.__esModule
                      : a.writable || a.configurable)) &&
                    (a = {
                      enumerable: !0,
                      get: function () {
                        return o[s];
                      },
                    }),
                    Object.defineProperty(r, i, a));
                }
              : function (r, o, s, i) {
                  (i === void 0 && (i = s), (r[i] = o[s]));
                }),
          n =
            (Tr && Tr.__exportStar) ||
            function (r, o) {
              for (var s in r)
                s !== "default" &&
                  !Object.prototype.hasOwnProperty.call(o, s) &&
                  t(o, r, s);
            };
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          n(ww(), e),
          n(kw(), e),
          n(Gw(), e),
          n(Vw(), e),
          n(xw(), e));
      })(Tr)),
    Tr
  );
}
var Q = pt();
const $w = "process.runtime.name",
  Zc = {
    [Q.ATTR_TELEMETRY_SDK_NAME]: "opentelemetry",
    [$w]: "node",
    [Q.ATTR_TELEMETRY_SDK_LANGUAGE]: Q.TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS,
    [Q.ATTR_TELEMETRY_SDK_VERSION]: Lw,
  },
  iI = 9,
  Bw = 6,
  Hw = Math.pow(10, Bw),
  cu = Math.pow(10, iI);
function kn(e) {
  const t = e / 1e3,
    n = Math.trunc(t),
    r = Math.round((e % 1e3) * Hw);
  return [n, r];
}
function tl() {
  let e = Wr.timeOrigin;
  if (typeof e != "number") {
    const t = Wr;
    e = t.timing && t.timing.fetchStart;
  }
  return e;
}
function rE(e) {
  const t = kn(tl()),
    n = kn(typeof e == "number" ? e : Wr.now());
  return oE(t, n);
}
function Fw(e) {
  if (nl(e)) return e;
  if (typeof e == "number") return e < tl() ? rE(e) : kn(e);
  if (e instanceof Date) return kn(e.getTime());
  throw TypeError("Invalid input type");
}
function aI(e, t) {
  let n = t[0] - e[0],
    r = t[1] - e[1];
  return (r < 0 && ((n -= 1), (r += cu)), [n, r]);
}
function Yw(e) {
  const t = iI,
    n = `${"0".repeat(t)}${e[1]}Z`,
    r = n.substring(n.length - t - 1);
  return new Date(e[0] * 1e3).toISOString().replace("000Z", r);
}
function jw(e) {
  return e[0] * cu + e[1];
}
function qw(e) {
  return e[0] * 1e3 + e[1] / 1e6;
}
function Ww(e) {
  return e[0] * 1e6 + e[1] / 1e3;
}
function nl(e) {
  return (
    Array.isArray(e) &&
    e.length === 2 &&
    typeof e[0] == "number" &&
    typeof e[1] == "number"
  );
}
function sp(e) {
  return nl(e) || typeof e == "number" || e instanceof Date;
}
function oE(e, t) {
  const n = [e[0] + t[0], e[1] + t[1]];
  return (n[1] >= cu && ((n[1] -= cu), (n[0] += 1)), n);
}
function Kw(e) {
  typeof e != "number" && e.unref();
}
var ip;
(function (e) {
  ((e[(e.SUCCESS = 0)] = "SUCCESS"), (e[(e.FAILED = 1)] = "FAILED"));
})(ip || (ip = {}));
class zw {
  _propagators;
  _fields;
  constructor(t = {}) {
    ((this._propagators = t.propagators ?? []),
      (this._fields = Array.from(
        new Set(
          this._propagators
            .map((n) => (typeof n.fields == "function" ? n.fields() : []))
            .reduce((n, r) => n.concat(r), []),
        ),
      )));
  }
  inject(t, n, r) {
    for (const o of this._propagators)
      try {
        o.inject(t, n, r);
      } catch (s) {
        C.diag.warn(
          `Failed to inject with ${o.constructor.name}. Err: ${s.message}`,
        );
      }
  }
  extract(t, n, r) {
    return this._propagators.reduce((o, s) => {
      try {
        return s.extract(o, n, r);
      } catch (i) {
        C.diag.warn(
          `Failed to extract with ${s.constructor.name}. Err: ${i.message}`,
        );
      }
      return o;
    }, t);
  }
  fields() {
    return this._fields.slice();
  }
}
const ap = "[_0-9a-z-*/]",
  Zw = `[a-z]${ap}{0,255}`,
  Xw = `[a-z0-9]${ap}{0,240}@[a-z]${ap}{0,13}`,
  Qw = new RegExp(`^(?:${Zw}|${Xw})$`),
  Jw = /^[ -~]{0,255}[!-~]$/,
  e0 = /,|=/;
function t0(e) {
  return Qw.test(e);
}
function n0(e) {
  return Jw.test(e) && !e0.test(e);
}
const rA = 32,
  r0 = 512,
  oA = ",",
  sA = "=";
class zo {
  _internalState = new Map();
  constructor(t) {
    t && this._parse(t);
  }
  set(t, n) {
    const r = this._clone();
    return (
      r._internalState.has(t) && r._internalState.delete(t),
      r._internalState.set(t, n),
      r
    );
  }
  unset(t) {
    const n = this._clone();
    return (n._internalState.delete(t), n);
  }
  get(t) {
    return this._internalState.get(t);
  }
  serialize() {
    return this._keys()
      .reduce((t, n) => (t.push(n + sA + this.get(n)), t), [])
      .join(oA);
  }
  _parse(t) {
    t.length > r0 ||
      ((this._internalState = t
        .split(oA)
        .reverse()
        .reduce((n, r) => {
          const o = r.trim(),
            s = o.indexOf(sA);
          if (s !== -1) {
            const i = o.slice(0, s),
              a = o.slice(s + 1, r.length);
            t0(i) && n0(a) && n.set(i, a);
          }
          return n;
        }, new Map())),
      this._internalState.size > rA &&
        (this._internalState = new Map(
          Array.from(this._internalState.entries()).reverse().slice(0, rA),
        )));
  }
  _keys() {
    return Array.from(this._internalState.keys()).reverse();
  }
  _clone() {
    const t = new zo();
    return ((t._internalState = new Map(this._internalState)), t);
  }
}
const Xc = "traceparent",
  Qc = "tracestate",
  o0 = "00",
  s0 = "(?!ff)[\\da-f]{2}",
  i0 = "(?![0]{32})[\\da-f]{32}",
  a0 = "(?![0]{16})[\\da-f]{16}",
  c0 = "[\\da-f]{2}",
  u0 = new RegExp(`^\\s?(${s0})-(${i0})-(${a0})-(${c0})(-.*)?\\s?$`);
function cI(e) {
  const t = u0.exec(e);
  return !t || (t[1] === "00" && t[5])
    ? null
    : {
        traceId: t[2],
        spanId: t[3],
        traceFlags: parseInt(t[4], 16),
      };
}
class l0 {
  inject(t, n, r) {
    const o = C.trace.getSpanContext(t);
    if (!o || Rn(t) || !C.isSpanContextValid(o)) return;
    const s = `${o0}-${o.traceId}-${o.spanId}-0${Number(o.traceFlags || C.TraceFlags.NONE).toString(16)}`;
    (r.set(n, Xc, s), o.traceState && r.set(n, Qc, o.traceState.serialize()));
  }
  extract(t, n, r) {
    const o = r.get(n, Xc);
    if (!o) return t;
    const s = Array.isArray(o) ? o[0] : o;
    if (typeof s != "string") return t;
    const i = cI(s);
    if (!i) return t;
    i.isRemote = !0;
    const a = r.get(n, Qc);
    if (a) {
      const c = Array.isArray(a) ? a.join(",") : a;
      i.traceState = new zo(typeof c == "string" ? c : void 0);
    }
    return C.trace.setSpanContext(t, i);
  }
  fields() {
    return [Xc, Qc];
  }
}
const sE = C.createContextKey("OpenTelemetry SDK Context Key RPC_METADATA");
var Zr;
(function (e) {
  e.HTTP = "http";
})(Zr || (Zr = {}));
function uI(e, t) {
  return e.setValue(sE, t);
}
function d0(e) {
  return e.deleteValue(sE);
}
function rl(e) {
  return e.getValue(sE);
}
const f0 = "[object Object]",
  _0 = "[object Null]",
  p0 = "[object Undefined]",
  E0 = Function.prototype,
  lI = E0.toString,
  h0 = lI.call(Object),
  T0 = Object.getPrototypeOf,
  dI = Object.prototype,
  fI = dI.hasOwnProperty,
  jr = Symbol ? Symbol.toStringTag : void 0,
  _I = dI.toString;
function iA(e) {
  if (!S0(e) || m0(e) !== f0) return !1;
  const t = T0(e);
  if (t === null) return !0;
  const n = fI.call(t, "constructor") && t.constructor;
  return typeof n == "function" && n instanceof n && lI.call(n) === h0;
}
function S0(e) {
  return e != null && typeof e == "object";
}
function m0(e) {
  return e == null
    ? e === void 0
      ? p0
      : _0
    : jr && jr in Object(e)
      ? A0(e)
      : g0(e);
}
function A0(e) {
  const t = fI.call(e, jr),
    n = e[jr];
  let r = !1;
  try {
    ((e[jr] = void 0), (r = !0));
  } catch {}
  const o = _I.call(e);
  return (r && (t ? (e[jr] = n) : delete e[jr]), o);
}
function g0(e) {
  return _I.call(e);
}
const R0 = 20;
function pI(...e) {
  let t = e.shift();
  const n = new WeakMap();
  for (; e.length > 0; ) t = EI(t, e.shift(), 0, n);
  return t;
}
function od(e) {
  return uu(e) ? e.slice() : e;
}
function EI(e, t, n = 0, r) {
  let o;
  if (!(n > R0)) {
    if ((n++, Jc(e) || Jc(t) || hI(t))) o = od(t);
    else if (uu(e)) {
      if (((o = e.slice()), uu(t)))
        for (let s = 0, i = t.length; s < i; s++) o.push(od(t[s]));
      else if (Qi(t)) {
        const s = Object.keys(t);
        for (let i = 0, a = s.length; i < a; i++) {
          const c = s[i];
          o[c] = od(t[c]);
        }
      }
    } else if (Qi(e))
      if (Qi(t)) {
        if (!N0(e, t)) return t;
        o = Object.assign({}, e);
        const s = Object.keys(t);
        for (let i = 0, a = s.length; i < a; i++) {
          const c = s[i],
            l = t[c];
          if (Jc(l)) typeof l > "u" ? delete o[c] : (o[c] = l);
          else {
            const f = o[c],
              d = l;
            if (aA(e, c, r) || aA(t, c, r)) delete o[c];
            else {
              if (Qi(f) && Qi(d)) {
                const u = r.get(f) || [],
                  _ = r.get(d) || [];
                (u.push({
                  obj: e,
                  key: c,
                }),
                  _.push({
                    obj: t,
                    key: c,
                  }),
                  r.set(f, u),
                  r.set(d, _));
              }
              o[c] = EI(o[c], l, n, r);
            }
          }
        }
      } else o = t;
    return o;
  }
}
function aA(e, t, n) {
  const r = n.get(e[t]) || [];
  for (let o = 0, s = r.length; o < s; o++) {
    const i = r[o];
    if (i.key === t && i.obj === e) return !0;
  }
  return !1;
}
function uu(e) {
  return Array.isArray(e);
}
function hI(e) {
  return typeof e == "function";
}
function Qi(e) {
  return !Jc(e) && !uu(e) && !hI(e) && typeof e == "object";
}
function Jc(e) {
  return (
    typeof e == "string" ||
    typeof e == "number" ||
    typeof e == "boolean" ||
    typeof e > "u" ||
    e instanceof Date ||
    e instanceof RegExp ||
    e === null
  );
}
function N0(e, t) {
  return !(!iA(e) || !iA(t));
}
class ol extends Error {
  constructor(t) {
    (super(t), Object.setPrototypeOf(this, ol.prototype));
  }
}
function y0(e, t) {
  let n;
  const r = new Promise(function (s, i) {
    n = setTimeout(function () {
      i(new ol("Operation timed out."));
    }, t);
  });
  return Promise.race([e, r]).then(
    (o) => (clearTimeout(n), o),
    (o) => {
      throw (clearTimeout(n), o);
    },
  );
}
function TI(e, t) {
  return typeof t == "string" ? e === t : !!e.match(t);
}
function O0(e, t) {
  if (!t) return !1;
  for (const n of t) if (TI(e, n)) return !0;
  return !1;
}
class C0 {
  _promise;
  _resolve;
  _reject;
  constructor() {
    this._promise = new Promise((t, n) => {
      ((this._resolve = t), (this._reject = n));
    });
  }
  get promise() {
    return this._promise;
  }
  resolve(t) {
    this._resolve(t);
  }
  reject(t) {
    this._reject(t);
  }
}
class b0 {
  _callback;
  _that;
  _isCalled = !1;
  _deferred = new C0();
  constructor(t, n) {
    ((this._callback = t), (this._that = n));
  }
  get isCalled() {
    return this._isCalled;
  }
  get promise() {
    return this._deferred.promise;
  }
  call(...t) {
    if (!this._isCalled) {
      this._isCalled = !0;
      try {
        Promise.resolve(this._callback.call(this._that, ...t)).then(
          (n) => this._deferred.resolve(n),
          (n) => this._deferred.reject(n),
        );
      } catch (n) {
        this._deferred.reject(n);
      }
    }
    return this._deferred.promise;
  }
}
const cA = {
  ALL: C.DiagLogLevel.ALL,
  VERBOSE: C.DiagLogLevel.VERBOSE,
  DEBUG: C.DiagLogLevel.DEBUG,
  INFO: C.DiagLogLevel.INFO,
  WARN: C.DiagLogLevel.WARN,
  ERROR: C.DiagLogLevel.ERROR,
  NONE: C.DiagLogLevel.NONE,
};
function I0(e) {
  if (e == null) return;
  const t = cA[e.toUpperCase()];
  return (
    t ??
    (C.diag.warn(
      `Unknown log level "${e}", expected one of ${Object.keys(cA)}, using default`,
    ),
    C.DiagLogLevel.INFO)
  );
}
function P0(e, t) {
  return new Promise((n) => {
    C.context.with(zr(C.context.active()), () => {
      e.export(t, (r) => {
        n(r);
      });
    });
  });
}
const M0 = {
    _export: P0,
  },
  v0 = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        AnchoredClock: Nw,
        BindOnceFuture: b0,
        CompositePropagator: zw,
        get ExportResultCode() {
          return ip;
        },
        get RPCType() {
          return Zr;
        },
        SDK_INFO: Zc,
        TRACE_PARENT_HEADER: Xc,
        TRACE_STATE_HEADER: Qc,
        TimeoutError: ol,
        TraceState: zo,
        W3CBaggagePropagator: tI,
        W3CTraceContextPropagator: l0,
        _globalThis: vw,
        addHrTimes: oE,
        callWithTimeout: y0,
        deleteRPCMetadata: d0,
        diagLogLevelFromString: I0,
        getBooleanFromEnv: Pw,
        getNumberFromEnv: Ct,
        getRPCMetadata: rl,
        getStringFromEnv: nE,
        getStringListFromEnv: Mw,
        getTimeOrigin: tl,
        globalErrorHandler: tE,
        hrTime: rE,
        hrTimeDuration: aI,
        hrTimeToMicroseconds: Ww,
        hrTimeToMilliseconds: qw,
        hrTimeToNanoseconds: jw,
        hrTimeToTimeStamp: Yw,
        internal: M0,
        isAttributeValue: eE,
        isTimeInput: sp,
        isTimeInputHrTime: nl,
        isTracingSuppressed: Rn,
        isUrlIgnored: O0,
        loggingErrorHandler: rI,
        merge: pI,
        millisToHrTime: kn,
        otperformance: Wr,
        parseKeyPairsIntoRecord: Rw,
        parseTraceParent: cI,
        sanitizeAttributes: qa,
        setGlobalErrorHandler: Iw,
        setRPCMetadata: uI,
        suppressTracing: zr,
        timeInputToHrTime: Fw,
        unrefTimer: Kw,
        unsuppressTracing: Ew,
        urlMatches: TI,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      },
    ),
  ),
  un = Yb(v0);
var Ji = {},
  uA;
function L0() {
  return (
    uA ||
      ((uA = 1),
      Object.defineProperty(Ji, "__esModule", {
        value: !0,
      }),
      (Ji.VERSION = void 0),
      (Ji.VERSION = "0.208.0")),
    Ji
  );
}
class SI {
  emit(t) {}
}
const D0 = new SI();
class w0 {
  getLogger(t, n, r) {
    return new SI();
  }
}
const mI = new w0();
class U0 {
  constructor(t, n, r, o) {
    ((this._provider = t),
      (this.name = n),
      (this.version = r),
      (this.options = o));
  }
  emit(t) {
    this._getLogger().emit(t);
  }
  _getLogger() {
    if (this._delegate) return this._delegate;
    const t = this._provider._getDelegateLogger(
      this.name,
      this.version,
      this.options,
    );
    return t ? ((this._delegate = t), this._delegate) : D0;
  }
}
class lA {
  getLogger(t, n, r) {
    var o;
    return (o = this._getDelegateLogger(t, n, r)) !== null && o !== void 0
      ? o
      : new U0(this, t, n, r);
  }
  _getDelegate() {
    var t;
    return (t = this._delegate) !== null && t !== void 0 ? t : mI;
  }
  _setDelegate(t) {
    this._delegate = t;
  }
  _getDelegateLogger(t, n, r) {
    var o;
    return (o = this._delegate) === null || o === void 0
      ? void 0
      : o.getLogger(t, n, r);
  }
}
const k0 = typeof globalThis == "object" ? globalThis : global,
  yc = Symbol.for("io.opentelemetry.js.api.logs"),
  ea = k0;
function G0(e, t, n) {
  return (r) => (r === e ? t : n);
}
const dA = 1;
class iE {
  constructor() {
    this._proxyLoggerProvider = new lA();
  }
  static getInstance() {
    return (this._instance || (this._instance = new iE()), this._instance);
  }
  setGlobalLoggerProvider(t) {
    return ea[yc]
      ? this.getLoggerProvider()
      : ((ea[yc] = G0(dA, t, mI)),
        this._proxyLoggerProvider._setDelegate(t),
        t);
  }
  getLoggerProvider() {
    var t, n;
    return (n =
      (t = ea[yc]) === null || t === void 0 ? void 0 : t.call(ea, dA)) !==
      null && n !== void 0
      ? n
      : this._proxyLoggerProvider;
  }
  getLogger(t, n, r) {
    return this.getLoggerProvider().getLogger(t, n, r);
  }
  disable() {
    (delete ea[yc], (this._proxyLoggerProvider = new lA()));
  }
}
const AI = iE.getInstance();
function V0(e, t, n, r) {
  for (let o = 0, s = e.length; o < s; o++) {
    const i = e[o];
    (t && i.setTracerProvider(t),
      n && i.setMeterProvider(n),
      r && i.setLoggerProvider && i.setLoggerProvider(r),
      i.getConfig().enabled || i.enable());
  }
}
function x0(e) {
  e.forEach((t) => t.disable());
}
function sl(e) {
  const t = e.tracerProvider || C.trace.getTracerProvider(),
    n = e.meterProvider || C.metrics.getMeterProvider(),
    r = e.loggerProvider || AI.getLoggerProvider(),
    o = e.instrumentations?.flat() ?? [];
  return (
    V0(o, t, n, r),
    () => {
      x0(o);
    }
  );
}
const gI =
    /^(?:v)?(?<version>(?<major>0|[1-9]\d*)\.(?<minor>0|[1-9]\d*)\.(?<patch>0|[1-9]\d*))(?:-(?<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?<build>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/,
  $0 =
    /^(?<op><|>|=|==|<=|>=|~|\^|~>)?\s*(?:v)?(?<version>(?<major>x|X|\*|0|[1-9]\d*)(?:\.(?<minor>x|X|\*|0|[1-9]\d*))?(?:\.(?<patch>x|X|\*|0|[1-9]\d*))?)(?:-(?<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?<build>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/,
  B0 = {
    ">": [1],
    ">=": [0, 1],
    "=": [0],
    "<=": [-1, 0],
    "<": [-1],
    "!=": [-1, 1],
  };
function H0(e, t, n) {
  if (!F0(e)) return (C.diag.error(`Invalid version: ${e}`), !1);
  if (!t) return !0;
  t = t.replace(/([<>=~^]+)\s+/g, "$1");
  const r = W0(e);
  if (!r) return !1;
  const o = [],
    s = RI(r, t, o, n);
  return s && !n?.includePrerelease ? j0(r, o) : s;
}
function F0(e) {
  return typeof e == "string" && gI.test(e);
}
function RI(e, t, n, r) {
  if (t.includes("||")) {
    const o = t.trim().split("||");
    for (const s of o) if (sd(e, s, n, r)) return !0;
    return !1;
  } else if (t.includes(" - ")) t = pU(t, r);
  else if (t.includes(" ")) {
    const o = t
      .trim()
      .replace(/\s{2,}/g, " ")
      .split(" ");
    for (const s of o) if (!sd(e, s, n, r)) return !1;
    return !0;
  }
  return sd(e, t, n, r);
}
function sd(e, t, n, r) {
  if (((t = q0(t, r)), t.includes(" "))) return RI(e, t, n, r);
  {
    const o = K0(t);
    return (n.push(o), Y0(e, o));
  }
}
function Y0(e, t) {
  if (t.invalid) return !1;
  if (!t.version || cp(t.version)) return !0;
  let n = _A(e.versionSegments || [], t.versionSegments || []);
  if (n === 0) {
    const r = e.prereleaseSegments || [],
      o = t.prereleaseSegments || [];
    !r.length && !o.length
      ? (n = 0)
      : !r.length && o.length
        ? (n = 1)
        : r.length && !o.length
          ? (n = -1)
          : (n = _A(r, o));
  }
  return B0[t.op]?.includes(n);
}
function j0(e, t) {
  return e.prerelease
    ? t.some((n) => n.prerelease && n.version === e.version)
    : !0;
}
function q0(e, t) {
  return (
    (e = e.trim()),
    (e = fU(e, t)),
    (e = dU(e)),
    (e = _U(e, t)),
    (e = e.trim()),
    e
  );
}
function Rt(e) {
  return !e || e.toLowerCase() === "x" || e === "*";
}
function W0(e) {
  const t = e.match(gI);
  if (!t) {
    C.diag.error(`Invalid version: ${e}`);
    return;
  }
  const n = t.groups.version,
    r = t.groups.prerelease,
    o = t.groups.build,
    s = n.split("."),
    i = r?.split(".");
  return {
    op: void 0,
    version: n,
    versionSegments: s,
    versionSegmentCount: s.length,
    prerelease: r,
    prereleaseSegments: i,
    prereleaseSegmentCount: i ? i.length : 0,
    build: o,
  };
}
function K0(e) {
  if (!e) return {};
  const t = e.match($0);
  if (!t)
    return (
      C.diag.error(`Invalid range: ${e}`),
      {
        invalid: !0,
      }
    );
  let n = t.groups.op;
  const r = t.groups.version,
    o = t.groups.prerelease,
    s = t.groups.build,
    i = r.split("."),
    a = o?.split(".");
  return (
    n === "==" && (n = "="),
    {
      op: n || "=",
      version: r,
      versionSegments: i,
      versionSegmentCount: i.length,
      prerelease: o,
      prereleaseSegments: a,
      prereleaseSegmentCount: a ? a.length : 0,
      build: s,
    }
  );
}
function cp(e) {
  return e === "*" || e === "x" || e === "X";
}
function fA(e) {
  const t = parseInt(e, 10);
  return isNaN(t) ? e : t;
}
function z0(e, t) {
  if (typeof e == typeof t) {
    if (typeof e == "number") return [e, t];
    if (typeof e == "string") return [e, t];
    throw new Error("Version segments can only be strings or numbers");
  } else return [String(e), String(t)];
}
function Z0(e, t) {
  if (cp(e) || cp(t)) return 0;
  const [n, r] = z0(fA(e), fA(t));
  return n > r ? 1 : n < r ? -1 : 0;
}
function _A(e, t) {
  for (let n = 0; n < Math.max(e.length, t.length); n++) {
    const r = Z0(e[n] || "0", t[n] || "0");
    if (r !== 0) return r;
  }
  return 0;
}
const NI = "[a-zA-Z0-9-]",
  yI = "0|[1-9]\\d*",
  X0 = `\\d*[a-zA-Z-]${NI}*`,
  Q0 = "((?:<|>)?=?)",
  pA = `(?:${yI}|${X0})`,
  J0 = `(?:-(${pA}(?:\\.${pA})*))`,
  EA = `${NI}+`,
  eU = `(?:\\+(${EA}(?:\\.${EA})*))`,
  id = `${yI}|x|X|\\*`,
  tc = `[v=\\s]*(${id})(?:\\.(${id})(?:\\.(${id})(?:${J0})?${eU}?)?)?`,
  tU = `^${Q0}\\s*${tc}$`,
  nU = new RegExp(tU),
  rU = `^\\s*(${tc})\\s+-\\s+(${tc})\\s*$`,
  oU = new RegExp(rU),
  sU = "(?:~>?)",
  iU = `^${sU}${tc}$`,
  aU = new RegExp(iU),
  cU = "(?:\\^)",
  uU = `^${cU}${tc}$`,
  lU = new RegExp(uU);
function dU(e) {
  const t = aU;
  return e.replace(t, (n, r, o, s, i) => {
    let a;
    return (
      Rt(r)
        ? (a = "")
        : Rt(o)
          ? (a = `>=${r}.0.0 <${+r + 1}.0.0-0`)
          : Rt(s)
            ? (a = `>=${r}.${o}.0 <${r}.${+o + 1}.0-0`)
            : i
              ? (a = `>=${r}.${o}.${s}-${i} <${r}.${+o + 1}.0-0`)
              : (a = `>=${r}.${o}.${s} <${r}.${+o + 1}.0-0`),
      a
    );
  });
}
function fU(e, t) {
  const n = lU,
    r = t?.includePrerelease ? "-0" : "";
  return e.replace(n, (o, s, i, a, c) => {
    let l;
    return (
      Rt(s)
        ? (l = "")
        : Rt(i)
          ? (l = `>=${s}.0.0${r} <${+s + 1}.0.0-0`)
          : Rt(a)
            ? s === "0"
              ? (l = `>=${s}.${i}.0${r} <${s}.${+i + 1}.0-0`)
              : (l = `>=${s}.${i}.0${r} <${+s + 1}.0.0-0`)
            : c
              ? s === "0"
                ? i === "0"
                  ? (l = `>=${s}.${i}.${a}-${c} <${s}.${i}.${+a + 1}-0`)
                  : (l = `>=${s}.${i}.${a}-${c} <${s}.${+i + 1}.0-0`)
                : (l = `>=${s}.${i}.${a}-${c} <${+s + 1}.0.0-0`)
              : s === "0"
                ? i === "0"
                  ? (l = `>=${s}.${i}.${a}${r} <${s}.${i}.${+a + 1}-0`)
                  : (l = `>=${s}.${i}.${a}${r} <${s}.${+i + 1}.0-0`)
                : (l = `>=${s}.${i}.${a} <${+s + 1}.0.0-0`),
      l
    );
  });
}
function _U(e, t) {
  const n = nU;
  return e.replace(n, (r, o, s, i, a, c) => {
    const l = Rt(s),
      f = l || Rt(i),
      d = f || Rt(a),
      u = d;
    return (
      o === "=" && u && (o = ""),
      (c = t?.includePrerelease ? "-0" : ""),
      l
        ? o === ">" || o === "<"
          ? (r = "<0.0.0-0")
          : (r = "*")
        : o && u
          ? (f && (i = 0),
            (a = 0),
            o === ">"
              ? ((o = ">="),
                f ? ((s = +s + 1), (i = 0), (a = 0)) : ((i = +i + 1), (a = 0)))
              : o === "<=" && ((o = "<"), f ? (s = +s + 1) : (i = +i + 1)),
            o === "<" && (c = "-0"),
            (r = `${o + s}.${i}.${a}${c}`))
          : f
            ? (r = `>=${s}.0.0${c} <${+s + 1}.0.0-0`)
            : d && (r = `>=${s}.${i}.0${c} <${s}.${+i + 1}.0-0`),
      r
    );
  });
}
function pU(e, t) {
  const n = oU;
  return e.replace(
    n,
    (r, o, s, i, a, c, l, f, d, u, _, p) => (
      Rt(s)
        ? (o = "")
        : Rt(i)
          ? (o = `>=${s}.0.0${t?.includePrerelease ? "-0" : ""}`)
          : Rt(a)
            ? (o = `>=${s}.${i}.0${t?.includePrerelease ? "-0" : ""}`)
            : c
              ? (o = `>=${o}`)
              : (o = `>=${o}${t?.includePrerelease ? "-0" : ""}`),
      Rt(d)
        ? (f = "")
        : Rt(u)
          ? (f = `<${+d + 1}.0.0-0`)
          : Rt(_)
            ? (f = `<${d}.${+u + 1}.0-0`)
            : p
              ? (f = `<=${d}.${u}.${_}-${p}`)
              : t?.includePrerelease
                ? (f = `<${d}.${u}.${+_ + 1}-0`)
                : (f = `<=${f}`),
      `${o} ${f}`.trim()
    ),
  );
}
let Ut = console.error.bind(console);
function ta(e, t, n) {
  const r = !!e[t] && Object.prototype.propertyIsEnumerable.call(e, t);
  Object.defineProperty(e, t, {
    configurable: !0,
    enumerable: r,
    writable: !0,
    value: n,
  });
}
const lu = (e, t, n) => {
    if (!e || !e[t]) {
      Ut("no original function " + String(t) + " to wrap");
      return;
    }
    if (!n) {
      (Ut("no wrapper function"), Ut(new Error().stack));
      return;
    }
    const r = e[t];
    if (typeof r != "function" || typeof n != "function") {
      Ut("original object and wrapper must be functions");
      return;
    }
    const o = n(r, t);
    return (
      ta(o, "__original", r),
      ta(o, "__unwrap", () => {
        e[t] === o && ta(e, t, r);
      }),
      ta(o, "__wrapped", !0),
      ta(e, t, o),
      o
    );
  },
  EU = (e, t, n) => {
    if (e) Array.isArray(e) || (e = [e]);
    else {
      (Ut("must provide one or more modules to patch"), Ut(new Error().stack));
      return;
    }
    if (!(t && Array.isArray(t))) {
      Ut("must provide one or more functions to wrap on modules");
      return;
    }
    e.forEach((r) => {
      t.forEach((o) => {
        lu(r, o, n);
      });
    });
  },
  aE = (e, t) => {
    if (!e || !e[t]) {
      (Ut("no function to unwrap."), Ut(new Error().stack));
      return;
    }
    const n = e[t];
    if (!n.__unwrap)
      Ut(
        "no original to unwrap to -- has " +
          String(t) +
          " already been unwrapped?",
      );
    else {
      n.__unwrap();
      return;
    }
  },
  hU = (e, t) => {
    if (e) Array.isArray(e) || (e = [e]);
    else {
      (Ut("must provide one or more modules to patch"), Ut(new Error().stack));
      return;
    }
    if (!(t && Array.isArray(t))) {
      Ut("must provide one or more functions to unwrap on modules");
      return;
    }
    e.forEach((n) => {
      t.forEach((r) => {
        aE(n, r);
      });
    });
  };
class TU {
  instrumentationName;
  instrumentationVersion;
  _config = {};
  _tracer;
  _meter;
  _logger;
  _diag;
  constructor(t, n, r) {
    ((this.instrumentationName = t),
      (this.instrumentationVersion = n),
      this.setConfig(r),
      (this._diag = C.diag.createComponentLogger({
        namespace: t,
      })),
      (this._tracer = C.trace.getTracer(t, n)),
      (this._meter = C.metrics.getMeter(t, n)),
      (this._logger = AI.getLogger(t, n)),
      this._updateMetricInstruments());
  }
  _wrap = lu;
  _unwrap = aE;
  _massWrap = EU;
  _massUnwrap = hU;
  get meter() {
    return this._meter;
  }
  setMeterProvider(t) {
    ((this._meter = t.getMeter(
      this.instrumentationName,
      this.instrumentationVersion,
    )),
      this._updateMetricInstruments());
  }
  get logger() {
    return this._logger;
  }
  setLoggerProvider(t) {
    this._logger = t.getLogger(
      this.instrumentationName,
      this.instrumentationVersion,
    );
  }
  getModuleDefinitions() {
    const t = this.init() ?? [];
    return Array.isArray(t) ? t : [t];
  }
  _updateMetricInstruments() {}
  getConfig() {
    return this._config;
  }
  setConfig(t) {
    this._config = {
      enabled: !0,
      ...t,
    };
  }
  setTracerProvider(t) {
    this._tracer = t.getTracer(
      this.instrumentationName,
      this.instrumentationVersion,
    );
  }
  get tracer() {
    return this._tracer;
  }
  _runSpanCustomizationHook(t, n, r, o) {
    if (t)
      try {
        t(r, o);
      } catch (s) {
        this._diag.error(
          "Error running span customization hook due to exception in handler",
          {
            triggerName: n,
          },
          s,
        );
      }
  }
}
var Oc = {
    exports: {},
  },
  Cc = {
    exports: {},
  },
  bc = {
    exports: {},
  },
  ad,
  hA;
function SU() {
  if (hA) return ad;
  hA = 1;
  var e = 1e3,
    t = e * 60,
    n = t * 60,
    r = n * 24,
    o = r * 7,
    s = r * 365.25;
  ad = function (f, d) {
    d = d || {};
    var u = typeof f;
    if (u === "string" && f.length > 0) return i(f);
    if (u === "number" && isFinite(f)) return d.long ? c(f) : a(f);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" +
        JSON.stringify(f),
    );
  };
  function i(f) {
    if (((f = String(f)), !(f.length > 100))) {
      var d =
        /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          f,
        );
      if (d) {
        var u = parseFloat(d[1]),
          _ = (d[2] || "ms").toLowerCase();
        switch (_) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return u * s;
          case "weeks":
          case "week":
          case "w":
            return u * o;
          case "days":
          case "day":
          case "d":
            return u * r;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return u * n;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return u * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return u * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return u;
          default:
            return;
        }
      }
    }
  }
  function a(f) {
    var d = Math.abs(f);
    return d >= r
      ? Math.round(f / r) + "d"
      : d >= n
        ? Math.round(f / n) + "h"
        : d >= t
          ? Math.round(f / t) + "m"
          : d >= e
            ? Math.round(f / e) + "s"
            : f + "ms";
  }
  function c(f) {
    var d = Math.abs(f);
    return d >= r
      ? l(f, d, r, "day")
      : d >= n
        ? l(f, d, n, "hour")
        : d >= t
          ? l(f, d, t, "minute")
          : d >= e
            ? l(f, d, e, "second")
            : f + " ms";
  }
  function l(f, d, u, _) {
    var p = d >= u * 1.5;
    return Math.round(f / u) + " " + _ + (p ? "s" : "");
  }
  return ad;
}
var cd, TA;
function OI() {
  if (TA) return cd;
  TA = 1;
  function e(t) {
    ((r.debug = r),
      (r.default = r),
      (r.coerce = l),
      (r.disable = a),
      (r.enable = s),
      (r.enabled = c),
      (r.humanize = SU()),
      (r.destroy = f),
      Object.keys(t).forEach((d) => {
        r[d] = t[d];
      }),
      (r.names = []),
      (r.skips = []),
      (r.formatters = {}));
    function n(d) {
      let u = 0;
      for (let _ = 0; _ < d.length; _++)
        ((u = (u << 5) - u + d.charCodeAt(_)), (u |= 0));
      return r.colors[Math.abs(u) % r.colors.length];
    }
    r.selectColor = n;
    function r(d) {
      let u,
        _ = null,
        p,
        E;
      function h(...T) {
        if (!h.enabled) return;
        const m = h,
          A = Number(new Date()),
          g = A - (u || A);
        ((m.diff = g),
          (m.prev = u),
          (m.curr = A),
          (u = A),
          (T[0] = r.coerce(T[0])),
          typeof T[0] != "string" && T.unshift("%O"));
        let N = 0;
        ((T[0] = T[0].replace(/%([a-zA-Z%])/g, (I, b) => {
          if (I === "%%") return "%";
          N++;
          const w = r.formatters[b];
          if (typeof w == "function") {
            const L = T[N];
            ((I = w.call(m, L)), T.splice(N, 1), N--);
          }
          return I;
        })),
          r.formatArgs.call(m, T),
          (m.log || r.log).apply(m, T));
      }
      return (
        (h.namespace = d),
        (h.useColors = r.useColors()),
        (h.color = r.selectColor(d)),
        (h.extend = o),
        (h.destroy = r.destroy),
        Object.defineProperty(h, "enabled", {
          enumerable: !0,
          configurable: !1,
          get: () =>
            _ !== null
              ? _
              : (p !== r.namespaces && ((p = r.namespaces), (E = r.enabled(d))),
                E),
          set: (T) => {
            _ = T;
          },
        }),
        typeof r.init == "function" && r.init(h),
        h
      );
    }
    function o(d, u) {
      const _ = r(this.namespace + (typeof u > "u" ? ":" : u) + d);
      return ((_.log = this.log), _);
    }
    function s(d) {
      (r.save(d), (r.namespaces = d), (r.names = []), (r.skips = []));
      const u = (typeof d == "string" ? d : "")
        .trim()
        .replace(/\s+/g, ",")
        .split(",")
        .filter(Boolean);
      for (const _ of u)
        _[0] === "-" ? r.skips.push(_.slice(1)) : r.names.push(_);
    }
    function i(d, u) {
      let _ = 0,
        p = 0,
        E = -1,
        h = 0;
      for (; _ < d.length; )
        if (p < u.length && (u[p] === d[_] || u[p] === "*"))
          u[p] === "*" ? ((E = p), (h = _), p++) : (_++, p++);
        else if (E !== -1) ((p = E + 1), h++, (_ = h));
        else return !1;
      for (; p < u.length && u[p] === "*"; ) p++;
      return p === u.length;
    }
    function a() {
      const d = [...r.names, ...r.skips.map((u) => "-" + u)].join(",");
      return (r.enable(""), d);
    }
    function c(d) {
      for (const u of r.skips) if (i(d, u)) return !1;
      for (const u of r.names) if (i(d, u)) return !0;
      return !1;
    }
    function l(d) {
      return d instanceof Error ? d.stack || d.message : d;
    }
    function f() {
      console.warn(
        "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
      );
    }
    return (r.enable(r.load()), r);
  }
  return ((cd = e), cd);
}
var SA;
function mU() {
  return (
    SA ||
      ((SA = 1),
      (function (e, t) {
        ((t.formatArgs = r),
          (t.save = o),
          (t.load = s),
          (t.useColors = n),
          (t.storage = i()),
          (t.destroy = (() => {
            let c = !1;
            return () => {
              c ||
                ((c = !0),
                console.warn(
                  "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
                ));
            };
          })()),
          (t.colors = [
            "#0000CC",
            "#0000FF",
            "#0033CC",
            "#0033FF",
            "#0066CC",
            "#0066FF",
            "#0099CC",
            "#0099FF",
            "#00CC00",
            "#00CC33",
            "#00CC66",
            "#00CC99",
            "#00CCCC",
            "#00CCFF",
            "#3300CC",
            "#3300FF",
            "#3333CC",
            "#3333FF",
            "#3366CC",
            "#3366FF",
            "#3399CC",
            "#3399FF",
            "#33CC00",
            "#33CC33",
            "#33CC66",
            "#33CC99",
            "#33CCCC",
            "#33CCFF",
            "#6600CC",
            "#6600FF",
            "#6633CC",
            "#6633FF",
            "#66CC00",
            "#66CC33",
            "#9900CC",
            "#9900FF",
            "#9933CC",
            "#9933FF",
            "#99CC00",
            "#99CC33",
            "#CC0000",
            "#CC0033",
            "#CC0066",
            "#CC0099",
            "#CC00CC",
            "#CC00FF",
            "#CC3300",
            "#CC3333",
            "#CC3366",
            "#CC3399",
            "#CC33CC",
            "#CC33FF",
            "#CC6600",
            "#CC6633",
            "#CC9900",
            "#CC9933",
            "#CCCC00",
            "#CCCC33",
            "#FF0000",
            "#FF0033",
            "#FF0066",
            "#FF0099",
            "#FF00CC",
            "#FF00FF",
            "#FF3300",
            "#FF3333",
            "#FF3366",
            "#FF3399",
            "#FF33CC",
            "#FF33FF",
            "#FF6600",
            "#FF6633",
            "#FF9900",
            "#FF9933",
            "#FFCC00",
            "#FFCC33",
          ]));
        function n() {
          if (
            typeof window < "u" &&
            window.process &&
            (window.process.type === "renderer" || window.process.__nwjs)
          )
            return !0;
          if (
            typeof navigator < "u" &&
            navigator.userAgent &&
            navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
          )
            return !1;
          let c;
          return (
            (typeof document < "u" &&
              document.documentElement &&
              document.documentElement.style &&
              document.documentElement.style.WebkitAppearance) ||
            (typeof window < "u" &&
              window.console &&
              (window.console.firebug ||
                (window.console.exception && window.console.table))) ||
            (typeof navigator < "u" &&
              navigator.userAgent &&
              (c = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) &&
              parseInt(c[1], 10) >= 31) ||
            (typeof navigator < "u" &&
              navigator.userAgent &&
              navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
          );
        }
        function r(c) {
          if (
            ((c[0] =
              (this.useColors ? "%c" : "") +
              this.namespace +
              (this.useColors ? " %c" : " ") +
              c[0] +
              (this.useColors ? "%c " : " ") +
              "+" +
              e.exports.humanize(this.diff)),
            !this.useColors)
          )
            return;
          const l = "color: " + this.color;
          c.splice(1, 0, l, "color: inherit");
          let f = 0,
            d = 0;
          (c[0].replace(/%[a-zA-Z%]/g, (u) => {
            u !== "%%" && (f++, u === "%c" && (d = f));
          }),
            c.splice(d, 0, l));
        }
        t.log = console.debug || console.log || (() => {});
        function o(c) {
          try {
            c ? t.storage.setItem("debug", c) : t.storage.removeItem("debug");
          } catch {}
        }
        function s() {
          let c;
          try {
            c = t.storage.getItem("debug") || t.storage.getItem("DEBUG");
          } catch {}
          return (
            !c &&
              typeof process < "u" &&
              "env" in process &&
              (c = process.env.DEBUG),
            c
          );
        }
        function i() {
          try {
            return localStorage;
          } catch {}
        }
        e.exports = OI()(t);
        const { formatters: a } = e.exports;
        a.j = function (c) {
          try {
            return JSON.stringify(c);
          } catch (l) {
            return "[UnexpectedJSONParseError]: " + l.message;
          }
        };
      })(bc, bc.exports)),
    bc.exports
  );
}
var Ic = {
    exports: {},
  },
  ud,
  mA;
function AU() {
  return (
    mA ||
      ((mA = 1),
      (ud = (e, t = process.argv) => {
        const n = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--",
          r = t.indexOf(n + e),
          o = t.indexOf("--");
        return r !== -1 && (o === -1 || r < o);
      })),
    ud
  );
}
var ld, AA;
function gU() {
  if (AA) return ld;
  AA = 1;
  const e = os3,
    t = tty,
    n = AU(),
    { env: r } = process;
  let o;
  n("no-color") || n("no-colors") || n("color=false") || n("color=never")
    ? (o = 0)
    : (n("color") || n("colors") || n("color=true") || n("color=always")) &&
      (o = 1);
  function s() {
    if ("FORCE_COLOR" in r)
      return r.FORCE_COLOR === "true"
        ? 1
        : r.FORCE_COLOR === "false"
          ? 0
          : r.FORCE_COLOR.length === 0
            ? 1
            : Math.min(Number.parseInt(r.FORCE_COLOR, 10), 3);
  }
  function i(l) {
    return l === 0
      ? !1
      : {
          level: l,
          hasBasic: !0,
          has256: l >= 2,
          has16m: l >= 3,
        };
  }
  function a(l, { streamIsTTY: f, sniffFlags: d = !0 } = {}) {
    const u = s();
    u !== void 0 && (o = u);
    const _ = d ? o : u;
    if (_ === 0) return 0;
    if (d) {
      if (n("color=16m") || n("color=full") || n("color=truecolor")) return 3;
      if (n("color=256")) return 2;
    }
    if (l && !f && _ === void 0) return 0;
    const p = _ || 0;
    if (r.TERM === "dumb") return p;
    if (process.platform === "win32") {
      const E = e.release().split(".");
      return Number(E[0]) >= 10 && Number(E[2]) >= 10586
        ? Number(E[2]) >= 14931
          ? 3
          : 2
        : 1;
    }
    if ("CI" in r)
      return [
        "TRAVIS",
        "CIRCLECI",
        "APPVEYOR",
        "GITLAB_CI",
        "GITHUB_ACTIONS",
        "BUILDKITE",
        "DRONE",
      ].some((E) => E in r) || r.CI_NAME === "codeship"
        ? 1
        : p;
    if ("TEAMCITY_VERSION" in r)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(r.TEAMCITY_VERSION) ? 1 : 0;
    if (r.COLORTERM === "truecolor") return 3;
    if ("TERM_PROGRAM" in r) {
      const E = Number.parseInt(
        (r.TERM_PROGRAM_VERSION || "").split(".")[0],
        10,
      );
      switch (r.TERM_PROGRAM) {
        case "iTerm.app":
          return E >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(r.TERM)
      ? 2
      : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(
            r.TERM,
          ) || "COLORTERM" in r
        ? 1
        : p;
  }
  function c(l, f = {}) {
    const d = a(l, {
      streamIsTTY: l && l.isTTY,
      ...f,
    });
    return i(d);
  }
  return (
    (ld = {
      supportsColor: c,
      stdout: c({
        isTTY: t.isatty(1),
      }),
      stderr: c({
        isTTY: t.isatty(2),
      }),
    }),
    ld
  );
}
var gA;
function RU() {
  return (
    gA ||
      ((gA = 1),
      (function (e, t) {
        const n = tty,
          r = util2;
        ((t.init = f),
          (t.log = a),
          (t.formatArgs = s),
          (t.save = c),
          (t.load = l),
          (t.useColors = o),
          (t.destroy = r.deprecate(
            () => {},
            "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
          )),
          (t.colors = [6, 2, 3, 4, 5, 1]));
        try {
          const u = gU();
          u &&
            (u.stderr || u).level >= 2 &&
            (t.colors = [
              20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57,
              62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99,
              112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164,
              165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185,
              196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208,
              209, 214, 215, 220, 221,
            ]);
        } catch {}
        t.inspectOpts = Object.keys(process.env)
          .filter((u) => /^debug_/i.test(u))
          .reduce((u, _) => {
            const p = _.substring(6)
              .toLowerCase()
              .replace(/_([a-z])/g, (h, T) => T.toUpperCase());
            let E = process.env[_];
            return (
              /^(yes|on|true|enabled)$/i.test(E)
                ? (E = !0)
                : /^(no|off|false|disabled)$/i.test(E)
                  ? (E = !1)
                  : E === "null"
                    ? (E = null)
                    : (E = Number(E)),
              (u[p] = E),
              u
            );
          }, {});
        function o() {
          return "colors" in t.inspectOpts
            ? !!t.inspectOpts.colors
            : n.isatty(process.stderr.fd);
        }
        function s(u) {
          const { namespace: _, useColors: p } = this;
          if (p) {
            const E = this.color,
              h = "\x1B[3" + (E < 8 ? E : "8;5;" + E),
              T = `  ${h};1m${_} \x1B[0m`;
            ((u[0] =
              T +
              u[0]
                .split(
                  `
`,
                )
                .join(
                  `
` + T,
                )),
              u.push(h + "m+" + e.exports.humanize(this.diff) + "\x1B[0m"));
          } else u[0] = i() + _ + " " + u[0];
        }
        function i() {
          return t.inspectOpts.hideDate ? "" : new Date().toISOString() + " ";
        }
        function a(...u) {
          return process.stderr.write(
            r.formatWithOptions(t.inspectOpts, ...u) +
              `
`,
          );
        }
        function c(u) {
          u ? (process.env.DEBUG = u) : delete process.env.DEBUG;
        }
        function l() {
          return process.env.DEBUG;
        }
        function f(u) {
          u.inspectOpts = {};
          const _ = Object.keys(t.inspectOpts);
          for (let p = 0; p < _.length; p++)
            u.inspectOpts[_[p]] = t.inspectOpts[_[p]];
        }
        e.exports = OI()(t);
        const { formatters: d } = e.exports;
        ((d.o = function (u) {
          return (
            (this.inspectOpts.colors = this.useColors),
            r
              .inspect(u, this.inspectOpts)
              .split(
                `
`,
              )
              .map((_) => _.trim())
              .join(" ")
          );
        }),
          (d.O = function (u) {
            return (
              (this.inspectOpts.colors = this.useColors),
              r.inspect(u, this.inspectOpts)
            );
          }));
      })(Ic, Ic.exports)),
    Ic.exports
  );
}
var RA;
function NU() {
  return (
    RA ||
      ((RA = 1),
      typeof process > "u" ||
      process.type === "renderer" ||
      process.browser === !0 ||
      process.__nwjs
        ? (Cc.exports = mU())
        : (Cc.exports = RU())),
    Cc.exports
  );
}
var dd, NA;
function CI() {
  if (NA) return dd;
  NA = 1;
  var e = path.sep;
  return (
    (dd = function (t) {
      var n = t.split(e),
        r = n.lastIndexOf("node_modules");
      if (r !== -1 && n[r + 1]) {
        for (
          var o = n[r + 1][0] === "@",
            s = o ? n[r + 1] + "/" + n[r + 2] : n[r + 1],
            i = o ? 3 : 2,
            a = "",
            c = r + i - 1,
            l = 0;
          l <= c;
          l++
        )
          l === c ? (a += n[l]) : (a += n[l] + e);
        for (var f = "", d = n.length - 1, u = r + i; u <= d; u++)
          u === d ? (f += n[u]) : (f += n[u] + e);
        return {
          name: s,
          basedir: a,
          path: f,
        };
      }
    }),
    dd
  );
}
var yA;
function yU() {
  if (yA) return Oc.exports;
  yA = 1;
  const e = path,
    t = nodeModule,
    n = NU()("require-in-the-middle"),
    r = CI();
  ((Oc.exports = c), (Oc.exports.Hook = c));
  let o, s;
  if (t.isBuiltin) s = t.isBuiltin;
  else if (t.builtinModules)
    s = (f) =>
      f.startsWith("node:")
        ? !0
        : (o === void 0 && (o = new Set(t.builtinModules)), o.has(f));
  else
    throw new Error(
      "'require-in-the-middle' requires Node.js >=v9.3.0 or >=v8.10.0",
    );
  const i = /([/\\]index)?(\.js)?$/;
  class a {
    constructor() {
      ((this._localCache = new Map()),
        (this._kRitmExports = Symbol("RitmExports")));
    }
    has(d, u) {
      if (this._localCache.has(d)) return !0;
      if (u) return !1;
      {
        const _ = require.cache[d];
        return !!(_ && this._kRitmExports in _);
      }
    }
    get(d, u) {
      const _ = this._localCache.get(d);
      if (_ !== void 0) return _;
      if (!u) {
        const p = require.cache[d];
        return p && p[this._kRitmExports];
      }
    }
    set(d, u, _) {
      _
        ? this._localCache.set(d, u)
        : d in require.cache
          ? (require.cache[d][this._kRitmExports] = u)
          : (n('non-core module is unexpectedly not in require.cache: "%s"', d),
            this._localCache.set(d, u));
    }
  }
  function c(f, d, u) {
    if (!(this instanceof c)) return new c(f, d, u);
    if (
      (typeof f == "function"
        ? ((u = f), (f = null), (d = null))
        : typeof d == "function" && ((u = d), (d = null)),
      typeof t._resolveFilename != "function")
    ) {
      (console.error(
        "Error: Expected Module._resolveFilename to be a function (was: %s) - aborting!",
        typeof t._resolveFilename,
      ),
        console.error(
          "Please report this error as an issue related to Node.js %s at https://github.com/nodejs/require-in-the-middle/issues",
          process.version,
        ));
      return;
    }
    ((this._cache = new a()),
      (this._unhooked = !1),
      (this._origRequire = t.prototype.require));
    const _ = this,
      p = new Set(),
      E = d ? d.internals === !0 : !1,
      h = Array.isArray(f);
    (n("registering require hook"),
      (this._require = t.prototype.require =
        function (m) {
          return _._unhooked === !0
            ? (n("ignoring require call - module is soft-unhooked"),
              _._origRequire.apply(this, arguments))
            : T.call(this, arguments, !1);
        }),
      typeof process.getBuiltinModule == "function" &&
        ((this._origGetBuiltinModule = process.getBuiltinModule),
        (this._getBuiltinModule = process.getBuiltinModule =
          function (m) {
            return _._unhooked === !0
              ? (n(
                  "ignoring process.getBuiltinModule call - module is soft-unhooked",
                ),
                _._origGetBuiltinModule.apply(this, arguments))
              : T.call(this, arguments, !0);
          })));
    function T(m, A) {
      const g = m[0],
        N = s(g);
      let O;
      if (N) {
        if (((O = g), g.startsWith("node:"))) {
          const H = g.slice(5);
          s(H) && (O = H);
        }
      } else {
        if (A)
          return (
            n("call to process.getBuiltinModule with unknown built-in id"),
            _._origGetBuiltinModule.apply(this, m)
          );
        try {
          O = t._resolveFilename(g, this);
        } catch (H) {
          return (
            n(
              'Module._resolveFilename("%s") threw %j, calling original Module.require',
              g,
              H.message,
            ),
            _._origRequire.apply(this, m)
          );
        }
      }
      let I, b;
      if (
        (n(
          "processing %s module require('%s'): %s",
          N === !0 ? "core" : "non-core",
          g,
          O,
        ),
        _._cache.has(O, N) === !0)
      )
        return (
          n("returning already patched cached module: %s", O),
          _._cache.get(O, N)
        );
      const w = p.has(O);
      w === !1 && p.add(O);
      const L = A
        ? _._origGetBuiltinModule.apply(this, m)
        : _._origRequire.apply(this, m);
      if (w === !0)
        return (
          n(
            "module is in the process of being patched already - ignoring: %s",
            O,
          ),
          L
        );
      if ((p.delete(O), N === !0)) {
        if (h === !0 && f.includes(O) === !1)
          return (n("ignoring core module not on whitelist: %s", O), L);
        I = O;
      } else if (h === !0 && f.includes(O)) {
        const H = e.parse(O);
        ((I = H.name), (b = H.dir));
      } else {
        const H = r(O);
        if (H === void 0) return (n("could not parse filename: %s", O), L);
        ((I = H.name), (b = H.basedir));
        const x = l(H);
        n(
          "resolved filename to module: %s (id: %s, resolved: %s, basedir: %s)",
          I,
          g,
          x,
          b,
        );
        let B = !1;
        if (h) {
          if (
            (!g.startsWith(".") && f.includes(g) && ((I = g), (B = !0)),
            !f.includes(I) && !f.includes(x))
          )
            return L;
          f.includes(x) && x !== I && ((I = x), (B = !0));
        }
        if (!B) {
          let F;
          try {
            F = require.resolve(I, {
              paths: [b],
            });
          } catch {
            return (
              n("could not resolve module: %s", I),
              _._cache.set(O, L, N),
              L
            );
          }
          if (F !== O)
            if (E === !0)
              ((I = I + e.sep + e.relative(b, O)),
                n("preparing to process require of internal file: %s", I));
            else
              return (
                n("ignoring require of non-main module file: %s", F),
                _._cache.set(O, L, N),
                L
              );
        }
      }
      (_._cache.set(O, L, N), n("calling require hook: %s", I));
      const j = u(L, I, b);
      return (_._cache.set(O, j, N), n("returning module: %s", I), j);
    }
  }
  c.prototype.unhook = function () {
    ((this._unhooked = !0),
      this._require === t.prototype.require
        ? ((t.prototype.require = this._origRequire),
          n("require unhook successful"))
        : n("require unhook unsuccessful"),
      process.getBuiltinModule !== void 0 &&
        (this._getBuiltinModule === process.getBuiltinModule
          ? ((process.getBuiltinModule = this._origGetBuiltinModule),
            n("process.getBuiltinModule unhook successful"))
          : n("process.getBuiltinModule unhook unsuccessful")));
  };
  function l(f) {
    const d = e.sep !== "/" ? f.path.split(e.sep).join("/") : f.path;
    return e.posix.join(f.name, d).replace(i, "");
  }
  return Oc.exports;
}
var bI = yU();
const du = "/";
class OA {
  hooks = [];
  children = new Map();
}
class OU {
  _trie = new OA();
  _counter = 0;
  insert(t) {
    let n = this._trie;
    for (const r of t.moduleName.split(du)) {
      let o = n.children.get(r);
      (o || ((o = new OA()), n.children.set(r, o)), (n = o));
    }
    n.hooks.push({
      hook: t,
      insertedId: this._counter++,
    });
  }
  search(t, { maintainInsertionOrder: n, fullOnly: r } = {}) {
    let o = this._trie;
    const s = [];
    let i = !0;
    for (const a of t.split(du)) {
      const c = o.children.get(a);
      if (!c) {
        i = !1;
        break;
      }
      (r || s.push(...c.hooks), (o = c));
    }
    return (
      r && i && s.push(...o.hooks),
      s.length === 0
        ? []
        : s.length === 1
          ? [s[0].hook]
          : (n && s.sort((a, c) => a.insertedId - c.insertedId),
            s.map(({ hook: a }) => a))
    );
  }
}
const CU = [
  "afterEach",
  "after",
  "beforeEach",
  "before",
  "describe",
  "it",
].every((e) => typeof global[e] == "function");
class fu {
  _moduleNameTrie = new OU();
  static _instance;
  constructor() {
    this._initialize();
  }
  _initialize() {
    new bI.Hook(
      null,
      {
        internals: !0,
      },
      (t, n, r) => {
        const o = bU(n),
          s = this._moduleNameTrie.search(o, {
            maintainInsertionOrder: !0,
            fullOnly: r === void 0,
          });
        for (const { onRequire: i } of s) t = i(t, n, r);
        return t;
      },
    );
  }
  register(t, n) {
    const r = {
      moduleName: t,
      onRequire: n,
    };
    return (this._moduleNameTrie.insert(r), r);
  }
  static getInstance() {
    return CU ? new fu() : (this._instance = this._instance ?? new fu());
  }
}
function bU(e) {
  return Yr.sep !== du ? e.split(Yr.sep).join(du) : e;
}
var Ar = {
    exports: {},
  },
  jn = {},
  CA;
function IU() {
  if (CA) return jn;
  CA = 1;
  const e = [],
    t = new WeakMap(),
    n = new WeakMap(),
    r = new Map(),
    o = [],
    s = {
      set(f, d, u) {
        return t.get(f)[d](u);
      },
      get(f, d) {
        if (d === Symbol.toStringTag) return "Module";
        const u = n.get(f)[d];
        if (typeof u == "function") return u();
      },
      defineProperty(f, d, u) {
        if (!("value" in u))
          throw new Error(
            "Getters/setters are not supported for exports property descriptors.",
          );
        return t.get(f)[d](u.value);
      },
    };
  function i(f, d, u, _, p) {
    (r.set(f, p), t.set(d, u), n.set(d, _));
    const E = new Proxy(d, s);
    (e.forEach((h) => h(f, E)), o.push([f, E]));
  }
  let a = !1;
  function c() {
    return a;
  }
  function l(f) {
    a = f;
  }
  return (
    (jn.register = i),
    (jn.importHooks = e),
    (jn.specifiers = r),
    (jn.toHook = o),
    (jn.getExperimentalPatchInternals = c),
    (jn.setExperimentalPatchInternals = l),
    jn
  );
}
var bA;
function PU() {
  if (bA) return Ar.exports;
  bA = 1;
  const e = path,
    t = CI(),
    { fileURLToPath: n } = url,
    { MessageChannel: r } = workerThreads2,
    {
      importHooks: o,
      specifiers: s,
      toHook: i,
      getExperimentalPatchInternals: a,
    } = IU();
  function c(p) {
    (o.push(p), i.forEach(([E, h]) => p(E, h)));
  }
  function l(p) {
    const E = o.indexOf(p);
    E > -1 && o.splice(E, 1);
  }
  function f(p, E, h, T) {
    const m = p(E, h, T);
    m && m !== E && (E.default = m);
  }
  let d;
  function u() {
    const { port1: p, port2: E } = new r();
    let h = 0,
      T;
    ((d = (N) => {
      (h++, p.postMessage(N));
    }),
      p
        .on("message", () => {
          (h--, T && h <= 0 && T());
        })
        .unref());
    function m() {
      const N = setInterval(() => {}, 1e3),
        O = new Promise((I) => {
          T = I;
        }).then(() => {
          clearInterval(N);
        });
      return (h === 0 && T(), O);
    }
    const A = E;
    return {
      registerOptions: {
        data: {
          addHookMessagePort: A,
          include: [],
        },
        transferList: [A],
      },
      addHookMessagePort: A,
      waitForAllMessagesAcknowledged: m,
    };
  }
  function _(p, E, h) {
    if (!(this instanceof _)) return new _(p, E, h);
    typeof p == "function"
      ? ((h = p), (p = null), (E = null))
      : typeof E == "function" && ((h = E), (E = null));
    const T = E ? E.internals === !0 : !1;
    (d && Array.isArray(p) && d(p),
      (this._iitmHook = (m, A) => {
        const g = m,
          N = m.startsWith("node:");
        let O;
        if (N) m = m.replace(/^node:/, "");
        else {
          if (m.startsWith("file://"))
            try {
              m = n(m);
            } catch {}
          const I = t(m);
          I && ((m = I.name), (O = I.basedir));
        }
        if (p) {
          for (const I of p)
            if (I === m) {
              if (O) {
                if (T) m = m + e.sep + e.relative(O, n(g));
                else if (!a() && !O.endsWith(s.get(g))) continue;
              }
              f(h, A, m, O);
            }
        } else f(h, A, m, O);
      }),
      c(this._iitmHook));
  }
  return (
    (_.prototype.unhook = function () {
      l(this._iitmHook);
    }),
    (Ar.exports = _),
    (Ar.exports.Hook = _),
    (Ar.exports.addHook = c),
    (Ar.exports.removeHook = l),
    (Ar.exports.createAddHookMessageChannel = u),
    Ar.exports
  );
}
var II = PU();
function er(e, t, n) {
  let r, o;
  try {
    o = e();
  } catch (s) {
    r = s;
  } finally {
    if ((t(r, o), r && !n)) throw r;
    return o;
  }
}
async function MU(e, t, n) {
  let r, o;
  try {
    o = await e();
  } catch (s) {
    r = s;
  } finally {
    if ((await t(r, o), r && !n)) throw r;
    return o;
  }
}
function il(e) {
  return (
    typeof e == "function" &&
    typeof e.__original == "function" &&
    typeof e.__unwrap == "function" &&
    e.__wrapped === !0
  );
}
class Ot extends TU {
  _modules;
  _hooks = [];
  _requireInTheMiddleSingleton = fu.getInstance();
  _enabled = !1;
  constructor(t, n, r) {
    super(t, n, r);
    let o = this.init();
    (o && !Array.isArray(o) && (o = [o]),
      (this._modules = o || []),
      this._config.enabled && this.enable());
  }
  _wrap = (t, n, r) => {
    if ((il(t[n]) && this._unwrap(t, n), util2.types.isProxy(t))) {
      const o = lu(Object.assign({}, t), n, r);
      return (
        Object.defineProperty(t, n, {
          value: o,
        }),
        o
      );
    } else return lu(t, n, r);
  };
  _unwrap = (t, n) =>
    util2.types.isProxy(t)
      ? Object.defineProperty(t, n, {
          value: t[n],
        })
      : aE(t, n);
  _massWrap = (t, n, r) => {
    if (t) Array.isArray(t) || (t = [t]);
    else {
      C.diag.error("must provide one or more modules to patch");
      return;
    }
    if (!(n && Array.isArray(n))) {
      C.diag.error("must provide one or more functions to wrap on modules");
      return;
    }
    t.forEach((o) => {
      n.forEach((s) => {
        this._wrap(o, s, r);
      });
    });
  };
  _massUnwrap = (t, n) => {
    if (t) Array.isArray(t) || (t = [t]);
    else {
      C.diag.error("must provide one or more modules to patch");
      return;
    }
    if (!(n && Array.isArray(n))) {
      C.diag.error("must provide one or more functions to wrap on modules");
      return;
    }
    t.forEach((r) => {
      n.forEach((o) => {
        this._unwrap(r, o);
      });
    });
  };
  _warnOnPreloadedModules() {
    this._modules.forEach((t) => {
      const { name: n } = t;
      try {
        const r = require.resolve(n);
        require.cache[r] &&
          this._diag.warn(
            `Module ${n} has been loaded before ${this.instrumentationName} so it might not work, please initialize it before requiring ${n}`,
          );
      } catch {}
    });
  }
  _extractPackageVersion(t) {
    try {
      const n = fs2.readFileSync(Yr.join(t, "package.json"), {
          encoding: "utf8",
        }),
        r = JSON.parse(n).version;
      return typeof r == "string" ? r : void 0;
    } catch {
      C.diag.warn("Failed extracting version", t);
    }
  }
  _onRequire(t, n, r, o) {
    if (!o)
      return typeof t.patch == "function" &&
        ((t.moduleExports = n), this._enabled)
        ? (this._diag.debug(
            "Applying instrumentation patch for nodejs core module on require hook",
            {
              module: t.name,
            },
          ),
          t.patch(n))
        : n;
    const s = this._extractPackageVersion(o);
    if (((t.moduleVersion = s), t.name === r))
      return IA(t.supportedVersions, s, t.includePrerelease) &&
        typeof t.patch == "function" &&
        ((t.moduleExports = n), this._enabled)
        ? (this._diag.debug(
            "Applying instrumentation patch for module on require hook",
            {
              module: t.name,
              version: t.moduleVersion,
              baseDir: o,
            },
          ),
          t.patch(n, t.moduleVersion))
        : n;
    const i = t.files ?? [],
      a = Yr.normalize(r);
    return i
      .filter((l) => l.name === a)
      .filter((l) => IA(l.supportedVersions, s, t.includePrerelease))
      .reduce(
        (l, f) => (
          (f.moduleExports = l),
          this._enabled
            ? (this._diag.debug(
                "Applying instrumentation patch for nodejs module file on require hook",
                {
                  module: t.name,
                  version: t.moduleVersion,
                  fileName: f.name,
                  baseDir: o,
                },
              ),
              f.patch(l, t.moduleVersion))
            : l
        ),
        n,
      );
  }
  enable() {
    if (!this._enabled) {
      if (((this._enabled = !0), this._hooks.length > 0)) {
        for (const t of this._modules) {
          typeof t.patch == "function" &&
            t.moduleExports &&
            (this._diag.debug(
              "Applying instrumentation patch for nodejs module on instrumentation enabled",
              {
                module: t.name,
                version: t.moduleVersion,
              },
            ),
            t.patch(t.moduleExports, t.moduleVersion));
          for (const n of t.files)
            n.moduleExports &&
              (this._diag.debug(
                "Applying instrumentation patch for nodejs module file on instrumentation enabled",
                {
                  module: t.name,
                  version: t.moduleVersion,
                  fileName: n.name,
                },
              ),
              n.patch(n.moduleExports, t.moduleVersion));
        }
        return;
      }
      this._warnOnPreloadedModules();
      for (const t of this._modules) {
        const n = (i, a, c) => {
            if (!c && Yr.isAbsolute(a)) {
              const l = Yr.parse(a);
              ((a = l.name), (c = l.dir));
            }
            return this._onRequire(t, i, a, c);
          },
          r = (i, a, c) => this._onRequire(t, i, a, c),
          o = Yr.isAbsolute(t.name)
            ? new bI.Hook(
                [t.name],
                {
                  internals: !0,
                },
                r,
              )
            : this._requireInTheMiddleSingleton.register(t.name, r);
        this._hooks.push(o);
        const s = new II.Hook(
          [t.name],
          {
            internals: !1,
          },
          n,
        );
        this._hooks.push(s);
      }
    }
  }
  disable() {
    if (this._enabled) {
      this._enabled = !1;
      for (const t of this._modules) {
        typeof t.unpatch == "function" &&
          t.moduleExports &&
          (this._diag.debug(
            "Removing instrumentation patch for nodejs module on instrumentation disabled",
            {
              module: t.name,
              version: t.moduleVersion,
            },
          ),
          t.unpatch(t.moduleExports, t.moduleVersion));
        for (const n of t.files)
          n.moduleExports &&
            (this._diag.debug(
              "Removing instrumentation patch for nodejs module file on instrumentation disabled",
              {
                module: t.name,
                version: t.moduleVersion,
                fileName: n.name,
              },
            ),
            n.unpatch(n.moduleExports, t.moduleVersion));
      }
    }
  }
  isEnabled() {
    return this._enabled;
  }
}
function IA(e, t, n) {
  return typeof t > "u"
    ? e.includes("*")
    : e.some((r) =>
        H0(t, r, {
          includePrerelease: n,
        }),
      );
}
class ft {
  name;
  supportedVersions;
  patch;
  unpatch;
  files;
  constructor(t, n, r, o, s) {
    ((this.name = t),
      (this.supportedVersions = n),
      (this.patch = r),
      (this.unpatch = o),
      (this.files = s || []));
  }
}
class Bn {
  supportedVersions;
  patch;
  unpatch;
  name;
  constructor(t, n, r, o) {
    ((this.supportedVersions = n),
      (this.patch = r),
      (this.unpatch = o),
      (this.name = path.normalize(t)));
  }
}
var Mo;
(function (e) {
  ((e[(e.STABLE = 1)] = "STABLE"),
    (e[(e.OLD = 2)] = "OLD"),
    (e[(e.DUPLICATE = 3)] = "DUPLICATE"));
})(Mo || (Mo = {}));
function vU(e, t) {
  let n = Mo.OLD;
  const r = t
    ?.split(",")
    .map((o) => o.trim())
    .filter((o) => o !== "");
  for (const o of r ?? [])
    if (o.toLowerCase() === e + "/dup") {
      n = Mo.DUPLICATE;
      break;
    } else o.toLowerCase() === e && (n = Mo.STABLE);
  return n;
}
const LU = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        InstrumentationBase: Ot,
        InstrumentationNodeModuleDefinition: ft,
        InstrumentationNodeModuleFile: Bn,
        get SemconvStability() {
          return Mo;
        },
        isWrapped: il,
        registerInstrumentations: sl,
        safeExecuteInTheMiddle: er,
        safeExecuteInTheMiddleAsync: MU,
        semconvStabilityFromStr: vU,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      },
    ),
  ),
  Le = Yb(LU);
var fd = {},
  ie = {},
  PA;
function DU() {
  return (
    PA ||
      ((PA = 1),
      Object.defineProperty(ie, "__esModule", {
        value: !0,
      }),
      (ie.HTTP_FLAVOR_VALUE_HTTP_1_1 =
        ie.NET_TRANSPORT_VALUE_IP_UDP =
        ie.NET_TRANSPORT_VALUE_IP_TCP =
        ie.ATTR_NET_TRANSPORT =
        ie.ATTR_NET_PEER_PORT =
        ie.ATTR_NET_PEER_NAME =
        ie.ATTR_NET_PEER_IP =
        ie.ATTR_NET_HOST_PORT =
        ie.ATTR_NET_HOST_NAME =
        ie.ATTR_NET_HOST_IP =
        ie.ATTR_HTTP_USER_AGENT =
        ie.ATTR_HTTP_URL =
        ie.ATTR_HTTP_TARGET =
        ie.ATTR_HTTP_STATUS_CODE =
        ie.ATTR_HTTP_SERVER_NAME =
        ie.ATTR_HTTP_SCHEME =
        ie.ATTR_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED =
        ie.ATTR_HTTP_RESPONSE_CONTENT_LENGTH =
        ie.ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED =
        ie.ATTR_HTTP_REQUEST_CONTENT_LENGTH =
        ie.ATTR_HTTP_METHOD =
        ie.ATTR_HTTP_HOST =
        ie.ATTR_HTTP_FLAVOR =
        ie.ATTR_HTTP_CLIENT_IP =
        ie.USER_AGENT_SYNTHETIC_TYPE_VALUE_TEST =
        ie.USER_AGENT_SYNTHETIC_TYPE_VALUE_BOT =
        ie.ATTR_USER_AGENT_SYNTHETIC_TYPE =
          void 0),
      (ie.ATTR_USER_AGENT_SYNTHETIC_TYPE = "user_agent.synthetic.type"),
      (ie.USER_AGENT_SYNTHETIC_TYPE_VALUE_BOT = "bot"),
      (ie.USER_AGENT_SYNTHETIC_TYPE_VALUE_TEST = "test"),
      (ie.ATTR_HTTP_CLIENT_IP = "http.client_ip"),
      (ie.ATTR_HTTP_FLAVOR = "http.flavor"),
      (ie.ATTR_HTTP_HOST = "http.host"),
      (ie.ATTR_HTTP_METHOD = "http.method"),
      (ie.ATTR_HTTP_REQUEST_CONTENT_LENGTH = "http.request_content_length"),
      (ie.ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED =
        "http.request_content_length_uncompressed"),
      (ie.ATTR_HTTP_RESPONSE_CONTENT_LENGTH = "http.response_content_length"),
      (ie.ATTR_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED =
        "http.response_content_length_uncompressed"),
      (ie.ATTR_HTTP_SCHEME = "http.scheme"),
      (ie.ATTR_HTTP_SERVER_NAME = "http.server_name"),
      (ie.ATTR_HTTP_STATUS_CODE = "http.status_code"),
      (ie.ATTR_HTTP_TARGET = "http.target"),
      (ie.ATTR_HTTP_URL = "http.url"),
      (ie.ATTR_HTTP_USER_AGENT = "http.user_agent"),
      (ie.ATTR_NET_HOST_IP = "net.host.ip"),
      (ie.ATTR_NET_HOST_NAME = "net.host.name"),
      (ie.ATTR_NET_HOST_PORT = "net.host.port"),
      (ie.ATTR_NET_PEER_IP = "net.peer.ip"),
      (ie.ATTR_NET_PEER_NAME = "net.peer.name"),
      (ie.ATTR_NET_PEER_PORT = "net.peer.port"),
      (ie.ATTR_NET_TRANSPORT = "net.transport"),
      (ie.NET_TRANSPORT_VALUE_IP_TCP = "ip_tcp"),
      (ie.NET_TRANSPORT_VALUE_IP_UDP = "ip_udp"),
      (ie.HTTP_FLAVOR_VALUE_HTTP_1_1 = "1.1")),
    ie
  );
}
var _d = {},
  MA;
function wU() {
  return (
    MA ||
      ((MA = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.AttributeNames = void 0),
          (function (t) {
            ((t.HTTP_ERROR_NAME = "http.error_name"),
              (t.HTTP_ERROR_MESSAGE = "http.error_message"),
              (t.HTTP_STATUS_TEXT = "http.status_text"));
          })(e.AttributeNames || (e.AttributeNames = {})));
      })(_d)),
    _d
  );
}
var Jt = {},
  vA;
function LA() {
  return (
    vA ||
      ((vA = 1),
      Object.defineProperty(Jt, "__esModule", {
        value: !0,
      }),
      (Jt.DEFAULT_QUERY_STRINGS_TO_REDACT =
        Jt.STR_REDACTED =
        Jt.SYNTHETIC_BOT_NAMES =
        Jt.SYNTHETIC_TEST_NAMES =
          void 0),
      (Jt.SYNTHETIC_TEST_NAMES = ["alwayson"]),
      (Jt.SYNTHETIC_BOT_NAMES = ["googlebot", "bingbot"]),
      (Jt.STR_REDACTED = "REDACTED"),
      (Jt.DEFAULT_QUERY_STRINGS_TO_REDACT = [
        "sig",
        "Signature",
        "AWSAccessKeyId",
        "X-Goog-Signature",
      ])),
    Jt
  );
}
var pd, DA;
function UU() {
  if (DA) return pd;
  DA = 1;
  var e = util2;
  function t(n, r) {
    (Error.captureStackTrace(this, t),
      (this.name = this.constructor.name),
      (this.message = n),
      (this.input = r));
  }
  return (e.inherits(t, Error), (pd = t), pd);
}
var Ed, wA;
function kU() {
  if (wA) return Ed;
  wA = 1;
  function e(o) {
    return (
      o === 34 ||
      o === 40 ||
      o === 41 ||
      o === 44 ||
      o === 47 ||
      (o >= 58 && o <= 64) ||
      (o >= 91 && o <= 93) ||
      o === 123 ||
      o === 125
    );
  }
  function t(o) {
    return (
      o === 33 ||
      (o >= 35 && o <= 39) ||
      o === 42 ||
      o === 43 ||
      o === 45 ||
      o === 46 ||
      (o >= 48 && o <= 57) ||
      (o >= 65 && o <= 90) ||
      (o >= 94 && o <= 122) ||
      o === 124 ||
      o === 126
    );
  }
  function n(o) {
    return o >= 32 && o <= 126;
  }
  function r(o) {
    return o >= 128 && o <= 255;
  }
  return (
    (Ed = {
      isDelimiter: e,
      isTokenChar: t,
      isExtended: r,
      isPrint: n,
    }),
    Ed
  );
}
var hd, UA;
function GU() {
  if (UA) return hd;
  UA = 1;
  var e = util2,
    t = UU(),
    n = kU(),
    r = n.isDelimiter,
    o = n.isTokenChar,
    s = n.isExtended,
    i = n.isPrint;
  function a(f) {
    return f.replace(/\\(.)/g, "$1");
  }
  function c(f, d) {
    return e.format("Unexpected character '%s' at index %d", f.charAt(d), d);
  }
  function l(f) {
    for (
      var d = !1, u = !1, _ = !1, p = {}, E = [], h = -1, T = -1, m, A, g = 0;
      g < f.length;
      g++
    )
      if (((A = f.charCodeAt(g)), m === void 0)) {
        if (g !== 0 && h === -1 && (A === 32 || A === 9)) continue;
        if (o(A)) h === -1 && (h = g);
        else if (A === 61 && h !== -1)
          ((m = f.slice(h, g).toLowerCase()), (h = -1));
        else throw new t(c(f, g), f);
      } else if (u && (A === 9 || i(A) || s(A))) u = !1;
      else if (o(A)) {
        if (T !== -1) throw new t(c(f, g), f);
        h === -1 && (h = g);
      } else if (r(A) || s(A)) {
        if (_)
          A === 34
            ? ((_ = !1), (T = g))
            : A === 92
              ? (h === -1 && (h = g), (u = d = !0))
              : h === -1 && (h = g);
        else if (A === 34 && f.charCodeAt(g - 1) === 61) _ = !0;
        else if ((A === 44 || A === 59) && (h !== -1 || T !== -1))
          (h !== -1
            ? (T === -1 && (T = g),
              (p[m] = d ? a(f.slice(h, T)) : f.slice(h, T)))
            : (p[m] = ""),
            A === 44 && (E.push(p), (p = {})),
            (m = void 0),
            (h = T = -1));
        else throw new t(c(f, g), f);
      } else if (A === 32 || A === 9) {
        if (T !== -1) continue;
        if (_) h === -1 && (h = g);
        else if (h !== -1) T = g;
        else throw new t(c(f, g), f);
      } else throw new t(c(f, g), f);
    if (m === void 0 || _ || (h === -1 && T === -1) || A === 32 || A === 9)
      throw new t("Unexpected end of input", f);
    return (
      h !== -1
        ? (T === -1 && (T = g), (p[m] = d ? a(f.slice(h, T)) : f.slice(h, T)))
        : (p[m] = ""),
      E.push(p),
      E
    );
  }
  return ((hd = l), hd);
}
var kA;
function VU() {
  return (
    kA ||
      ((kA = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.headerCapture =
            e.getIncomingStableRequestMetricAttributesOnResponse =
            e.getIncomingRequestMetricAttributesOnResponse =
            e.getIncomingRequestAttributesOnResponse =
            e.getIncomingRequestMetricAttributes =
            e.getIncomingRequestAttributes =
            e.getRemoteClientAddress =
            e.getOutgoingStableRequestMetricAttributesOnResponse =
            e.getOutgoingRequestMetricAttributesOnResponse =
            e.getOutgoingRequestAttributesOnResponse =
            e.setAttributesFromHttpKind =
            e.getOutgoingRequestMetricAttributes =
            e.getOutgoingRequestAttributes =
            e.extractHostnameAndPort =
            e.isValidOptionsType =
            e.getRequestInfo =
            e.isCompressed =
            e.setResponseContentLengthAttribute =
            e.setRequestContentLengthAttribute =
            e.setSpanWithError =
            e.satisfiesPattern =
            e.parseResponseStatus =
            e.getAbsoluteUrl =
              void 0));
        const t = Pe(),
          n = pt(),
          r = DU(),
          o = un,
          s = Le,
          i = url,
          a = wU(),
          c = LA(),
          l = LA(),
          f = GU(),
          d = (
            v,
            D,
            z = "http:",
            q = Array.from(l.DEFAULT_QUERY_STRINGS_TO_REDACT),
          ) => {
            const ee = v || {},
              te = ee.protocol || z,
              _e = (ee.port || "").toString();
            let se = ee.path || "/",
              ue = ee.host || ee.hostname || D.host || "localhost";
            if (
              (ue.indexOf(":") === -1 &&
                _e &&
                _e !== "80" &&
                _e !== "443" &&
                (ue += `:${_e}`),
              se.includes("?"))
            ) {
              const ve = i.parse(se),
                De = ve.pathname || "",
                qe = ve.query || "",
                Mt = new URLSearchParams(qe),
                it = q || [];
              for (const nt of it)
                Mt.has(nt) && Mt.get(nt) !== "" && Mt.set(nt, l.STR_REDACTED);
              const at = Mt.toString();
              se = `${De}?${at}`;
            }
            const Te = ee.auth ? `${l.STR_REDACTED}:${l.STR_REDACTED}@` : "";
            return `${te}//${Te}${ue}${se}`;
          };
        e.getAbsoluteUrl = d;
        const u = (v, D) => {
          const z = v === t.SpanKind.CLIENT ? 400 : 500;
          return D && D >= 100 && D < z
            ? t.SpanStatusCode.UNSET
            : t.SpanStatusCode.ERROR;
        };
        e.parseResponseStatus = u;
        const _ = (v, D) => {
          if (typeof D == "string") return D === v;
          if (D instanceof RegExp) return D.test(v);
          if (typeof D == "function") return D(v);
          throw new TypeError("Pattern is in unsupported datatype");
        };
        e.satisfiesPattern = _;
        const p = (v, D, z) => {
          const q = D.message;
          (z & s.SemconvStability.OLD &&
            (v.setAttribute(a.AttributeNames.HTTP_ERROR_NAME, D.name),
            v.setAttribute(a.AttributeNames.HTTP_ERROR_MESSAGE, q)),
            z & s.SemconvStability.STABLE &&
              v.setAttribute(n.ATTR_ERROR_TYPE, D.name),
            v.setStatus({
              code: t.SpanStatusCode.ERROR,
              message: q,
            }),
            v.recordException(D));
        };
        e.setSpanWithError = p;
        const E = (v, D) => {
          const z = T(v.headers);
          z !== null &&
            ((0, e.isCompressed)(v.headers)
              ? (D[r.ATTR_HTTP_REQUEST_CONTENT_LENGTH] = z)
              : (D[r.ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED] = z));
        };
        e.setRequestContentLengthAttribute = E;
        const h = (v, D) => {
          const z = T(v.headers);
          z !== null &&
            ((0, e.isCompressed)(v.headers)
              ? (D[r.ATTR_HTTP_RESPONSE_CONTENT_LENGTH] = z)
              : (D[r.ATTR_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED] = z));
        };
        e.setResponseContentLengthAttribute = h;
        function T(v) {
          const D = v["content-length"];
          if (D === void 0) return null;
          const z = parseInt(D, 10);
          return isNaN(z) ? null : z;
        }
        const m = (v) => {
          const D = v["content-encoding"];
          return !!D && D !== "identity";
        };
        e.isCompressed = m;
        function A(v) {
          const {
              hostname: D,
              pathname: z,
              port: q,
              username: ee,
              password: te,
              search: _e,
              protocol: se,
              hash: ue,
              href: Te,
              origin: ve,
              host: De,
            } = new URL(v),
            qe = {
              protocol: se,
              hostname: D && D[0] === "[" ? D.slice(1, -1) : D,
              hash: ue,
              search: _e,
              pathname: z,
              path: `${z || ""}${_e || ""}`,
              href: Te,
              origin: ve,
              host: De,
            };
          return (
            q !== "" && (qe.port = Number(q)),
            (ee || te) &&
              (qe.auth = `${decodeURIComponent(ee)}:${decodeURIComponent(te)}`),
            qe
          );
        }
        const g = (v, D, z) => {
          let q,
            ee,
            te,
            _e = !1;
          if (typeof D == "string") {
            try {
              const ue = A(D);
              ((te = ue), (q = ue.pathname || "/"));
            } catch (ue) {
              ((_e = !0),
                v.verbose(
                  "Unable to parse URL provided to HTTP request, using fallback to determine path. Original error:",
                  ue,
                ),
                (te = {
                  path: D,
                }),
                (q = te.path || "/"));
            }
            ((ee = `${te.protocol || "http:"}//${te.host}`),
              z !== void 0 && Object.assign(te, z));
          } else if (D instanceof i.URL)
            ((te = {
              protocol: D.protocol,
              hostname:
                typeof D.hostname == "string" && D.hostname.startsWith("[")
                  ? D.hostname.slice(1, -1)
                  : D.hostname,
              path: `${D.pathname || ""}${D.search || ""}`,
            }),
              D.port !== "" && (te.port = Number(D.port)),
              (D.username || D.password) &&
                (te.auth = `${D.username}:${D.password}`),
              (q = D.pathname),
              (ee = D.origin),
              z !== void 0 && Object.assign(te, z));
          else {
            te = Object.assign(
              {
                protocol: D.host ? "http:" : void 0,
              },
              D,
            );
            const ue =
              te.host ||
              (te.port != null ? `${te.hostname}${te.port}` : te.hostname);
            if (
              ((ee = `${te.protocol || "http:"}//${ue}`),
              (q = D.pathname),
              !q && te.path)
            )
              try {
                q = new URL(te.path, ee).pathname || "/";
              } catch {
                q = "/";
              }
          }
          const se = te.method ? te.method.toUpperCase() : "GET";
          return {
            origin: ee,
            pathname: q,
            method: se,
            optionsParsed: te,
            invalidUrl: _e,
          };
        };
        e.getRequestInfo = g;
        const N = (v) => {
          if (!v) return !1;
          const D = typeof v;
          return D === "string" || (D === "object" && !Array.isArray(v));
        };
        e.isValidOptionsType = N;
        const O = (v) => {
          if (v.hostname && v.port)
            return {
              hostname: v.hostname,
              port: v.port,
            };
          const D = v.host?.match(/^([^:/ ]+)(:\d{1,5})?/) || null,
            z = v.hostname || (D === null ? "localhost" : D[1]);
          let q = v.port;
          return (
            q ||
              (D && D[2]
                ? (q = D[2].substring(1))
                : (q = v.protocol === "https:" ? "443" : "80")),
            {
              hostname: z,
              port: q,
            }
          );
        };
        e.extractHostnameAndPort = O;
        const I = (v, D, z, q) => {
          const ee = D.hostname,
            te = D.port,
            _e = v.method ?? "GET",
            se = K(_e),
            ue = v.headers || {},
            Te = ue["user-agent"],
            ve = (0, e.getAbsoluteUrl)(
              v,
              ue,
              `${D.component}:`,
              D.redactedQueryParams,
            ),
            De = {
              [r.ATTR_HTTP_URL]: ve,
              [r.ATTR_HTTP_METHOD]: _e,
              [r.ATTR_HTTP_TARGET]: v.path || "/",
              [r.ATTR_NET_PEER_NAME]: ee,
              [r.ATTR_HTTP_HOST]: ue.host ?? `${ee}:${te}`,
            },
            qe = {
              [n.ATTR_HTTP_REQUEST_METHOD]: se,
              [n.ATTR_SERVER_ADDRESS]: ee,
              [n.ATTR_SERVER_PORT]: Number(te),
              [n.ATTR_URL_FULL]: ve,
              [n.ATTR_USER_AGENT_ORIGINAL]: Te,
            };
          switch (
            (_e !== se && (qe[n.ATTR_HTTP_REQUEST_METHOD_ORIGINAL] = _e),
            q && Te && (qe[r.ATTR_USER_AGENT_SYNTHETIC_TYPE] = L(Te)),
            Te !== void 0 && (De[r.ATTR_HTTP_USER_AGENT] = Te),
            z)
          ) {
            case s.SemconvStability.STABLE:
              return Object.assign(qe, D.hookAttributes);
            case s.SemconvStability.OLD:
              return Object.assign(De, D.hookAttributes);
          }
          return Object.assign(De, qe, D.hookAttributes);
        };
        e.getOutgoingRequestAttributes = I;
        const b = (v) => {
          const D = {};
          return (
            (D[r.ATTR_HTTP_METHOD] = v[r.ATTR_HTTP_METHOD]),
            (D[r.ATTR_NET_PEER_NAME] = v[r.ATTR_NET_PEER_NAME]),
            D
          );
        };
        e.getOutgoingRequestMetricAttributes = b;
        const w = (v, D) => {
          v &&
            ((D[r.ATTR_HTTP_FLAVOR] = v),
            v.toUpperCase() !== "QUIC"
              ? (D[r.ATTR_NET_TRANSPORT] = r.NET_TRANSPORT_VALUE_IP_TCP)
              : (D[r.ATTR_NET_TRANSPORT] = r.NET_TRANSPORT_VALUE_IP_UDP));
        };
        e.setAttributesFromHttpKind = w;
        const L = (v) => {
            const D = String(v).toLowerCase();
            for (const z of c.SYNTHETIC_TEST_NAMES)
              if (D.includes(z)) return r.USER_AGENT_SYNTHETIC_TYPE_VALUE_TEST;
            for (const z of c.SYNTHETIC_BOT_NAMES)
              if (D.includes(z)) return r.USER_AGENT_SYNTHETIC_TYPE_VALUE_BOT;
          },
          j = (v, D) => {
            const {
                statusCode: z,
                statusMessage: q,
                httpVersion: ee,
                socket: te,
              } = v,
              _e = {},
              se = {};
            if ((z != null && (se[n.ATTR_HTTP_RESPONSE_STATUS_CODE] = z), te)) {
              const { remoteAddress: ue, remotePort: Te } = te;
              ((_e[r.ATTR_NET_PEER_IP] = ue),
                (_e[r.ATTR_NET_PEER_PORT] = Te),
                (se[n.ATTR_NETWORK_PEER_ADDRESS] = ue),
                (se[n.ATTR_NETWORK_PEER_PORT] = Te),
                (se[n.ATTR_NETWORK_PROTOCOL_VERSION] = v.httpVersion));
            }
            switch (
              ((0, e.setResponseContentLengthAttribute)(v, _e),
              z &&
                ((_e[r.ATTR_HTTP_STATUS_CODE] = z),
                (_e[a.AttributeNames.HTTP_STATUS_TEXT] = (
                  q || ""
                ).toUpperCase())),
              (0, e.setAttributesFromHttpKind)(ee, _e),
              D)
            ) {
              case s.SemconvStability.STABLE:
                return se;
              case s.SemconvStability.OLD:
                return _e;
            }
            return Object.assign(_e, se);
          };
        e.getOutgoingRequestAttributesOnResponse = j;
        const H = (v) => {
          const D = {};
          return (
            (D[r.ATTR_NET_PEER_PORT] = v[r.ATTR_NET_PEER_PORT]),
            (D[r.ATTR_HTTP_STATUS_CODE] = v[r.ATTR_HTTP_STATUS_CODE]),
            (D[r.ATTR_HTTP_FLAVOR] = v[r.ATTR_HTTP_FLAVOR]),
            D
          );
        };
        e.getOutgoingRequestMetricAttributesOnResponse = H;
        const x = (v) => {
          const D = {};
          return (
            v[n.ATTR_NETWORK_PROTOCOL_VERSION] &&
              (D[n.ATTR_NETWORK_PROTOCOL_VERSION] =
                v[n.ATTR_NETWORK_PROTOCOL_VERSION]),
            v[n.ATTR_HTTP_RESPONSE_STATUS_CODE] &&
              (D[n.ATTR_HTTP_RESPONSE_STATUS_CODE] =
                v[n.ATTR_HTTP_RESPONSE_STATUS_CODE]),
            D
          );
        };
        e.getOutgoingStableRequestMetricAttributesOnResponse = x;
        function B(v, D) {
          const z = v.split(":");
          if (z.length === 1)
            return D === "http"
              ? {
                  host: z[0],
                  port: "80",
                }
              : D === "https"
                ? {
                    host: z[0],
                    port: "443",
                  }
                : {
                    host: z[0],
                  };
          if (z.length === 2)
            return {
              host: z[0],
              port: z[1],
            };
          if (z[0].startsWith("[")) {
            if (z[z.length - 1].endsWith("]")) {
              if (D === "http")
                return {
                  host: v,
                  port: "80",
                };
              if (D === "https")
                return {
                  host: v,
                  port: "443",
                };
            } else if (z[z.length - 2].endsWith("]"))
              return {
                host: z.slice(0, -1).join(":"),
                port: z[z.length - 1],
              };
          }
          return {
            host: v,
          };
        }
        function F(v, D) {
          const z = v.headers.forwarded;
          if (z) {
            for (const te of X(z)) if (te.host) return B(te.host, te.proto);
          }
          const q = v.headers["x-forwarded-host"];
          if (typeof q == "string")
            return typeof v.headers["x-forwarded-proto"] == "string"
              ? B(q, v.headers["x-forwarded-proto"])
              : Array.isArray(v.headers["x-forwarded-proto"])
                ? B(q, v.headers["x-forwarded-proto"][0])
                : B(q);
          if (Array.isArray(q) && typeof q[0] == "string" && q[0].length > 0)
            return typeof v.headers["x-forwarded-proto"] == "string"
              ? B(q[0], v.headers["x-forwarded-proto"])
              : Array.isArray(v.headers["x-forwarded-proto"])
                ? B(q[0], v.headers["x-forwarded-proto"][0])
                : B(q[0]);
          const ee = v.headers.host;
          return typeof ee == "string" && ee.length > 0 ? B(ee, D) : null;
        }
        function U(v) {
          const D = v.headers.forwarded;
          if (D) {
            for (const ee of X(D)) if (ee.for) return k(ee.for);
          }
          const z = v.headers["x-forwarded-for"];
          if (z) {
            let ee;
            if (
              (typeof z == "string"
                ? (ee = z)
                : Array.isArray(z) && (ee = z[0]),
              typeof ee == "string")
            )
              return ((ee = ee.split(",")[0].trim()), k(ee));
          }
          const q = v.socket.remoteAddress;
          return q || null;
        }
        e.getRemoteClientAddress = U;
        function k(v) {
          try {
            const { hostname: D } = new URL(`http://${v}`);
            return D.startsWith("[") && D.endsWith("]") ? D.slice(1, -1) : D;
          } catch {
            return v;
          }
        }
        function Y(v, D, z) {
          try {
            if (D.headers.host)
              return new URL(D.url ?? "/", `${v}://${D.headers.host}`);
            {
              const q = new URL(D.url ?? "/", `${v}://localhost`);
              return {
                pathname: q.pathname,
                search: q.search,
                toString: function () {
                  return q.pathname + q.search;
                },
              };
            }
          } catch (q) {
            return (z.verbose("Unable to get URL from request", q), {});
          }
        }
        const oe = (v, D, z) => {
          const q = v.headers,
            ee = q["user-agent"],
            te = q["x-forwarded-for"],
            _e = v.httpVersion,
            se = q.host,
            ue = se?.replace(/^(.*)(:[0-9]{1,5})/, "$1") || "localhost",
            Te = v.method,
            ve = K(Te),
            De = F(v, D.component),
            qe = D.serverName,
            Mt = U(v),
            it = {
              [n.ATTR_HTTP_REQUEST_METHOD]: ve,
              [n.ATTR_URL_SCHEME]: D.component,
              [n.ATTR_SERVER_ADDRESS]: De?.host,
              [n.ATTR_NETWORK_PEER_ADDRESS]: v.socket.remoteAddress,
              [n.ATTR_NETWORK_PEER_PORT]: v.socket.remotePort,
              [n.ATTR_NETWORK_PROTOCOL_VERSION]: v.httpVersion,
              [n.ATTR_USER_AGENT_ORIGINAL]: ee,
            },
            at = Y(D.component, v, z);
          (at?.pathname != null && (it[n.ATTR_URL_PATH] = at.pathname),
            at.search && (it[n.ATTR_URL_QUERY] = at.search.slice(1)),
            Mt != null && (it[n.ATTR_CLIENT_ADDRESS] = Mt),
            De?.port != null && (it[n.ATTR_SERVER_PORT] = Number(De.port)),
            Te !== ve && (it[n.ATTR_HTTP_REQUEST_METHOD_ORIGINAL] = Te),
            D.enableSyntheticSourceDetection &&
              ee &&
              (it[r.ATTR_USER_AGENT_SYNTHETIC_TYPE] = L(ee)));
          const nt = {
            [r.ATTR_HTTP_URL]: at.toString(),
            [r.ATTR_HTTP_HOST]: se,
            [r.ATTR_NET_HOST_NAME]: ue,
            [r.ATTR_HTTP_METHOD]: Te,
            [r.ATTR_HTTP_SCHEME]: D.component,
          };
          switch (
            (typeof te == "string" &&
              (nt[r.ATTR_HTTP_CLIENT_IP] = te.split(",")[0]),
            typeof qe == "string" && (nt[r.ATTR_HTTP_SERVER_NAME] = qe),
            at?.pathname &&
              (nt[r.ATTR_HTTP_TARGET] = at?.pathname + at?.search || "/"),
            ee !== void 0 && (nt[r.ATTR_HTTP_USER_AGENT] = ee),
            (0, e.setRequestContentLengthAttribute)(v, nt),
            (0, e.setAttributesFromHttpKind)(_e, nt),
            D.semconvStability)
          ) {
            case s.SemconvStability.STABLE:
              return Object.assign(it, D.hookAttributes);
            case s.SemconvStability.OLD:
              return Object.assign(nt, D.hookAttributes);
          }
          return Object.assign(nt, it, D.hookAttributes);
        };
        e.getIncomingRequestAttributes = oe;
        const ae = (v) => {
          const D = {};
          return (
            (D[r.ATTR_HTTP_SCHEME] = v[r.ATTR_HTTP_SCHEME]),
            (D[r.ATTR_HTTP_METHOD] = v[r.ATTR_HTTP_METHOD]),
            (D[r.ATTR_NET_HOST_NAME] = v[r.ATTR_NET_HOST_NAME]),
            (D[r.ATTR_HTTP_FLAVOR] = v[r.ATTR_HTTP_FLAVOR]),
            D
          );
        };
        e.getIncomingRequestMetricAttributes = ae;
        const ne = (v, D, z) => {
          const { socket: q } = v,
            { statusCode: ee, statusMessage: te } = D,
            _e = {
              [n.ATTR_HTTP_RESPONSE_STATUS_CODE]: ee,
            },
            se = (0, o.getRPCMetadata)(t.context.active()),
            ue = {};
          if (q) {
            const {
              localAddress: Te,
              localPort: ve,
              remoteAddress: De,
              remotePort: qe,
            } = q;
            ((ue[r.ATTR_NET_HOST_IP] = Te),
              (ue[r.ATTR_NET_HOST_PORT] = ve),
              (ue[r.ATTR_NET_PEER_IP] = De),
              (ue[r.ATTR_NET_PEER_PORT] = qe));
          }
          switch (
            ((ue[r.ATTR_HTTP_STATUS_CODE] = ee),
            (ue[a.AttributeNames.HTTP_STATUS_TEXT] = (te || "").toUpperCase()),
            se?.type === o.RPCType.HTTP &&
              se.route !== void 0 &&
              ((ue[n.ATTR_HTTP_ROUTE] = se.route),
              (_e[n.ATTR_HTTP_ROUTE] = se.route)),
            z)
          ) {
            case s.SemconvStability.STABLE:
              return _e;
            case s.SemconvStability.OLD:
              return ue;
          }
          return Object.assign(ue, _e);
        };
        e.getIncomingRequestAttributesOnResponse = ne;
        const P = (v) => {
          const D = {};
          return (
            (D[r.ATTR_HTTP_STATUS_CODE] = v[r.ATTR_HTTP_STATUS_CODE]),
            (D[r.ATTR_NET_HOST_PORT] = v[r.ATTR_NET_HOST_PORT]),
            v[n.ATTR_HTTP_ROUTE] !== void 0 &&
              (D[n.ATTR_HTTP_ROUTE] = v[n.ATTR_HTTP_ROUTE]),
            D
          );
        };
        e.getIncomingRequestMetricAttributesOnResponse = P;
        const M = (v) => {
          const D = {};
          return (
            v[n.ATTR_HTTP_ROUTE] !== void 0 &&
              (D[n.ATTR_HTTP_ROUTE] = v[n.ATTR_HTTP_ROUTE]),
            v[n.ATTR_HTTP_RESPONSE_STATUS_CODE] &&
              (D[n.ATTR_HTTP_RESPONSE_STATUS_CODE] =
                v[n.ATTR_HTTP_RESPONSE_STATUS_CODE]),
            D
          );
        };
        e.getIncomingStableRequestMetricAttributesOnResponse = M;
        function G(v, D) {
          const z = new Map();
          for (let q = 0, ee = D.length; q < ee; q++) {
            const te = D[q].toLowerCase();
            z.set(te, te.replace(/-/g, "_"));
          }
          return (q, ee) => {
            for (const te of z.keys()) {
              const _e = ee(te);
              if (_e === void 0) continue;
              const se = z.get(te),
                ue = `http.${v}.header.${se}`;
              typeof _e == "string"
                ? q.setAttribute(ue, [_e])
                : Array.isArray(_e)
                  ? q.setAttribute(ue, _e)
                  : q.setAttribute(ue, [_e]);
            }
          };
        }
        e.headerCapture = G;
        const V = new Set([
          "GET",
          "HEAD",
          "POST",
          "PUT",
          "DELETE",
          "CONNECT",
          "OPTIONS",
          "TRACE",
          "PATCH",
        ]);
        function K(v) {
          if (v == null) return "GET";
          const D = v.toUpperCase();
          return V.has(D) ? D : "_OTHER";
        }
        function X(v) {
          try {
            return f(v);
          } catch {
            return [];
          }
        }
      })(fd)),
    fd
  );
}
var GA;
function xU() {
  if (GA) return zi;
  ((GA = 1),
    Object.defineProperty(zi, "__esModule", {
      value: !0,
    }),
    (zi.HttpInstrumentation = void 0));
  const e = Pe(),
    t = un,
    n = url,
    r = L0(),
    o = Le,
    s = events,
    i = pt(),
    a = VU();
  class c extends o.InstrumentationBase {
    _spanNotEnded = new WeakSet();
    _headerCapture;
    _semconvStability = o.SemconvStability.OLD;
    constructor(f = {}) {
      (super("@opentelemetry/instrumentation-http", r.VERSION, f),
        (this._headerCapture = this._createHeaderCapture()),
        (this._semconvStability = (0, o.semconvStabilityFromStr)(
          "http",
          process.env.OTEL_SEMCONV_STABILITY_OPT_IN,
        )));
    }
    _updateMetricInstruments() {
      ((this._oldHttpServerDurationHistogram = this.meter.createHistogram(
        "http.server.duration",
        {
          description: "Measures the duration of inbound HTTP requests.",
          unit: "ms",
          valueType: e.ValueType.DOUBLE,
        },
      )),
        (this._oldHttpClientDurationHistogram = this.meter.createHistogram(
          "http.client.duration",
          {
            description: "Measures the duration of outbound HTTP requests.",
            unit: "ms",
            valueType: e.ValueType.DOUBLE,
          },
        )),
        (this._stableHttpServerDurationHistogram = this.meter.createHistogram(
          i.METRIC_HTTP_SERVER_REQUEST_DURATION,
          {
            description: "Duration of HTTP server requests.",
            unit: "s",
            valueType: e.ValueType.DOUBLE,
            advice: {
              explicitBucketBoundaries: [
                0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 2.5,
                5, 7.5, 10,
              ],
            },
          },
        )),
        (this._stableHttpClientDurationHistogram = this.meter.createHistogram(
          i.METRIC_HTTP_CLIENT_REQUEST_DURATION,
          {
            description: "Duration of HTTP client requests.",
            unit: "s",
            valueType: e.ValueType.DOUBLE,
            advice: {
              explicitBucketBoundaries: [
                0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 2.5,
                5, 7.5, 10,
              ],
            },
          },
        )));
    }
    _recordServerDuration(f, d, u) {
      (this._semconvStability & o.SemconvStability.OLD &&
        this._oldHttpServerDurationHistogram.record(f, d),
        this._semconvStability & o.SemconvStability.STABLE &&
          this._stableHttpServerDurationHistogram.record(f / 1e3, u));
    }
    _recordClientDuration(f, d, u) {
      (this._semconvStability & o.SemconvStability.OLD &&
        this._oldHttpClientDurationHistogram.record(f, d),
        this._semconvStability & o.SemconvStability.STABLE &&
          this._stableHttpClientDurationHistogram.record(f / 1e3, u));
    }
    setConfig(f = {}) {
      (super.setConfig(f), (this._headerCapture = this._createHeaderCapture()));
    }
    init() {
      return [this._getHttpsInstrumentation(), this._getHttpInstrumentation()];
    }
    _getHttpInstrumentation() {
      return new o.InstrumentationNodeModuleDefinition(
        "http",
        ["*"],
        (f) => {
          const d = f[Symbol.toStringTag] === "Module";
          if (!this.getConfig().disableOutgoingRequestInstrumentation) {
            const u = this._wrap(
                f,
                "request",
                this._getPatchOutgoingRequestFunction("http"),
              ),
              _ = this._wrap(f, "get", this._getPatchOutgoingGetFunction(u));
            d && ((f.default.request = u), (f.default.get = _));
          }
          return (
            this.getConfig().disableIncomingRequestInstrumentation ||
              this._wrap(
                f.Server.prototype,
                "emit",
                this._getPatchIncomingRequestFunction("http"),
              ),
            f
          );
        },
        (f) => {
          f !== void 0 &&
            (this.getConfig().disableOutgoingRequestInstrumentation ||
              (this._unwrap(f, "request"), this._unwrap(f, "get")),
            this.getConfig().disableIncomingRequestInstrumentation ||
              this._unwrap(f.Server.prototype, "emit"));
        },
      );
    }
    _getHttpsInstrumentation() {
      return new o.InstrumentationNodeModuleDefinition(
        "https",
        ["*"],
        (f) => {
          const d = f[Symbol.toStringTag] === "Module";
          if (!this.getConfig().disableOutgoingRequestInstrumentation) {
            const u = this._wrap(
                f,
                "request",
                this._getPatchHttpsOutgoingRequestFunction("https"),
              ),
              _ = this._wrap(
                f,
                "get",
                this._getPatchHttpsOutgoingGetFunction(u),
              );
            d && ((f.default.request = u), (f.default.get = _));
          }
          return (
            this.getConfig().disableIncomingRequestInstrumentation ||
              this._wrap(
                f.Server.prototype,
                "emit",
                this._getPatchIncomingRequestFunction("https"),
              ),
            f
          );
        },
        (f) => {
          f !== void 0 &&
            (this.getConfig().disableOutgoingRequestInstrumentation ||
              (this._unwrap(f, "request"), this._unwrap(f, "get")),
            this.getConfig().disableIncomingRequestInstrumentation ||
              this._unwrap(f.Server.prototype, "emit"));
        },
      );
    }
    _getPatchIncomingRequestFunction(f) {
      return (d) => this._incomingRequestFunction(f, d);
    }
    _getPatchOutgoingRequestFunction(f) {
      return (d) => this._outgoingRequestFunction(f, d);
    }
    _getPatchOutgoingGetFunction(f) {
      return (d) =>
        function (_, ...p) {
          const E = f(_, ...p);
          return (E.end(), E);
        };
    }
    _getPatchHttpsOutgoingRequestFunction(f) {
      return (d) => {
        const u = this;
        return function (p, ...E) {
          return (
            f === "https" &&
              typeof p == "object" &&
              p?.constructor?.name !== "URL" &&
              ((p = Object.assign({}, p)), u._setDefaultOptions(p)),
            u._getPatchOutgoingRequestFunction(f)(d)(p, ...E)
          );
        };
      };
    }
    _setDefaultOptions(f) {
      ((f.protocol = f.protocol || "https:"), (f.port = f.port || 443));
    }
    _getPatchHttpsOutgoingGetFunction(f) {
      return (d) => {
        const u = this;
        return function (p, ...E) {
          return u._getPatchOutgoingGetFunction(f)(d)(p, ...E);
        };
      };
    }
    _traceClientRequest(f, d, u, _, p) {
      this.getConfig().requestHook && this._callRequestHook(d, f);
      let E = !1;
      return (
        f.prependListener("response", (h) => {
          (this._diag.debug("outgoingRequest on response()"),
            f.listenerCount("response") <= 1 && h.resume());
          const T = (0, a.getOutgoingRequestAttributesOnResponse)(
            h,
            this._semconvStability,
          );
          (d.setAttributes(T),
            (_ = Object.assign(
              _,
              (0, a.getOutgoingRequestMetricAttributesOnResponse)(T),
            )),
            (p = Object.assign(
              p,
              (0, a.getOutgoingStableRequestMetricAttributesOnResponse)(T),
            )),
            this.getConfig().responseHook && this._callResponseHook(d, h),
            this._headerCapture.client.captureRequestHeaders(d, (A) =>
              f.getHeader(A),
            ),
            this._headerCapture.client.captureResponseHeaders(
              d,
              (A) => h.headers[A],
            ),
            e.context.bind(e.context.active(), h));
          const m = () => {
            if ((this._diag.debug("outgoingRequest on end()"), E)) return;
            E = !0;
            let A;
            (h.aborted && !h.complete
              ? (A = {
                  code: e.SpanStatusCode.ERROR,
                })
              : (A = {
                  code: (0, a.parseResponseStatus)(
                    e.SpanKind.CLIENT,
                    h.statusCode,
                  ),
                }),
              d.setStatus(A),
              this.getConfig().applyCustomAttributesOnSpan &&
                (0, o.safeExecuteInTheMiddle)(
                  () => this.getConfig().applyCustomAttributesOnSpan(d, f, h),
                  () => {},
                  !0,
                ),
              this._closeHttpSpan(d, e.SpanKind.CLIENT, u, _, p));
          };
          (h.on("end", m),
            h.on(s.errorMonitor, (A) => {
              (this._diag.debug("outgoingRequest on error()", A),
                !E && ((E = !0), this._onOutgoingRequestError(d, _, p, u, A)));
            }));
        }),
        f.on("close", () => {
          (this._diag.debug("outgoingRequest on request close()"),
            !(f.aborted || E) &&
              ((E = !0), this._closeHttpSpan(d, e.SpanKind.CLIENT, u, _, p)));
        }),
        f.on(s.errorMonitor, (h) => {
          (this._diag.debug("outgoingRequest on request error()", h),
            !E && ((E = !0), this._onOutgoingRequestError(d, _, p, u, h)));
        }),
        this._diag.debug("http.ClientRequest return request"),
        f
      );
    }
    _incomingRequestFunction(f, d) {
      const u = this;
      return function (p, ...E) {
        if (p !== "request") return d.apply(this, [p, ...E]);
        const h = E[0],
          T = E[1],
          m = h.method || "GET";
        if (
          (u._diag.debug(`${f} instrumentation incomingRequest`),
          (0, o.safeExecuteInTheMiddle)(
            () => u.getConfig().ignoreIncomingRequestHook?.(h),
            (H) => {
              H != null &&
                u._diag.error("caught ignoreIncomingRequestHook error: ", H);
            },
            !0,
          ))
        )
          return e.context.with(
            (0, t.suppressTracing)(e.context.active()),
            () => (
              e.context.bind(e.context.active(), h),
              e.context.bind(e.context.active(), T),
              d.apply(this, [p, ...E])
            ),
          );
        const A = h.headers,
          g = (0, a.getIncomingRequestAttributes)(
            h,
            {
              component: f,
              serverName: u.getConfig().serverName,
              hookAttributes: u._callStartSpanHook(
                h,
                u.getConfig().startIncomingSpanHook,
              ),
              semconvStability: u._semconvStability,
              enableSyntheticSourceDetection:
                u.getConfig().enableSyntheticSourceDetection || !1,
            },
            u._diag,
          ),
          N = {
            kind: e.SpanKind.SERVER,
            attributes: g,
          },
          O = (0, t.hrTime)(),
          I = (0, a.getIncomingRequestMetricAttributes)(g),
          b = {
            [i.ATTR_HTTP_REQUEST_METHOD]: g[i.ATTR_HTTP_REQUEST_METHOD],
            [i.ATTR_URL_SCHEME]: g[i.ATTR_URL_SCHEME],
          };
        g[i.ATTR_NETWORK_PROTOCOL_VERSION] &&
          (b[i.ATTR_NETWORK_PROTOCOL_VERSION] =
            g[i.ATTR_NETWORK_PROTOCOL_VERSION]);
        const w = e.propagation.extract(e.ROOT_CONTEXT, A),
          L = u._startHttpSpan(m, N, w),
          j = {
            type: t.RPCType.HTTP,
            span: L,
          };
        return e.context.with(
          (0, t.setRPCMetadata)(e.trace.setSpan(w, L), j),
          () => {
            (e.context.bind(e.context.active(), h),
              e.context.bind(e.context.active(), T),
              u.getConfig().requestHook && u._callRequestHook(L, h),
              u.getConfig().responseHook && u._callResponseHook(L, T),
              u._headerCapture.server.captureRequestHeaders(
                L,
                (x) => h.headers[x],
              ));
            let H = !1;
            return (
              T.on("close", () => {
                H || u._onServerResponseFinish(h, T, L, I, b, O);
              }),
              T.on(s.errorMonitor, (x) => {
                ((H = !0), u._onServerResponseError(L, I, b, O, x));
              }),
              (0, o.safeExecuteInTheMiddle)(
                () => d.apply(this, [p, ...E]),
                (x) => {
                  if (x) throw (u._onServerResponseError(L, I, b, O, x), x);
                },
              )
            );
          },
        );
      };
    }
    _outgoingRequestFunction(f, d) {
      const u = this;
      return function (p, ...E) {
        if (!(0, a.isValidOptionsType)(p)) return d.apply(this, [p, ...E]);
        const h =
            typeof E[0] == "object" &&
            (typeof p == "string" || p instanceof n.URL)
              ? E.shift()
              : void 0,
          {
            method: T,
            invalidUrl: m,
            optionsParsed: A,
          } = (0, a.getRequestInfo)(u._diag, p, h);
        if (
          (0, o.safeExecuteInTheMiddle)(
            () => u.getConfig().ignoreOutgoingRequestHook?.(A),
            (B) => {
              B != null &&
                u._diag.error("caught ignoreOutgoingRequestHook error: ", B);
            },
            !0,
          )
        )
          return d.apply(this, [A, ...E]);
        const { hostname: g, port: N } = (0, a.extractHostnameAndPort)(A),
          O = (0, a.getOutgoingRequestAttributes)(
            A,
            {
              component: f,
              port: N,
              hostname: g,
              hookAttributes: u._callStartSpanHook(
                A,
                u.getConfig().startOutgoingSpanHook,
              ),
              redactedQueryParams: u.getConfig().redactedQueryParams,
            },
            u._semconvStability,
            u.getConfig().enableSyntheticSourceDetection || !1,
          ),
          I = (0, t.hrTime)(),
          b = (0, a.getOutgoingRequestMetricAttributes)(O),
          w = {
            [i.ATTR_HTTP_REQUEST_METHOD]: O[i.ATTR_HTTP_REQUEST_METHOD],
            [i.ATTR_SERVER_ADDRESS]: O[i.ATTR_SERVER_ADDRESS],
            [i.ATTR_SERVER_PORT]: O[i.ATTR_SERVER_PORT],
          };
        (O[i.ATTR_HTTP_RESPONSE_STATUS_CODE] &&
          (w[i.ATTR_HTTP_RESPONSE_STATUS_CODE] =
            O[i.ATTR_HTTP_RESPONSE_STATUS_CODE]),
          O[i.ATTR_NETWORK_PROTOCOL_VERSION] &&
            (w[i.ATTR_NETWORK_PROTOCOL_VERSION] =
              O[i.ATTR_NETWORK_PROTOCOL_VERSION]));
        const L = {
            kind: e.SpanKind.CLIENT,
            attributes: O,
          },
          j = u._startHttpSpan(T, L),
          H = e.context.active(),
          x = e.trace.setSpan(H, j);
        return (
          A.headers
            ? (A.headers = Object.assign({}, A.headers))
            : (A.headers = {}),
          e.propagation.inject(x, A.headers),
          e.context.with(x, () => {
            const B = E[E.length - 1];
            typeof B == "function" && (E[E.length - 1] = e.context.bind(H, B));
            const F = (0, o.safeExecuteInTheMiddle)(
              () => (m ? d.apply(this, [p, ...E]) : d.apply(this, [A, ...E])),
              (U) => {
                if (U) throw (u._onOutgoingRequestError(j, b, w, I, U), U);
              },
            );
            return (
              u._diag.debug(`${f} instrumentation outgoingRequest`),
              e.context.bind(H, F),
              u._traceClientRequest(F, j, I, b, w)
            );
          })
        );
      };
    }
    _onServerResponseFinish(f, d, u, _, p, E) {
      const h = (0, a.getIncomingRequestAttributesOnResponse)(
        f,
        d,
        this._semconvStability,
      );
      ((_ = Object.assign(
        _,
        (0, a.getIncomingRequestMetricAttributesOnResponse)(h),
      )),
        (p = Object.assign(
          p,
          (0, a.getIncomingStableRequestMetricAttributesOnResponse)(h),
        )),
        this._headerCapture.server.captureResponseHeaders(u, (m) =>
          d.getHeader(m),
        ),
        u.setAttributes(h).setStatus({
          code: (0, a.parseResponseStatus)(e.SpanKind.SERVER, d.statusCode),
        }));
      const T = h[i.ATTR_HTTP_ROUTE];
      (T && u.updateName(`${f.method || "GET"} ${T}`),
        this.getConfig().applyCustomAttributesOnSpan &&
          (0, o.safeExecuteInTheMiddle)(
            () => this.getConfig().applyCustomAttributesOnSpan(u, f, d),
            () => {},
            !0,
          ),
        this._closeHttpSpan(u, e.SpanKind.SERVER, E, _, p));
    }
    _onOutgoingRequestError(f, d, u, _, p) {
      ((0, a.setSpanWithError)(f, p, this._semconvStability),
        (u[i.ATTR_ERROR_TYPE] = p.name),
        this._closeHttpSpan(f, e.SpanKind.CLIENT, _, d, u));
    }
    _onServerResponseError(f, d, u, _, p) {
      ((0, a.setSpanWithError)(f, p, this._semconvStability),
        (u[i.ATTR_ERROR_TYPE] = p.name),
        this._closeHttpSpan(f, e.SpanKind.SERVER, _, d, u));
    }
    _startHttpSpan(f, d, u = e.context.active()) {
      const _ =
        d.kind === e.SpanKind.CLIENT
          ? this.getConfig().requireParentforOutgoingSpans
          : this.getConfig().requireParentforIncomingSpans;
      let p;
      const E = e.trace.getSpan(u);
      return (
        _ === !0 && (!E || !e.trace.isSpanContextValid(E.spanContext()))
          ? (p = e.trace.wrapSpanContext(e.INVALID_SPAN_CONTEXT))
          : _ === !0 && E?.spanContext().isRemote
            ? (p = E)
            : (p = this.tracer.startSpan(f, d, u)),
        this._spanNotEnded.add(p),
        p
      );
    }
    _closeHttpSpan(f, d, u, _, p) {
      if (!this._spanNotEnded.has(f)) return;
      (f.end(), this._spanNotEnded.delete(f));
      const E = (0, t.hrTimeToMilliseconds)(
        (0, t.hrTimeDuration)(u, (0, t.hrTime)()),
      );
      d === e.SpanKind.SERVER
        ? this._recordServerDuration(E, _, p)
        : d === e.SpanKind.CLIENT && this._recordClientDuration(E, _, p);
    }
    _callResponseHook(f, d) {
      (0, o.safeExecuteInTheMiddle)(
        () => this.getConfig().responseHook(f, d),
        () => {},
        !0,
      );
    }
    _callRequestHook(f, d) {
      (0, o.safeExecuteInTheMiddle)(
        () => this.getConfig().requestHook(f, d),
        () => {},
        !0,
      );
    }
    _callStartSpanHook(f, d) {
      if (typeof d == "function")
        return (0, o.safeExecuteInTheMiddle)(
          () => d(f),
          () => {},
          !0,
        );
    }
    _createHeaderCapture() {
      const f = this.getConfig();
      return {
        client: {
          captureRequestHeaders: (0, a.headerCapture)(
            "request",
            f.headersToSpanAttributes?.client?.requestHeaders ?? [],
          ),
          captureResponseHeaders: (0, a.headerCapture)(
            "response",
            f.headersToSpanAttributes?.client?.responseHeaders ?? [],
          ),
        },
        server: {
          captureRequestHeaders: (0, a.headerCapture)(
            "request",
            f.headersToSpanAttributes?.server?.requestHeaders ?? [],
          ),
          captureResponseHeaders: (0, a.headerCapture)(
            "response",
            f.headersToSpanAttributes?.server?.responseHeaders ?? [],
          ),
        },
      };
    }
  }
  return ((zi.HttpInstrumentation = c), zi);
}
var VA;
function $U() {
  return (
    VA ||
      ((VA = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.HttpInstrumentation = void 0));
        var t = xU();
        Object.defineProperty(e, "HttpInstrumentation", {
          enumerable: !0,
          get: function () {
            return t.HttpInstrumentation;
          },
        });
      })(nd)),
    nd
  );
}
var BU = $U();
const le = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__,
  ye = globalThis,
  Ze = "10.29.0";
function Fn() {
  return (hc(ye), ye);
}
function hc(e) {
  const t = (e.__SENTRY__ = e.__SENTRY__ || {});
  return ((t.version = t.version || Ze), (t[Ze] = t[Ze] || {}));
}
function Zo(e, t, n = ye) {
  const r = (n.__SENTRY__ = n.__SENTRY__ || {}),
    o = (r[Ze] = r[Ze] || {});
  return o[e] || (o[e] = t());
}
const PI = ["debug", "info", "warn", "error", "log", "assert", "trace"],
  HU = "Sentry Logger ",
  _u = {};
function on(e) {
  if (!("console" in ye)) return e();
  const t = ye.console,
    n = {},
    r = Object.keys(_u);
  r.forEach((o) => {
    const s = _u[o];
    ((n[o] = t[o]), (t[o] = s));
  });
  try {
    return e();
  } finally {
    r.forEach((o) => {
      t[o] = n[o];
    });
  }
}
function FU() {
  uE().enabled = !0;
}
function YU() {
  uE().enabled = !1;
}
function MI() {
  return uE().enabled;
}
function jU(...e) {
  cE("log", ...e);
}
function qU(...e) {
  cE("warn", ...e);
}
function WU(...e) {
  cE("error", ...e);
}
function cE(e, ...t) {
  le &&
    MI() &&
    on(() => {
      ye.console[e](`${HU}[${e}]:`, ...t);
    });
}
function uE() {
  return le
    ? Zo("loggerSettings", () => ({
        enabled: !1,
      }))
    : {
        enabled: !1,
      };
}
const $ = {
    enable: FU,
    disable: YU,
    isEnabled: MI,
    log: jU,
    warn: qU,
    error: WU,
  },
  vI = 50,
  LI = "?",
  xA = /\(error: (.*)\)/,
  $A = /captureMessage|captureException/;
function DI(...e) {
  const t = e.sort((n, r) => n[0] - r[0]).map((n) => n[1]);
  return (n, r = 0, o = 0) => {
    const s = [],
      i = n.split(`
`);
    for (let a = r; a < i.length; a++) {
      let c = i[a];
      c.length > 1024 && (c = c.slice(0, 1024));
      const l = xA.test(c) ? c.replace(xA, "$1") : c;
      if (!l.match(/\S*Error: /)) {
        for (const f of t) {
          const d = f(l);
          if (d) {
            s.push(d);
            break;
          }
        }
        if (s.length >= vI + o) break;
      }
    }
    return zU(s.slice(o));
  };
}
function KU(e) {
  return Array.isArray(e) ? DI(...e) : e;
}
function zU(e) {
  if (!e.length) return [];
  const t = Array.from(e);
  return (
    /sentryWrapped/.test(Pc(t).function || "") && t.pop(),
    t.reverse(),
    $A.test(Pc(t).function || "") &&
      (t.pop(), $A.test(Pc(t).function || "") && t.pop()),
    t.slice(0, vI).map((n) => ({
      ...n,
      filename: n.filename || Pc(t).filename,
      function: n.function || LI,
    }))
  );
}
function Pc(e) {
  return e[e.length - 1] || {};
}
const Td = "<anonymous>";
function wI(e) {
  try {
    return !e || typeof e != "function" ? Td : e.name || Td;
  } catch {
    return Td;
  }
}
function UI(e) {
  return "__v_isVNode" in e && e.__v_isVNode ? "[VueVNode]" : "[VueViewModel]";
}
const eu = {},
  BA = {};
function lE(e, t) {
  ((eu[e] = eu[e] || []), eu[e].push(t));
}
function dE(e, t) {
  if (!BA[e]) {
    BA[e] = !0;
    try {
      t();
    } catch (n) {
      le && $.error(`Error while instrumenting ${e}`, n);
    }
  }
}
function fE(e, t) {
  const n = e && eu[e];
  if (n)
    for (const r of n)
      try {
        r(t);
      } catch (o) {
        le &&
          $.error(
            `Error while triggering instrumentation handler.
Type: ${e}
Name: ${wI(r)}
Error:`,
            o,
          );
      }
}
let Sd = null;
function ZU(e) {
  const t = "error";
  (lE(t, e), dE(t, XU));
}
function XU() {
  ((Sd = ye.onerror),
    (ye.onerror = function (e, t, n, r, o) {
      return (
        fE("error", {
          column: r,
          error: o,
          line: n,
          msg: e,
          url: t,
        }),
        Sd ? Sd.apply(this, arguments) : !1
      );
    }),
    (ye.onerror.__SENTRY_INSTRUMENTED__ = !0));
}
let md = null;
function QU(e) {
  const t = "unhandledrejection";
  (lE(t, e), dE(t, JU));
}
function JU() {
  ((md = ye.onunhandledrejection),
    (ye.onunhandledrejection = function (e) {
      return (fE("unhandledrejection", e), md ? md.apply(this, arguments) : !0);
    }),
    (ye.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0));
}
const kI = Object.prototype.toString;
function pu(e) {
  switch (kI.call(e)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
    case "[object WebAssembly.Exception]":
      return !0;
    default:
      return Xr(e, Error);
  }
}
function al(e, t) {
  return kI.call(e) === `[object ${t}]`;
}
function ek(e) {
  return al(e, "ErrorEvent");
}
function Eu(e) {
  return al(e, "String");
}
function _E(e) {
  return (
    typeof e == "object" &&
    e !== null &&
    "__sentry_template_string__" in e &&
    "__sentry_template_values__" in e
  );
}
function GI(e) {
  return (
    e === null || _E(e) || (typeof e != "object" && typeof e != "function")
  );
}
function nc(e) {
  return al(e, "Object");
}
function tk(e) {
  return typeof Event < "u" && Xr(e, Event);
}
function nk(e) {
  return typeof Element < "u" && Xr(e, Element);
}
function rk(e) {
  return al(e, "RegExp");
}
function tr(e) {
  return !!(e?.then && typeof e.then == "function");
}
function ok(e) {
  return (
    nc(e) &&
    "nativeEvent" in e &&
    "preventDefault" in e &&
    "stopPropagation" in e
  );
}
function Xr(e, t) {
  try {
    return e instanceof t;
  } catch {
    return !1;
  }
}
function VI(e) {
  return !!(
    typeof e == "object" &&
    e !== null &&
    (e.__isVue || e._isVue || e.__v_isVNode)
  );
}
const sk = ye,
  ik = 80;
function ak(e, t = {}) {
  if (!e) return "<unknown>";
  try {
    let n = e;
    const r = 5,
      o = [];
    let s = 0,
      i = 0;
    const a = " > ",
      c = a.length;
    let l;
    const f = Array.isArray(t) ? t : t.keyAttrs,
      d = (!Array.isArray(t) && t.maxStringLength) || ik;
    for (
      ;
      n &&
      s++ < r &&
      ((l = ck(n, f)),
      !(l === "html" || (s > 1 && i + o.length * c + l.length >= d)));
    )
      (o.push(l), (i += l.length), (n = n.parentNode));
    return o.reverse().join(a);
  } catch {
    return "<unknown>";
  }
}
function ck(e, t) {
  const n = e,
    r = [];
  if (!n?.tagName) return "";
  if (sk.HTMLElement && n instanceof HTMLElement && n.dataset) {
    if (n.dataset.sentryComponent) return n.dataset.sentryComponent;
    if (n.dataset.sentryElement) return n.dataset.sentryElement;
  }
  r.push(n.tagName.toLowerCase());
  const o = t?.length
    ? t.filter((i) => n.getAttribute(i)).map((i) => [i, n.getAttribute(i)])
    : null;
  if (o?.length)
    o.forEach((i) => {
      r.push(`[${i[0]}="${i[1]}"]`);
    });
  else {
    n.id && r.push(`#${n.id}`);
    const i = n.className;
    if (i && Eu(i)) {
      const a = i.split(/\s+/);
      for (const c of a) r.push(`.${c}`);
    }
  }
  const s = ["aria-label", "type", "name", "title", "alt"];
  for (const i of s) {
    const a = n.getAttribute(i);
    a && r.push(`[${i}="${a}"]`);
  }
  return r.join("");
}
function uk(e, t, n) {
  if (!(t in e)) return;
  const r = e[t];
  if (typeof r != "function") return;
  const o = n(r);
  typeof o == "function" && lk(o, r);
  try {
    e[t] = o;
  } catch {
    le && $.log(`Failed to replace method "${t}" in object`, e);
  }
}
function sn(e, t, n) {
  try {
    Object.defineProperty(e, t, {
      value: n,
      writable: !0,
      configurable: !0,
    });
  } catch {
    le && $.log(`Failed to add non-enumerable property "${t}" to object`, e);
  }
}
function lk(e, t) {
  try {
    const n = t.prototype || {};
    ((e.prototype = t.prototype = n), sn(e, "__sentry_original__", t));
  } catch {}
}
function dk(e) {
  return e.__sentry_original__;
}
function xI(e) {
  if (pu(e))
    return {
      message: e.message,
      name: e.name,
      stack: e.stack,
      ...FA(e),
    };
  if (tk(e)) {
    const t = {
      type: e.type,
      target: HA(e.target),
      currentTarget: HA(e.currentTarget),
      ...FA(e),
    };
    return (
      typeof CustomEvent < "u" && Xr(e, CustomEvent) && (t.detail = e.detail),
      t
    );
  } else return e;
}
function HA(e) {
  try {
    return nk(e) ? ak(e) : Object.prototype.toString.call(e);
  } catch {
    return "<unknown>";
  }
}
function FA(e) {
  if (typeof e == "object" && e !== null) {
    const t = {};
    for (const n in e)
      Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
    return t;
  } else return {};
}
function fk(e) {
  const t = Object.keys(xI(e));
  return (t.sort(), t[0] ? t.join(", ") : "[object has no keys]");
}
function hu(e, t = 0) {
  return typeof e != "string" || t === 0 || e.length <= t
    ? e
    : `${e.slice(0, t)}...`;
}
function _k(e, t) {
  let n = e;
  const r = n.length;
  if (r <= 150) return n;
  t > r && (t = r);
  let o = Math.max(t - 60, 0);
  o < 5 && (o = 0);
  let s = Math.min(o + 140, r);
  return (
    s > r - 5 && (s = r),
    s === r && (o = Math.max(s - 140, 0)),
    (n = n.slice(o, s)),
    o > 0 && (n = `'{snip} ${n}`),
    s < r && (n += " {snip}"),
    n
  );
}
function pk(e, t) {
  if (!Array.isArray(e)) return "";
  const n = [];
  for (let r = 0; r < e.length; r++) {
    const o = e[r];
    try {
      VI(o) ? n.push(UI(o)) : n.push(String(o));
    } catch {
      n.push("[value cannot be serialized]");
    }
  }
  return n.join(t);
}
function vo(e, t, n = !1) {
  return Eu(e)
    ? rk(t)
      ? t.test(e)
      : Eu(t)
        ? n
          ? e === t
          : e.includes(t)
        : !1
    : !1;
}
function Tc(e, t = [], n = !1) {
  return t.some((r) => vo(e, r, n));
}
function Ek() {
  const e = ye;
  return e.crypto || e.msCrypto;
}
let Ad;
function hk() {
  return Math.random() * 16;
}
function Ft(e = Ek()) {
  try {
    if (e?.randomUUID) return e.randomUUID().replace(/-/g, "");
  } catch {}
  return (
    Ad || (Ad = "10000000100040008000" + 1e11),
    Ad.replace(/[018]/g, (t) => (t ^ ((hk() & 15) >> (t / 4))).toString(16))
  );
}
function $I(e) {
  return e.exception?.values?.[0];
}
function go(e) {
  const { message: t, event_id: n } = e;
  if (t) return t;
  const r = $I(e);
  return r
    ? r.type && r.value
      ? `${r.type}: ${r.value}`
      : r.type || r.value || n || "<unknown>"
    : n || "<unknown>";
}
function Tk(e, t, n) {
  const r = (e.exception = e.exception || {}),
    o = (r.values = r.values || []),
    s = (o[0] = o[0] || {});
  (s.value || (s.value = ""), s.type || (s.type = "Error"));
}
function pE(e, t) {
  const n = $I(e);
  if (!n) return;
  const r = {
      type: "generic",
      handled: !0,
    },
    o = n.mechanism;
  if (
    ((n.mechanism = {
      ...r,
      ...o,
      ...t,
    }),
    t && "data" in t)
  ) {
    const s = {
      ...o?.data,
      ...t.data,
    };
    n.mechanism.data = s;
  }
}
const Sk =
  /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
function gd(e) {
  return parseInt(e || "", 10);
}
function mk(e) {
  const t = e.match(Sk) || [],
    n = gd(t[1]),
    r = gd(t[2]),
    o = gd(t[3]);
  return {
    buildmetadata: t[5],
    major: isNaN(n) ? void 0 : n,
    minor: isNaN(r) ? void 0 : r,
    patch: isNaN(o) ? void 0 : o,
    prerelease: t[4],
  };
}
function YA(e) {
  if (Ak(e)) return !0;
  try {
    sn(e, "__sentry_captured__", !0);
  } catch {}
  return !1;
}
function Ak(e) {
  try {
    return e.__sentry_captured__;
  } catch {}
}
const BI = 1e3;
function Sc() {
  return Date.now() / BI;
}
function gk() {
  const { performance: e } = ye;
  if (!e?.now || !e.timeOrigin) return Sc;
  const t = e.timeOrigin;
  return () => (t + e.now()) / BI;
}
let jA;
function rc() {
  return (jA ?? (jA = gk()))();
}
function Rk(e) {
  const t = rc(),
    n = {
      sid: Ft(),
      init: !0,
      timestamp: t,
      started: t,
      duration: 0,
      status: "ok",
      errors: 0,
      ignoreDuration: !1,
      toJSON: () => yk(n),
    };
  return (e && Uo(n, e), n);
}
function Uo(e, t = {}) {
  if (
    (t.user &&
      (!e.ipAddress && t.user.ip_address && (e.ipAddress = t.user.ip_address),
      !e.did &&
        !t.did &&
        (e.did = t.user.id || t.user.email || t.user.username)),
    (e.timestamp = t.timestamp || rc()),
    t.abnormal_mechanism && (e.abnormal_mechanism = t.abnormal_mechanism),
    t.ignoreDuration && (e.ignoreDuration = t.ignoreDuration),
    t.sid && (e.sid = t.sid.length === 32 ? t.sid : Ft()),
    t.init !== void 0 && (e.init = t.init),
    !e.did && t.did && (e.did = `${t.did}`),
    typeof t.started == "number" && (e.started = t.started),
    e.ignoreDuration)
  )
    e.duration = void 0;
  else if (typeof t.duration == "number") e.duration = t.duration;
  else {
    const n = e.timestamp - e.started;
    e.duration = n >= 0 ? n : 0;
  }
  (t.release && (e.release = t.release),
    t.environment && (e.environment = t.environment),
    !e.ipAddress && t.ipAddress && (e.ipAddress = t.ipAddress),
    !e.userAgent && t.userAgent && (e.userAgent = t.userAgent),
    typeof t.errors == "number" && (e.errors = t.errors),
    t.status && (e.status = t.status));
}
function Nk(e, t) {
  let n = {};
  (e.status === "ok" &&
    (n = {
      status: "exited",
    }),
    Uo(e, n));
}
function yk(e) {
  return {
    sid: `${e.sid}`,
    init: e.init,
    started: new Date(e.started * 1e3).toISOString(),
    timestamp: new Date(e.timestamp * 1e3).toISOString(),
    status: e.status,
    errors: e.errors,
    did:
      typeof e.did == "number" || typeof e.did == "string"
        ? `${e.did}`
        : void 0,
    duration: e.duration,
    abnormal_mechanism: e.abnormal_mechanism,
    attrs: {
      release: e.release,
      environment: e.environment,
      ip_address: e.ipAddress,
      user_agent: e.userAgent,
    },
  };
}
function mc(e, t, n = 2) {
  if (!t || typeof t != "object" || n <= 0) return t;
  if (e && Object.keys(t).length === 0) return e;
  const r = {
    ...e,
  };
  for (const o in t)
    Object.prototype.hasOwnProperty.call(t, o) &&
      (r[o] = mc(r[o], t[o], n - 1));
  return r;
}
function Qr() {
  return Ft();
}
function ao() {
  return Ft().substring(16);
}
const up = "_sentrySpan";
function oc(e, t) {
  t ? sn(e, up, t) : delete e[up];
}
function Tu(e) {
  return e[up];
}
const Ok = 100;
class mn {
  constructor() {
    ((this._notifyingListeners = !1),
      (this._scopeListeners = []),
      (this._eventProcessors = []),
      (this._breadcrumbs = []),
      (this._attachments = []),
      (this._user = {}),
      (this._tags = {}),
      (this._attributes = {}),
      (this._extra = {}),
      (this._contexts = {}),
      (this._sdkProcessingMetadata = {}),
      (this._propagationContext = {
        traceId: Qr(),
        sampleRand: Math.random(),
      }));
  }
  clone() {
    const t = new mn();
    return (
      (t._breadcrumbs = [...this._breadcrumbs]),
      (t._tags = {
        ...this._tags,
      }),
      (t._attributes = {
        ...this._attributes,
      }),
      (t._extra = {
        ...this._extra,
      }),
      (t._contexts = {
        ...this._contexts,
      }),
      this._contexts.flags &&
        (t._contexts.flags = {
          values: [...this._contexts.flags.values],
        }),
      (t._user = this._user),
      (t._level = this._level),
      (t._session = this._session),
      (t._transactionName = this._transactionName),
      (t._fingerprint = this._fingerprint),
      (t._eventProcessors = [...this._eventProcessors]),
      (t._attachments = [...this._attachments]),
      (t._sdkProcessingMetadata = {
        ...this._sdkProcessingMetadata,
      }),
      (t._propagationContext = {
        ...this._propagationContext,
      }),
      (t._client = this._client),
      (t._lastEventId = this._lastEventId),
      oc(t, Tu(this)),
      t
    );
  }
  setClient(t) {
    this._client = t;
  }
  setLastEventId(t) {
    this._lastEventId = t;
  }
  getClient() {
    return this._client;
  }
  lastEventId() {
    return this._lastEventId;
  }
  addScopeListener(t) {
    this._scopeListeners.push(t);
  }
  addEventProcessor(t) {
    return (this._eventProcessors.push(t), this);
  }
  setUser(t) {
    return (
      (this._user = t || {
        email: void 0,
        id: void 0,
        ip_address: void 0,
        username: void 0,
      }),
      this._session &&
        Uo(this._session, {
          user: t,
        }),
      this._notifyScopeListeners(),
      this
    );
  }
  getUser() {
    return this._user;
  }
  setTags(t) {
    return (
      (this._tags = {
        ...this._tags,
        ...t,
      }),
      this._notifyScopeListeners(),
      this
    );
  }
  setTag(t, n) {
    return this.setTags({
      [t]: n,
    });
  }
  setAttributes(t) {
    return (
      (this._attributes = {
        ...this._attributes,
        ...t,
      }),
      this._notifyScopeListeners(),
      this
    );
  }
  setAttribute(t, n) {
    return this.setAttributes({
      [t]: n,
    });
  }
  removeAttribute(t) {
    return (
      t in this._attributes &&
        (delete this._attributes[t], this._notifyScopeListeners()),
      this
    );
  }
  setExtras(t) {
    return (
      (this._extra = {
        ...this._extra,
        ...t,
      }),
      this._notifyScopeListeners(),
      this
    );
  }
  setExtra(t, n) {
    return (
      (this._extra = {
        ...this._extra,
        [t]: n,
      }),
      this._notifyScopeListeners(),
      this
    );
  }
  setFingerprint(t) {
    return ((this._fingerprint = t), this._notifyScopeListeners(), this);
  }
  setLevel(t) {
    return ((this._level = t), this._notifyScopeListeners(), this);
  }
  setTransactionName(t) {
    return ((this._transactionName = t), this._notifyScopeListeners(), this);
  }
  setContext(t, n) {
    return (
      n === null ? delete this._contexts[t] : (this._contexts[t] = n),
      this._notifyScopeListeners(),
      this
    );
  }
  setSession(t) {
    return (
      t ? (this._session = t) : delete this._session,
      this._notifyScopeListeners(),
      this
    );
  }
  getSession() {
    return this._session;
  }
  update(t) {
    if (!t) return this;
    const n = typeof t == "function" ? t(this) : t,
      r = n instanceof mn ? n.getScopeData() : nc(n) ? t : void 0,
      {
        tags: o,
        attributes: s,
        extra: i,
        user: a,
        contexts: c,
        level: l,
        fingerprint: f = [],
        propagationContext: d,
      } = r || {};
    return (
      (this._tags = {
        ...this._tags,
        ...o,
      }),
      (this._attributes = {
        ...this._attributes,
        ...s,
      }),
      (this._extra = {
        ...this._extra,
        ...i,
      }),
      (this._contexts = {
        ...this._contexts,
        ...c,
      }),
      a && Object.keys(a).length && (this._user = a),
      l && (this._level = l),
      f.length && (this._fingerprint = f),
      d && (this._propagationContext = d),
      this
    );
  }
  clear() {
    return (
      (this._breadcrumbs = []),
      (this._tags = {}),
      (this._attributes = {}),
      (this._extra = {}),
      (this._user = {}),
      (this._contexts = {}),
      (this._level = void 0),
      (this._transactionName = void 0),
      (this._fingerprint = void 0),
      (this._session = void 0),
      oc(this, void 0),
      (this._attachments = []),
      this.setPropagationContext({
        traceId: Qr(),
        sampleRand: Math.random(),
      }),
      this._notifyScopeListeners(),
      this
    );
  }
  addBreadcrumb(t, n) {
    const r = typeof n == "number" ? n : Ok;
    if (r <= 0) return this;
    const o = {
      timestamp: Sc(),
      ...t,
      message: t.message ? hu(t.message, 2048) : t.message,
    };
    return (
      this._breadcrumbs.push(o),
      this._breadcrumbs.length > r &&
        ((this._breadcrumbs = this._breadcrumbs.slice(-r)),
        this._client?.recordDroppedEvent("buffer_overflow", "log_item")),
      this._notifyScopeListeners(),
      this
    );
  }
  getLastBreadcrumb() {
    return this._breadcrumbs[this._breadcrumbs.length - 1];
  }
  clearBreadcrumbs() {
    return ((this._breadcrumbs = []), this._notifyScopeListeners(), this);
  }
  addAttachment(t) {
    return (this._attachments.push(t), this);
  }
  clearAttachments() {
    return ((this._attachments = []), this);
  }
  getScopeData() {
    return {
      breadcrumbs: this._breadcrumbs,
      attachments: this._attachments,
      contexts: this._contexts,
      tags: this._tags,
      attributes: this._attributes,
      extra: this._extra,
      user: this._user,
      level: this._level,
      fingerprint: this._fingerprint || [],
      eventProcessors: this._eventProcessors,
      propagationContext: this._propagationContext,
      sdkProcessingMetadata: this._sdkProcessingMetadata,
      transactionName: this._transactionName,
      span: Tu(this),
    };
  }
  setSDKProcessingMetadata(t) {
    return (
      (this._sdkProcessingMetadata = mc(this._sdkProcessingMetadata, t, 2)),
      this
    );
  }
  setPropagationContext(t) {
    return ((this._propagationContext = t), this);
  }
  getPropagationContext() {
    return this._propagationContext;
  }
  captureException(t, n) {
    const r = n?.event_id || Ft();
    if (!this._client)
      return (
        le &&
          $.warn("No client configured on scope - will not capture exception!"),
        r
      );
    const o = new Error("Sentry syntheticException");
    return (
      this._client.captureException(
        t,
        {
          originalException: t,
          syntheticException: o,
          ...n,
          event_id: r,
        },
        this,
      ),
      r
    );
  }
  captureMessage(t, n, r) {
    const o = r?.event_id || Ft();
    if (!this._client)
      return (
        le &&
          $.warn("No client configured on scope - will not capture message!"),
        o
      );
    const s = r?.syntheticException ?? new Error(t);
    return (
      this._client.captureMessage(
        t,
        n,
        {
          originalException: t,
          syntheticException: s,
          ...r,
          event_id: o,
        },
        this,
      ),
      o
    );
  }
  captureEvent(t, n) {
    const r = n?.event_id || Ft();
    return this._client
      ? (this._client.captureEvent(
          t,
          {
            ...n,
            event_id: r,
          },
          this,
        ),
        r)
      : (le &&
          $.warn("No client configured on scope - will not capture event!"),
        r);
  }
  _notifyScopeListeners() {
    this._notifyingListeners ||
      ((this._notifyingListeners = !0),
      this._scopeListeners.forEach((t) => {
        t(this);
      }),
      (this._notifyingListeners = !1));
  }
}
function EE() {
  return Zo("defaultCurrentScope", () => new mn());
}
function Xo() {
  return Zo("defaultIsolationScope", () => new mn());
}
class Ck {
  constructor(t, n) {
    let r;
    t ? (r = t) : (r = new mn());
    let o;
    (n ? (o = n) : (o = new mn()),
      (this._stack = [
        {
          scope: r,
        },
      ]),
      (this._isolationScope = o));
  }
  withScope(t) {
    const n = this._pushScope();
    let r;
    try {
      r = t(n);
    } catch (o) {
      throw (this._popScope(), o);
    }
    return tr(r)
      ? r.then(
          (o) => (this._popScope(), o),
          (o) => {
            throw (this._popScope(), o);
          },
        )
      : (this._popScope(), r);
  }
  getClient() {
    return this.getStackTop().client;
  }
  getScope() {
    return this.getStackTop().scope;
  }
  getIsolationScope() {
    return this._isolationScope;
  }
  getStackTop() {
    return this._stack[this._stack.length - 1];
  }
  _pushScope() {
    const t = this.getScope().clone();
    return (
      this._stack.push({
        client: this.getClient(),
        scope: t,
      }),
      t
    );
  }
  _popScope() {
    return this._stack.length <= 1 ? !1 : !!this._stack.pop();
  }
}
function ko() {
  const e = Fn(),
    t = hc(e);
  return (t.stack = t.stack || new Ck(EE(), Xo()));
}
function bk(e) {
  return ko().withScope(e);
}
function Ik(e, t) {
  const n = ko();
  return n.withScope(() => ((n.getStackTop().scope = e), t(e)));
}
function qA(e) {
  return ko().withScope(() => e(ko().getIsolationScope()));
}
function Pk() {
  return {
    withIsolationScope: qA,
    withScope: bk,
    withSetScope: Ik,
    withSetIsolationScope: (e, t) => qA(t),
    getCurrentScope: () => ko().getScope(),
    getIsolationScope: () => ko().getIsolationScope(),
  };
}
function Mk(e) {
  const t = Fn(),
    n = hc(t);
  n.acs = e;
}
function co(e) {
  const t = hc(e);
  return t.acs ? t.acs : Pk();
}
function Ke() {
  const e = Fn();
  return co(e).getCurrentScope();
}
function je() {
  const e = Fn();
  return co(e).getIsolationScope();
}
function vk() {
  return Zo("globalScope", () => new mn());
}
function Jr(...e) {
  const t = Fn(),
    n = co(t);
  if (e.length === 2) {
    const [r, o] = e;
    return r ? n.withSetScope(r, o) : n.withScope(o);
  }
  return n.withScope(e[0]);
}
function Lk(...e) {
  const t = Fn(),
    n = co(t);
  if (e.length === 2) {
    const [r, o] = e;
    return r ? n.withSetIsolationScope(r, o) : n.withIsolationScope(o);
  }
  return n.withIsolationScope(e[0]);
}
function he() {
  return Ke().getClient();
}
function hE(e) {
  const t = e.getPropagationContext(),
    { traceId: n, parentSpanId: r, propagationSpanId: o } = t,
    s = {
      trace_id: n,
      span_id: o || ao(),
    };
  return (r && (s.parent_span_id = r), s);
}
const Kt = "sentry.source",
  Go = "sentry.sample_rate",
  Dk = "sentry.previous_trace_sample_rate",
  Ee = "sentry.op",
  Ge = "sentry.origin",
  wk = "sentry.measurement_unit",
  Uk = "sentry.measurement_value",
  Vo = "sentry.custom_span_name",
  TE = "sentry.profile_id",
  SE = "sentry.exclusive_time",
  kk = "cache.hit",
  Gk = "cache.key",
  Vk = "cache.item_size",
  xk = 0,
  Su = 1,
  Ae = 2;
function lp(e) {
  if (e < 400 && e >= 100)
    return {
      code: Su,
    };
  if (e >= 400 && e < 500)
    switch (e) {
      case 401:
        return {
          code: Ae,
          message: "unauthenticated",
        };
      case 403:
        return {
          code: Ae,
          message: "permission_denied",
        };
      case 404:
        return {
          code: Ae,
          message: "not_found",
        };
      case 409:
        return {
          code: Ae,
          message: "already_exists",
        };
      case 413:
        return {
          code: Ae,
          message: "failed_precondition",
        };
      case 429:
        return {
          code: Ae,
          message: "resource_exhausted",
        };
      case 499:
        return {
          code: Ae,
          message: "cancelled",
        };
      default:
        return {
          code: Ae,
          message: "invalid_argument",
        };
    }
  if (e >= 500 && e < 600)
    switch (e) {
      case 501:
        return {
          code: Ae,
          message: "unimplemented",
        };
      case 503:
        return {
          code: Ae,
          message: "unavailable",
        };
      case 504:
        return {
          code: Ae,
          message: "deadline_exceeded",
        };
      default:
        return {
          code: Ae,
          message: "internal_error",
        };
    }
  return {
    code: Ae,
    message: "internal_error",
  };
}
const HI = "_sentryScope",
  FI = "_sentryIsolationScope";
function $k(e) {
  try {
    const t = ye.WeakRef;
    if (typeof t == "function") return new t(e);
  } catch {}
  return e;
}
function Bk(e) {
  if (e) {
    if (typeof e == "object" && "deref" in e && typeof e.deref == "function")
      try {
        return e.deref();
      } catch {
        return;
      }
    return e;
  }
}
function YI(e, t, n) {
  e && (sn(e, FI, $k(n)), sn(e, HI, t));
}
function xo(e) {
  const t = e;
  return {
    scope: t[HI],
    isolationScope: Bk(t[FI]),
  };
}
const mE = "sentry-",
  Hk = /^sentry-/,
  Fk = 8192;
function Ac(e) {
  const t = mu(e);
  if (!t) return;
  const n = Object.entries(t).reduce((r, [o, s]) => {
    if (o.match(Hk)) {
      const i = o.slice(mE.length);
      r[i] = s;
    }
    return r;
  }, {});
  if (Object.keys(n).length > 0) return n;
}
function AE(e) {
  if (!e) return;
  const t = Object.entries(e).reduce(
    (n, [r, o]) => (o && (n[`${mE}${r}`] = o), n),
    {},
  );
  return jI(t);
}
function mu(e) {
  if (!(!e || (!Eu(e) && !Array.isArray(e))))
    return Array.isArray(e)
      ? e.reduce((t, n) => {
          const r = WA(n);
          return (
            Object.entries(r).forEach(([o, s]) => {
              t[o] = s;
            }),
            t
          );
        }, {})
      : WA(e);
}
function WA(e) {
  return e
    .split(",")
    .map((t) => {
      const n = t.indexOf("=");
      if (n === -1) return [];
      const r = t.slice(0, n),
        o = t.slice(n + 1);
      return [r, o].map((s) => {
        try {
          return decodeURIComponent(s.trim());
        } catch {
          return;
        }
      });
    })
    .reduce((t, [n, r]) => (n && r && (t[n] = r), t), {});
}
function jI(e) {
  if (Object.keys(e).length !== 0)
    return Object.entries(e).reduce((t, [n, r], o) => {
      const s = `${encodeURIComponent(n)}=${encodeURIComponent(r)}`,
        i = o === 0 ? s : `${t},${s}`;
      return i.length > Fk
        ? (le &&
            $.warn(
              `Not adding key: ${n} with val: ${r} to baggage header due to exceeding baggage size limits.`,
            ),
          t)
        : i;
    }, "");
}
const Yk = /^o(\d+)\./,
  jk = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function qk(e) {
  return e === "http" || e === "https";
}
function uo(e, t = !1) {
  const {
    host: n,
    path: r,
    pass: o,
    port: s,
    projectId: i,
    protocol: a,
    publicKey: c,
  } = e;
  return `${a}://${c}${t && o ? `:${o}` : ""}@${n}${s ? `:${s}` : ""}/${r && `${r}/`}${i}`;
}
function Wk(e) {
  const t = jk.exec(e);
  if (!t) {
    on(() => {
      console.error(`Invalid Sentry Dsn: ${e}`);
    });
    return;
  }
  const [n, r, o = "", s = "", i = "", a = ""] = t.slice(1);
  let c = "",
    l = a;
  const f = l.split("/");
  if ((f.length > 1 && ((c = f.slice(0, -1).join("/")), (l = f.pop())), l)) {
    const d = l.match(/^\d+/);
    d && (l = d[0]);
  }
  return qI({
    host: s,
    pass: o,
    path: c,
    projectId: l,
    port: i,
    protocol: n,
    publicKey: r,
  });
}
function qI(e) {
  return {
    protocol: e.protocol,
    publicKey: e.publicKey || "",
    pass: e.pass || "",
    host: e.host,
    port: e.port || "",
    path: e.path || "",
    projectId: e.projectId,
  };
}
function Kk(e) {
  if (!le) return !0;
  const { port: t, projectId: n, protocol: r } = e;
  return ["protocol", "publicKey", "host", "projectId"].find((i) =>
    e[i] ? !1 : ($.error(`Invalid Sentry Dsn: ${i} missing`), !0),
  )
    ? !1
    : n.match(/^\d+$/)
      ? qk(r)
        ? t && isNaN(parseInt(t, 10))
          ? ($.error(`Invalid Sentry Dsn: Invalid port ${t}`), !1)
          : !0
        : ($.error(`Invalid Sentry Dsn: Invalid protocol ${r}`), !1)
      : ($.error(`Invalid Sentry Dsn: Invalid projectId ${n}`), !1);
}
function zk(e) {
  return e.match(Yk)?.[1];
}
function WI(e) {
  const t = e.getOptions(),
    { host: n } = e.getDsn() || {};
  let r;
  return (t.orgId ? (r = String(t.orgId)) : n && (r = zk(n)), r);
}
function Zk(e) {
  const t = typeof e == "string" ? Wk(e) : qI(e);
  if (!(!t || !Kk(t))) return t;
}
function eo(e) {
  if (typeof e == "boolean") return Number(e);
  const t = typeof e == "string" ? parseFloat(e) : e;
  if (!(typeof t != "number" || isNaN(t) || t < 0 || t > 1)) return t;
}
const KI = new RegExp(
  "^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$",
);
function Xk(e) {
  if (!e) return;
  const t = e.match(KI);
  if (!t) return;
  let n;
  return (
    t[3] === "1" ? (n = !0) : t[3] === "0" && (n = !1),
    {
      traceId: t[1],
      parentSampled: n,
      parentSpanId: t[2],
    }
  );
}
function zI(e, t) {
  const n = Xk(e),
    r = Ac(t);
  if (!n?.traceId)
    return {
      traceId: Qr(),
      sampleRand: Math.random(),
    };
  const o = Qk(n, r);
  r && (r.sample_rand = o.toString());
  const { traceId: s, parentSpanId: i, parentSampled: a } = n;
  return {
    traceId: s,
    parentSpanId: i,
    sampled: a,
    dsc: r || {},
    sampleRand: o,
  };
}
function cl(e = Qr(), t = ao(), n) {
  let r = "";
  return (n !== void 0 && (r = n ? "-1" : "-0"), `${e}-${t}${r}`);
}
function ZI(e = Qr(), t = ao(), n) {
  return `00-${e}-${t}-${n ? "01" : "00"}`;
}
function Qk(e, t) {
  const n = eo(t?.sample_rand);
  if (n !== void 0) return n;
  const r = eo(t?.sample_rate);
  return r && e?.parentSampled !== void 0
    ? e.parentSampled
      ? Math.random() * r
      : r + Math.random() * (1 - r)
    : Math.random();
}
function Jk(e, t) {
  const n = WI(e);
  return t && n && t !== n
    ? ($.log(
        `Won't continue trace because org IDs don't match (incoming baggage: ${t}, SDK options: ${n})`,
      ),
      !1)
    : (e.getOptions().strictTraceContinuation || !1) && ((t && !n) || (!t && n))
      ? ($.log(
          `Starting a new trace because strict trace continuation is enabled but one org ID is missing (incoming baggage: ${t}, Sentry client: ${n})`,
        ),
        !1)
      : !0;
}
const XI = 0,
  gE = 1;
let KA = !1;
function e1(e) {
  const { spanId: t, traceId: n } = e.spanContext(),
    {
      data: r,
      op: o,
      parent_span_id: s,
      status: i,
      origin: a,
      links: c,
    } = Re(e);
  return {
    parent_span_id: s,
    span_id: t,
    trace_id: n,
    data: r,
    op: o,
    status: i,
    origin: a,
    links: c,
  };
}
function ul(e) {
  const { spanId: t, traceId: n, isRemote: r } = e.spanContext(),
    o = r ? t : Re(e).parent_span_id,
    s = xo(e).scope,
    i = r ? s?.getPropagationContext().propagationSpanId || ao() : t;
  return {
    parent_span_id: o,
    span_id: i,
    trace_id: n,
  };
}
function t1(e) {
  const { traceId: t, spanId: n } = e.spanContext(),
    r = lo(e);
  return cl(t, n, r);
}
function n1(e) {
  const { traceId: t, spanId: n } = e.spanContext(),
    r = lo(e);
  return ZI(t, n, r);
}
function ll(e) {
  if (e && e.length > 0)
    return e.map(
      ({
        context: { spanId: t, traceId: n, traceFlags: r, ...o },
        attributes: s,
      }) => ({
        span_id: t,
        trace_id: n,
        sampled: r === gE,
        attributes: s,
        ...o,
      }),
    );
}
function Sn(e) {
  return typeof e == "number"
    ? zA(e)
    : Array.isArray(e)
      ? e[0] + e[1] / 1e9
      : e instanceof Date
        ? zA(e.getTime())
        : rc();
}
function zA(e) {
  return e > 9999999999 ? e / 1e3 : e;
}
function Re(e) {
  if (o1(e)) return e.getSpanJSON();
  const { spanId: t, traceId: n } = e.spanContext();
  if (r1(e)) {
    const {
        attributes: r,
        startTime: o,
        name: s,
        endTime: i,
        status: a,
        links: c,
      } = e,
      l =
        "parentSpanId" in e
          ? e.parentSpanId
          : "parentSpanContext" in e
            ? e.parentSpanContext?.spanId
            : void 0;
    return {
      span_id: t,
      trace_id: n,
      data: r,
      description: s,
      parent_span_id: l,
      start_timestamp: Sn(o),
      timestamp: Sn(i) || void 0,
      status: dl(a),
      op: r[Ee],
      origin: r[Ge],
      links: ll(c),
    };
  }
  return {
    span_id: t,
    trace_id: n,
    start_timestamp: 0,
    data: {},
  };
}
function r1(e) {
  const t = e;
  return (
    !!t.attributes && !!t.startTime && !!t.name && !!t.endTime && !!t.status
  );
}
function o1(e) {
  return typeof e.getSpanJSON == "function";
}
function lo(e) {
  const { traceFlags: t } = e.spanContext();
  return t === gE;
}
function dl(e) {
  if (!(!e || e.code === xk))
    return e.code === Su ? "ok" : e.message || "internal_error";
}
const Wa = "_sentryChildSpans",
  dp = "_sentryRootSpan";
function RE(e, t) {
  const n = e[dp] || e;
  (sn(t, dp, n), e[Wa] ? e[Wa].add(t) : sn(e, Wa, new Set([t])));
}
function s1(e) {
  const t = new Set();
  function n(r) {
    if (!t.has(r) && lo(r)) {
      t.add(r);
      const o = r[Wa] ? Array.from(r[Wa]) : [];
      for (const s of o) n(s);
    }
  }
  return (n(e), Array.from(t));
}
function Yt(e) {
  return e[dp] || e;
}
function fl() {
  const e = Fn(),
    t = co(e);
  return t.getActiveSpan ? t.getActiveSpan() : Tu(Ke());
}
function fp() {
  KA ||
    (on(() => {
      console.warn(
        "[Sentry] Returning null from `beforeSendSpan` is disallowed. To drop certain spans, configure the respective integrations directly or use `ignoreSpans`.",
      );
    }),
    (KA = !0));
}
let ZA = !1;
function i1() {
  if (ZA) return;
  function e() {
    const t = fl(),
      n = t && Yt(t);
    if (n) {
      const r = "internal_error";
      (le && $.log(`[Tracing] Root span: ${r} -> Global error occurred`),
        n.setStatus({
          code: Ae,
          message: r,
        }));
    }
  }
  ((e.tag = "sentry_tracingErrorCallback"), (ZA = !0), ZU(e), QU(e));
}
function zt(e) {
  if (typeof __SENTRY_TRACING__ == "boolean" && !__SENTRY_TRACING__) return !1;
  const t = e || he()?.getOptions();
  return !!t && (t.tracesSampleRate != null || !!t.tracesSampler);
}
function XA(e) {
  $.log(
    `Ignoring span ${e.op} - ${e.description} because it matches \`ignoreSpans\`.`,
  );
}
function _p(e, t) {
  if (!t?.length || !e.description) return !1;
  for (const n of t) {
    if (c1(n)) {
      if (vo(e.description, n)) return (le && XA(e), !0);
      continue;
    }
    if (!n.name && !n.op) continue;
    const r = n.name ? vo(e.description, n.name) : !0,
      o = n.op ? e.op && vo(e.op, n.op) : !0;
    if (r && o) return (le && XA(e), !0);
  }
  return !1;
}
function a1(e, t) {
  const n = t.parent_span_id,
    r = t.span_id;
  if (n) for (const o of e) o.parent_span_id === r && (o.parent_span_id = n);
}
function c1(e) {
  return typeof e == "string" || e instanceof RegExp;
}
const NE = "production",
  QI = "_frozenDsc";
function Rd(e, t) {
  sn(e, QI, t);
}
function JI(e, t) {
  const n = t.getOptions(),
    { publicKey: r } = t.getDsn() || {},
    o = {
      environment: n.environment || NE,
      release: n.release,
      public_key: r,
      trace_id: e,
      org_id: WI(t),
    };
  return (t.emit("createDsc", o), o);
}
function gc(e, t) {
  const n = t.getPropagationContext();
  return n.dsc || JI(n.traceId, e);
}
function Vt(e) {
  const t = he();
  if (!t) return {};
  const n = Yt(e),
    r = Re(n),
    o = r.data,
    s = n.spanContext().traceState,
    i = s?.get("sentry.sample_rate") ?? o[Go] ?? o[Dk];
  function a(p) {
    return (
      (typeof i == "number" || typeof i == "string") &&
        (p.sample_rate = `${i}`),
      p
    );
  }
  const c = n[QI];
  if (c) return a(c);
  const l = s?.get("sentry.dsc"),
    f = l && Ac(l);
  if (f) return a(f);
  const d = JI(e.spanContext().traceId, t),
    u = o[Kt],
    _ = r.description;
  return (
    u !== "url" && _ && (d.transaction = _),
    zt() &&
      ((d.sampled = String(lo(n))),
      (d.sample_rand =
        s?.get("sentry.sample_rand") ??
        xo(n).scope?.getPropagationContext().sampleRand.toString())),
    a(d),
    t.emit("createDsc", d, n),
    d
  );
}
class _l {
  constructor(t = {}) {
    ((this._traceId = t.traceId || Qr()), (this._spanId = t.spanId || ao()));
  }
  spanContext() {
    return {
      spanId: this._spanId,
      traceId: this._traceId,
      traceFlags: XI,
    };
  }
  end(t) {}
  setAttribute(t, n) {
    return this;
  }
  setAttributes(t) {
    return this;
  }
  setStatus(t) {
    return this;
  }
  updateName(t) {
    return this;
  }
  isRecording() {
    return !1;
  }
  addEvent(t, n, r) {
    return this;
  }
  addLink(t) {
    return this;
  }
  addLinks(t) {
    return this;
  }
  recordException(t, n) {}
}
function wn(e, t = 100, n = 1 / 0) {
  try {
    return pp("", e, t, n);
  } catch (r) {
    return {
      ERROR: `**non-serializable** (${r})`,
    };
  }
}
function eP(e, t = 3, n = 100 * 1024) {
  const r = wn(e, t);
  return f1(r) > n ? eP(e, t - 1, n) : r;
}
function pp(e, t, n = 1 / 0, r = 1 / 0, o = _1()) {
  const [s, i] = o;
  if (
    t == null ||
    ["boolean", "string"].includes(typeof t) ||
    (typeof t == "number" && Number.isFinite(t))
  )
    return t;
  const a = u1(e, t);
  if (!a.startsWith("[object ")) return a;
  if (t.__sentry_skip_normalization__) return t;
  const c =
    typeof t.__sentry_override_normalization_depth__ == "number"
      ? t.__sentry_override_normalization_depth__
      : n;
  if (c === 0) return a.replace("object ", "");
  if (s(t)) return "[Circular ~]";
  const l = t;
  if (l && typeof l.toJSON == "function")
    try {
      const _ = l.toJSON();
      return pp("", _, c - 1, r, o);
    } catch {}
  const f = Array.isArray(t) ? [] : {};
  let d = 0;
  const u = xI(t);
  for (const _ in u) {
    if (!Object.prototype.hasOwnProperty.call(u, _)) continue;
    if (d >= r) {
      f[_] = "[MaxProperties ~]";
      break;
    }
    const p = u[_];
    ((f[_] = pp(_, p, c - 1, r, o)), d++);
  }
  return (i(t), f);
}
function u1(e, t) {
  try {
    if (e === "domain" && t && typeof t == "object" && t._events)
      return "[Domain]";
    if (e === "domainEmitter") return "[DomainEmitter]";
    if (typeof global < "u" && t === global) return "[Global]";
    if (typeof window < "u" && t === window) return "[Window]";
    if (typeof document < "u" && t === document) return "[Document]";
    if (VI(t)) return UI(t);
    if (ok(t)) return "[SyntheticEvent]";
    if (typeof t == "number" && !Number.isFinite(t)) return `[${t}]`;
    if (typeof t == "function") return `[Function: ${wI(t)}]`;
    if (typeof t == "symbol") return `[${String(t)}]`;
    if (typeof t == "bigint") return `[BigInt: ${String(t)}]`;
    const n = l1(t);
    return /^HTML(\w*)Element$/.test(n)
      ? `[HTMLElement: ${n}]`
      : `[object ${n}]`;
  } catch (n) {
    return `**non-serializable** (${n})`;
  }
}
function l1(e) {
  const t = Object.getPrototypeOf(e);
  return t?.constructor ? t.constructor.name : "null prototype";
}
function d1(e) {
  return ~-encodeURI(e).split(/%..|./).length;
}
function f1(e) {
  return d1(JSON.stringify(e));
}
function _1() {
  const e = new WeakSet();
  function t(r) {
    return e.has(r) ? !0 : (e.add(r), !1);
  }
  function n(r) {
    e.delete(r);
  }
  return [t, n];
}
function nr(e, t = []) {
  return [e, t];
}
function p1(e, t) {
  const [n, r] = e;
  return [n, [...r, t]];
}
function QA(e, t) {
  const n = e[1];
  for (const r of n) {
    const o = r[0].type;
    if (t(r, o)) return !0;
  }
  return !1;
}
function Ep(e) {
  const t = hc(ye);
  return t.encodePolyfill ? t.encodePolyfill(e) : new TextEncoder().encode(e);
}
function tP(e) {
  const [t, n] = e;
  let r = JSON.stringify(t);
  function o(s) {
    typeof r == "string"
      ? (r = typeof s == "string" ? r + s : [Ep(r), s])
      : r.push(typeof s == "string" ? Ep(s) : s);
  }
  for (const s of n) {
    const [i, a] = s;
    if (
      (o(`
${JSON.stringify(i)}
`),
      typeof a == "string" || a instanceof Uint8Array)
    )
      o(a);
    else {
      let c;
      try {
        c = JSON.stringify(a);
      } catch {
        c = JSON.stringify(wn(a));
      }
      o(c);
    }
  }
  return typeof r == "string" ? r : E1(r);
}
function E1(e) {
  const t = e.reduce((o, s) => o + s.length, 0),
    n = new Uint8Array(t);
  let r = 0;
  for (const o of e) (n.set(o, r), (r += o.length));
  return n;
}
function h1(e) {
  return [
    {
      type: "span",
    },
    e,
  ];
}
function T1(e) {
  const t = typeof e.data == "string" ? Ep(e.data) : e.data;
  return [
    {
      type: "attachment",
      length: t.length,
      filename: e.filename,
      content_type: e.contentType,
      attachment_type: e.attachmentType,
    },
    t,
  ];
}
const S1 = {
  session: "session",
  sessions: "session",
  attachment: "attachment",
  transaction: "transaction",
  event: "error",
  client_report: "internal",
  user_report: "default",
  profile: "profile",
  profile_chunk: "profile",
  replay_event: "replay",
  replay_recording: "replay",
  check_in: "monitor",
  feedback: "feedback",
  span: "span",
  raw_security: "security",
  log: "log_item",
  metric: "metric",
  trace_metric: "metric",
};
function JA(e) {
  return S1[e];
}
function nP(e) {
  if (!e?.sdk) return;
  const { name: t, version: n } = e.sdk;
  return {
    name: t,
    version: n,
  };
}
function m1(e, t, n, r) {
  const o = e.sdkProcessingMetadata?.dynamicSamplingContext;
  return {
    event_id: e.event_id,
    sent_at: new Date().toISOString(),
    ...(t && {
      sdk: t,
    }),
    ...(!!n &&
      r && {
        dsn: uo(r),
      }),
    ...(o && {
      trace: o,
    }),
  };
}
function A1(e, t) {
  if (!t) return e;
  const n = e.sdk || {};
  return (
    (e.sdk = {
      ...n,
      name: n.name || t.name,
      version: n.version || t.version,
      integrations: [...(e.sdk?.integrations || []), ...(t.integrations || [])],
      packages: [...(e.sdk?.packages || []), ...(t.packages || [])],
      settings:
        e.sdk?.settings || t.settings
          ? {
              ...e.sdk?.settings,
              ...t.settings,
            }
          : void 0,
    }),
    e
  );
}
function g1(e, t, n, r) {
  const o = nP(n),
    s = {
      sent_at: new Date().toISOString(),
      ...(o && {
        sdk: o,
      }),
      ...(!!r &&
        t && {
          dsn: uo(t),
        }),
    },
    i =
      "aggregates" in e
        ? [
            {
              type: "sessions",
            },
            e,
          ]
        : [
            {
              type: "session",
            },
            e.toJSON(),
          ];
  return nr(s, [i]);
}
function R1(e, t, n, r) {
  const o = nP(n),
    s = e.type && e.type !== "replay_event" ? e.type : "event";
  A1(e, n?.sdk);
  const i = m1(e, o, r, t);
  return (
    delete e.sdkProcessingMetadata,
    nr(i, [
      [
        {
          type: s,
        },
        e,
      ],
    ])
  );
}
function N1(e, t) {
  function n(_) {
    return !!_.trace_id && !!_.public_key;
  }
  const r = Vt(e[0]),
    o = t?.getDsn(),
    s = t?.getOptions().tunnel,
    i = {
      sent_at: new Date().toISOString(),
      ...(n(r) && {
        trace: r,
      }),
      ...(!!s &&
        o && {
          dsn: uo(o),
        }),
    },
    { beforeSendSpan: a, ignoreSpans: c } = t?.getOptions() || {},
    l = c?.length ? e.filter((_) => !_p(Re(_), c)) : e,
    f = e.length - l.length;
  f && t?.recordDroppedEvent("before_send", "span", f);
  const d = a
      ? (_) => {
          const p = Re(_),
            E = a(p);
          return E || (fp(), p);
        }
      : Re,
    u = [];
  for (const _ of l) {
    const p = d(_);
    p && u.push(h1(p));
  }
  return nr(i, u);
}
function rP(e) {
  if (!le) return;
  const {
      description: t = "< unknown name >",
      op: n = "< unknown op >",
      parent_span_id: r,
    } = Re(e),
    { spanId: o } = e.spanContext(),
    s = lo(e),
    i = Yt(e),
    a = i === e,
    c = `[Tracing] Starting ${s ? "sampled" : "unsampled"} ${a ? "root " : ""}span`,
    l = [`op: ${n}`, `name: ${t}`, `ID: ${o}`];
  if ((r && l.push(`parent ID: ${r}`), !a)) {
    const { op: f, description: d } = Re(i);
    (l.push(`root ID: ${i.spanContext().spanId}`),
      f && l.push(`root op: ${f}`),
      d && l.push(`root description: ${d}`));
  }
  $.log(`${c}
  ${l.join(`
  `)}`);
}
function oP(e) {
  if (!le) return;
  const { description: t = "< unknown name >", op: n = "< unknown op >" } =
      Re(e),
    { spanId: r } = e.spanContext(),
    s = Yt(e) === e,
    i = `[Tracing] Finishing "${n}" ${s ? "root " : ""}span "${t}" with ID ${r}`;
  $.log(i);
}
function Au(e) {
  if (!e || e.length === 0) return;
  const t = {};
  return (
    e.forEach((n) => {
      const r = n.attributes || {},
        o = r[wk],
        s = r[Uk];
      typeof o == "string" &&
        typeof s == "number" &&
        (t[n.name] = {
          value: s,
          unit: o,
        });
    }),
    t
  );
}
const eg = 1e3;
class yE {
  constructor(t = {}) {
    ((this._traceId = t.traceId || Qr()),
      (this._spanId = t.spanId || ao()),
      (this._startTime = t.startTimestamp || rc()),
      (this._links = t.links),
      (this._attributes = {}),
      this.setAttributes({
        [Ge]: "manual",
        [Ee]: t.op,
        ...t.attributes,
      }),
      (this._name = t.name),
      t.parentSpanId && (this._parentSpanId = t.parentSpanId),
      "sampled" in t && (this._sampled = t.sampled),
      t.endTimestamp && (this._endTime = t.endTimestamp),
      (this._events = []),
      (this._isStandaloneSpan = t.isStandalone),
      this._endTime && this._onSpanEnded());
  }
  addLink(t) {
    return (this._links ? this._links.push(t) : (this._links = [t]), this);
  }
  addLinks(t) {
    return (this._links ? this._links.push(...t) : (this._links = t), this);
  }
  recordException(t, n) {}
  spanContext() {
    const { _spanId: t, _traceId: n, _sampled: r } = this;
    return {
      spanId: t,
      traceId: n,
      traceFlags: r ? gE : XI,
    };
  }
  setAttribute(t, n) {
    return (
      n === void 0 ? delete this._attributes[t] : (this._attributes[t] = n),
      this
    );
  }
  setAttributes(t) {
    return (Object.keys(t).forEach((n) => this.setAttribute(n, t[n])), this);
  }
  updateStartTime(t) {
    this._startTime = Sn(t);
  }
  setStatus(t) {
    return ((this._status = t), this);
  }
  updateName(t) {
    return ((this._name = t), this.setAttribute(Kt, "custom"), this);
  }
  end(t) {
    this._endTime || ((this._endTime = Sn(t)), oP(this), this._onSpanEnded());
  }
  getSpanJSON() {
    return {
      data: this._attributes,
      description: this._name,
      op: this._attributes[Ee],
      parent_span_id: this._parentSpanId,
      span_id: this._spanId,
      start_timestamp: this._startTime,
      status: dl(this._status),
      timestamp: this._endTime,
      trace_id: this._traceId,
      origin: this._attributes[Ge],
      profile_id: this._attributes[TE],
      exclusive_time: this._attributes[SE],
      measurements: Au(this._events),
      is_segment: (this._isStandaloneSpan && Yt(this) === this) || void 0,
      segment_id: this._isStandaloneSpan
        ? Yt(this).spanContext().spanId
        : void 0,
      links: ll(this._links),
    };
  }
  isRecording() {
    return !this._endTime && !!this._sampled;
  }
  addEvent(t, n, r) {
    le && $.log("[Tracing] Adding an event to span:", t);
    const o = tg(n) ? n : r || rc(),
      s = tg(n) ? {} : n || {},
      i = {
        name: t,
        time: Sn(o),
        attributes: s,
      };
    return (this._events.push(i), this);
  }
  isStandaloneSpan() {
    return !!this._isStandaloneSpan;
  }
  _onSpanEnded() {
    const t = he();
    if (
      (t && t.emit("spanEnd", this),
      !(this._isStandaloneSpan || this === Yt(this)))
    )
      return;
    if (this._isStandaloneSpan) {
      this._sampled
        ? O1(N1([this], t))
        : (le &&
            $.log(
              "[Tracing] Discarding standalone span because its trace was not chosen to be sampled.",
            ),
          t && t.recordDroppedEvent("sample_rate", "span"));
      return;
    }
    const r = this._convertSpanToTransaction();
    r && (xo(this).scope || Ke()).captureEvent(r);
  }
  _convertSpanToTransaction() {
    if (!ng(Re(this))) return;
    this._name ||
      (le &&
        $.warn(
          "Transaction has no name, falling back to `<unlabeled transaction>`.",
        ),
      (this._name = "<unlabeled transaction>"));
    const { scope: t, isolationScope: n } = xo(this),
      r = t?.getScopeData().sdkProcessingMetadata?.normalizedRequest;
    if (this._sampled !== !0) return;
    const s = s1(this)
        .filter((f) => f !== this && !y1(f))
        .map((f) => Re(f))
        .filter(ng),
      i = this._attributes[Kt];
    (delete this._attributes[Vo],
      s.forEach((f) => {
        delete f.data[Vo];
      }));
    const a = {
        contexts: {
          trace: e1(this),
        },
        spans:
          s.length > eg
            ? s
                .sort((f, d) => f.start_timestamp - d.start_timestamp)
                .slice(0, eg)
            : s,
        start_timestamp: this._startTime,
        timestamp: this._endTime,
        transaction: this._name,
        type: "transaction",
        sdkProcessingMetadata: {
          capturedSpanScope: t,
          capturedSpanIsolationScope: n,
          dynamicSamplingContext: Vt(this),
        },
        request: r,
        ...(i && {
          transaction_info: {
            source: i,
          },
        }),
      },
      c = Au(this._events);
    return (
      c &&
        Object.keys(c).length &&
        (le &&
          $.log(
            "[Measurements] Adding measurements to transaction event",
            JSON.stringify(c, void 0, 2),
          ),
        (a.measurements = c)),
      a
    );
  }
}
function tg(e) {
  return (e && typeof e == "number") || e instanceof Date || Array.isArray(e);
}
function ng(e) {
  return !!e.start_timestamp && !!e.timestamp && !!e.span_id && !!e.trace_id;
}
function y1(e) {
  return e instanceof yE && e.isStandaloneSpan();
}
function O1(e) {
  const t = he();
  if (!t) return;
  const n = e[1];
  if (!n || n.length === 0) {
    t.recordDroppedEvent("before_send", "span");
    return;
  }
  t.sendEnvelope(e);
}
function to(e, t, n = () => {}, r = () => {}) {
  let o;
  try {
    o = e();
  } catch (s) {
    throw (t(s), n(), s);
  }
  return C1(o, t, n, r);
}
function C1(e, t, n, r) {
  return tr(e)
    ? e.then(
        (o) => (n(), r(o), o),
        (o) => {
          throw (t(o), n(), o);
        },
      )
    : (n(), r(e), e);
}
function sP(e, t, n) {
  if (!zt(e)) return [!1];
  let r, o;
  typeof e.tracesSampler == "function"
    ? ((o = e.tracesSampler({
        ...t,
        inheritOrSampleWith: (a) =>
          typeof t.parentSampleRate == "number"
            ? t.parentSampleRate
            : typeof t.parentSampled == "boolean"
              ? Number(t.parentSampled)
              : a,
      })),
      (r = !0))
    : t.parentSampled !== void 0
      ? (o = t.parentSampled)
      : typeof e.tracesSampleRate < "u" && ((o = e.tracesSampleRate), (r = !0));
  const s = eo(o);
  if (s === void 0)
    return (
      le &&
        $.warn(
          `[Tracing] Discarding root span because of invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(o)} of type ${JSON.stringify(typeof o)}.`,
        ),
      [!1]
    );
  if (!s)
    return (
      le &&
        $.log(
          `[Tracing] Discarding transaction because ${typeof e.tracesSampler == "function" ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0"}`,
        ),
      [!1, s, r]
    );
  const i = n < s;
  return (
    i ||
      (le &&
        $.log(
          `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(o)})`,
        )),
    [i, s, r]
  );
}
const gu = "__SENTRY_SUPPRESS_TRACING__";
function Qo(e, t) {
  const n = pl();
  if (n.startSpan) return n.startSpan(e, t);
  const r = uP(e),
    { forceTransaction: o, parentSpan: s, scope: i } = e,
    a = i?.clone();
  return Jr(a, () =>
    dP(s)(() => {
      const l = Ke(),
        f = lP(l, s),
        u =
          e.onlyIfParent && !f
            ? new _l()
            : cP({
                parentSpan: f,
                spanArguments: r,
                forceTransaction: o,
                scope: l,
              });
      return (
        oc(l, u),
        to(
          () => t(u),
          () => {
            const { status: _ } = Re(u);
            u.isRecording() &&
              (!_ || _ === "ok") &&
              u.setStatus({
                code: Ae,
                message: "internal_error",
              });
          },
          () => {
            u.end();
          },
        )
      );
    }),
  );
}
function Gn(e, t) {
  const n = pl();
  if (n.startSpanManual) return n.startSpanManual(e, t);
  const r = uP(e),
    { forceTransaction: o, parentSpan: s, scope: i } = e,
    a = i?.clone();
  return Jr(a, () =>
    dP(s)(() => {
      const l = Ke(),
        f = lP(l, s),
        u =
          e.onlyIfParent && !f
            ? new _l()
            : cP({
                parentSpan: f,
                spanArguments: r,
                forceTransaction: o,
                scope: l,
              });
      return (
        oc(l, u),
        to(
          () => t(u, () => u.end()),
          () => {
            const { status: _ } = Re(u);
            u.isRecording() &&
              (!_ || _ === "ok") &&
              u.setStatus({
                code: Ae,
                message: "internal_error",
              });
          },
        )
      );
    }),
  );
}
function iP(e, t) {
  const n = pl();
  return n.withActiveSpan
    ? n.withActiveSpan(e, t)
    : Jr((r) => (oc(r, e || void 0), t(r)));
}
function aP(e) {
  const t = pl();
  return t.suppressTracing
    ? t.suppressTracing(e)
    : Jr((n) => {
        n.setSDKProcessingMetadata({
          [gu]: !0,
        });
        const r = e();
        return (
          n.setSDKProcessingMetadata({
            [gu]: void 0,
          }),
          r
        );
      });
}
function cP({
  parentSpan: e,
  spanArguments: t,
  forceTransaction: n,
  scope: r,
}) {
  if (!zt()) {
    const i = new _l();
    if (n || !e) {
      const a = {
        sampled: "false",
        sample_rate: "0",
        transaction: t.name,
        ...Vt(i),
      };
      Rd(i, a);
    }
    return i;
  }
  const o = je();
  let s;
  if (e && !n) ((s = b1(e, r, t)), RE(e, s));
  else if (e) {
    const i = Vt(e),
      { traceId: a, spanId: c } = e.spanContext(),
      l = lo(e);
    ((s = rg(
      {
        traceId: a,
        parentSpanId: c,
        ...t,
      },
      r,
      l,
    )),
      Rd(s, i));
  } else {
    const {
      traceId: i,
      dsc: a,
      parentSpanId: c,
      sampled: l,
    } = {
      ...o.getPropagationContext(),
      ...r.getPropagationContext(),
    };
    ((s = rg(
      {
        traceId: i,
        parentSpanId: c,
        ...t,
      },
      r,
      l,
    )),
      a && Rd(s, a));
  }
  return (rP(s), YI(s, r, o), s);
}
function uP(e) {
  const n = {
    isStandalone: (e.experimental || {}).standalone,
    ...e,
  };
  if (e.startTime) {
    const r = {
      ...n,
    };
    return ((r.startTimestamp = Sn(e.startTime)), delete r.startTime, r);
  }
  return n;
}
function pl() {
  const e = Fn();
  return co(e);
}
function rg(e, t, n) {
  const r = he(),
    o = r?.getOptions() || {},
    { name: s = "" } = e,
    i = {
      spanAttributes: {
        ...e.attributes,
      },
      spanName: s,
      parentSampled: n,
    };
  r?.emit("beforeSampling", i, {
    decision: !1,
  });
  const a = i.parentSampled ?? n,
    c = i.spanAttributes,
    l = t.getPropagationContext(),
    [f, d, u] = t.getScopeData().sdkProcessingMetadata[gu]
      ? [!1]
      : sP(
          o,
          {
            name: s,
            parentSampled: a,
            attributes: c,
            parentSampleRate: eo(l.dsc?.sample_rate),
          },
          l.sampleRand,
        ),
    _ = new yE({
      ...e,
      attributes: {
        [Kt]: "custom",
        [Go]: d !== void 0 && u ? d : void 0,
        ...c,
      },
      sampled: f,
    });
  return (
    !f &&
      r &&
      (le &&
        $.log(
          "[Tracing] Discarding root span because its trace was not chosen to be sampled.",
        ),
      r.recordDroppedEvent("sample_rate", "transaction")),
    r && r.emit("spanStart", _),
    _
  );
}
function b1(e, t, n) {
  const { spanId: r, traceId: o } = e.spanContext(),
    s = t.getScopeData().sdkProcessingMetadata[gu] ? !1 : lo(e),
    i = s
      ? new yE({
          ...n,
          parentSpanId: r,
          traceId: o,
          sampled: s,
        })
      : new _l({
          traceId: o,
        });
  RE(e, i);
  const a = he();
  return (
    a && (a.emit("spanStart", i), n.endTimestamp && a.emit("spanEnd", i)),
    i
  );
}
function lP(e, t) {
  if (t) return t;
  if (t === null) return;
  const n = Tu(e);
  if (!n) return;
  const r = he();
  return (r ? r.getOptions() : {}).parentSpanIsAlwaysRootSpan ? Yt(n) : n;
}
function dP(e) {
  return e !== void 0 ? (t) => iP(e, t) : (t) => t();
}
const Nd = 0,
  og = 1,
  sg = 2;
function Ru(e) {
  return new sc((t) => {
    t(e);
  });
}
function OE(e) {
  return new sc((t, n) => {
    n(e);
  });
}
class sc {
  constructor(t) {
    ((this._state = Nd), (this._handlers = []), this._runExecutor(t));
  }
  then(t, n) {
    return new sc((r, o) => {
      (this._handlers.push([
        !1,
        (s) => {
          if (!t) r(s);
          else
            try {
              r(t(s));
            } catch (i) {
              o(i);
            }
        },
        (s) => {
          if (!n) o(s);
          else
            try {
              r(n(s));
            } catch (i) {
              o(i);
            }
        },
      ]),
        this._executeHandlers());
    });
  }
  catch(t) {
    return this.then((n) => n, t);
  }
  finally(t) {
    return new sc((n, r) => {
      let o, s;
      return this.then(
        (i) => {
          ((s = !1), (o = i), t && t());
        },
        (i) => {
          ((s = !0), (o = i), t && t());
        },
      ).then(() => {
        if (s) {
          r(o);
          return;
        }
        n(o);
      });
    });
  }
  _executeHandlers() {
    if (this._state === Nd) return;
    const t = this._handlers.slice();
    ((this._handlers = []),
      t.forEach((n) => {
        n[0] ||
          (this._state === og && n[1](this._value),
          this._state === sg && n[2](this._value),
          (n[0] = !0));
      }));
  }
  _runExecutor(t) {
    const n = (s, i) => {
        if (this._state === Nd) {
          if (tr(i)) {
            i.then(r, o);
            return;
          }
          ((this._state = s), (this._value = i), this._executeHandlers());
        }
      },
      r = (s) => {
        n(og, s);
      },
      o = (s) => {
        n(sg, s);
      };
    try {
      t(r, o);
    } catch (s) {
      o(s);
    }
  }
}
function I1(e, t, n, r = 0) {
  try {
    const o = hp(t, n, e, r);
    return tr(o) ? o : Ru(o);
  } catch (o) {
    return OE(o);
  }
}
function hp(e, t, n, r) {
  const o = n[r];
  if (!e || !o) return e;
  const s = o(
    {
      ...e,
    },
    t,
  );
  return (
    le && s === null && $.log(`Event processor "${o.id || "?"}" dropped event`),
    tr(s) ? s.then((i) => hp(i, t, n, r + 1)) : hp(s, t, n, r + 1)
  );
}
function P1(e, t) {
  const {
    fingerprint: n,
    span: r,
    breadcrumbs: o,
    sdkProcessingMetadata: s,
  } = t;
  (M1(e, t), r && D1(e, r), w1(e, n), v1(e, o), L1(e, s));
}
function ig(e, t) {
  const {
    extra: n,
    tags: r,
    user: o,
    contexts: s,
    level: i,
    sdkProcessingMetadata: a,
    breadcrumbs: c,
    fingerprint: l,
    eventProcessors: f,
    attachments: d,
    propagationContext: u,
    transactionName: _,
    span: p,
  } = t;
  (Mc(e, "extra", n),
    Mc(e, "tags", r),
    Mc(e, "user", o),
    Mc(e, "contexts", s),
    (e.sdkProcessingMetadata = mc(e.sdkProcessingMetadata, a, 2)),
    i && (e.level = i),
    _ && (e.transactionName = _),
    p && (e.span = p),
    c.length && (e.breadcrumbs = [...e.breadcrumbs, ...c]),
    l.length && (e.fingerprint = [...e.fingerprint, ...l]),
    f.length && (e.eventProcessors = [...e.eventProcessors, ...f]),
    d.length && (e.attachments = [...e.attachments, ...d]),
    (e.propagationContext = {
      ...e.propagationContext,
      ...u,
    }));
}
function Mc(e, t, n) {
  e[t] = mc(e[t], n, 1);
}
function M1(e, t) {
  const {
    extra: n,
    tags: r,
    user: o,
    contexts: s,
    level: i,
    transactionName: a,
  } = t;
  (Object.keys(n).length &&
    (e.extra = {
      ...n,
      ...e.extra,
    }),
    Object.keys(r).length &&
      (e.tags = {
        ...r,
        ...e.tags,
      }),
    Object.keys(o).length &&
      (e.user = {
        ...o,
        ...e.user,
      }),
    Object.keys(s).length &&
      (e.contexts = {
        ...s,
        ...e.contexts,
      }),
    i && (e.level = i),
    a && e.type !== "transaction" && (e.transaction = a));
}
function v1(e, t) {
  const n = [...(e.breadcrumbs || []), ...t];
  e.breadcrumbs = n.length ? n : void 0;
}
function L1(e, t) {
  e.sdkProcessingMetadata = {
    ...e.sdkProcessingMetadata,
    ...t,
  };
}
function D1(e, t) {
  ((e.contexts = {
    trace: ul(t),
    ...e.contexts,
  }),
    (e.sdkProcessingMetadata = {
      dynamicSamplingContext: Vt(t),
      ...e.sdkProcessingMetadata,
    }));
  const n = Yt(t),
    r = Re(n).description;
  r && !e.transaction && e.type === "transaction" && (e.transaction = r);
}
function w1(e, t) {
  ((e.fingerprint = e.fingerprint
    ? Array.isArray(e.fingerprint)
      ? e.fingerprint
      : [e.fingerprint]
    : []),
    t && (e.fingerprint = e.fingerprint.concat(t)),
    e.fingerprint.length || delete e.fingerprint);
}
let gr, ag, cg, qn;
function U1(e) {
  const t = ye._sentryDebugIds,
    n = ye._debugIds;
  if (!t && !n) return {};
  const r = t ? Object.keys(t) : [],
    o = n ? Object.keys(n) : [];
  if (qn && r.length === ag && o.length === cg) return qn;
  ((ag = r.length), (cg = o.length), (qn = {}), gr || (gr = {}));
  const s = (i, a) => {
    for (const c of i) {
      const l = a[c],
        f = gr?.[c];
      if (f && qn && l) ((qn[f[0]] = l), gr && (gr[c] = [f[0], l]));
      else if (l) {
        const d = e(c);
        for (let u = d.length - 1; u >= 0; u--) {
          const p = d[u]?.filename;
          if (p && qn && gr) {
            ((qn[p] = l), (gr[c] = [p, l]));
            break;
          }
        }
      }
    }
  };
  return (t && s(r, t), n && s(o, n), qn);
}
function k1(e, t, n, r, o, s) {
  const { normalizeDepth: i = 3, normalizeMaxBreadth: a = 1e3 } = e,
    c = {
      ...t,
      event_id: t.event_id || n.event_id || Ft(),
      timestamp: t.timestamp || Sc(),
    },
    l = n.integrations || e.integrations.map((h) => h.name);
  (G1(c, e),
    $1(c, l),
    o && o.emit("applyFrameMetadata", t),
    t.type === void 0 && V1(c, e.stackParser));
  const f = H1(r, n.captureContext);
  n.mechanism && pE(c, n.mechanism);
  const d = o ? o.getEventProcessors() : [],
    u = vk().getScopeData();
  if (s) {
    const h = s.getScopeData();
    ig(u, h);
  }
  if (f) {
    const h = f.getScopeData();
    ig(u, h);
  }
  const _ = [...(n.attachments || []), ...u.attachments];
  (_.length && (n.attachments = _), P1(c, u));
  const p = [...d, ...u.eventProcessors];
  return I1(p, c, n).then(
    (h) => (h && x1(h), typeof i == "number" && i > 0 ? B1(h, i, a) : h),
  );
}
function G1(e, t) {
  const { environment: n, release: r, dist: o, maxValueLength: s } = t;
  ((e.environment = e.environment || n || NE),
    !e.release && r && (e.release = r),
    !e.dist && o && (e.dist = o));
  const i = e.request;
  (i?.url && s && (i.url = hu(i.url, s)),
    s &&
      e.exception?.values?.forEach((a) => {
        a.value && (a.value = hu(a.value, s));
      }));
}
function V1(e, t) {
  const n = U1(t);
  e.exception?.values?.forEach((r) => {
    r.stacktrace?.frames?.forEach((o) => {
      o.filename && (o.debug_id = n[o.filename]);
    });
  });
}
function x1(e) {
  const t = {};
  if (
    (e.exception?.values?.forEach((r) => {
      r.stacktrace?.frames?.forEach((o) => {
        o.debug_id &&
          (o.abs_path
            ? (t[o.abs_path] = o.debug_id)
            : o.filename && (t[o.filename] = o.debug_id),
          delete o.debug_id);
      });
    }),
    Object.keys(t).length === 0)
  )
    return;
  ((e.debug_meta = e.debug_meta || {}),
    (e.debug_meta.images = e.debug_meta.images || []));
  const n = e.debug_meta.images;
  Object.entries(t).forEach(([r, o]) => {
    n.push({
      type: "sourcemap",
      code_file: r,
      debug_id: o,
    });
  });
}
function $1(e, t) {
  t.length > 0 &&
    ((e.sdk = e.sdk || {}),
    (e.sdk.integrations = [...(e.sdk.integrations || []), ...t]));
}
function B1(e, t, n) {
  if (!e) return null;
  const r = {
    ...e,
    ...(e.breadcrumbs && {
      breadcrumbs: e.breadcrumbs.map((o) => ({
        ...o,
        ...(o.data && {
          data: wn(o.data, t, n),
        }),
      })),
    }),
    ...(e.user && {
      user: wn(e.user, t, n),
    }),
    ...(e.contexts && {
      contexts: wn(e.contexts, t, n),
    }),
    ...(e.extra && {
      extra: wn(e.extra, t, n),
    }),
  };
  return (
    e.contexts?.trace &&
      r.contexts &&
      ((r.contexts.trace = e.contexts.trace),
      e.contexts.trace.data &&
        (r.contexts.trace.data = wn(e.contexts.trace.data, t, n))),
    e.spans &&
      (r.spans = e.spans.map((o) => ({
        ...o,
        ...(o.data && {
          data: wn(o.data, t, n),
        }),
      }))),
    e.contexts?.flags &&
      r.contexts &&
      (r.contexts.flags = wn(e.contexts.flags, 3, n)),
    r
  );
}
function H1(e, t) {
  if (!t) return e;
  const n = e ? e.clone() : new mn();
  return (n.update(t), n);
}
function F1(e) {
  if (e)
    return Y1(e)
      ? {
          captureContext: e,
        }
      : q1(e)
        ? {
            captureContext: e,
          }
        : e;
}
function Y1(e) {
  return e instanceof mn || typeof e == "function";
}
const j1 = [
  "user",
  "level",
  "extra",
  "contexts",
  "tags",
  "fingerprint",
  "propagationContext",
];
function q1(e) {
  return Object.keys(e).some((t) => j1.includes(t));
}
function xe(e, t) {
  return Ke().captureException(e, F1(t));
}
function W1(e, t) {
  return Ke().captureEvent(e, t);
}
function K1(e, t) {
  je().setTag(e, t);
}
function ug(e) {
  je().setUser(e);
}
async function z1(e) {
  const t = he();
  return t
    ? t.flush(e)
    : (le && $.warn("Cannot flush events. No client defined."),
      Promise.resolve(!1));
}
function Z1() {
  const e = he();
  return e?.getOptions().enabled !== !1 && !!e?.getTransport();
}
function X1(e) {
  const t = je(),
    n = Ke(),
    { userAgent: r } = ye.navigator || {},
    o = Rk({
      user: n.getUser() || t.getUser(),
      ...(r && {
        userAgent: r,
      }),
      ...e,
    }),
    s = t.getSession();
  return (
    s?.status === "ok" &&
      Uo(s, {
        status: "exited",
      }),
    fP(),
    t.setSession(o),
    o
  );
}
function fP() {
  const e = je(),
    n = Ke().getSession() || e.getSession();
  (n && Nk(n), Q1(), e.setSession());
}
function Q1() {
  const e = je(),
    t = he(),
    n = e.getSession();
  n && t && t.captureSession(n);
}
const J1 = "7";
function eG(e) {
  const t = e.protocol ? `${e.protocol}:` : "",
    n = e.port ? `:${e.port}` : "";
  return `${t}//${e.host}${n}${e.path ? `/${e.path}` : ""}/api/`;
}
function tG(e) {
  return `${eG(e)}${e.projectId}/envelope/`;
}
function nG(e, t) {
  const n = {
    sentry_version: J1,
  };
  return (
    e.publicKey && (n.sentry_key = e.publicKey),
    t && (n.sentry_client = `${t.name}/${t.version}`),
    new URLSearchParams(n).toString()
  );
}
function rG(e, t, n) {
  return t || `${tG(e)}?${nG(e, n)}`;
}
const lg = [];
function oG(e) {
  const t = {};
  return (
    e.forEach((n) => {
      const { name: r } = n,
        o = t[r];
      (o && !o.isDefaultInstance && n.isDefaultInstance) || (t[r] = n);
    }),
    Object.values(t)
  );
}
function sG(e) {
  const t = e.defaultIntegrations || [],
    n = e.integrations;
  t.forEach((o) => {
    o.isDefaultInstance = !0;
  });
  let r;
  if (Array.isArray(n)) r = [...t, ...n];
  else if (typeof n == "function") {
    const o = n(t);
    r = Array.isArray(o) ? o : [o];
  } else r = t;
  return oG(r);
}
function iG(e, t) {
  const n = {};
  return (
    t.forEach((r) => {
      r && _P(e, r, n);
    }),
    n
  );
}
function dg(e, t) {
  for (const n of t) n?.afterAllSetup && n.afterAllSetup(e);
}
function _P(e, t, n) {
  if (n[t.name]) {
    le &&
      $.log(`Integration skipped because it was already installed: ${t.name}`);
    return;
  }
  if (
    ((n[t.name] = t),
    !lg.includes(t.name) &&
      typeof t.setupOnce == "function" &&
      (t.setupOnce(), lg.push(t.name)),
    t.setup && typeof t.setup == "function" && t.setup(e),
    typeof t.preprocessEvent == "function")
  ) {
    const r = t.preprocessEvent.bind(t);
    e.on("preprocessEvent", (o, s) => r(o, s, e));
  }
  if (typeof t.processEvent == "function") {
    const r = t.processEvent.bind(t),
      o = Object.assign((s, i) => r(s, i, e), {
        id: t.name,
      });
    e.addEventProcessor(o);
  }
  le && $.log(`Integration installed: ${t.name}`);
}
function aG(e, t) {
  return t
    ? Jr(t, () => {
        const n = fl(),
          r = n ? ul(n) : hE(t);
        return [n ? Vt(n) : gc(e, t), r];
      })
    : [void 0, void 0];
}
function cG(e) {
  return [
    {
      type: "log",
      item_count: e.length,
      content_type: "application/vnd.sentry.items.log+json",
    },
    {
      items: e,
    },
  ];
}
function uG(e, t, n, r) {
  const o = {};
  return (
    t?.sdk &&
      (o.sdk = {
        name: t.sdk.name,
        version: t.sdk.version,
      }),
    n && r && (o.dsn = uo(r)),
    nr(o, [cG(e)])
  );
}
function pP(e, t) {
  const n = t ?? lG(e) ?? [];
  if (n.length === 0) return;
  const r = e.getOptions(),
    o = uG(n, r._metadata, r.tunnel, e.getDsn());
  (EP().set(e, []), e.emit("flushLogs"), e.sendEnvelope(o));
}
function lG(e) {
  return EP().get(e);
}
function EP() {
  return Zo("clientToLogBufferMap", () => new WeakMap());
}
function dG(e) {
  return [
    {
      type: "trace_metric",
      item_count: e.length,
      content_type: "application/vnd.sentry.items.trace-metric+json",
    },
    {
      items: e,
    },
  ];
}
function fG(e, t, n, r) {
  const o = {};
  return (
    t?.sdk &&
      (o.sdk = {
        name: t.sdk.name,
        version: t.sdk.version,
      }),
    n && r && (o.dsn = uo(r)),
    nr(o, [dG(e)])
  );
}
function _G(e, t) {
  const n = t ?? pG(e) ?? [];
  if (n.length === 0) return;
  const r = e.getOptions(),
    o = fG(n, r._metadata, r.tunnel, e.getDsn());
  (hP().set(e, []), e.emit("flushMetrics"), e.sendEnvelope(o));
}
function pG(e) {
  return hP().get(e);
}
function hP() {
  return Zo("clientToMetricBufferMap", () => new WeakMap());
}
const CE = Symbol.for("SentryBufferFullError");
function TP(e = 100) {
  const t = new Set();
  function n() {
    return t.size < e;
  }
  function r(i) {
    t.delete(i);
  }
  function o(i) {
    if (!n()) return OE(CE);
    const a = i();
    return (
      t.add(a),
      a.then(
        () => r(a),
        () => r(a),
      ),
      a
    );
  }
  function s(i) {
    if (!t.size) return Ru(!0);
    const a = Promise.allSettled(Array.from(t)).then(() => !0);
    if (!i) return a;
    const c = [a, new Promise((l) => setTimeout(() => l(!1), i))];
    return Promise.race(c);
  }
  return {
    get $() {
      return Array.from(t);
    },
    add: o,
    drain: s,
  };
}
const EG = 60 * 1e3;
function hG(e, t = Date.now()) {
  const n = parseInt(`${e}`, 10);
  if (!isNaN(n)) return n * 1e3;
  const r = Date.parse(`${e}`);
  return isNaN(r) ? EG : r - t;
}
function TG(e, t) {
  return e[t] || e.all || 0;
}
function SG(e, t, n = Date.now()) {
  return TG(e, t) > n;
}
function mG(e, { statusCode: t, headers: n }, r = Date.now()) {
  const o = {
      ...e,
    },
    s = n?.["x-sentry-rate-limits"],
    i = n?.["retry-after"];
  if (s)
    for (const a of s.trim().split(",")) {
      const [c, l, , , f] = a.split(":", 5),
        d = parseInt(c, 10),
        u = (isNaN(d) ? 60 : d) * 1e3;
      if (!l) o.all = r + u;
      else
        for (const _ of l.split(";"))
          _ === "metric_bucket"
            ? (!f || f.split(";").includes("custom")) && (o[_] = r + u)
            : (o[_] = r + u);
    }
  else i ? (o.all = r + hG(i, r)) : t === 429 && (o.all = r + 60 * 1e3);
  return o;
}
const SP = 64;
function fg(e, t, n = TP(e.bufferSize || SP)) {
  let r = {};
  const o = (i) => n.drain(i);
  function s(i) {
    const a = [];
    if (
      (QA(i, (d, u) => {
        const _ = JA(u);
        SG(r, _) ? e.recordDroppedEvent("ratelimit_backoff", _) : a.push(d);
      }),
      a.length === 0)
    )
      return Promise.resolve({});
    const c = nr(i[0], a),
      l = (d) => {
        QA(c, (u, _) => {
          e.recordDroppedEvent(d, JA(_));
        });
      },
      f = () =>
        t({
          body: tP(c),
        }).then(
          (d) => (
            d.statusCode !== void 0 &&
              (d.statusCode < 200 || d.statusCode >= 300) &&
              le &&
              $.warn(
                `Sentry responded with status code ${d.statusCode} to sent event.`,
              ),
            (r = mG(r, d)),
            d
          ),
          (d) => {
            throw (
              l("network_error"),
              le && $.error("Encountered error running transport request:", d),
              d
            );
          },
        );
    return n.add(f).then(
      (d) => d,
      (d) => {
        if (d === CE)
          return (
            le && $.error("Skipped sending event because buffer is full."),
            l("queue_overflow"),
            Promise.resolve({})
          );
        throw d;
      },
    );
  }
  return {
    send: s,
    flush: o,
  };
}
function AG(e, t, n) {
  const r = [
    {
      type: "client_report",
    },
    {
      timestamp: Sc(),
      discarded_events: e,
    },
  ];
  return nr(
    t
      ? {
          dsn: t,
        }
      : {},
    [r],
  );
}
function mP(e) {
  const t = [];
  e.message && t.push(e.message);
  try {
    const n = e.exception.values[e.exception.values.length - 1];
    n?.value && (t.push(n.value), n.type && t.push(`${n.type}: ${n.value}`));
  } catch {}
  return t;
}
function gG(e) {
  const {
    trace_id: t,
    parent_span_id: n,
    span_id: r,
    status: o,
    origin: s,
    data: i,
    op: a,
  } = e.contexts?.trace ?? {};
  return {
    data: i ?? {},
    description: e.transaction,
    op: a,
    parent_span_id: n,
    span_id: r ?? "",
    start_timestamp: e.start_timestamp ?? 0,
    status: o,
    timestamp: e.timestamp,
    trace_id: t ?? "",
    origin: s,
    profile_id: i?.[TE],
    exclusive_time: i?.[SE],
    measurements: e.measurements,
    is_segment: !0,
  };
}
function RG(e) {
  return {
    type: "transaction",
    timestamp: e.timestamp,
    start_timestamp: e.start_timestamp,
    transaction: e.description,
    contexts: {
      trace: {
        trace_id: e.trace_id,
        span_id: e.span_id,
        parent_span_id: e.parent_span_id,
        op: e.op,
        status: e.status,
        origin: e.origin,
        data: {
          ...e.data,
          ...(e.profile_id && {
            [TE]: e.profile_id,
          }),
          ...(e.exclusive_time && {
            [SE]: e.exclusive_time,
          }),
        },
      },
    },
    measurements: e.measurements,
  };
}
const _g = "Not capturing exception because it's already been captured.",
  pg = "Discarded session because of missing or non-string release",
  AP = Symbol.for("SentryInternalError"),
  gP = Symbol.for("SentryDoNotSendEventError"),
  NG = 5e3;
function tu(e) {
  return {
    message: e,
    [AP]: !0,
  };
}
function yd(e) {
  return {
    message: e,
    [gP]: !0,
  };
}
function Eg(e) {
  return !!e && typeof e == "object" && AP in e;
}
function hg(e) {
  return !!e && typeof e == "object" && gP in e;
}
function Tg(e, t, n, r, o) {
  let s = 0,
    i,
    a = !1;
  (e.on(n, () => {
    ((s = 0), clearTimeout(i), (a = !1));
  }),
    e.on(t, (c) => {
      ((s += r(c)),
        s >= 8e5
          ? o(e)
          : a ||
            ((a = !0),
            (i = setTimeout(() => {
              o(e);
            }, NG))));
    }),
    e.on("flush", () => {
      o(e);
    }));
}
class yG {
  constructor(t) {
    if (
      ((this._options = t),
      (this._integrations = {}),
      (this._numProcessing = 0),
      (this._outcomes = {}),
      (this._hooks = {}),
      (this._eventProcessors = []),
      (this._promiseBuffer = TP(t.transportOptions?.bufferSize ?? SP)),
      t.dsn
        ? (this._dsn = Zk(t.dsn))
        : le && $.warn("No DSN provided, client will not send events."),
      this._dsn)
    ) {
      const r = rG(this._dsn, t.tunnel, t._metadata ? t._metadata.sdk : void 0);
      this._transport = t.transport({
        tunnel: this._options.tunnel,
        recordDroppedEvent: this.recordDroppedEvent.bind(this),
        ...t.transportOptions,
        url: r,
      });
    }
    ((this._options.enableLogs =
      this._options.enableLogs ?? this._options._experiments?.enableLogs),
      this._options.enableLogs &&
        Tg(this, "afterCaptureLog", "flushLogs", IG, pP),
      (this._options.enableMetrics ??
        this._options._experiments?.enableMetrics ??
        !0) &&
        Tg(this, "afterCaptureMetric", "flushMetrics", bG, _G));
  }
  captureException(t, n, r) {
    const o = Ft();
    if (YA(t)) return (le && $.log(_g), o);
    const s = {
      event_id: o,
      ...n,
    };
    return (
      this._process(
        () =>
          this.eventFromException(t, s)
            .then((i) => this._captureEvent(i, s, r))
            .then((i) => i),
        "error",
      ),
      s.event_id
    );
  }
  captureMessage(t, n, r, o) {
    const s = {
        event_id: Ft(),
        ...r,
      },
      i = _E(t) ? t : String(t),
      a = GI(t),
      c = a ? this.eventFromMessage(i, n, s) : this.eventFromException(t, s);
    return (
      this._process(
        () => c.then((l) => this._captureEvent(l, s, o)),
        a ? "unknown" : "error",
      ),
      s.event_id
    );
  }
  captureEvent(t, n, r) {
    const o = Ft();
    if (n?.originalException && YA(n.originalException))
      return (le && $.log(_g), o);
    const s = {
        event_id: o,
        ...n,
      },
      i = t.sdkProcessingMetadata || {},
      a = i.capturedSpanScope,
      c = i.capturedSpanIsolationScope,
      l = Sg(t.type);
    return (
      this._process(() => this._captureEvent(t, s, a || r, c), l),
      s.event_id
    );
  }
  captureSession(t) {
    (this.sendSession(t),
      Uo(t, {
        init: !1,
      }));
  }
  getDsn() {
    return this._dsn;
  }
  getOptions() {
    return this._options;
  }
  getSdkMetadata() {
    return this._options._metadata;
  }
  getTransport() {
    return this._transport;
  }
  async flush(t) {
    const n = this._transport;
    if (!n) return !0;
    this.emit("flush");
    const r = await this._isClientDoneProcessing(t),
      o = await n.flush(t);
    return r && o;
  }
  async close(t) {
    const n = await this.flush(t);
    return ((this.getOptions().enabled = !1), this.emit("close"), n);
  }
  getEventProcessors() {
    return this._eventProcessors;
  }
  addEventProcessor(t) {
    this._eventProcessors.push(t);
  }
  init() {
    (this._isEnabled() ||
      this._options.integrations.some(({ name: t }) =>
        t.startsWith("Spotlight"),
      )) &&
      this._setupIntegrations();
  }
  getIntegrationByName(t) {
    return this._integrations[t];
  }
  addIntegration(t) {
    const n = this._integrations[t.name];
    (_P(this, t, this._integrations), n || dg(this, [t]));
  }
  sendEvent(t, n = {}) {
    this.emit("beforeSendEvent", t, n);
    let r = R1(t, this._dsn, this._options._metadata, this._options.tunnel);
    for (const o of n.attachments || []) r = p1(r, T1(o));
    this.sendEnvelope(r).then((o) => this.emit("afterSendEvent", t, o));
  }
  sendSession(t) {
    const { release: n, environment: r = NE } = this._options;
    if ("aggregates" in t) {
      const s = t.attrs || {};
      if (!s.release && !n) {
        le && $.warn(pg);
        return;
      }
      ((s.release = s.release || n),
        (s.environment = s.environment || r),
        (t.attrs = s));
    } else {
      if (!t.release && !n) {
        le && $.warn(pg);
        return;
      }
      ((t.release = t.release || n), (t.environment = t.environment || r));
    }
    this.emit("beforeSendSession", t);
    const o = g1(t, this._dsn, this._options._metadata, this._options.tunnel);
    this.sendEnvelope(o);
  }
  recordDroppedEvent(t, n, r = 1) {
    if (this._options.sendClientReports) {
      const o = `${t}:${n}`;
      (le && $.log(`Recording outcome: "${o}"${r > 1 ? ` (${r} times)` : ""}`),
        (this._outcomes[o] = (this._outcomes[o] || 0) + r));
    }
  }
  on(t, n) {
    const r = (this._hooks[t] = this._hooks[t] || new Set()),
      o = (...s) => n(...s);
    return (
      r.add(o),
      () => {
        r.delete(o);
      }
    );
  }
  emit(t, ...n) {
    const r = this._hooks[t];
    r && r.forEach((o) => o(...n));
  }
  async sendEnvelope(t) {
    if ((this.emit("beforeEnvelope", t), this._isEnabled() && this._transport))
      try {
        return await this._transport.send(t);
      } catch (n) {
        return (le && $.error("Error while sending envelope:", n), {});
      }
    return (le && $.error("Transport disabled"), {});
  }
  _setupIntegrations() {
    const { integrations: t } = this._options;
    ((this._integrations = iG(this, t)), dg(this, t));
  }
  _updateSessionFromEvent(t, n) {
    let r = n.level === "fatal",
      o = !1;
    const s = n.exception?.values;
    if (s) {
      ((o = !0), (r = !1));
      for (const c of s)
        if (c.mechanism?.handled === !1) {
          r = !0;
          break;
        }
    }
    const i = t.status === "ok";
    ((i && t.errors === 0) || (i && r)) &&
      (Uo(t, {
        ...(r && {
          status: "crashed",
        }),
        errors: t.errors || Number(o || r),
      }),
      this.captureSession(t));
  }
  async _isClientDoneProcessing(t) {
    let n = 0;
    for (; !t || n < t; ) {
      if ((await new Promise((r) => setTimeout(r, 1)), !this._numProcessing))
        return !0;
      n++;
    }
    return !1;
  }
  _isEnabled() {
    return this.getOptions().enabled !== !1 && this._transport !== void 0;
  }
  _prepareEvent(t, n, r, o) {
    const s = this.getOptions(),
      i = Object.keys(this._integrations);
    return (
      !n.integrations && i?.length && (n.integrations = i),
      this.emit("preprocessEvent", t, n),
      t.type || o.setLastEventId(t.event_id || n.event_id),
      k1(s, t, n, r, this, o).then((a) => {
        if (a === null) return a;
        (this.emit("postprocessEvent", a, n),
          (a.contexts = {
            trace: hE(r),
            ...a.contexts,
          }));
        const c = gc(this, r);
        return (
          (a.sdkProcessingMetadata = {
            dynamicSamplingContext: c,
            ...a.sdkProcessingMetadata,
          }),
          a
        );
      })
    );
  }
  _captureEvent(t, n = {}, r = Ke(), o = je()) {
    return (
      le &&
        Tp(t) &&
        $.log(`Captured error event \`${mP(t)[0] || "<unknown>"}\``),
      this._processEvent(t, n, r, o).then(
        (s) => s.event_id,
        (s) => {
          le &&
            (hg(s) ? $.log(s.message) : Eg(s) ? $.warn(s.message) : $.warn(s));
        },
      )
    );
  }
  _processEvent(t, n, r, o) {
    const s = this.getOptions(),
      { sampleRate: i } = s,
      a = RP(t),
      c = Tp(t),
      f = `before send for type \`${t.type || "error"}\``,
      d = typeof i > "u" ? void 0 : eo(i);
    if (c && typeof d == "number" && Math.random() > d)
      return (
        this.recordDroppedEvent("sample_rate", "error"),
        OE(
          yd(
            `Discarding event because it's not included in the random sample (sampling rate = ${i})`,
          ),
        )
      );
    const u = Sg(t.type);
    return this._prepareEvent(t, n, r, o)
      .then((_) => {
        if (_ === null)
          throw (
            this.recordDroppedEvent("event_processor", u),
            yd("An event processor returned `null`, will not send event.")
          );
        if (n.data && n.data.__sentry__ === !0) return _;
        const E = CG(this, s, _, n);
        return OG(E, f);
      })
      .then((_) => {
        if (_ === null) {
          if ((this.recordDroppedEvent("before_send", u), a)) {
            const T = 1 + (t.spans || []).length;
            this.recordDroppedEvent("before_send", "span", T);
          }
          throw yd(`${f} returned \`null\`, will not send event.`);
        }
        const p = r.getSession() || o.getSession();
        if ((c && p && this._updateSessionFromEvent(p, _), a)) {
          const h = _.sdkProcessingMetadata?.spanCountBeforeProcessing || 0,
            T = _.spans ? _.spans.length : 0,
            m = h - T;
          m > 0 && this.recordDroppedEvent("before_send", "span", m);
        }
        const E = _.transaction_info;
        if (a && E && _.transaction !== t.transaction) {
          const h = "custom";
          _.transaction_info = {
            ...E,
            source: h,
          };
        }
        return (this.sendEvent(_, n), _);
      })
      .then(null, (_) => {
        throw hg(_) || Eg(_)
          ? _
          : (this.captureException(_, {
              mechanism: {
                handled: !1,
                type: "internal",
              },
              data: {
                __sentry__: !0,
              },
              originalException: _,
            }),
            tu(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${_}`));
      });
  }
  _process(t, n) {
    (this._numProcessing++,
      this._promiseBuffer.add(t).then(
        (r) => (this._numProcessing--, r),
        (r) => (
          this._numProcessing--,
          r === CE && this.recordDroppedEvent("queue_overflow", n),
          r
        ),
      ));
  }
  _clearOutcomes() {
    const t = this._outcomes;
    return (
      (this._outcomes = {}),
      Object.entries(t).map(([n, r]) => {
        const [o, s] = n.split(":");
        return {
          reason: o,
          category: s,
          quantity: r,
        };
      })
    );
  }
  _flushOutcomes() {
    le && $.log("Flushing outcomes...");
    const t = this._clearOutcomes();
    if (t.length === 0) {
      le && $.log("No outcomes to send");
      return;
    }
    if (!this._dsn) {
      le && $.log("No dsn provided, will not send outcomes");
      return;
    }
    le && $.log("Sending outcomes:", t);
    const n = AG(t, this._options.tunnel && uo(this._dsn));
    this.sendEnvelope(n);
  }
}
function Sg(e) {
  return e === "replay_event" ? "replay" : e || "error";
}
function OG(e, t) {
  const n = `${t} must return \`null\` or a valid event.`;
  if (tr(e))
    return e.then(
      (r) => {
        if (!nc(r) && r !== null) throw tu(n);
        return r;
      },
      (r) => {
        throw tu(`${t} rejected with ${r}`);
      },
    );
  if (!nc(e) && e !== null) throw tu(n);
  return e;
}
function CG(e, t, n, r) {
  const {
    beforeSend: o,
    beforeSendTransaction: s,
    beforeSendSpan: i,
    ignoreSpans: a,
  } = t;
  let c = n;
  if (Tp(c) && o) return o(c, r);
  if (RP(c)) {
    if (i || a) {
      const l = gG(c);
      if (a?.length && _p(l, a)) return null;
      if (i) {
        const f = i(l);
        f ? (c = mc(n, RG(f))) : fp();
      }
      if (c.spans) {
        const f = [],
          d = c.spans;
        for (const _ of d) {
          if (a?.length && _p(_, a)) {
            a1(d, _);
            continue;
          }
          if (i) {
            const p = i(_);
            p ? f.push(p) : (fp(), f.push(_));
          } else f.push(_);
        }
        const u = c.spans.length - f.length;
        (u && e.recordDroppedEvent("before_send", "span", u), (c.spans = f));
      }
    }
    if (s) {
      if (c.spans) {
        const l = c.spans.length;
        c.sdkProcessingMetadata = {
          ...n.sdkProcessingMetadata,
          spanCountBeforeProcessing: l,
        };
      }
      return s(c, r);
    }
  }
  return c;
}
function Tp(e) {
  return e.type === void 0;
}
function RP(e) {
  return e.type === "transaction";
}
function bG(e) {
  let t = 0;
  return (e.name && (t += e.name.length * 2), (t += 8), t + NP(e.attributes));
}
function IG(e) {
  let t = 0;
  return (e.message && (t += e.message.length * 2), t + NP(e.attributes));
}
function NP(e) {
  if (!e) return 0;
  let t = 0;
  return (
    Object.values(e).forEach((n) => {
      Array.isArray(n)
        ? (t += n.length * mg(n[0]))
        : GI(n)
          ? (t += mg(n))
          : (t += 100);
    }),
    t
  );
}
function mg(e) {
  return typeof e == "string"
    ? e.length * 2
    : typeof e == "number"
      ? 8
      : typeof e == "boolean"
        ? 4
        : 0;
}
function PG(e, t, n, r, o) {
  const s = {
    sent_at: new Date().toISOString(),
  };
  (n?.sdk &&
    (s.sdk = {
      name: n.sdk.name,
      version: n.sdk.version,
    }),
    r && o && (s.dsn = uo(o)),
    t && (s.trace = t));
  const i = MG(e);
  return nr(s, [i]);
}
function MG(e) {
  return [
    {
      type: "check_in",
    },
    e,
  ];
}
function vG(e) {
  const t = e._metadata?.sdk,
    n = t?.name && t?.version ? `${t?.name}/${t?.version}` : void 0;
  e.transportOptions = {
    ...e.transportOptions,
    headers: {
      ...(n && {
        "user-agent": n,
      }),
      ...e.transportOptions?.headers,
    },
  };
}
function yP(e, t) {
  return e(t.stack || "", 1);
}
function OP(e, t) {
  const n = {
      type: t.name || t.constructor.name,
      value: t.message,
    },
    r = yP(e, t);
  return (
    r.length &&
      (n.stacktrace = {
        frames: r,
      }),
    n
  );
}
function LG(e) {
  for (const t in e)
    if (Object.prototype.hasOwnProperty.call(e, t)) {
      const n = e[t];
      if (n instanceof Error) return n;
    }
}
function DG(e) {
  if ("name" in e && typeof e.name == "string") {
    let r = `'${e.name}' captured as exception`;
    return (
      "message" in e &&
        typeof e.message == "string" &&
        (r += ` with message '${e.message}'`),
      r
    );
  } else if ("message" in e && typeof e.message == "string") return e.message;
  const t = fk(e);
  if (ek(e))
    return `Event \`ErrorEvent\` captured as exception with message \`${e.message}\``;
  const n = wG(e);
  return `${n && n !== "Object" ? `'${n}'` : "Object"} captured as exception with keys: ${t}`;
}
function wG(e) {
  try {
    const t = Object.getPrototypeOf(e);
    return t ? t.constructor.name : void 0;
  } catch {}
}
function UG(e, t, n, r) {
  if (pu(n)) return [n, void 0];
  if (((t.synthetic = !0), nc(n))) {
    const s = e?.getOptions().normalizeDepth,
      i = {
        __serialized__: eP(n, s),
      },
      a = LG(n);
    if (a) return [a, i];
    const c = DG(n),
      l = r?.syntheticException || new Error(c);
    return ((l.message = c), [l, i]);
  }
  const o = r?.syntheticException || new Error(n);
  return ((o.message = `${n}`), [o, void 0]);
}
function kG(e, t, n, r) {
  const s = (r?.data && r.data.mechanism) || {
      handled: !0,
      type: "generic",
    },
    [i, a] = UG(e, s, n, r),
    c = {
      exception: {
        values: [OP(t, i)],
      },
    };
  return (
    a && (c.extra = a),
    Tk(c),
    pE(c, s),
    {
      ...c,
      event_id: r?.event_id,
    }
  );
}
function GG(e, t, n = "info", r, o) {
  const s = {
    event_id: r?.event_id,
    level: n,
  };
  if (o && r?.syntheticException) {
    const i = yP(e, r.syntheticException);
    i.length &&
      ((s.exception = {
        values: [
          {
            value: t,
            stacktrace: {
              frames: i,
            },
          },
        ],
      }),
      pE(s, {
        synthetic: !0,
      }));
  }
  if (_E(t)) {
    const { __sentry_template_string__: i, __sentry_template_values__: a } = t;
    return (
      (s.logentry = {
        message: i,
        params: a,
      }),
      s
    );
  }
  return ((s.message = t), s);
}
class VG extends yG {
  constructor(t) {
    (i1(), vG(t), super(t), this._setUpMetricsProcessing());
  }
  eventFromException(t, n) {
    const r = kG(this, this._options.stackParser, t, n);
    return ((r.level = "error"), Ru(r));
  }
  eventFromMessage(t, n = "info", r) {
    return Ru(
      GG(this._options.stackParser, t, n, r, this._options.attachStacktrace),
    );
  }
  captureException(t, n, r) {
    return (Ag(n), super.captureException(t, n, r));
  }
  captureEvent(t, n, r) {
    return (
      !t.type && t.exception?.values && t.exception.values.length > 0 && Ag(n),
      super.captureEvent(t, n, r)
    );
  }
  captureCheckIn(t, n, r) {
    const o = "checkInId" in t && t.checkInId ? t.checkInId : Ft();
    if (!this._isEnabled())
      return (le && $.warn("SDK not enabled, will not capture check-in."), o);
    const s = this.getOptions(),
      { release: i, environment: a, tunnel: c } = s,
      l = {
        check_in_id: o,
        monitor_slug: t.monitorSlug,
        status: t.status,
        release: i,
        environment: a,
      };
    ("duration" in t && (l.duration = t.duration),
      n &&
        (l.monitor_config = {
          schedule: n.schedule,
          checkin_margin: n.checkinMargin,
          max_runtime: n.maxRuntime,
          timezone: n.timezone,
          failure_issue_threshold: n.failureIssueThreshold,
          recovery_threshold: n.recoveryThreshold,
        }));
    const [f, d] = aG(this, r);
    d &&
      (l.contexts = {
        trace: d,
      });
    const u = PG(l, f, this.getSdkMetadata(), c, this.getDsn());
    return (
      le && $.log("Sending checkin:", t.monitorSlug, t.status),
      this.sendEnvelope(u),
      o
    );
  }
  _prepareEvent(t, n, r, o) {
    return (
      this._options.platform &&
        (t.platform = t.platform || this._options.platform),
      this._options.runtime &&
        (t.contexts = {
          ...t.contexts,
          runtime: t.contexts?.runtime || this._options.runtime,
        }),
      this._options.serverName &&
        (t.server_name = t.server_name || this._options.serverName),
      super._prepareEvent(t, n, r, o)
    );
  }
  _setUpMetricsProcessing() {
    this.on("processMetric", (t) => {
      this._options.serverName &&
        (t.attributes = {
          "server.address": this._options.serverName,
          ...t.attributes,
        });
    });
  }
}
function Ag(e) {
  const t = je().getScopeData().sdkProcessingMetadata.requestSession;
  if (t) {
    const n = e?.mechanism?.handled ?? !0;
    n && t.status !== "crashed"
      ? (t.status = "errored")
      : n || (t.status = "crashed");
  }
}
const bE = new Set();
function xG(e) {
  e.forEach((t) => {
    (bE.add(t), le && $.log(`AI provider "${t}" wrapping will be skipped`));
  });
}
function IE(e) {
  return bE.has(e);
}
function $G() {
  (bE.clear(), le && $.log("Cleared AI provider skip registrations"));
}
const BG = "thismessage:/";
function HG(e, t) {
  const n = e.indexOf("://") <= 0 && e.indexOf("//") !== 0,
    r = n ? BG : void 0;
  try {
    if ("canParse" in URL && !URL.canParse(e, r)) return;
    const o = new URL(e, r);
    return n
      ? {
          isRelative: n,
          pathname: o.pathname,
          search: o.search,
          hash: o.hash,
        }
      : o;
  } catch {}
}
function El(e) {
  if (!e) return {};
  const t = e.match(
    /^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/,
  );
  if (!t) return {};
  const n = t[6] || "",
    r = t[8] || "";
  return {
    host: t[4],
    path: t[5],
    protocol: t[2],
    search: n,
    hash: r,
    relative: t[5] + n + r,
  };
}
function ic(e) {
  return e.split(/[?#]/, 1)[0];
}
function hl(e) {
  const { protocol: t, host: n, path: r } = e,
    o =
      n
        ?.replace(/^.*@/, "[filtered]:[filtered]@")
        .replace(/(:80)$/, "")
        .replace(/(:443)$/, "") || "";
  return `${t ? `${t}://` : ""}${o}${r}`;
}
function PE(e, t, n = [t], r = "npm") {
  const o = e._metadata || {};
  (o.sdk ||
    (o.sdk = {
      name: `sentry.javascript.${t}`,
      packages: n.map((s) => ({
        name: `${r}:@sentry/${s}`,
        version: Ze,
      })),
      version: Ze,
    }),
    (e._metadata = o));
}
function CP(e = {}) {
  const t = e.client || he();
  if (!Z1() || !t) return {};
  const n = Fn(),
    r = co(n);
  if (r.getTraceData) return r.getTraceData(e);
  const o = e.scope || Ke(),
    s = e.span || fl(),
    i = s ? t1(s) : FG(o),
    a = s ? Vt(s) : gc(t, o),
    c = AE(a);
  if (!KI.test(i))
    return (
      $.warn("Invalid sentry-trace data. Cannot generate trace data"),
      {}
    );
  const f = {
    "sentry-trace": i,
    baggage: c,
  };
  if (e.propagateTraceparent) {
    const d = s ? n1(s) : YG(o);
    d && (f.traceparent = d);
  }
  return f;
}
function FG(e) {
  const {
    traceId: t,
    sampled: n,
    propagationSpanId: r,
  } = e.getPropagationContext();
  return cl(t, r, n);
}
function YG(e) {
  const {
    traceId: t,
    sampled: n,
    propagationSpanId: r,
  } = e.getPropagationContext();
  return ZI(t, r, n);
}
function jG(e, t, n) {
  let r, o, s;
  const i = Math.max(n.maxWait, t),
    a = n?.setTimeoutImpl || setTimeout;
  function c() {
    return (l(), (r = e()), r);
  }
  function l() {
    (o !== void 0 && clearTimeout(o),
      s !== void 0 && clearTimeout(s),
      (o = s = void 0));
  }
  function f() {
    return o !== void 0 || s !== void 0 ? c() : r;
  }
  function d() {
    return (
      o && clearTimeout(o),
      (o = a(c, t)),
      i && s === void 0 && (s = a(c, i)),
      r
    );
  }
  return ((d.cancel = l), (d.flush = f), d);
}
function qG(e) {
  const t = Object.create(null);
  try {
    Object.entries(e).forEach(([n, r]) => {
      typeof r == "string" && (t[n] = r);
    });
  } catch {}
  return t;
}
function WG(e) {
  const t = e.headers || {},
    r =
      (typeof t["x-forwarded-host"] == "string"
        ? t["x-forwarded-host"]
        : void 0) || (typeof t.host == "string" ? t.host : void 0),
    s =
      (typeof t["x-forwarded-proto"] == "string"
        ? t["x-forwarded-proto"]
        : void 0) ||
      e.protocol ||
      (e.socket?.encrypted ? "https" : "http"),
    i = e.url || "",
    a = KG({
      url: i,
      host: r,
      protocol: s,
    }),
    c = e.body || void 0,
    l = e.cookies;
  return {
    url: a,
    method: e.method,
    query_string: XG(i),
    headers: qG(t),
    cookies: l,
    data: c,
  };
}
function KG({ url: e, protocol: t, host: n }) {
  if (e?.startsWith("http")) return e;
  if (e && n) return `${t}://${n}${e}`;
}
const zG = [
  "auth",
  "token",
  "secret",
  "cookie",
  "-user",
  "password",
  "key",
  "jwt",
  "bearer",
  "sso",
  "saml",
];
function ZG(e) {
  const t = {};
  try {
    Object.entries(e).forEach(([n, r]) => {
      if (r == null) return;
      const o = n.toLowerCase(),
        s = zG.some((a) => o.includes(a)),
        i = `http.request.header.${o.replace(/-/g, "_")}`;
      s
        ? (t[i] = "[Filtered]")
        : Array.isArray(r)
          ? (t[i] = r.map((a) => (a != null ? String(a) : a)).join(";"))
          : typeof r == "string" && (t[i] = r);
    });
  } catch {}
  return t;
}
function XG(e) {
  if (e)
    try {
      const t = new URL(e, "http://s.io").search.slice(1);
      return t.length ? t : void 0;
    } catch {
      return;
    }
}
const QG = 100;
function $o(e, t) {
  const n = he(),
    r = je();
  if (!n) return;
  const { beforeBreadcrumb: o = null, maxBreadcrumbs: s = QG } = n.getOptions();
  if (s <= 0) return;
  const a = {
      timestamp: Sc(),
      ...e,
    },
    c = o ? on(() => o(a, t)) : a;
  c !== null &&
    (n.emit && n.emit("beforeAddBreadcrumb", c, t), r.addBreadcrumb(c, s));
}
let gg;
const JG = "FunctionToString",
  Rg = new WeakMap(),
  eV = () => ({
    name: JG,
    setupOnce() {
      gg = Function.prototype.toString;
      try {
        Function.prototype.toString = function (...e) {
          const t = dk(this),
            n = Rg.has(he()) && t !== void 0 ? t : this;
          return gg.apply(n, e);
        };
      } catch {}
    },
    setup(e) {
      Rg.set(e, !0);
    },
  }),
  tV = eV,
  nV = [
    /^Script error\.?$/,
    /^Javascript error: Script error\.? on line 0$/,
    /^ResizeObserver loop completed with undelivered notifications.$/,
    /^Cannot redefine property: googletag$/,
    /^Can't find variable: gmo$/,
    /^undefined is not an object \(evaluating 'a\.[A-Z]'\)$/,
    `can't redefine non-configurable property "solana"`,
    "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)",
    "Can't find variable: _AutofillCallbackHandler",
    /^Non-Error promise rejection captured with value: Object Not Found Matching Id:\d+, MethodName:simulateEvent, ParamCount:\d+$/,
    /^Java exception was raised during method invocation$/,
  ],
  rV = "EventFilters",
  oV = (e = {}) => {
    let t;
    return {
      name: rV,
      setup(n) {
        const r = n.getOptions();
        t = Ng(e, r);
      },
      processEvent(n, r, o) {
        if (!t) {
          const s = o.getOptions();
          t = Ng(e, s);
        }
        return iV(n, t) ? null : n;
      },
    };
  },
  sV = (e = {}) => ({
    ...oV(e),
    name: "InboundFilters",
  });
function Ng(e = {}, t = {}) {
  return {
    allowUrls: [...(e.allowUrls || []), ...(t.allowUrls || [])],
    denyUrls: [...(e.denyUrls || []), ...(t.denyUrls || [])],
    ignoreErrors: [
      ...(e.ignoreErrors || []),
      ...(t.ignoreErrors || []),
      ...(e.disableErrorDefaults ? [] : nV),
    ],
    ignoreTransactions: [
      ...(e.ignoreTransactions || []),
      ...(t.ignoreTransactions || []),
    ],
  };
}
function iV(e, t) {
  if (e.type) {
    if (e.type === "transaction" && cV(e, t.ignoreTransactions))
      return (
        le &&
          $.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${go(e)}`),
        !0
      );
  } else {
    if (aV(e, t.ignoreErrors))
      return (
        le &&
          $.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${go(e)}`),
        !0
      );
    if (fV(e))
      return (
        le &&
          $.warn(`Event dropped due to not having an error message, error type or stacktrace.
Event: ${go(e)}`),
        !0
      );
    if (uV(e, t.denyUrls))
      return (
        le &&
          $.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${go(e)}.
Url: ${Nu(e)}`),
        !0
      );
    if (!lV(e, t.allowUrls))
      return (
        le &&
          $.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${go(e)}.
Url: ${Nu(e)}`),
        !0
      );
  }
  return !1;
}
function aV(e, t) {
  return t?.length ? mP(e).some((n) => Tc(n, t)) : !1;
}
function cV(e, t) {
  if (!t?.length) return !1;
  const n = e.transaction;
  return n ? Tc(n, t) : !1;
}
function uV(e, t) {
  if (!t?.length) return !1;
  const n = Nu(e);
  return n ? Tc(n, t) : !1;
}
function lV(e, t) {
  if (!t?.length) return !0;
  const n = Nu(e);
  return n ? Tc(n, t) : !0;
}
function dV(e = []) {
  for (let t = e.length - 1; t >= 0; t--) {
    const n = e[t];
    if (n && n.filename !== "<anonymous>" && n.filename !== "[native code]")
      return n.filename || null;
  }
  return null;
}
function Nu(e) {
  try {
    const n = [...(e.exception?.values ?? [])]
      .reverse()
      .find(
        (r) =>
          r.mechanism?.parent_id === void 0 && r.stacktrace?.frames?.length,
      )?.stacktrace?.frames;
    return n ? dV(n) : null;
  } catch {
    return (le && $.error(`Cannot extract url for event ${go(e)}`), null);
  }
}
function fV(e) {
  return e.exception?.values?.length
    ? !e.message &&
        !e.exception.values.some(
          (t) => t.stacktrace || (t.type && t.type !== "Error") || t.value,
        )
    : !1;
}
function _V(e, t, n, r, o, s) {
  if (!o.exception?.values || !s || !Xr(s.originalException, Error)) return;
  const i =
    o.exception.values.length > 0
      ? o.exception.values[o.exception.values.length - 1]
      : void 0;
  i &&
    (o.exception.values = Sp(
      e,
      t,
      r,
      s.originalException,
      n,
      o.exception.values,
      i,
      0,
    ));
}
function Sp(e, t, n, r, o, s, i, a) {
  if (s.length >= n + 1) return s;
  let c = [...s];
  if (Xr(r[o], Error)) {
    yg(i, a);
    const l = e(t, r[o]),
      f = c.length;
    (Og(l, o, f, a), (c = Sp(e, t, n, r[o], o, [l, ...c], l, f)));
  }
  return (
    Array.isArray(r.errors) &&
      r.errors.forEach((l, f) => {
        if (Xr(l, Error)) {
          yg(i, a);
          const d = e(t, l),
            u = c.length;
          (Og(d, `errors[${f}]`, u, a),
            (c = Sp(e, t, n, l, o, [d, ...c], d, u)));
        }
      }),
    c
  );
}
function yg(e, t) {
  e.mechanism = {
    handled: !0,
    type: "auto.core.linked_errors",
    ...e.mechanism,
    ...(e.type === "AggregateError" && {
      is_exception_group: !0,
    }),
    exception_id: t,
  };
}
function Og(e, t, n, r) {
  e.mechanism = {
    handled: !0,
    ...e.mechanism,
    type: "chained",
    source: t,
    exception_id: n,
    parent_id: r,
  };
}
const pV = "cause",
  EV = 5,
  hV = "LinkedErrors",
  TV = (e = {}) => {
    const t = e.limit || EV,
      n = e.key || pV;
    return {
      name: hV,
      preprocessEvent(r, o, s) {
        const i = s.getOptions();
        _V(OP, i.stackParser, n, t, r, o);
      },
    };
  },
  SV = TV;
function mV(e) {
  const t = {};
  let n = 0;
  for (; n < e.length; ) {
    const r = e.indexOf("=", n);
    if (r === -1) break;
    let o = e.indexOf(";", n);
    if (o === -1) o = e.length;
    else if (o < r) {
      n = e.lastIndexOf(";", r - 1) + 1;
      continue;
    }
    const s = e.slice(n, r).trim();
    if (t[s] === void 0) {
      let i = e.slice(r + 1, o).trim();
      i.charCodeAt(0) === 34 && (i = i.slice(1, -1));
      try {
        t[s] = i.indexOf("%") !== -1 ? decodeURIComponent(i) : i;
      } catch {
        t[s] = i;
      }
    }
    n = o + 1;
  }
  return t;
}
const bP = [
  "X-Client-IP",
  "X-Forwarded-For",
  "Fly-Client-IP",
  "CF-Connecting-IP",
  "Fastly-Client-Ip",
  "True-Client-Ip",
  "X-Real-IP",
  "X-Cluster-Client-IP",
  "X-Forwarded",
  "Forwarded-For",
  "Forwarded",
  "X-Vercel-Forwarded-For",
];
function AV(e) {
  return (
    bP
      .map((o) => {
        const s = e[o],
          i = Array.isArray(s) ? s.join(";") : s;
        return o === "Forwarded" ? gV(i) : i?.split(",").map((a) => a.trim());
      })
      .reduce((o, s) => (s ? o.concat(s) : o), [])
      .find((o) => o !== null && RV(o)) || null
  );
}
function gV(e) {
  if (!e) return null;
  for (const t of e.split(";")) if (t.startsWith("for=")) return t.slice(4);
  return null;
}
function RV(e) {
  return /(?:^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}$)|(?:^(?:(?:[a-fA-F\d]{1,4}:){7}(?:[a-fA-F\d]{1,4}|:)|(?:[a-fA-F\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|:[a-fA-F\d]{1,4}|:)|(?:[a-fA-F\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,2}|:)|(?:[a-fA-F\d]{1,4}:){4}(?:(?::[a-fA-F\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,3}|:)|(?:[a-fA-F\d]{1,4}:){3}(?:(?::[a-fA-F\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,4}|:)|(?:[a-fA-F\d]{1,4}:){2}(?:(?::[a-fA-F\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,5}|:)|(?:[a-fA-F\d]{1,4}:){1}(?:(?::[a-fA-F\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,6}|:)|(?::(?:(?::[a-fA-F\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,7}|:)))(?:%[0-9a-zA-Z]{1,})?$)/.test(
    e,
  );
}
const NV = {
    cookies: !0,
    data: !0,
    headers: !0,
    query_string: !0,
    url: !0,
  },
  yV = "RequestData",
  OV = (e = {}) => {
    const t = {
      ...NV,
      ...e.include,
    };
    return {
      name: yV,
      processEvent(n, r, o) {
        const { sdkProcessingMetadata: s = {} } = n,
          { normalizedRequest: i, ipAddress: a } = s,
          c = {
            ...t,
            ip: t.ip ?? o.getOptions().sendDefaultPii,
          };
        return (
          i &&
            bV(
              n,
              i,
              {
                ipAddress: a,
              },
              c,
            ),
          n
        );
      },
    };
  },
  CV = OV;
function bV(e, t, n, r) {
  if (
    ((e.request = {
      ...e.request,
      ...IV(t, r),
    }),
    r.ip)
  ) {
    const o = (t.headers && AV(t.headers)) || n.ipAddress;
    o &&
      (e.user = {
        ...e.user,
        ip_address: o,
      });
  }
}
function IV(e, t) {
  const n = {},
    r = {
      ...e.headers,
    };
  if (
    (t.headers &&
      ((n.headers = r),
      t.cookies || delete r.cookie,
      t.ip ||
        bP.forEach((o) => {
          delete r[o];
        })),
    (n.method = e.method),
    t.url && (n.url = e.url),
    t.cookies)
  ) {
    const o = e.cookies || (r?.cookie ? mV(r.cookie) : void 0);
    n.cookies = o || {};
  }
  return (
    t.query_string && (n.query_string = e.query_string),
    t.data && (n.data = e.data),
    n
  );
}
function PV(e) {
  const t = "console";
  (lE(t, e), dE(t, MV));
}
function MV() {
  "console" in ye &&
    PI.forEach(function (e) {
      e in ye.console &&
        uk(ye.console, e, function (t) {
          return (
            (_u[e] = t),
            function (...n) {
              (fE("console", {
                args: n,
                level: e,
              }),
                _u[e]?.apply(ye.console, n));
            }
          );
        });
    });
}
function vV(e) {
  return e === "warn"
    ? "warning"
    : ["fatal", "error", "warning", "log", "info", "debug"].includes(e)
      ? e
      : "log";
}
function LV(e, t) {
  let n = 0;
  for (let r = e.length - 1; r >= 0; r--) {
    const o = e[r];
    o === "."
      ? e.splice(r, 1)
      : o === ".."
        ? (e.splice(r, 1), n++)
        : n && (e.splice(r, 1), n--);
  }
  if (t) for (; n--; n) e.unshift("..");
  return e;
}
const DV =
  /^(\S+:\\|\/?)([\s\S]*?)((?:\.{1,2}|[^/\\]+?|)(\.[^./\\]*|))(?:[/\\]*)$/;
function IP(e) {
  const t = e.length > 1024 ? `<truncated>${e.slice(-1024)}` : e,
    n = DV.exec(t);
  return n ? n.slice(1) : [];
}
function Cg(...e) {
  let t = "",
    n = !1;
  for (let r = e.length - 1; r >= -1 && !n; r--) {
    const o = r >= 0 ? e[r] : "/";
    o && ((t = `${o}/${t}`), (n = o.charAt(0) === "/"));
  }
  return (
    (t = LV(
      t.split("/").filter((r) => !!r),
      !n,
    ).join("/")),
    (n ? "/" : "") + t || "."
  );
}
function bg(e) {
  let t = 0;
  for (; t < e.length && e[t] === ""; t++);
  let n = e.length - 1;
  for (; n >= 0 && e[n] === ""; n--);
  return t > n ? [] : e.slice(t, n - t + 1);
}
function wV(e, t) {
  ((e = Cg(e).slice(1)), (t = Cg(t).slice(1)));
  const n = bg(e.split("/")),
    r = bg(t.split("/")),
    o = Math.min(n.length, r.length);
  let s = o;
  for (let a = 0; a < o; a++)
    if (n[a] !== r[a]) {
      s = a;
      break;
    }
  let i = [];
  for (let a = s; a < n.length; a++) i.push("..");
  return ((i = i.concat(r.slice(s))), i.join("/"));
}
function UV(e) {
  const t = IP(e),
    n = t[0] || "";
  let r = t[1];
  return !n && !r ? "." : (r && (r = r.slice(0, r.length - 1)), n + r);
}
function kV(e, t) {
  return IP(e)[2] || "";
}
const GV = "RewriteFrames",
  VV = (e = {}) => {
    const t = e.root,
      n = e.prefix || "app:///",
      r = "window" in ye && !!ye.window,
      o =
        e.iteratee ||
        xV({
          isBrowser: r,
          root: t,
          prefix: n,
        });
    function s(a) {
      try {
        return {
          ...a,
          exception: {
            ...a.exception,
            values: a.exception.values.map((c) => ({
              ...c,
              ...(c.stacktrace && {
                stacktrace: i(c.stacktrace),
              }),
            })),
          },
        };
      } catch {
        return a;
      }
    }
    function i(a) {
      return {
        ...a,
        frames: a?.frames?.map((c) => o(c)),
      };
    }
    return {
      name: GV,
      processEvent(a) {
        let c = a;
        return (
          a.exception && Array.isArray(a.exception.values) && (c = s(c)),
          c
        );
      },
    };
  };
function xV({ isBrowser: e, root: t, prefix: n }) {
  return (r) => {
    if (!r.filename) return r;
    const o =
        /^[a-zA-Z]:\\/.test(r.filename) ||
        (r.filename.includes("\\") && !r.filename.includes("/")),
      s = /^\//.test(r.filename);
    if (e) {
      if (t) {
        const i = r.filename;
        i.indexOf(t) === 0 && (r.filename = i.replace(t, n));
      }
    } else if (o || s) {
      const i = o
          ? r.filename.replace(/^[a-zA-Z]:/, "").replace(/\\/g, "/")
          : r.filename,
        a = t ? wV(t, i) : kV(i);
      r.filename = `${n}${a}`;
    }
    return r;
  };
}
const $V = "Console",
  BV = (e = {}) => {
    const t = new Set(e.levels || PI);
    return {
      name: $V,
      setup(n) {
        PV(({ args: r, level: o }) => {
          he() !== n || !t.has(o) || HV(o, r);
        });
      },
    };
  };
function HV(e, t) {
  const n = {
    category: "console",
    data: {
      arguments: t,
      logger: "console",
    },
    level: vV(e),
    message: Ig(t),
  };
  if (e === "assert")
    if (t[0] === !1) {
      const r = t.slice(1);
      ((n.message =
        r.length > 0 ? `Assertion failed: ${Ig(r)}` : "Assertion failed"),
        (n.data.arguments = r));
    } else return;
  $o(n, {
    input: t,
    level: e,
  });
}
function Ig(e) {
  return "util" in ye && typeof ye.util.format == "function"
    ? ye.util.format(...e)
    : pk(e, " ");
}
const FV = "gen_ai.prompt",
  Tl = "gen_ai.system",
  Nt = "gen_ai.request.model",
  ME = "gen_ai.request.stream",
  Sl = "gen_ai.request.temperature",
  vE = "gen_ai.request.max_tokens",
  ml = "gen_ai.request.frequency_penalty",
  LE = "gen_ai.request.presence_penalty",
  Al = "gen_ai.request.top_p",
  PP = "gen_ai.request.top_k",
  YV = "gen_ai.request.encoding_format",
  jV = "gen_ai.request.dimensions",
  rr = "gen_ai.response.finish_reasons",
  An = "gen_ai.response.model",
  Jo = "gen_ai.response.id",
  qV = "gen_ai.response.stop_reason",
  jt = "gen_ai.usage.input_tokens",
  qt = "gen_ai.usage.output_tokens",
  no = "gen_ai.usage.total_tokens",
  Hn = "gen_ai.operation.name",
  Gt = "gen_ai.request.messages",
  Wt = "gen_ai.response.text",
  gl = "gen_ai.request.available_tools",
  Rl = "gen_ai.response.streaming",
  Nn = "gen_ai.response.tool_calls",
  MP = "gen_ai.agent.name",
  WV = "gen_ai.pipeline.name",
  KV = "gen_ai.usage.cache_creation_input_tokens",
  zV = "gen_ai.usage.cache_read_input_tokens",
  Pg = "gen_ai.usage.input_tokens.cache_write",
  xa = "gen_ai.usage.input_tokens.cached",
  ZV = "gen_ai.invoke_agent",
  XV = "openai.response.id",
  vP = "openai.response.model",
  QV = "openai.response.timestamp",
  JV = "openai.usage.completion_tokens",
  ex = "openai.usage.prompt_tokens",
  Od = {
    CHAT: "chat",
    RESPONSES: "responses",
    EMBEDDINGS: "embeddings",
  },
  Mg = "anthropic.response.timestamp",
  DE = new Map(),
  LP = 2e4,
  yu = (e) => new TextEncoder().encode(e).length,
  Ou = (e) => yu(JSON.stringify(e));
function wE(e, t) {
  if (yu(e) <= t) return e;
  let n = 0,
    r = e.length,
    o = "";
  for (; n <= r; ) {
    const s = Math.floor((n + r) / 2),
      i = e.slice(0, s);
    yu(i) <= t ? ((o = i), (n = s + 1)) : (r = s - 1);
  }
  return o;
}
function tx(e) {
  return typeof e == "string" ? e : e.text;
}
function vg(e, t) {
  return typeof e == "string"
    ? t
    : {
        ...e,
        text: t,
      };
}
function nx(e) {
  return (
    e !== null &&
    typeof e == "object" &&
    "content" in e &&
    typeof e.content == "string"
  );
}
function rx(e) {
  return (
    e !== null &&
    typeof e == "object" &&
    "parts" in e &&
    Array.isArray(e.parts) &&
    e.parts.length > 0
  );
}
function ox(e, t) {
  const n = {
      ...e,
      content: "",
    },
    r = Ou(n),
    o = t - r;
  if (o <= 0) return [];
  const s = wE(e.content, o);
  return [
    {
      ...e,
      content: s,
    },
  ];
}
function sx(e, t) {
  const { parts: n } = e,
    r = n.map((a) => vg(a, "")),
    o = Ou({
      ...e,
      parts: r,
    });
  let s = t - o;
  if (s <= 0) return [];
  const i = [];
  for (const a of n) {
    const c = tx(a),
      l = yu(c);
    if (l <= s) (i.push(a), (s -= l));
    else if (i.length === 0) {
      const f = wE(c, s);
      f && i.push(vg(a, f));
      break;
    } else break;
  }
  return i.length > 0
    ? [
        {
          ...e,
          parts: i,
        },
      ]
    : [];
}
function ix(e, t) {
  return !e || typeof e != "object"
    ? []
    : nx(e)
      ? ox(e, t)
      : rx(e)
        ? sx(e, t)
        : [];
}
function ax(e, t) {
  if (!Array.isArray(e) || e.length === 0 || Ou(e) <= t) return e;
  const r = e.map(Ou);
  let o = 0,
    s = e.length;
  for (let i = e.length - 1; i >= 0; i--) {
    const a = r[i];
    if (a && o + a > t) break;
    (a && (o += a), (s = i));
  }
  if (s === e.length) {
    const i = e[e.length - 1];
    return ix(i, t);
  }
  return e.slice(s);
}
function UE(e) {
  return ax(e, LP);
}
function cx(e) {
  return wE(e, LP);
}
function Rc(e) {
  return e.includes("messages")
    ? "messages"
    : e.includes("completions")
      ? "completions"
      : e.includes("models")
        ? "models"
        : e.includes("chat")
          ? "chat"
          : e.split(".").pop() || "unknown";
}
function Cu(e) {
  return `gen_ai.${Rc(e)}`;
}
function DP(e, t) {
  return e ? `${e}.${t}` : t;
}
function kE(e, t, n, r, o) {
  if (
    (t !== void 0 &&
      e.setAttributes({
        [jt]: t,
      }),
    n !== void 0 &&
      e.setAttributes({
        [qt]: n,
      }),
    t !== void 0 || n !== void 0 || r !== void 0 || o !== void 0)
  ) {
    const s = (t ?? 0) + (n ?? 0) + (r ?? 0) + (o ?? 0);
    e.setAttributes({
      [no]: s,
    });
  }
}
function Vn(e) {
  if (typeof e == "string") return cx(e);
  if (Array.isArray(e)) {
    const t = UE(e);
    return JSON.stringify(t);
  }
  return JSON.stringify(e);
}
const ux = "operation.name",
  Cd = "ai.prompt",
  lx = "ai.schema",
  dx = "ai.response.object",
  fx = "ai.response.text",
  _x = "ai.response.toolCalls",
  wP = "ai.prompt.messages",
  na = "ai.prompt.tools",
  fn = "ai.model.id",
  px = "ai.model.provider",
  Ex = "ai.response.providerMetadata",
  hx = "ai.usage.cachedInputTokens",
  Tx = "ai.telemetry.functionId",
  Sx = "ai.usage.completionTokens",
  mx = "ai.usage.promptTokens",
  UP = "ai.toolCall.name",
  kP = "ai.toolCall.id",
  Ax = "ai.toolCall.args",
  gx = "ai.toolCall.result";
function Rx(e, t) {
  const n = e.parent_span_id;
  if (!n) return;
  const r = e.data[jt],
    o = e.data[qt];
  if (typeof r == "number" || typeof o == "number") {
    const s = t.get(n) || {
      inputTokens: 0,
      outputTokens: 0,
    };
    (typeof r == "number" && (s.inputTokens += r),
      typeof o == "number" && (s.outputTokens += o),
      t.set(n, s));
  }
}
function Lg(e, t) {
  const n = t.get(e.span_id);
  !n ||
    !e.data ||
    (n.inputTokens > 0 && (e.data[jt] = n.inputTokens),
    n.outputTokens > 0 && (e.data[qt] = n.outputTokens),
    (n.inputTokens > 0 || n.outputTokens > 0) &&
      (e.data["gen_ai.usage.total_tokens"] = n.inputTokens + n.outputTokens));
}
function Nx(e) {
  return DE.get(e);
}
function yx(e) {
  DE.delete(e);
}
function Ox(e) {
  const t = e.map((n) => {
    if (typeof n == "string")
      try {
        return JSON.parse(n);
      } catch {
        return n;
      }
    return n;
  });
  return JSON.stringify(t);
}
function Cx(e) {
  try {
    const t = JSON.parse(e);
    if (t && typeof t == "object") {
      const { prompt: n, system: r } = t;
      if (typeof n == "string" || typeof r == "string") {
        const o = [];
        return (
          typeof r == "string" &&
            o.push({
              role: "system",
              content: r,
            }),
          typeof n == "string" &&
            o.push({
              role: "user",
              content: n,
            }),
          o
        );
      }
    }
  } catch {}
  return [];
}
function bx(e, t) {
  if (t[Cd]) {
    const r = Vn(t[Cd]);
    e.setAttribute("gen_ai.prompt", r);
  }
  const n = t[Cd];
  if (typeof n == "string" && !t[Gt] && !t[wP]) {
    const r = Cx(n);
    r.length && e.setAttribute(Gt, Vn(r));
  }
}
function GP(e, t) {
  e.setAttribute(Ge, t);
}
function Ix(e) {
  const { data: t, description: n } = Re(e);
  if (!n) return;
  if (t[UP] && t[kP] && n === "ai.toolCall") {
    vx(e, t);
    return;
  }
  const r = t[fn],
    o = t[px];
  typeof r != "string" || typeof o != "string" || !r || !o || Lx(e, n, t);
}
function Px(e) {
  if (e.type === "transaction" && e.spans) {
    const t = new Map();
    for (const r of e.spans) (Mx(r), Rx(r, t));
    for (const r of e.spans) r.op === "gen_ai.invoke_agent" && Lg(r, t);
    const n = e.contexts?.trace;
    n && n.op === "gen_ai.invoke_agent" && Lg(n, t);
  }
  return e;
}
function Mx(e) {
  const { data: t, origin: n } = e;
  if (n === "auto.vercelai.otel") {
    (ct(t, Sx, qt),
      ct(t, mx, jt),
      ct(t, hx, xa),
      typeof t[qt] == "number" &&
        typeof t[jt] == "number" &&
        (t["gen_ai.usage.total_tokens"] = t[qt] + t[jt]),
      t[na] && Array.isArray(t[na]) && (t[na] = Ox(t[na])),
      ct(t, ux, Hn),
      ct(t, wP, Gt),
      ct(t, fx, "gen_ai.response.text"),
      ct(t, _x, "gen_ai.response.tool_calls"),
      ct(t, dx, "gen_ai.response.object"),
      ct(t, na, "gen_ai.request.available_tools"),
      ct(t, Ax, "gen_ai.tool.input"),
      ct(t, gx, "gen_ai.tool.output"),
      ct(t, lx, "gen_ai.request.schema"),
      ct(t, fn, Nt),
      Dx(t));
    for (const r of Object.keys(t))
      r.startsWith("ai.") && ct(t, r, `vercel.${r}`);
  }
}
function ct(e, t, n) {
  e[t] != null && ((e[n] = e[t]), delete e[t]);
}
function vx(e, t) {
  (GP(e, "auto.vercelai.otel"),
    e.setAttribute(Ee, "gen_ai.execute_tool"),
    ct(t, UP, "gen_ai.tool.name"),
    ct(t, kP, "gen_ai.tool.call.id"));
  const n = t["gen_ai.tool.call.id"];
  (typeof n == "string" && DE.set(n, e),
    t["gen_ai.tool.type"] || e.setAttribute("gen_ai.tool.type", "function"));
  const r = t["gen_ai.tool.name"];
  r && e.updateName(`execute_tool ${r}`);
}
function Lx(e, t, n) {
  GP(e, "auto.vercelai.otel");
  const r = t.replace("ai.", "");
  (e.setAttribute("ai.pipeline.name", r), e.updateName(r));
  const o = n[Tx];
  if (
    (o &&
      typeof o == "string" &&
      (e.updateName(`${r} ${o}`), e.setAttribute("gen_ai.function_id", o)),
    bx(e, n),
    n[fn] && !n[An] && e.setAttribute(An, n[fn]),
    e.setAttribute("ai.streaming", t.includes("stream")),
    t === "ai.generateText")
  ) {
    e.setAttribute(Ee, "gen_ai.invoke_agent");
    return;
  }
  if (t === "ai.generateText.doGenerate") {
    (e.setAttribute(Ee, "gen_ai.generate_text"),
      e.updateName(`generate_text ${n[fn]}`));
    return;
  }
  if (t === "ai.streamText") {
    e.setAttribute(Ee, "gen_ai.invoke_agent");
    return;
  }
  if (t === "ai.streamText.doStream") {
    (e.setAttribute(Ee, "gen_ai.stream_text"),
      e.updateName(`stream_text ${n[fn]}`));
    return;
  }
  if (t === "ai.generateObject") {
    e.setAttribute(Ee, "gen_ai.invoke_agent");
    return;
  }
  if (t === "ai.generateObject.doGenerate") {
    (e.setAttribute(Ee, "gen_ai.generate_object"),
      e.updateName(`generate_object ${n[fn]}`));
    return;
  }
  if (t === "ai.streamObject") {
    e.setAttribute(Ee, "gen_ai.invoke_agent");
    return;
  }
  if (t === "ai.streamObject.doStream") {
    (e.setAttribute(Ee, "gen_ai.stream_object"),
      e.updateName(`stream_object ${n[fn]}`));
    return;
  }
  if (t === "ai.embed") {
    e.setAttribute(Ee, "gen_ai.invoke_agent");
    return;
  }
  if (t === "ai.embed.doEmbed") {
    (e.setAttribute(Ee, "gen_ai.embed"), e.updateName(`embed ${n[fn]}`));
    return;
  }
  if (t === "ai.embedMany") {
    e.setAttribute(Ee, "gen_ai.invoke_agent");
    return;
  }
  if (t === "ai.embedMany.doEmbed") {
    (e.setAttribute(Ee, "gen_ai.embed_many"),
      e.updateName(`embed_many ${n[fn]}`));
    return;
  }
  if (t.startsWith("ai.stream")) {
    e.setAttribute(Ee, "ai.run");
    return;
  }
}
function Dg(e) {
  (e.on("spanStart", Ix),
    e.addEventProcessor(
      Object.assign(Px, {
        id: "VercelAiEventProcessor",
      }),
    ));
}
function Dx(e) {
  const t = e[Ex];
  if (t)
    try {
      const n = JSON.parse(t);
      if (
        (n.openai &&
          (en(e, xa, n.openai.cachedPromptTokens),
          en(
            e,
            "gen_ai.usage.output_tokens.reasoning",
            n.openai.reasoningTokens,
          ),
          en(
            e,
            "gen_ai.usage.output_tokens.prediction_accepted",
            n.openai.acceptedPredictionTokens,
          ),
          en(
            e,
            "gen_ai.usage.output_tokens.prediction_rejected",
            n.openai.rejectedPredictionTokens,
          ),
          en(e, "gen_ai.conversation.id", n.openai.responseId)),
        n.anthropic)
      ) {
        const r =
          n.anthropic.usage?.cache_read_input_tokens ??
          n.anthropic.cacheReadInputTokens;
        en(e, xa, r);
        const o =
          n.anthropic.usage?.cache_creation_input_tokens ??
          n.anthropic.cacheCreationInputTokens;
        en(e, Pg, o);
      }
      (n.bedrock?.usage &&
        (en(e, xa, n.bedrock.usage.cacheReadInputTokens),
        en(e, Pg, n.bedrock.usage.cacheWriteInputTokens)),
        n.deepseek &&
          (en(e, xa, n.deepseek.promptCacheHitTokens),
          en(
            e,
            "gen_ai.usage.input_tokens.cache_miss",
            n.deepseek.promptCacheMissTokens,
          )));
    } catch {}
}
function en(e, t, n) {
  n != null && (e[t] = n);
}
const Nl = "OpenAI",
  wx = ["responses.create", "chat.completions.create", "embeddings.create"],
  Ux = [
    "response.output_item.added",
    "response.function_call_arguments.delta",
    "response.function_call_arguments.done",
    "response.output_item.done",
  ],
  kx = [
    "response.created",
    "response.in_progress",
    "response.failed",
    "response.completed",
    "response.incomplete",
    "response.queued",
    "response.output_text.delta",
    ...Ux,
  ];
function GE(e) {
  return e.includes("chat.completions")
    ? Od.CHAT
    : e.includes("responses")
      ? Od.RESPONSES
      : e.includes("embeddings")
        ? Od.EMBEDDINGS
        : e.split(".").pop() || "unknown";
}
function wg(e) {
  return `gen_ai.${GE(e)}`;
}
function Gx(e) {
  return wx.includes(e);
}
function Vx(e, t) {
  return e ? `${e}.${t}` : t;
}
function xx(e) {
  return (
    e !== null &&
    typeof e == "object" &&
    "object" in e &&
    e.object === "chat.completion"
  );
}
function $x(e) {
  return (
    e !== null &&
    typeof e == "object" &&
    "object" in e &&
    e.object === "response"
  );
}
function Bx(e) {
  if (e === null || typeof e != "object" || !("object" in e)) return !1;
  const t = e;
  return (
    t.object === "list" &&
    typeof t.model == "string" &&
    t.model.toLowerCase().includes("embedding")
  );
}
function Hx(e) {
  return (
    e !== null &&
    typeof e == "object" &&
    "type" in e &&
    typeof e.type == "string" &&
    e.type.startsWith("response.")
  );
}
function Fx(e) {
  return (
    e !== null &&
    typeof e == "object" &&
    "object" in e &&
    e.object === "chat.completion.chunk"
  );
}
function Yx(e, t, n) {
  if (
    (VE(e, t.id, t.model, t.created),
    t.usage &&
      yl(
        e,
        t.usage.prompt_tokens,
        t.usage.completion_tokens,
        t.usage.total_tokens,
      ),
    Array.isArray(t.choices))
  ) {
    const r = t.choices.map((o) => o.finish_reason).filter((o) => o !== null);
    if (
      (r.length > 0 &&
        e.setAttributes({
          [rr]: JSON.stringify(r),
        }),
      n)
    ) {
      const o = t.choices
        .map((s) => s.message?.tool_calls)
        .filter((s) => Array.isArray(s) && s.length > 0)
        .flat();
      o.length > 0 &&
        e.setAttributes({
          [Nn]: JSON.stringify(o),
        });
    }
  }
}
function jx(e, t, n) {
  if (
    (VE(e, t.id, t.model, t.created_at),
    t.status &&
      e.setAttributes({
        [rr]: JSON.stringify([t.status]),
      }),
    t.usage &&
      yl(e, t.usage.input_tokens, t.usage.output_tokens, t.usage.total_tokens),
    n)
  ) {
    const r = t;
    if (Array.isArray(r.output) && r.output.length > 0) {
      const o = r.output.filter(
        (s) => typeof s == "object" && s !== null && s.type === "function_call",
      );
      o.length > 0 &&
        e.setAttributes({
          [Nn]: JSON.stringify(o),
        });
    }
  }
}
function qx(e, t) {
  (e.setAttributes({
    [vP]: t.model,
    [An]: t.model,
  }),
    t.usage && yl(e, t.usage.prompt_tokens, void 0, t.usage.total_tokens));
}
function yl(e, t, n, r) {
  (t !== void 0 &&
    e.setAttributes({
      [ex]: t,
      [jt]: t,
    }),
    n !== void 0 &&
      e.setAttributes({
        [JV]: n,
        [qt]: n,
      }),
    r !== void 0 &&
      e.setAttributes({
        [no]: r,
      }));
}
function VE(e, t, n, r) {
  (e.setAttributes({
    [XV]: t,
    [Jo]: t,
  }),
    e.setAttributes({
      [vP]: n,
      [An]: n,
    }),
    e.setAttributes({
      [QV]: new Date(r * 1e3).toISOString(),
    }));
}
function Wx(e, t) {
  for (const n of e) {
    const r = n.index;
    if (!(r === void 0 || !n.function))
      if (!(r in t.chatCompletionToolCalls))
        t.chatCompletionToolCalls[r] = {
          ...n,
          function: {
            name: n.function.name,
            arguments: n.function.arguments || "",
          },
        };
      else {
        const o = t.chatCompletionToolCalls[r];
        n.function.arguments &&
          o?.function &&
          (o.function.arguments += n.function.arguments);
      }
  }
}
function Kx(e, t, n) {
  ((t.responseId = e.id ?? t.responseId),
    (t.responseModel = e.model ?? t.responseModel),
    (t.responseTimestamp = e.created ?? t.responseTimestamp),
    e.usage &&
      ((t.promptTokens = e.usage.prompt_tokens),
      (t.completionTokens = e.usage.completion_tokens),
      (t.totalTokens = e.usage.total_tokens)));
  for (const r of e.choices ?? [])
    (n &&
      (r.delta?.content && t.responseTexts.push(r.delta.content),
      r.delta?.tool_calls && Wx(r.delta.tool_calls, t)),
      r.finish_reason && t.finishReasons.push(r.finish_reason));
}
function zx(e, t, n, r) {
  if (!(e && typeof e == "object")) {
    t.eventTypes.push("unknown:non-object");
    return;
  }
  if (e instanceof Error) {
    (r.setStatus({
      code: Ae,
      message: "internal_error",
    }),
      xe(e, {
        mechanism: {
          handled: !1,
          type: "auto.ai.openai.stream-response",
        },
      }));
    return;
  }
  if (!("type" in e)) return;
  const o = e;
  if (!kx.includes(o.type)) {
    t.eventTypes.push(o.type);
    return;
  }
  if (
    n &&
    (o.type === "response.output_item.done" &&
      "item" in o &&
      t.responsesApiToolCalls.push(o.item),
    o.type === "response.output_text.delta" && "delta" in o && o.delta)
  ) {
    t.responseTexts.push(o.delta);
    return;
  }
  if ("response" in o) {
    const { response: s } = o;
    ((t.responseId = s.id ?? t.responseId),
      (t.responseModel = s.model ?? t.responseModel),
      (t.responseTimestamp = s.created_at ?? t.responseTimestamp),
      s.usage &&
        ((t.promptTokens = s.usage.input_tokens),
        (t.completionTokens = s.usage.output_tokens),
        (t.totalTokens = s.usage.total_tokens)),
      s.status && t.finishReasons.push(s.status),
      n && s.output_text && t.responseTexts.push(s.output_text));
  }
}
async function* Zx(e, t, n) {
  const r = {
    eventTypes: [],
    responseTexts: [],
    finishReasons: [],
    responseId: "",
    responseModel: "",
    responseTimestamp: 0,
    promptTokens: void 0,
    completionTokens: void 0,
    totalTokens: void 0,
    chatCompletionToolCalls: {},
    responsesApiToolCalls: [],
  };
  try {
    for await (const o of e)
      (Fx(o) ? Kx(o, r, n) : Hx(o) && zx(o, r, n, t), yield o);
  } finally {
    (VE(t, r.responseId, r.responseModel, r.responseTimestamp),
      yl(t, r.promptTokens, r.completionTokens, r.totalTokens),
      t.setAttributes({
        [Rl]: !0,
      }),
      r.finishReasons.length &&
        t.setAttributes({
          [rr]: JSON.stringify(r.finishReasons),
        }),
      n &&
        r.responseTexts.length &&
        t.setAttributes({
          [Wt]: r.responseTexts.join(""),
        }));
    const s = [
      ...Object.values(r.chatCompletionToolCalls),
      ...r.responsesApiToolCalls,
    ];
    (s.length > 0 &&
      t.setAttributes({
        [Nn]: JSON.stringify(s),
      }),
      t.end());
  }
}
function Xx(e, t) {
  const n = {
    [Tl]: "openai",
    [Hn]: GE(t),
    [Ge]: "auto.ai.openai",
  };
  if (e.length > 0 && typeof e[0] == "object" && e[0] !== null) {
    const r = e[0],
      o = Array.isArray(r.tools) ? r.tools : [],
      i =
        r.web_search_options && typeof r.web_search_options == "object"
          ? [
              {
                type: "web_search_options",
                ...r.web_search_options,
              },
            ]
          : [],
      a = [...o, ...i];
    a.length > 0 && (n[gl] = JSON.stringify(a));
  }
  if (e.length > 0 && typeof e[0] == "object" && e[0] !== null) {
    const r = e[0];
    ((n[Nt] = r.model ?? "unknown"),
      "temperature" in r && (n[Sl] = r.temperature),
      "top_p" in r && (n[Al] = r.top_p),
      "frequency_penalty" in r && (n[ml] = r.frequency_penalty),
      "presence_penalty" in r && (n[LE] = r.presence_penalty),
      "stream" in r && (n[ME] = r.stream),
      "encoding_format" in r && (n[YV] = r.encoding_format),
      "dimensions" in r && (n[jV] = r.dimensions));
  } else n[Nt] = "unknown";
  return n;
}
function Qx(e, t, n) {
  if (!t || typeof t != "object") return;
  const r = t;
  if (xx(r)) {
    if ((Yx(e, r, n), n && r.choices?.length)) {
      const o = r.choices.map((s) => s.message?.content || "");
      e.setAttributes({
        [Wt]: JSON.stringify(o),
      });
    }
  } else
    $x(r)
      ? (jx(e, r, n),
        n &&
          r.output_text &&
          e.setAttributes({
            [Wt]: r.output_text,
          }))
      : Bx(r) && qx(e, r);
}
function Ug(e, t) {
  if ("messages" in t) {
    const n = Vn(t.messages);
    e.setAttributes({
      [Gt]: n,
    });
  }
  if ("input" in t) {
    const n = Vn(t.input);
    e.setAttributes({
      [Gt]: n,
    });
  }
}
function Jx(e, t, n, r) {
  return async function (...s) {
    const i = Xx(s, t),
      a = i[Nt] || "unknown",
      c = GE(t),
      l = s[0];
    return l && typeof l == "object" && l.stream === !0
      ? Gn(
          {
            name: `${c} ${a} stream-response`,
            op: wg(t),
            attributes: i,
          },
          async (d) => {
            try {
              r.recordInputs && l && Ug(d, l);
              const u = await e.apply(n, s);
              return Zx(u, d, r.recordOutputs ?? !1);
            } catch (u) {
              throw (
                d.setStatus({
                  code: Ae,
                  message: "internal_error",
                }),
                xe(u, {
                  mechanism: {
                    handled: !1,
                    type: "auto.ai.openai.stream",
                    data: {
                      function: t,
                    },
                  },
                }),
                d.end(),
                u
              );
            }
          },
        )
      : Qo(
          {
            name: `${c} ${a}`,
            op: wg(t),
            attributes: i,
          },
          async (d) => {
            try {
              r.recordInputs && l && Ug(d, l);
              const u = await e.apply(n, s);
              return (Qx(d, u, r.recordOutputs), u);
            } catch (u) {
              throw (
                xe(u, {
                  mechanism: {
                    handled: !1,
                    type: "auto.ai.openai",
                    data: {
                      function: t,
                    },
                  },
                }),
                u
              );
            }
          },
        );
  };
}
function VP(e, t = "", n) {
  return new Proxy(e, {
    get(r, o) {
      const s = r[o],
        i = Vx(t, String(o));
      return typeof s == "function" && Gx(i)
        ? Jx(s, i, r, n)
        : typeof s == "function"
          ? s.bind(r)
          : s && typeof s == "object"
            ? VP(s, i, n)
            : s;
    },
  });
}
function e$(e, t) {
  const n = !!he()?.getOptions().sendDefaultPii,
    r = {
      recordInputs: n,
      recordOutputs: n,
      ...t,
    };
  return VP(e, "", r);
}
function t$(e, t) {
  return "type" in e && typeof e.type == "string" && e.type === "error"
    ? (t.setStatus({
        code: Ae,
        message: e.error?.type ?? "internal_error",
      }),
      xe(e.error, {
        mechanism: {
          handled: !1,
          type: "auto.ai.anthropic.anthropic_error",
        },
      }),
      !0)
    : !1;
}
function n$(e, t) {
  if (
    (e.type === "message_delta" &&
      e.usage &&
      "output_tokens" in e.usage &&
      typeof e.usage.output_tokens == "number" &&
      (t.completionTokens = e.usage.output_tokens),
    e.message)
  ) {
    const n = e.message;
    (n.id && (t.responseId = n.id),
      n.model && (t.responseModel = n.model),
      n.stop_reason && t.finishReasons.push(n.stop_reason),
      n.usage &&
        (typeof n.usage.input_tokens == "number" &&
          (t.promptTokens = n.usage.input_tokens),
        typeof n.usage.cache_creation_input_tokens == "number" &&
          (t.cacheCreationInputTokens = n.usage.cache_creation_input_tokens),
        typeof n.usage.cache_read_input_tokens == "number" &&
          (t.cacheReadInputTokens = n.usage.cache_read_input_tokens)));
  }
}
function r$(e, t) {
  e.type !== "content_block_start" ||
    typeof e.index != "number" ||
    !e.content_block ||
    ((e.content_block.type === "tool_use" ||
      e.content_block.type === "server_tool_use") &&
      (t.activeToolBlocks[e.index] = {
        id: e.content_block.id,
        name: e.content_block.name,
        inputJsonParts: [],
      }));
}
function o$(e, t, n) {
  if (!(e.type !== "content_block_delta" || !e.delta)) {
    if (
      typeof e.index == "number" &&
      "partial_json" in e.delta &&
      typeof e.delta.partial_json == "string"
    ) {
      const r = t.activeToolBlocks[e.index];
      r && r.inputJsonParts.push(e.delta.partial_json);
    }
    n && typeof e.delta.text == "string" && t.responseTexts.push(e.delta.text);
  }
}
function s$(e, t) {
  if (e.type !== "content_block_stop" || typeof e.index != "number") return;
  const n = t.activeToolBlocks[e.index];
  if (!n) return;
  const r = n.inputJsonParts.join("");
  let o;
  try {
    o = r ? JSON.parse(r) : {};
  } catch {
    o = {
      __unparsed: r,
    };
  }
  (t.toolCalls.push({
    type: "tool_use",
    id: n.id,
    name: n.name,
    input: o,
  }),
    delete t.activeToolBlocks[e.index]);
}
function xP(e, t, n, r) {
  !(e && typeof e == "object") ||
    t$(e, r) ||
    (n$(e, t), r$(e, t), o$(e, t, n), s$(e, t));
}
function i$(e, t, n) {
  t.isRecording() &&
    (e.responseId &&
      t.setAttributes({
        [Jo]: e.responseId,
      }),
    e.responseModel &&
      t.setAttributes({
        [An]: e.responseModel,
      }),
    kE(
      t,
      e.promptTokens,
      e.completionTokens,
      e.cacheCreationInputTokens,
      e.cacheReadInputTokens,
    ),
    t.setAttributes({
      [Rl]: !0,
    }),
    e.finishReasons.length > 0 &&
      t.setAttributes({
        [rr]: JSON.stringify(e.finishReasons),
      }),
    n &&
      e.responseTexts.length > 0 &&
      t.setAttributes({
        [Wt]: e.responseTexts.join(""),
      }),
    n &&
      e.toolCalls.length > 0 &&
      t.setAttributes({
        [Nn]: JSON.stringify(e.toolCalls),
      }),
    t.end());
}
async function* a$(e, t, n) {
  const r = {
    responseTexts: [],
    finishReasons: [],
    responseId: "",
    responseModel: "",
    promptTokens: void 0,
    completionTokens: void 0,
    cacheCreationInputTokens: void 0,
    cacheReadInputTokens: void 0,
    toolCalls: [],
    activeToolBlocks: {},
  };
  try {
    for await (const o of e) (xP(o, r, n, t), yield o);
  } finally {
    (r.responseId &&
      t.setAttributes({
        [Jo]: r.responseId,
      }),
      r.responseModel &&
        t.setAttributes({
          [An]: r.responseModel,
        }),
      kE(
        t,
        r.promptTokens,
        r.completionTokens,
        r.cacheCreationInputTokens,
        r.cacheReadInputTokens,
      ),
      t.setAttributes({
        [Rl]: !0,
      }),
      r.finishReasons.length > 0 &&
        t.setAttributes({
          [rr]: JSON.stringify(r.finishReasons),
        }),
      n &&
        r.responseTexts.length > 0 &&
        t.setAttributes({
          [Wt]: r.responseTexts.join(""),
        }),
      n &&
        r.toolCalls.length > 0 &&
        t.setAttributes({
          [Nn]: JSON.stringify(r.toolCalls),
        }),
      t.end());
  }
}
function c$(e, t, n) {
  const r = {
    responseTexts: [],
    finishReasons: [],
    responseId: "",
    responseModel: "",
    promptTokens: void 0,
    completionTokens: void 0,
    cacheCreationInputTokens: void 0,
    cacheReadInputTokens: void 0,
    toolCalls: [],
    activeToolBlocks: {},
  };
  return (
    e.on("streamEvent", (o) => {
      xP(o, r, n, t);
    }),
    e.on("message", () => {
      i$(r, t, n);
    }),
    e.on("error", (o) => {
      (xe(o, {
        mechanism: {
          handled: !1,
          type: "auto.ai.anthropic.stream_error",
        },
      }),
        t.isRecording() &&
          (t.setStatus({
            code: Ae,
            message: "stream_error",
          }),
          t.end()));
    }),
    e
  );
}
const Ol = "Anthropic_AI",
  u$ = [
    "messages.create",
    "messages.stream",
    "messages.countTokens",
    "models.get",
    "completions.create",
    "models.retrieve",
    "beta.messages.create",
  ];
function l$(e) {
  return u$.includes(e);
}
function d$(e, t) {
  t.error &&
    (e.setStatus({
      code: Ae,
      message: t.error.type || "internal_error",
    }),
    xe(t.error, {
      mechanism: {
        handled: !1,
        type: "auto.ai.anthropic.anthropic_error",
      },
    }));
}
function f$(e) {
  const { system: t, messages: n } = e,
    r =
      typeof t == "string"
        ? [
            {
              role: "system",
              content: e.system,
            },
          ]
        : [],
    o = Array.isArray(n) ? n : n != null ? [n] : [];
  return [...r, ...o];
}
function _$(e, t) {
  const n = {
    [Tl]: "anthropic",
    [Hn]: Rc(t),
    [Ge]: "auto.ai.anthropic",
  };
  if (e.length > 0 && typeof e[0] == "object" && e[0] !== null) {
    const r = e[0];
    (r.tools && Array.isArray(r.tools) && (n[gl] = JSON.stringify(r.tools)),
      (n[Nt] = r.model ?? "unknown"),
      "temperature" in r && (n[Sl] = r.temperature),
      "top_p" in r && (n[Al] = r.top_p),
      "stream" in r && (n[ME] = r.stream),
      "top_k" in r && (n[PP] = r.top_k),
      "frequency_penalty" in r && (n[ml] = r.frequency_penalty),
      "max_tokens" in r && (n[vE] = r.max_tokens));
  } else
    t === "models.retrieve" || t === "models.get"
      ? (n[Nt] = e[0])
      : (n[Nt] = "unknown");
  return n;
}
function mp(e, t) {
  const n = f$(t);
  if (n.length) {
    const r = Vn(n);
    e.setAttributes({
      [Gt]: r,
    });
  }
  if ("input" in t) {
    const r = Vn(t.input);
    e.setAttributes({
      [Gt]: r,
    });
  }
  "prompt" in t &&
    e.setAttributes({
      [FV]: JSON.stringify(t.prompt),
    });
}
function p$(e, t) {
  if ("content" in t && Array.isArray(t.content)) {
    e.setAttributes({
      [Wt]: t.content
        .map((r) => r.text)
        .filter((r) => !!r)
        .join(""),
    });
    const n = [];
    for (const r of t.content)
      (r.type === "tool_use" || r.type === "server_tool_use") && n.push(r);
    n.length > 0 &&
      e.setAttributes({
        [Nn]: JSON.stringify(n),
      });
  }
  ("completion" in t &&
    e.setAttributes({
      [Wt]: t.completion,
    }),
    "input_tokens" in t &&
      e.setAttributes({
        [Wt]: JSON.stringify(t.input_tokens),
      }));
}
function E$(e, t) {
  "id" in t &&
    "model" in t &&
    (e.setAttributes({
      [Jo]: t.id,
      [An]: t.model,
    }),
    "created" in t &&
      typeof t.created == "number" &&
      e.setAttributes({
        [Mg]: new Date(t.created * 1e3).toISOString(),
      }),
    "created_at" in t &&
      typeof t.created_at == "number" &&
      e.setAttributes({
        [Mg]: new Date(t.created_at * 1e3).toISOString(),
      }),
    "usage" in t &&
      t.usage &&
      kE(
        e,
        t.usage.input_tokens,
        t.usage.output_tokens,
        t.usage.cache_creation_input_tokens,
        t.usage.cache_read_input_tokens,
      ));
}
function h$(e, t, n) {
  if (!(!t || typeof t != "object")) {
    if ("type" in t && t.type === "error") {
      d$(e, t);
      return;
    }
    (n && p$(e, t), E$(e, t));
  }
}
function kg(e, t, n) {
  throw (
    xe(e, {
      mechanism: {
        handled: !1,
        type: "auto.ai.anthropic",
        data: {
          function: n,
        },
      },
    }),
    t.isRecording() &&
      (t.setStatus({
        code: Ae,
        message: "internal_error",
      }),
      t.end()),
    e
  );
}
function T$(e, t, n, r, o, s, i, a, c, l, f) {
  const d = o[Nt] ?? "unknown",
    u = {
      name: `${s} ${d} stream-response`,
      op: Cu(i),
      attributes: o,
    };
  return l && !f
    ? Gn(u, async (_) => {
        try {
          c.recordInputs && a && mp(_, a);
          const p = await e.apply(n, r);
          return a$(p, _, c.recordOutputs ?? !1);
        } catch (p) {
          return kg(p, _, i);
        }
      })
    : Gn(u, (_) => {
        try {
          c.recordInputs && a && mp(_, a);
          const p = t.apply(n, r);
          return c$(p, _, c.recordOutputs ?? !1);
        } catch (p) {
          return kg(p, _, i);
        }
      });
}
function S$(e, t, n, r) {
  return new Proxy(e, {
    apply(o, s, i) {
      const a = _$(i, t),
        c = a[Nt] ?? "unknown",
        l = Rc(t),
        f = typeof i[0] == "object" ? i[0] : void 0,
        d = !!f?.stream,
        u = t === "messages.stream";
      return d || u
        ? T$(e, o, n, i, a, l, t, f, r, d, u)
        : Qo(
            {
              name: `${l} ${c}`,
              op: Cu(t),
              attributes: a,
            },
            (_) => (
              r.recordInputs && f && mp(_, f),
              to(
                () => o.apply(n, i),
                (p) => {
                  xe(p, {
                    mechanism: {
                      handled: !1,
                      type: "auto.ai.anthropic",
                      data: {
                        function: t,
                      },
                    },
                  });
                },
                () => {},
                (p) => h$(_, p, r.recordOutputs),
              )
            ),
          );
    },
  });
}
function $P(e, t = "", n) {
  return new Proxy(e, {
    get(r, o) {
      const s = r[o],
        i = DP(t, String(o));
      return typeof s == "function" && l$(i)
        ? S$(s, i, r, n)
        : typeof s == "function"
          ? s.bind(r)
          : s && typeof s == "object"
            ? $P(s, i, n)
            : s;
    },
  });
}
function m$(e, t) {
  const n = !!he()?.getOptions().sendDefaultPii,
    r = {
      recordInputs: n,
      recordOutputs: n,
      ...t,
    };
  return $P(e, "", r);
}
const Cl = "Google_GenAI",
  Gg = [
    "models.generateContent",
    "models.generateContentStream",
    "chats.create",
    "sendMessage",
    "sendMessageStream",
  ],
  A$ = "google_genai",
  BP = "chats.create",
  g$ = "chat";
function R$(e, t) {
  const n = e?.promptFeedback;
  if (n?.blockReason) {
    const r = n.blockReasonMessage ?? n.blockReason;
    return (
      t.setStatus({
        code: Ae,
        message: `Content blocked: ${r}`,
      }),
      xe(`Content blocked: ${r}`, {
        mechanism: {
          handled: !1,
          type: "auto.ai.google_genai",
        },
      }),
      !0
    );
  }
  return !1;
}
function N$(e, t) {
  (typeof e.responseId == "string" && (t.responseId = e.responseId),
    typeof e.modelVersion == "string" && (t.responseModel = e.modelVersion));
  const n = e.usageMetadata;
  n &&
    (typeof n.promptTokenCount == "number" &&
      (t.promptTokens = n.promptTokenCount),
    typeof n.candidatesTokenCount == "number" &&
      (t.completionTokens = n.candidatesTokenCount),
    typeof n.totalTokenCount == "number" &&
      (t.totalTokens = n.totalTokenCount));
}
function y$(e, t, n) {
  Array.isArray(e.functionCalls) && t.toolCalls.push(...e.functionCalls);
  for (const r of e.candidates ?? []) {
    r?.finishReason &&
      !t.finishReasons.includes(r.finishReason) &&
      t.finishReasons.push(r.finishReason);
    for (const o of r?.content?.parts ?? [])
      (n && o.text && t.responseTexts.push(o.text),
        o.functionCall &&
          t.toolCalls.push({
            type: "function",
            id: o.functionCall.id,
            name: o.functionCall.name,
            arguments: o.functionCall.args,
          }));
  }
}
function O$(e, t, n, r) {
  !e || R$(e, r) || (N$(e, t), y$(e, t, n));
}
async function* C$(e, t, n) {
  const r = {
    responseTexts: [],
    finishReasons: [],
    toolCalls: [],
  };
  try {
    for await (const o of e) (O$(o, r, n, t), yield o);
  } finally {
    const o = {
      [Rl]: !0,
    };
    (r.responseId && (o[Jo] = r.responseId),
      r.responseModel && (o[An] = r.responseModel),
      r.promptTokens !== void 0 && (o[jt] = r.promptTokens),
      r.completionTokens !== void 0 && (o[qt] = r.completionTokens),
      r.totalTokens !== void 0 && (o[no] = r.totalTokens),
      r.finishReasons.length && (o[rr] = JSON.stringify(r.finishReasons)),
      n && r.responseTexts.length && (o[Wt] = r.responseTexts.join("")),
      n && r.toolCalls.length && (o[Nn] = JSON.stringify(r.toolCalls)),
      t.setAttributes(o),
      t.end());
  }
}
function b$(e) {
  if (Gg.includes(e)) return !0;
  const t = e.split(".").pop();
  return Gg.includes(t);
}
function I$(e) {
  return (
    e.includes("Stream") ||
    e.endsWith("generateContentStream") ||
    e.endsWith("sendMessageStream")
  );
}
function Vg(e, t) {
  if ("model" in e && typeof e.model == "string") return e.model;
  if (t && typeof t == "object") {
    const n = t;
    if ("model" in n && typeof n.model == "string") return n.model;
    if ("modelVersion" in n && typeof n.modelVersion == "string")
      return n.modelVersion;
  }
  return "unknown";
}
function P$(e) {
  const t = {};
  return (
    "temperature" in e &&
      typeof e.temperature == "number" &&
      (t[Sl] = e.temperature),
    "topP" in e && typeof e.topP == "number" && (t[Al] = e.topP),
    "topK" in e && typeof e.topK == "number" && (t[PP] = e.topK),
    "maxOutputTokens" in e &&
      typeof e.maxOutputTokens == "number" &&
      (t[vE] = e.maxOutputTokens),
    "frequencyPenalty" in e &&
      typeof e.frequencyPenalty == "number" &&
      (t[ml] = e.frequencyPenalty),
    "presencePenalty" in e &&
      typeof e.presencePenalty == "number" &&
      (t[LE] = e.presencePenalty),
    t
  );
}
function M$(e, t, n) {
  const r = {
    [Tl]: A$,
    [Hn]: Rc(e),
    [Ge]: "auto.ai.google_genai",
  };
  if (t) {
    if (
      ((r[Nt] = Vg(t, n)),
      "config" in t && typeof t.config == "object" && t.config)
    ) {
      const o = t.config;
      if ((Object.assign(r, P$(o)), "tools" in o && Array.isArray(o.tools))) {
        const s = o.tools.flatMap((i) => i.functionDeclarations);
        r[gl] = JSON.stringify(s);
      }
    }
  } else r[Nt] = Vg({}, n);
  return r;
}
function xg(e, t) {
  if ("contents" in t) {
    const n = t.contents,
      r = Vn(n);
    e.setAttributes({
      [Gt]: r,
    });
  }
  if ("message" in t) {
    const n = t.message,
      r = Vn(n);
    e.setAttributes({
      [Gt]: r,
    });
  }
  if ("history" in t) {
    const n = t.history,
      r = Vn(n);
    e.setAttributes({
      [Gt]: r,
    });
  }
}
function v$(e, t, n) {
  if (!(!t || typeof t != "object")) {
    if (t.usageMetadata && typeof t.usageMetadata == "object") {
      const r = t.usageMetadata;
      (typeof r.promptTokenCount == "number" &&
        e.setAttributes({
          [jt]: r.promptTokenCount,
        }),
        typeof r.candidatesTokenCount == "number" &&
          e.setAttributes({
            [qt]: r.candidatesTokenCount,
          }),
        typeof r.totalTokenCount == "number" &&
          e.setAttributes({
            [no]: r.totalTokenCount,
          }));
    }
    if (n && Array.isArray(t.candidates) && t.candidates.length > 0) {
      const r = t.candidates
        .map((o) =>
          o.content?.parts && Array.isArray(o.content.parts)
            ? o.content.parts
                .map((s) => (typeof s.text == "string" ? s.text : ""))
                .filter((s) => s.length > 0)
                .join("")
            : "",
        )
        .filter((o) => o.length > 0);
      r.length > 0 &&
        e.setAttributes({
          [Wt]: r.join(""),
        });
    }
    if (n && t.functionCalls) {
      const r = t.functionCalls;
      Array.isArray(r) &&
        r.length > 0 &&
        e.setAttributes({
          [Nn]: JSON.stringify(r),
        });
    }
  }
}
function $g(e, t, n, r) {
  const o = t === BP;
  return new Proxy(e, {
    apply(s, i, a) {
      const c = a[0],
        l = M$(t, c, n),
        f = l[Nt] ?? "unknown",
        d = Rc(t);
      return I$(t)
        ? Gn(
            {
              name: `${d} ${f} stream-response`,
              op: Cu(t),
              attributes: l,
            },
            async (u) => {
              try {
                r.recordInputs && c && xg(u, c);
                const _ = await s.apply(n, a);
                return C$(_, u, !!r.recordOutputs);
              } catch (_) {
                throw (
                  u.setStatus({
                    code: Ae,
                    message: "internal_error",
                  }),
                  xe(_, {
                    mechanism: {
                      handled: !1,
                      type: "auto.ai.google_genai",
                      data: {
                        function: t,
                      },
                    },
                  }),
                  u.end(),
                  _
                );
              }
            },
          )
        : Qo(
            {
              name: o ? `${d} ${f} create` : `${d} ${f}`,
              op: Cu(t),
              attributes: l,
            },
            (u) => (
              r.recordInputs && c && xg(u, c),
              to(
                () => s.apply(n, a),
                (_) => {
                  xe(_, {
                    mechanism: {
                      handled: !1,
                      type: "auto.ai.google_genai",
                      data: {
                        function: t,
                      },
                    },
                  });
                },
                () => {},
                (_) => {
                  o || v$(u, _, r.recordOutputs);
                },
              )
            ),
          );
    },
  });
}
function Ap(e, t = "", n) {
  return new Proxy(e, {
    get: (r, o, s) => {
      const i = Reflect.get(r, o, s),
        a = DP(t, String(o));
      if (typeof i == "function" && b$(a)) {
        if (a === BP) {
          const c = $g(i, a, r, n);
          return function (...f) {
            const d = c(...f);
            return d && typeof d == "object" ? Ap(d, g$, n) : d;
          };
        }
        return $g(i, a, r, n);
      }
      return typeof i == "function"
        ? i.bind(r)
        : i && typeof i == "object"
          ? Ap(i, a, n)
          : i;
    },
  });
}
function L$(e, t) {
  const n = !!he()?.getOptions().sendDefaultPii,
    r = {
      recordInputs: n,
      recordOutputs: n,
      ...t,
    };
  return Ap(e, "", r);
}
const HP = "LangChain",
  $a = "auto.ai.langchain",
  D$ = {
    human: "user",
    ai: "assistant",
    assistant: "assistant",
    system: "system",
    function: "function",
    tool: "tool",
  },
  Un = (e, t, n) => {
    n != null && (e[t] = n);
  },
  Lt = (e, t, n) => {
    const r = Number(n);
    Number.isNaN(r) || (e[t] = r);
  };
function bt(e) {
  if (typeof e == "string") return e;
  try {
    return JSON.stringify(e);
  } catch {
    return String(e);
  }
}
function ra(e) {
  const t = e.toLowerCase();
  return D$[t] ?? t;
}
function Bg(e) {
  return e.includes("System")
    ? "system"
    : e.includes("Human")
      ? "user"
      : e.includes("AI") || e.includes("Assistant")
        ? "assistant"
        : e.includes("Function")
          ? "function"
          : e.includes("Tool")
            ? "tool"
            : "user";
}
function Hg(e) {
  if (!(!e || Array.isArray(e))) return e.invocation_params;
}
function xE(e) {
  return e.map((t) => {
    const n = t._getType;
    if (typeof n == "function") {
      const o = n.call(t);
      return {
        role: ra(o),
        content: bt(t.content),
      };
    }
    const r = t.constructor?.name;
    if (r)
      return {
        role: ra(Bg(r)),
        content: bt(t.content),
      };
    if (t.type) {
      const o = String(t.type).toLowerCase();
      return {
        role: ra(o),
        content: bt(t.content),
      };
    }
    if (t.role)
      return {
        role: ra(String(t.role)),
        content: bt(t.content),
      };
    if (t.lc === 1 && t.kwargs) {
      const o = t.id,
        s = Array.isArray(o) && o.length > 0 ? o[o.length - 1] : "",
        i = typeof s == "string" ? Bg(s) : "user";
      return {
        role: ra(i),
        content: bt(t.kwargs?.content),
      };
    }
    return {
      role: "user",
      content: bt(t.content),
    };
  });
}
function w$(e, t, n) {
  const r = {},
    o = "kwargs" in e ? e.kwargs : void 0,
    s = t?.temperature ?? n?.ls_temperature ?? o?.temperature;
  Lt(r, Sl, s);
  const i = t?.max_tokens ?? n?.ls_max_tokens ?? o?.max_tokens;
  Lt(r, vE, i);
  const a = t?.top_p ?? o?.top_p;
  Lt(r, Al, a);
  const c = t?.frequency_penalty;
  Lt(r, ml, c);
  const l = t?.presence_penalty;
  return (Lt(r, LE, l), t && "stream" in t && Un(r, ME, !!t.stream), r);
}
function FP(e, t, n, r, o, s) {
  return {
    [Tl]: bt(e ?? "langchain"),
    [Hn]: n,
    [Nt]: bt(t),
    [Ge]: $a,
    ...w$(r, o, s),
  };
}
function U$(e, t, n, r, o) {
  const s = o?.ls_provider,
    i = r?.model ?? o?.ls_model_name ?? "unknown",
    a = FP(s, i, "pipeline", e, r, o);
  if (n && Array.isArray(t) && t.length > 0) {
    const c = t.map((l) => ({
      role: "user",
      content: l,
    }));
    Un(a, Gt, bt(c));
  }
  return a;
}
function k$(e, t, n, r, o) {
  const s = o?.ls_provider ?? e.id?.[2],
    i = r?.model ?? o?.ls_model_name ?? "unknown",
    a = FP(s, i, "chat", e, r, o);
  if (n && Array.isArray(t) && t.length > 0) {
    const c = xE(t.flat()),
      l = UE(c);
    Un(a, Gt, bt(l));
  }
  return a;
}
function G$(e, t) {
  const n = [],
    r = e.flat();
  for (const o of r) {
    const s = o.message?.content;
    if (Array.isArray(s))
      for (const i of s) {
        const a = i;
        a.type === "tool_use" && n.push(a);
      }
  }
  n.length > 0 && Un(t, Nn, bt(n));
}
function V$(e, t) {
  if (!e) return;
  const n = e.tokenUsage,
    r = e.usage;
  if (n)
    (Lt(t, jt, n.promptTokens),
      Lt(t, qt, n.completionTokens),
      Lt(t, no, n.totalTokens));
  else if (r) {
    (Lt(t, jt, r.input_tokens), Lt(t, qt, r.output_tokens));
    const o = Number(r.input_tokens),
      s = Number(r.output_tokens),
      i = (Number.isNaN(o) ? 0 : o) + (Number.isNaN(s) ? 0 : s);
    (i > 0 && Lt(t, no, i),
      r.cache_creation_input_tokens !== void 0 &&
        Lt(t, KV, r.cache_creation_input_tokens),
      r.cache_read_input_tokens !== void 0 &&
        Lt(t, zV, r.cache_read_input_tokens));
  }
}
function x$(e, t) {
  if (!e) return;
  const n = {};
  if (Array.isArray(e.generations)) {
    const l = e.generations
      .flat()
      .map((f) =>
        f.generationInfo?.finish_reason
          ? f.generationInfo.finish_reason
          : f.generation_info?.finish_reason
            ? f.generation_info.finish_reason
            : null,
      )
      .filter((f) => typeof f == "string");
    if ((l.length > 0 && Un(n, rr, bt(l)), G$(e.generations, n), t)) {
      const f = e.generations
        .flat()
        .map((d) => d.text ?? d.message?.content)
        .filter((d) => typeof d == "string");
      f.length > 0 && Un(n, Wt, bt(f));
    }
  }
  V$(e.llmOutput, n);
  const r = e.llmOutput,
    s = e.generations?.[0]?.[0]?.message,
    i = r?.model_name ?? r?.model ?? s?.response_metadata?.model_name;
  i && Un(n, An, i);
  const a = r?.id ?? s?.id;
  a && Un(n, Jo, a);
  const c = r?.stop_reason ?? s?.response_metadata?.finish_reason;
  return (c && Un(n, qV, bt(c)), n);
}
function $$(e = {}) {
  const t = e.recordInputs ?? !1,
    n = e.recordOutputs ?? !1,
    r = new Map(),
    o = (i) => {
      const a = r.get(i);
      a?.isRecording() && (a.end(), r.delete(i));
    },
    s = {
      lc_serializable: !1,
      lc_namespace: ["langchain_core", "callbacks", "sentry"],
      lc_secrets: void 0,
      lc_attributes: void 0,
      lc_aliases: void 0,
      lc_serializable_keys: void 0,
      lc_id: ["langchain_core", "callbacks", "sentry"],
      lc_kwargs: {},
      name: "SentryCallbackHandler",
      ignoreLLM: !1,
      ignoreChain: !1,
      ignoreAgent: !1,
      ignoreRetriever: !1,
      ignoreCustomEvent: !1,
      raiseError: !1,
      awaitHandlers: !0,
      handleLLMStart(i, a, c, l, f, d, u, _) {
        const p = Hg(d),
          E = U$(i, a, t, p, u),
          h = E[Nt],
          T = E[Hn];
        Gn(
          {
            name: `${T} ${h}`,
            op: "gen_ai.pipeline",
            attributes: {
              ...E,
              [Ee]: "gen_ai.pipeline",
            },
          },
          (m) => (r.set(c, m), m),
        );
      },
      handleChatModelStart(i, a, c, l, f, d, u, _) {
        const p = Hg(d),
          E = k$(i, a, t, p, u),
          h = E[Nt],
          T = E[Hn];
        Gn(
          {
            name: `${T} ${h}`,
            op: "gen_ai.chat",
            attributes: {
              ...E,
              [Ee]: "gen_ai.chat",
            },
          },
          (m) => (r.set(c, m), m),
        );
      },
      handleLLMEnd(i, a, c, l, f) {
        const d = r.get(a);
        if (d?.isRecording()) {
          const u = x$(i, n);
          (u && d.setAttributes(u), o(a));
        }
      },
      handleLLMError(i, a) {
        const c = r.get(a);
        (c?.isRecording() &&
          (c.setStatus({
            code: Ae,
            message: "llm_error",
          }),
          o(a)),
          xe(i, {
            mechanism: {
              handled: !1,
              type: `${$a}.llm_error_handler`,
            },
          }));
      },
      handleChainStart(i, a, c, l) {
        const f = i.name || "unknown_chain",
          d = {
            [Ge]: "auto.ai.langchain",
            "langchain.chain.name": f,
          };
        (t && (d["langchain.chain.inputs"] = JSON.stringify(a)),
          Gn(
            {
              name: `chain ${f}`,
              op: "gen_ai.invoke_agent",
              attributes: {
                ...d,
                [Ee]: "gen_ai.invoke_agent",
              },
            },
            (u) => (r.set(c, u), u),
          ));
      },
      handleChainEnd(i, a) {
        const c = r.get(a);
        c?.isRecording() &&
          (n &&
            c.setAttributes({
              "langchain.chain.outputs": JSON.stringify(i),
            }),
          o(a));
      },
      handleChainError(i, a) {
        const c = r.get(a);
        (c?.isRecording() &&
          (c.setStatus({
            code: Ae,
            message: "chain_error",
          }),
          o(a)),
          xe(i, {
            mechanism: {
              handled: !1,
              type: `${$a}.chain_error_handler`,
            },
          }));
      },
      handleToolStart(i, a, c, l) {
        const f = i.name || "unknown_tool",
          d = {
            [Ge]: $a,
            "gen_ai.tool.name": f,
          };
        (t && (d["gen_ai.tool.input"] = a),
          Gn(
            {
              name: `execute_tool ${f}`,
              op: "gen_ai.execute_tool",
              attributes: {
                ...d,
                [Ee]: "gen_ai.execute_tool",
              },
            },
            (u) => (r.set(c, u), u),
          ));
      },
      handleToolEnd(i, a) {
        const c = r.get(a);
        c?.isRecording() &&
          (n &&
            c.setAttributes({
              "gen_ai.tool.output": JSON.stringify(i),
            }),
          o(a));
      },
      handleToolError(i, a) {
        const c = r.get(a);
        (c?.isRecording() &&
          (c.setStatus({
            code: Ae,
            message: "tool_error",
          }),
          o(a)),
          xe(i, {
            mechanism: {
              handled: !1,
              type: `${$a}.tool_error_handler`,
            },
          }));
      },
      copy() {
        return s;
      },
      toJSON() {
        return {
          lc: 1,
          type: "not_implemented",
          id: s.lc_id,
        };
      },
      toJSONNotImplemented() {
        return {
          lc: 1,
          type: "not_implemented",
          id: s.lc_id,
        };
      },
    };
  return s;
}
const YP = "LangGraph",
  jP = "auto.ai.langgraph";
function B$(e) {
  if (!e || e.length === 0) return null;
  const t = [];
  for (const n of e)
    if (n && typeof n == "object") {
      const r = n.tool_calls;
      r && Array.isArray(r) && t.push(...r);
    }
  return t.length > 0 ? t : null;
}
function H$(e) {
  const t = e;
  let n = 0,
    r = 0,
    o = 0;
  if (t.usage_metadata && typeof t.usage_metadata == "object") {
    const s = t.usage_metadata;
    return (
      typeof s.input_tokens == "number" && (n = s.input_tokens),
      typeof s.output_tokens == "number" && (r = s.output_tokens),
      typeof s.total_tokens == "number" && (o = s.total_tokens),
      {
        inputTokens: n,
        outputTokens: r,
        totalTokens: o,
      }
    );
  }
  if (t.response_metadata && typeof t.response_metadata == "object") {
    const s = t.response_metadata;
    if (s.tokenUsage && typeof s.tokenUsage == "object") {
      const i = s.tokenUsage;
      (typeof i.promptTokens == "number" && (n = i.promptTokens),
        typeof i.completionTokens == "number" && (r = i.completionTokens),
        typeof i.totalTokens == "number" && (o = i.totalTokens));
    }
  }
  return {
    inputTokens: n,
    outputTokens: r,
    totalTokens: o,
  };
}
function F$(e, t) {
  const n = t;
  if (n.response_metadata && typeof n.response_metadata == "object") {
    const r = n.response_metadata;
    (r.model_name &&
      typeof r.model_name == "string" &&
      e.setAttribute(An, r.model_name),
      r.finish_reason &&
        typeof r.finish_reason == "string" &&
        e.setAttribute(rr, [r.finish_reason]));
  }
}
function Y$(e) {
  if (!e.builder?.nodes?.tools?.runnable?.tools) return null;
  const t = e.builder?.nodes?.tools?.runnable?.tools;
  return !t || !Array.isArray(t) || t.length === 0
    ? null
    : t.map((n) => ({
        name: n.lc_kwargs?.name,
        description: n.lc_kwargs?.description,
        schema: n.lc_kwargs?.schema,
      }));
}
function j$(e, t, n) {
  const o = n?.messages;
  if (!o || !Array.isArray(o)) return;
  const s = t?.length ?? 0,
    i = o.length > s ? o.slice(s) : [];
  if (i.length === 0) return;
  const a = B$(i);
  a && e.setAttribute(Nn, JSON.stringify(a));
  const c = xE(i);
  e.setAttribute(Wt, JSON.stringify(c));
  let l = 0,
    f = 0,
    d = 0;
  for (const u of i) {
    const _ = H$(u);
    ((l += _.inputTokens),
      (f += _.outputTokens),
      (d += _.totalTokens),
      F$(e, u));
  }
  (l > 0 && e.setAttribute(jt, l),
    f > 0 && e.setAttribute(qt, f),
    d > 0 && e.setAttribute(no, d));
}
function q$(e, t) {
  return new Proxy(e, {
    apply(n, r, o) {
      return Qo(
        {
          op: "gen_ai.create_agent",
          name: "create_agent",
          attributes: {
            [Ge]: jP,
            [Ee]: "gen_ai.create_agent",
            [Hn]: "create_agent",
          },
        },
        (s) => {
          try {
            const i = Reflect.apply(n, r, o),
              a = o.length > 0 ? o[0] : {};
            a?.name &&
              typeof a.name == "string" &&
              (s.setAttribute(MP, a.name),
              s.updateName(`create_agent ${a.name}`));
            const c = i.invoke;
            return (
              c &&
                typeof c == "function" &&
                (i.invoke = W$(c.bind(i), i, a, t)),
              i
            );
          } catch (i) {
            throw (
              s.setStatus({
                code: Ae,
                message: "internal_error",
              }),
              xe(i, {
                mechanism: {
                  handled: !1,
                  type: "auto.ai.langgraph.error",
                },
              }),
              i
            );
          }
        },
      );
    },
  });
}
function W$(e, t, n, r) {
  return new Proxy(e, {
    apply(o, s, i) {
      return Qo(
        {
          op: "gen_ai.invoke_agent",
          name: "invoke_agent",
          attributes: {
            [Ge]: jP,
            [Ee]: ZV,
            [Hn]: "invoke_agent",
          },
        },
        async (a) => {
          try {
            const c = n?.name;
            c &&
              typeof c == "string" &&
              (a.setAttribute(WV, c),
              a.setAttribute(MP, c),
              a.updateName(`invoke_agent ${c}`));
            const l = Y$(t);
            l && a.setAttribute(gl, JSON.stringify(l));
            const f = r.recordInputs,
              d = r.recordOutputs,
              u = i.length > 0 ? (i[0].messages ?? []) : [];
            if (u && f) {
              const p = xE(u),
                E = UE(p);
              a.setAttribute(Gt, JSON.stringify(E));
            }
            const _ = await Reflect.apply(o, s, i);
            return (d && j$(a, u ?? null, _), _);
          } catch (c) {
            throw (
              a.setStatus({
                code: Ae,
                message: "internal_error",
              }),
              xe(c, {
                mechanism: {
                  handled: !1,
                  type: "auto.ai.langgraph.error",
                },
              }),
              c
            );
          }
        },
      );
    },
  });
}
function qP(e) {
  if (e !== void 0)
    return e >= 400 && e < 500 ? "warning" : e >= 500 ? "error" : void 0;
}
function K$(e, t, n) {
  const r = e[t];
  if (typeof r == "function") {
    try {
      e[t] = n;
    } catch {
      Object.defineProperty(e, t, {
        value: n,
        writable: !0,
        configurable: !0,
        enumerable: !0,
      });
    }
    if (e.default === r)
      try {
        e.default = n;
      } catch {
        Object.defineProperty(e, "default", {
          value: n,
          writable: !0,
          configurable: !0,
          enumerable: !0,
        });
      }
  }
}
function z$(e, t = !1) {
  return (
    !(
      t ||
      (e &&
        !e.startsWith("/") &&
        !e.match(/^[A-Z]:/) &&
        !e.startsWith(".") &&
        !e.match(/^[a-zA-Z]([a-zA-Z0-9.\-+])*:\/\//))
    ) &&
    e !== void 0 &&
    !e.includes("node_modules/")
  );
}
function Z$(e) {
  const t = /^\s*[-]{4,}$/,
    n = /at (?:async )?(?:(.+?)\s+\()?(?:(.+):(\d+):(\d+)?|([^)]+))\)?/,
    r = /at (?:async )?(.+?) \(data:(.*?),/;
  return (o) => {
    const s = o.match(r);
    if (s)
      return {
        filename: `<data:${s[2]}>`,
        function: s[1],
      };
    const i = o.match(n);
    if (i) {
      let a, c, l, f, d;
      if (i[1]) {
        l = i[1];
        let p = l.lastIndexOf(".");
        if ((l[p - 1] === "." && p--, p > 0)) {
          ((a = l.slice(0, p)), (c = l.slice(p + 1)));
          const E = a.indexOf(".Module");
          E > 0 && ((l = l.slice(E + 1)), (a = a.slice(0, E)));
        }
        f = void 0;
      }
      (c && ((f = a), (d = c)),
        c === "<anonymous>" && ((d = void 0), (l = void 0)),
        l === void 0 && ((d = d || LI), (l = f ? `${f}.${d}` : d)));
      let u = i[2]?.startsWith("file://") ? i[2].slice(7) : i[2];
      const _ = i[5] === "native";
      return (
        u?.match(/\/[A-Z]:/) && (u = u.slice(1)),
        !u && i[5] && !_ && (u = i[5]),
        {
          filename: u ? decodeURI(u) : void 0,
          module: e ? e(u) : void 0,
          function: l,
          lineno: Fg(i[3]),
          colno: Fg(i[4]),
          in_app: z$(u || "", _),
        }
      );
    }
    if (o.match(t))
      return {
        filename: o,
      };
  };
}
function X$(e) {
  return [90, Z$(e)];
}
function Fg(e) {
  return parseInt(e || "", 10) || void 0;
}
class es {
  constructor(t) {
    ((this._maxSize = t), (this._cache = new Map()));
  }
  get size() {
    return this._cache.size;
  }
  get(t) {
    const n = this._cache.get(t);
    if (n !== void 0) return (this._cache.delete(t), this._cache.set(t, n), n);
  }
  set(t, n) {
    if (this._cache.size >= this._maxSize) {
      const r = this._cache.keys().next().value;
      this._cache.delete(r);
    }
    this._cache.set(t, n);
  }
  remove(t) {
    const n = this._cache.get(t);
    return (n && this._cache.delete(t), n);
  }
  clear() {
    this._cache.clear();
  }
  keys() {
    return Array.from(this._cache.keys());
  }
  values() {
    const t = [];
    return (this._cache.forEach((n) => t.push(n)), t);
  }
}
const bu = {};
function Ne(e, t, n) {
  return n ? J$(e, t, n) : Q$(e, t);
}
function Q$(e, t) {
  return Object.assign(
    (n) => {
      const r = bu[e];
      if (r) return (n && r.setConfig(n), r);
      const o = t(n);
      return (
        (bu[e] = o),
        sl({
          instrumentations: [o],
        }),
        o
      );
    },
    {
      id: e,
    },
  );
}
function J$(e, t, n) {
  return Object.assign(
    (r) => {
      const o = n(r),
        s = bu[e];
      if (s) return (s.setConfig(o), s);
      const i = new t(o);
      return (
        (bu[e] = i),
        sl({
          instrumentations: [i],
        }),
        i
      );
    },
    {
      id: e,
    },
  );
}
function WP(e) {
  let t = !1,
    n = [];
  if (!eB(e)) t = !0;
  else {
    const o = e._wrap;
    e._wrap = (...s) => ((t = !0), n.forEach((i) => i()), (n = []), o(...s));
  }
  return (o) => {
    t ? o() : n.push(o);
  };
}
function eB(e) {
  return typeof e._wrap == "function";
}
const Ie = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__,
  No = "@sentry/instrumentation-http",
  tB = 1024 * 1024,
  Yg = C.createContextKey("sentry_http_server_instrumented"),
  zn = "Http.Server",
  bd = new Map(),
  jg = new WeakSet();
function nB(e, t) {
  sn(e, "_startSpanCallback", new WeakRef(t));
}
const rB = (e = {}) => {
    const t = {
      sessions: e.sessions ?? !0,
      sessionFlushingDelayMS: e.sessionFlushingDelayMS ?? 6e4,
      maxRequestBodySize: e.maxRequestBodySize ?? "medium",
      ignoreRequestBody: e.ignoreRequestBody,
    };
    return {
      name: zn,
      setupOnce() {
        const n = (r) => {
          oB(r.server, t);
        };
        diagnosticsChannel.subscribe("http.server.request.start", n);
      },
      afterAllSetup(n) {
        Ie &&
          n.getIntegrationByName("Http") &&
          $.warn(
            "It seems that you have manually added `httpServerIntegration` while `httpIntegration` is also present. Make sure to remove `httpServerIntegration` when adding `httpIntegration`.",
          );
      },
    };
  },
  KP = rB;
function oB(
  e,
  {
    ignoreRequestBody: t,
    maxRequestBodySize: n,
    sessions: r,
    sessionFlushingDelayMS: o,
  },
) {
  const s = e.emit;
  if (jg.has(s)) return;
  const i = new Proxy(s, {
    apply(a, c, l) {
      if (l[0] !== "request") return a.apply(c, l);
      const f = he();
      if (C.context.active().getValue(Yg) || !f) return a.apply(c, l);
      Ie && $.log(zn, "Handling incoming request");
      const d = je().clone(),
        u = l[1],
        _ = l[2],
        p = WG(u),
        E = u.ip || u.socket?.remoteAddress,
        h = u.url || "/";
      (n !== "none" && !t?.(h, u) && iB(u, d, n),
        d.setSDKProcessingMetadata({
          normalizedRequest: p,
          ipAddress: E,
        }));
      const T = (u.method || "GET").toUpperCase(),
        m = ic(h),
        A = `${T} ${m}`;
      return (
        d.setTransactionName(A),
        r &&
          f &&
          sB(f, {
            requestIsolationScope: d,
            response: _,
            sessionFlushingDelayMS: o ?? 6e4,
          }),
        Lk(d, () => {
          Ke().getPropagationContext().propagationSpanId = ao();
          const g = C.propagation
            .extract(C.context.active(), p.headers)
            .setValue(Yg, !0);
          return C.context.with(g, () => {
            f.emit("httpServerRequest", u, _, p);
            const N = u._startSpanCallback?.deref();
            return N ? N(() => a.apply(c, l)) : a.apply(c, l);
          });
        })
      );
    },
  });
  (jg.add(i), (e.emit = i));
}
function sB(
  e,
  { requestIsolationScope: t, response: n, sessionFlushingDelayMS: r },
) {
  (t.setSDKProcessingMetadata({
    requestSession: {
      status: "ok",
    },
  }),
    n.once("close", () => {
      const o = t.getScopeData().sdkProcessingMetadata.requestSession;
      if (e && o) {
        Ie && $.log(`Recorded request session with status: ${o.status}`);
        const s = new Date();
        s.setSeconds(0, 0);
        const i = s.toISOString(),
          a = bd.get(e),
          c = a?.[i] || {
            exited: 0,
            crashed: 0,
            errored: 0,
          };
        if (
          (c[
            {
              ok: "exited",
              crashed: "crashed",
              errored: "errored",
            }[o.status]
          ]++,
          a)
        )
          a[i] = c;
        else {
          Ie && $.log("Opened new request session aggregate.");
          const l = {
            [i]: c,
          };
          bd.set(e, l);
          const f = () => {
              (clearTimeout(u), d(), bd.delete(e));
              const _ = Object.entries(l).map(([p, E]) => ({
                started: p,
                exited: E.exited,
                errored: E.errored,
                crashed: E.crashed,
              }));
              e.sendSession({
                aggregates: _,
              });
            },
            d = e.on("flush", () => {
              (Ie &&
                $.log("Sending request session aggregate due to client flush"),
                f());
            }),
            u = setTimeout(() => {
              (Ie &&
                $.log(
                  "Sending request session aggregate due to flushing schedule",
                ),
                f());
            }, r).unref();
        }
      }
    }));
}
function iB(e, t, n) {
  let r = 0;
  const o = [];
  Ie && $.log(zn, "Patching request.on");
  const s = new WeakMap(),
    i = n === "small" ? 1e3 : n === "medium" ? 1e4 : tB;
  try {
    ((e.on = new Proxy(e.on, {
      apply: (a, c, l) => {
        const [f, d, ...u] = l;
        if (f === "data") {
          Ie &&
            $.log(
              zn,
              `Handling request.on("data") with maximum body size of ${i}b`,
            );
          const _ = new Proxy(d, {
            apply: (p, E, h) => {
              try {
                const T = h[0],
                  m = Buffer.from(T);
                r < i
                  ? (o.push(m), (r += m.byteLength))
                  : Ie &&
                    $.log(
                      zn,
                      `Dropping request body chunk because maximum body length of ${i}b is exceeded.`,
                    );
              } catch {
                Ie &&
                  $.error(zn, "Encountered error while storing body chunk.");
              }
              return Reflect.apply(p, E, h);
            },
          });
          return (s.set(d, _), Reflect.apply(a, c, [f, _, ...u]));
        }
        return Reflect.apply(a, c, l);
      },
    })),
      (e.off = new Proxy(e.off, {
        apply: (a, c, l) => {
          const [, f] = l,
            d = s.get(f);
          if (d) {
            s.delete(f);
            const u = l.slice();
            return ((u[1] = d), Reflect.apply(a, c, u));
          }
          return Reflect.apply(a, c, l);
        },
      })),
      e.on("end", () => {
        try {
          const a = Buffer.concat(o).toString("utf-8");
          if (a) {
            const l =
              Buffer.byteLength(a, "utf-8") > i
                ? `${Buffer.from(a)
                    .subarray(0, i - 3)
                    .toString("utf-8")}...`
                : a;
            t.setSDKProcessingMetadata({
              normalizedRequest: {
                data: l,
              },
            });
          }
        } catch (a) {
          Ie && $.error(zn, "Error building captured request body", a);
        }
      }));
  } catch (a) {
    Ie && $.error(zn, "Error patching request to capture body", a);
  }
}
const qg = "Http.ServerSpans",
  aB = (e = {}) => {
    const t = e.ignoreStaticAssets ?? !0,
      n = e.ignoreIncomingRequests,
      r = e.ignoreStatusCodes ?? [
        [401, 404],
        [301, 303],
        [305, 399],
      ],
      { onSpanCreated: o } = e,
      {
        requestHook: s,
        responseHook: i,
        applyCustomAttributesOnSpan: a,
      } = e.instrumentation ?? {};
    return {
      name: qg,
      setup(c) {
        (typeof __SENTRY_TRACING__ < "u" && !__SENTRY_TRACING__) ||
          c.on("httpServerRequest", (l, f, d) => {
            const u = l,
              _ = f;
            nB(u, (E) => {
              if (
                lB(u, {
                  ignoreStaticAssets: t,
                  ignoreIncomingRequests: n,
                })
              )
                return (
                  Ie &&
                    $.log(
                      qg,
                      "Skipping span creation for incoming request",
                      u.url,
                    ),
                  E()
                );
              const h = d.url || u.url || "/",
                T = HG(h),
                m = u.headers,
                A = m["user-agent"],
                g = m["x-forwarded-for"],
                N = u.httpVersion,
                O = m.host,
                I = O?.replace(/^(.*)(:[0-9]{1,5})/, "$1") || "localhost",
                b = c.tracer,
                w = h.startsWith("https") ? "https" : "http",
                L = d.method || u.method?.toUpperCase() || "GET",
                j = T ? T.pathname : ic(h),
                H = `${L} ${j}`,
                x = b.startSpan(H, {
                  kind: C.SpanKind.SERVER,
                  attributes: {
                    [Ee]: "http.server",
                    [Ge]: "auto.http.otel.http",
                    "sentry.http.prefetch": cB(u) || void 0,
                    "http.url": h,
                    "http.method": d.method,
                    "http.target": T ? `${T.pathname}${T.search}` : j,
                    "http.host": O,
                    "net.host.name": I,
                    "http.client_ip":
                      typeof g == "string" ? g.split(",")[0] : void 0,
                    "http.user_agent": A,
                    "http.scheme": w,
                    "http.flavor": N,
                    "net.transport":
                      N?.toUpperCase() === "QUIC" ? "ip_udp" : "ip_tcp",
                    ...dB(u),
                    ...ZG(d.headers || {}),
                  },
                });
              (s?.(x, u), i?.(x, _), a?.(x, u, _), o?.(x, u, _));
              const B = {
                type: Zr.HTTP,
                span: x,
              };
              return C.context.with(
                uI(C.trace.setSpan(C.context.active(), x), B),
                () => {
                  (C.context.bind(C.context.active(), u),
                    C.context.bind(C.context.active(), _));
                  let F = !1;
                  function U(k) {
                    if (F) return;
                    F = !0;
                    const Y = pB(u, _);
                    (x.setAttributes(Y), x.setStatus(k), x.end());
                    const oe = Y["http.route"];
                    oe &&
                      je().setTransactionName(
                        `${u.method?.toUpperCase() || "GET"} ${oe}`,
                      );
                  }
                  return (
                    _.on("close", () => {
                      U(lp(_.statusCode));
                    }),
                    _.on(events2.errorMonitor, () => {
                      const k = lp(_.statusCode);
                      U(
                        k.code === Ae
                          ? k
                          : {
                              code: Ae,
                            },
                      );
                    }),
                    E()
                  );
                },
              );
            });
          });
      },
      processEvent(c) {
        if (c.type === "transaction") {
          const l = c.contexts?.trace?.data?.["http.response.status_code"];
          if (typeof l == "number" && EB(l, r))
            return (
              Ie && $.log("Dropping transaction due to status code", l),
              null
            );
        }
        return c;
      },
      afterAllSetup(c) {
        Ie &&
          (c.getIntegrationByName("Http") &&
            $.warn(
              "It seems that you have manually added `httpServerSpansIntergation` while `httpIntegration` is also present. Make sure to remove `httpIntegration` when adding `httpServerSpansIntegration`.",
            ),
          c.getIntegrationByName("Http.Server") ||
            $.error(
              "It seems that you have manually added `httpServerSpansIntergation` without adding `httpServerIntegration`. This is a requiement for spans to be created - please add the `httpServerIntegration` integration.",
            ));
      },
    };
  },
  zP = aB;
function cB(e) {
  return e.headers["next-router-prefetch"] === "1";
}
function uB(e) {
  const t = ic(e);
  return !!(
    t.match(
      /\.(ico|png|jpg|jpeg|gif|svg|css|js|woff|woff2|ttf|eot|webp|avif)$/,
    ) ||
    t.match(/^\/(robots\.txt|sitemap\.xml|manifest\.json|browserconfig\.xml)$/)
  );
}
function lB(e, { ignoreStaticAssets: t, ignoreIncomingRequests: n }) {
  if (Rn(C.context.active())) return !0;
  const r = e.url,
    o = e.method?.toUpperCase();
  return !!(
    o === "OPTIONS" ||
    o === "HEAD" ||
    !r ||
    (t && o === "GET" && uB(r)) ||
    n?.(r, e)
  );
}
function dB(e) {
  const t = fB(e.headers);
  return t == null
    ? {}
    : _B(e.headers)
      ? {
          "http.request_content_length": t,
        }
      : {
          "http.request_content_length_uncompressed": t,
        };
}
function fB(e) {
  const t = e["content-length"];
  if (t === void 0) return null;
  const n = parseInt(t, 10);
  return isNaN(n) ? null : n;
}
function _B(e) {
  const t = e["content-encoding"];
  return !!t && t !== "identity";
}
function pB(e, t) {
  const { socket: n } = e,
    { statusCode: r, statusMessage: o } = t,
    s = {
      [Q.ATTR_HTTP_RESPONSE_STATUS_CODE]: r,
      [Q.SEMATTRS_HTTP_STATUS_CODE]: r,
      "http.status_text": o?.toUpperCase(),
    },
    i = rl(C.context.active());
  if (n) {
    const {
      localAddress: a,
      localPort: c,
      remoteAddress: l,
      remotePort: f,
    } = n;
    ((s[Q.SEMATTRS_NET_HOST_IP] = a),
      (s[Q.SEMATTRS_NET_HOST_PORT] = c),
      (s[Q.SEMATTRS_NET_PEER_IP] = l),
      (s["net.peer.port"] = f));
  }
  if (
    ((s[Q.SEMATTRS_HTTP_STATUS_CODE] = r),
    (s["http.status_text"] = (o || "").toUpperCase()),
    i?.type === Zr.HTTP && i.route !== void 0)
  ) {
    const a = i.route;
    s[Q.ATTR_HTTP_ROUTE] = a;
  }
  return s;
}
function EB(e, t) {
  return t.some((n) => {
    if (typeof n == "number") return n === e;
    const [r, o] = n;
    return e >= r && e <= o;
  });
}
function ZP(e) {
  const t = e.protocol || "",
    n = e.hostname || e.host || "",
    r =
      !e.port || e.port === 80 || e.port === 443 || /^(.*):(\d+)$/.test(n)
        ? ""
        : `:${e.port}`,
    o = e.path ? e.path : "/";
  return `${t}//${n}${r}${o}`;
}
function hB() {
  return `unknown_service:${process.argv0}`;
}
const Ba = (e) =>
  e !== null && typeof e == "object" && typeof e.then == "function";
class Iu {
  _rawAttributes;
  _asyncAttributesPending = !1;
  _schemaUrl;
  _memoizedAttributes;
  static FromAttributeList(t, n) {
    const r = new Iu({}, n);
    return (
      (r._rawAttributes = Wg(t)),
      (r._asyncAttributesPending = t.filter(([o, s]) => Ba(s)).length > 0),
      r
    );
  }
  constructor(t, n) {
    const r = t.attributes ?? {};
    ((this._rawAttributes = Object.entries(r).map(
      ([o, s]) => (Ba(s) && (this._asyncAttributesPending = !0), [o, s]),
    )),
      (this._rawAttributes = Wg(this._rawAttributes)),
      (this._schemaUrl = TB(n?.schemaUrl)));
  }
  get asyncAttributesPending() {
    return this._asyncAttributesPending;
  }
  async waitForAsyncAttributes() {
    if (this.asyncAttributesPending) {
      for (let t = 0; t < this._rawAttributes.length; t++) {
        const [n, r] = this._rawAttributes[t];
        this._rawAttributes[t] = [n, Ba(r) ? await r : r];
      }
      this._asyncAttributesPending = !1;
    }
  }
  get attributes() {
    if (
      (this.asyncAttributesPending &&
        C.diag.error(
          "Accessing resource attributes before async attributes settled",
        ),
      this._memoizedAttributes)
    )
      return this._memoizedAttributes;
    const t = {};
    for (const [n, r] of this._rawAttributes) {
      if (Ba(r)) {
        C.diag.debug(`Unsettled resource attribute ${n} skipped`);
        continue;
      }
      r != null && (t[n] ??= r);
    }
    return (this._asyncAttributesPending || (this._memoizedAttributes = t), t);
  }
  getRawAttributes() {
    return this._rawAttributes;
  }
  get schemaUrl() {
    return this._schemaUrl;
  }
  merge(t) {
    if (t == null) return this;
    const n = SB(this, t),
      r = n
        ? {
            schemaUrl: n,
          }
        : void 0;
    return Iu.FromAttributeList(
      [...t.getRawAttributes(), ...this.getRawAttributes()],
      r,
    );
  }
}
function XP(e, t) {
  return Iu.FromAttributeList(Object.entries(e), t);
}
function QP() {
  return XP({
    [Q.ATTR_SERVICE_NAME]: hB(),
    [Q.ATTR_TELEMETRY_SDK_LANGUAGE]: Zc[Q.ATTR_TELEMETRY_SDK_LANGUAGE],
    [Q.ATTR_TELEMETRY_SDK_NAME]: Zc[Q.ATTR_TELEMETRY_SDK_NAME],
    [Q.ATTR_TELEMETRY_SDK_VERSION]: Zc[Q.ATTR_TELEMETRY_SDK_VERSION],
  });
}
function Wg(e) {
  return e.map(([t, n]) =>
    Ba(n)
      ? [
          t,
          n.catch((r) => {
            C.diag.debug(
              "promise rejection for resource attribute: %s - %s",
              t,
              r,
            );
          }),
        ]
      : [t, n],
  );
}
function TB(e) {
  if (typeof e == "string" || e === void 0) return e;
  C.diag.warn(
    "Schema URL must be string or undefined, got %s. Schema URL will be ignored.",
    e,
  );
}
function SB(e, t) {
  const n = e?.schemaUrl,
    r = t?.schemaUrl,
    o = n === void 0 || n === "",
    s = r === void 0 || r === "";
  if (o) return r;
  if (s || n === r) return n;
  C.diag.warn(
    'Schema URL merge conflict: old resource has "%s", updating resource has "%s". Resulting resource will have undefined Schema URL.',
    n,
    r,
  );
}
const mB = "exception";
class AB {
  _spanContext;
  kind;
  parentSpanContext;
  attributes = {};
  links = [];
  events = [];
  startTime;
  resource;
  instrumentationScope;
  _droppedAttributesCount = 0;
  _droppedEventsCount = 0;
  _droppedLinksCount = 0;
  name;
  status = {
    code: C.SpanStatusCode.UNSET,
  };
  endTime = [0, 0];
  _ended = !1;
  _duration = [-1, -1];
  _spanProcessor;
  _spanLimits;
  _attributeValueLengthLimit;
  _performanceStartTime;
  _performanceOffset;
  _startTimeProvided;
  constructor(t) {
    const n = Date.now();
    ((this._spanContext = t.spanContext),
      (this._performanceStartTime = Wr.now()),
      (this._performanceOffset = n - (this._performanceStartTime + tl())),
      (this._startTimeProvided = t.startTime != null),
      (this._spanLimits = t.spanLimits),
      (this._attributeValueLengthLimit =
        this._spanLimits.attributeValueLengthLimit || 0),
      (this._spanProcessor = t.spanProcessor),
      (this.name = t.name),
      (this.parentSpanContext = t.parentSpanContext),
      (this.kind = t.kind),
      (this.links = t.links || []),
      (this.startTime = this._getTime(t.startTime ?? n)),
      (this.resource = t.resource),
      (this.instrumentationScope = t.scope),
      t.attributes != null && this.setAttributes(t.attributes),
      this._spanProcessor.onStart(this, t.context));
  }
  spanContext() {
    return this._spanContext;
  }
  setAttribute(t, n) {
    if (n == null || this._isSpanEnded()) return this;
    if (t.length === 0)
      return (C.diag.warn(`Invalid attribute key: ${t}`), this);
    if (!eE(n))
      return (C.diag.warn(`Invalid attribute value set for key: ${t}`), this);
    const { attributeCountLimit: r } = this._spanLimits;
    return r !== void 0 &&
      Object.keys(this.attributes).length >= r &&
      !Object.prototype.hasOwnProperty.call(this.attributes, t)
      ? (this._droppedAttributesCount++, this)
      : ((this.attributes[t] = this._truncateToSize(n)), this);
  }
  setAttributes(t) {
    for (const [n, r] of Object.entries(t)) this.setAttribute(n, r);
    return this;
  }
  addEvent(t, n, r) {
    if (this._isSpanEnded()) return this;
    const { eventCountLimit: o } = this._spanLimits;
    if (o === 0)
      return (
        C.diag.warn("No events allowed."),
        this._droppedEventsCount++,
        this
      );
    (o !== void 0 &&
      this.events.length >= o &&
      (this._droppedEventsCount === 0 && C.diag.debug("Dropping extra events."),
      this.events.shift(),
      this._droppedEventsCount++),
      sp(n) && (sp(r) || (r = n), (n = void 0)));
    const s = qa(n);
    return (
      this.events.push({
        name: t,
        attributes: s,
        time: this._getTime(r),
        droppedAttributesCount: 0,
      }),
      this
    );
  }
  addLink(t) {
    return (this.links.push(t), this);
  }
  addLinks(t) {
    return (this.links.push(...t), this);
  }
  setStatus(t) {
    return this._isSpanEnded()
      ? this
      : ((this.status = {
          ...t,
        }),
        this.status.message != null &&
          typeof t.message != "string" &&
          (C.diag.warn(
            `Dropping invalid status.message of type '${typeof t.message}', expected 'string'`,
          ),
          delete this.status.message),
        this);
  }
  updateName(t) {
    return this._isSpanEnded() ? this : ((this.name = t), this);
  }
  end(t) {
    if (this._isSpanEnded()) {
      C.diag.error(
        `${this.name} ${this._spanContext.traceId}-${this._spanContext.spanId} - You can only call end() on a span once.`,
      );
      return;
    }
    ((this._ended = !0),
      (this.endTime = this._getTime(t)),
      (this._duration = aI(this.startTime, this.endTime)),
      this._duration[0] < 0 &&
        (C.diag.warn(
          "Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.",
          this.startTime,
          this.endTime,
        ),
        (this.endTime = this.startTime.slice()),
        (this._duration = [0, 0])),
      this._droppedEventsCount > 0 &&
        C.diag.warn(
          `Dropped ${this._droppedEventsCount} events because eventCountLimit reached`,
        ),
      this._spanProcessor.onEnd(this));
  }
  _getTime(t) {
    if (typeof t == "number" && t <= Wr.now())
      return rE(t + this._performanceOffset);
    if (typeof t == "number") return kn(t);
    if (t instanceof Date) return kn(t.getTime());
    if (nl(t)) return t;
    if (this._startTimeProvided) return kn(Date.now());
    const n = Wr.now() - this._performanceStartTime;
    return oE(this.startTime, kn(n));
  }
  isRecording() {
    return this._ended === !1;
  }
  recordException(t, n) {
    const r = {};
    (typeof t == "string"
      ? (r[Q.ATTR_EXCEPTION_MESSAGE] = t)
      : t &&
        (t.code
          ? (r[Q.ATTR_EXCEPTION_TYPE] = t.code.toString())
          : t.name && (r[Q.ATTR_EXCEPTION_TYPE] = t.name),
        t.message && (r[Q.ATTR_EXCEPTION_MESSAGE] = t.message),
        t.stack && (r[Q.ATTR_EXCEPTION_STACKTRACE] = t.stack)),
      r[Q.ATTR_EXCEPTION_TYPE] || r[Q.ATTR_EXCEPTION_MESSAGE]
        ? this.addEvent(mB, r, n)
        : C.diag.warn(`Failed to record an exception ${t}`));
  }
  get duration() {
    return this._duration;
  }
  get ended() {
    return this._ended;
  }
  get droppedAttributesCount() {
    return this._droppedAttributesCount;
  }
  get droppedEventsCount() {
    return this._droppedEventsCount;
  }
  get droppedLinksCount() {
    return this._droppedLinksCount;
  }
  _isSpanEnded() {
    if (this._ended) {
      const t = new Error(
        `Operation attempted on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`,
      );
      C.diag.warn(
        `Cannot execute the operation on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`,
        t,
      );
    }
    return this._ended;
  }
  _truncateToLimitUtil(t, n) {
    return t.length <= n ? t : t.substring(0, n);
  }
  _truncateToSize(t) {
    const n = this._attributeValueLengthLimit;
    return n <= 0
      ? (C.diag.warn(`Attribute value limit must be positive, got ${n}`), t)
      : typeof t == "string"
        ? this._truncateToLimitUtil(t, n)
        : Array.isArray(t)
          ? t.map((r) =>
              typeof r == "string" ? this._truncateToLimitUtil(r, n) : r,
            )
          : t;
  }
}
var wt;
(function (e) {
  ((e[(e.NOT_RECORD = 0)] = "NOT_RECORD"),
    (e[(e.RECORD = 1)] = "RECORD"),
    (e[(e.RECORD_AND_SAMPLED = 2)] = "RECORD_AND_SAMPLED"));
})(wt || (wt = {}));
class Pu {
  shouldSample() {
    return {
      decision: wt.NOT_RECORD,
    };
  }
  toString() {
    return "AlwaysOffSampler";
  }
}
class Lo {
  shouldSample() {
    return {
      decision: wt.RECORD_AND_SAMPLED,
    };
  }
  toString() {
    return "AlwaysOnSampler";
  }
}
class vc {
  _root;
  _remoteParentSampled;
  _remoteParentNotSampled;
  _localParentSampled;
  _localParentNotSampled;
  constructor(t) {
    ((this._root = t.root),
      this._root ||
        (tE(
          new Error("ParentBasedSampler must have a root sampler configured"),
        ),
        (this._root = new Lo())),
      (this._remoteParentSampled = t.remoteParentSampled ?? new Lo()),
      (this._remoteParentNotSampled = t.remoteParentNotSampled ?? new Pu()),
      (this._localParentSampled = t.localParentSampled ?? new Lo()),
      (this._localParentNotSampled = t.localParentNotSampled ?? new Pu()));
  }
  shouldSample(t, n, r, o, s, i) {
    const a = C.trace.getSpanContext(t);
    return !a || !C.isSpanContextValid(a)
      ? this._root.shouldSample(t, n, r, o, s, i)
      : a.isRemote
        ? a.traceFlags & C.TraceFlags.SAMPLED
          ? this._remoteParentSampled.shouldSample(t, n, r, o, s, i)
          : this._remoteParentNotSampled.shouldSample(t, n, r, o, s, i)
        : a.traceFlags & C.TraceFlags.SAMPLED
          ? this._localParentSampled.shouldSample(t, n, r, o, s, i)
          : this._localParentNotSampled.shouldSample(t, n, r, o, s, i);
  }
  toString() {
    return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;
  }
}
class Kg {
  _ratio;
  _upperBound;
  constructor(t = 0) {
    ((this._ratio = t),
      (this._ratio = this._normalize(t)),
      (this._upperBound = Math.floor(this._ratio * 4294967295)));
  }
  shouldSample(t, n) {
    return {
      decision:
        C.isValidTraceId(n) && this._accumulate(n) < this._upperBound
          ? wt.RECORD_AND_SAMPLED
          : wt.NOT_RECORD,
    };
  }
  toString() {
    return `TraceIdRatioBased{${this._ratio}}`;
  }
  _normalize(t) {
    return typeof t != "number" || isNaN(t) ? 0 : t >= 1 ? 1 : t <= 0 ? 0 : t;
  }
  _accumulate(t) {
    let n = 0;
    for (let r = 0; r < t.length / 8; r++) {
      const o = r * 8,
        s = parseInt(t.slice(o, o + 8), 16);
      n = (n ^ s) >>> 0;
    }
    return n;
  }
}
var _n;
(function (e) {
  ((e.AlwaysOff = "always_off"),
    (e.AlwaysOn = "always_on"),
    (e.ParentBasedAlwaysOff = "parentbased_always_off"),
    (e.ParentBasedAlwaysOn = "parentbased_always_on"),
    (e.ParentBasedTraceIdRatio = "parentbased_traceidratio"),
    (e.TraceIdRatio = "traceidratio"));
})(_n || (_n = {}));
const Lc = 1;
function JP() {
  return {
    sampler: eM(),
    forceFlushTimeoutMillis: 3e4,
    generalLimits: {
      attributeValueLengthLimit:
        Ct("OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT") ?? 1 / 0,
      attributeCountLimit: Ct("OTEL_ATTRIBUTE_COUNT_LIMIT") ?? 128,
    },
    spanLimits: {
      attributeValueLengthLimit:
        Ct("OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT") ?? 1 / 0,
      attributeCountLimit: Ct("OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT") ?? 128,
      linkCountLimit: Ct("OTEL_SPAN_LINK_COUNT_LIMIT") ?? 128,
      eventCountLimit: Ct("OTEL_SPAN_EVENT_COUNT_LIMIT") ?? 128,
      attributePerEventCountLimit:
        Ct("OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT") ?? 128,
      attributePerLinkCountLimit:
        Ct("OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT") ?? 128,
    },
  };
}
function eM() {
  const e = nE("OTEL_TRACES_SAMPLER") ?? _n.ParentBasedAlwaysOn;
  switch (e) {
    case _n.AlwaysOn:
      return new Lo();
    case _n.AlwaysOff:
      return new Pu();
    case _n.ParentBasedAlwaysOn:
      return new vc({
        root: new Lo(),
      });
    case _n.ParentBasedAlwaysOff:
      return new vc({
        root: new Pu(),
      });
    case _n.TraceIdRatio:
      return new Kg(zg());
    case _n.ParentBasedTraceIdRatio:
      return new vc({
        root: new Kg(zg()),
      });
    default:
      return (
        C.diag.error(
          `OTEL_TRACES_SAMPLER value "${e}" invalid, defaulting to "${_n.ParentBasedAlwaysOn}".`,
        ),
        new vc({
          root: new Lo(),
        })
      );
  }
}
function zg() {
  const e = Ct("OTEL_TRACES_SAMPLER_ARG");
  return e == null
    ? (C.diag.error(`OTEL_TRACES_SAMPLER_ARG is blank, defaulting to ${Lc}.`),
      Lc)
    : e < 0 || e > 1
      ? (C.diag.error(
          `OTEL_TRACES_SAMPLER_ARG=${e} was given, but it is out of range ([0..1]), defaulting to ${Lc}.`,
        ),
        Lc)
      : e;
}
const gB = 128,
  RB = 1 / 0;
function NB(e) {
  const t = {
      sampler: eM(),
    },
    n = JP(),
    r = Object.assign({}, n, t, e);
  return (
    (r.generalLimits = Object.assign(
      {},
      n.generalLimits,
      e.generalLimits || {},
    )),
    (r.spanLimits = Object.assign({}, n.spanLimits, e.spanLimits || {})),
    r
  );
}
function yB(e) {
  const t = Object.assign({}, e.spanLimits);
  return (
    (t.attributeCountLimit =
      e.spanLimits?.attributeCountLimit ??
      e.generalLimits?.attributeCountLimit ??
      Ct("OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT") ??
      Ct("OTEL_ATTRIBUTE_COUNT_LIMIT") ??
      gB),
    (t.attributeValueLengthLimit =
      e.spanLimits?.attributeValueLengthLimit ??
      e.generalLimits?.attributeValueLengthLimit ??
      Ct("OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT") ??
      Ct("OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT") ??
      RB),
    Object.assign({}, e, {
      spanLimits: t,
    })
  );
}
const OB = 8,
  tM = 16;
class CB {
  generateTraceId = Zg(tM);
  generateSpanId = Zg(OB);
}
const Dc = Buffer.allocUnsafe(tM);
function Zg(e) {
  return function () {
    for (let n = 0; n < e / 4; n++)
      Dc.writeUInt32BE((Math.random() * 2 ** 32) >>> 0, n * 4);
    for (let n = 0; n < e && !(Dc[n] > 0); n++) n === e - 1 && (Dc[e - 1] = 1);
    return Dc.toString("hex", 0, e);
  };
}
class bB {
  _sampler;
  _generalLimits;
  _spanLimits;
  _idGenerator;
  instrumentationScope;
  _resource;
  _spanProcessor;
  constructor(t, n, r, o) {
    const s = NB(n);
    ((this._sampler = s.sampler),
      (this._generalLimits = s.generalLimits),
      (this._spanLimits = s.spanLimits),
      (this._idGenerator = n.idGenerator || new CB()),
      (this._resource = r),
      (this._spanProcessor = o),
      (this.instrumentationScope = t));
  }
  startSpan(t, n = {}, r = C.context.active()) {
    n.root && (r = C.trace.deleteSpan(r));
    const o = C.trace.getSpan(r);
    if (Rn(r))
      return (
        C.diag.debug("Instrumentation suppressed, returning Noop Span"),
        C.trace.wrapSpanContext(C.INVALID_SPAN_CONTEXT)
      );
    const s = o?.spanContext(),
      i = this._idGenerator.generateSpanId();
    let a, c, l;
    !s || !C.trace.isSpanContextValid(s)
      ? (c = this._idGenerator.generateTraceId())
      : ((c = s.traceId), (l = s.traceState), (a = s));
    const f = n.kind ?? C.SpanKind.INTERNAL,
      d = (n.links ?? []).map((m) => ({
        context: m.context,
        attributes: qa(m.attributes),
      })),
      u = qa(n.attributes),
      _ = this._sampler.shouldSample(r, c, t, f, u, d);
    l = _.traceState ?? l;
    const p =
        _.decision === C.SamplingDecision.RECORD_AND_SAMPLED
          ? C.TraceFlags.SAMPLED
          : C.TraceFlags.NONE,
      E = {
        traceId: c,
        spanId: i,
        traceFlags: p,
        traceState: l,
      };
    if (_.decision === C.SamplingDecision.NOT_RECORD)
      return (
        C.diag.debug(
          "Recording is off, propagating context in a non-recording span",
        ),
        C.trace.wrapSpanContext(E)
      );
    const h = qa(Object.assign(u, _.attributes));
    return new AB({
      resource: this._resource,
      scope: this.instrumentationScope,
      context: r,
      spanContext: E,
      name: t,
      kind: f,
      links: d,
      parentSpanContext: a,
      attributes: h,
      startTime: n.startTime,
      spanProcessor: this._spanProcessor,
      spanLimits: this._spanLimits,
    });
  }
  startActiveSpan(t, n, r, o) {
    let s, i, a;
    if (arguments.length < 2) return;
    arguments.length === 2
      ? (a = n)
      : arguments.length === 3
        ? ((s = n), (a = r))
        : ((s = n), (i = r), (a = o));
    const c = i ?? C.context.active(),
      l = this.startSpan(t, s, c),
      f = C.trace.setSpan(c, l);
    return C.context.with(f, a, void 0, l);
  }
  getGeneralLimits() {
    return this._generalLimits;
  }
  getSpanLimits() {
    return this._spanLimits;
  }
}
class IB {
  _spanProcessors;
  constructor(t) {
    this._spanProcessors = t;
  }
  forceFlush() {
    const t = [];
    for (const n of this._spanProcessors) t.push(n.forceFlush());
    return new Promise((n) => {
      Promise.all(t)
        .then(() => {
          n();
        })
        .catch((r) => {
          (tE(r || new Error("MultiSpanProcessor: forceFlush failed")), n());
        });
    });
  }
  onStart(t, n) {
    for (const r of this._spanProcessors) r.onStart(t, n);
  }
  onEnd(t) {
    for (const n of this._spanProcessors) n.onEnd(t);
  }
  shutdown() {
    const t = [];
    for (const n of this._spanProcessors) t.push(n.shutdown());
    return new Promise((n, r) => {
      Promise.all(t).then(() => {
        n();
      }, r);
    });
  }
}
var qr;
(function (e) {
  ((e[(e.resolved = 0)] = "resolved"),
    (e[(e.timeout = 1)] = "timeout"),
    (e[(e.error = 2)] = "error"),
    (e[(e.unresolved = 3)] = "unresolved"));
})(qr || (qr = {}));
class PB {
  _config;
  _tracers = new Map();
  _resource;
  _activeSpanProcessor;
  constructor(t = {}) {
    const n = pI({}, JP(), yB(t));
    ((this._resource = n.resource ?? QP()),
      (this._config = Object.assign({}, n, {
        resource: this._resource,
      })));
    const r = [];
    (t.spanProcessors?.length && r.push(...t.spanProcessors),
      (this._activeSpanProcessor = new IB(r)));
  }
  getTracer(t, n, r) {
    const o = `${t}@${n || ""}:${r?.schemaUrl || ""}`;
    return (
      this._tracers.has(o) ||
        this._tracers.set(
          o,
          new bB(
            {
              name: t,
              version: n,
              schemaUrl: r?.schemaUrl,
            },
            this._config,
            this._resource,
            this._activeSpanProcessor,
          ),
        ),
      this._tracers.get(o)
    );
  }
  forceFlush() {
    const t = this._config.forceFlushTimeoutMillis,
      n = this._activeSpanProcessor._spanProcessors.map(
        (r) =>
          new Promise((o) => {
            let s;
            const i = setTimeout(() => {
              (o(
                new Error(
                  `Span processor did not completed within timeout period of ${t} ms`,
                ),
              ),
                (s = qr.timeout));
            }, t);
            r.forceFlush()
              .then(() => {
                (clearTimeout(i),
                  s !== qr.timeout && ((s = qr.resolved), o(s)));
              })
              .catch((a) => {
                (clearTimeout(i), (s = qr.error), o(a));
              });
          }),
      );
    return new Promise((r, o) => {
      Promise.all(n)
        .then((s) => {
          const i = s.filter((a) => a !== qr.resolved);
          i.length > 0 ? o(i) : r();
        })
        .catch((s) => o([s]));
    });
  }
  shutdown() {
    return this._activeSpanProcessor.shutdown();
  }
}
const $E = "sentry.parentIsRemote",
  Ha = "sentry.graphql.operation";
function BE(e) {
  if ("parentSpanId" in e) return e.parentSpanId;
  if ("parentSpanContext" in e) return e.parentSpanContext?.spanId;
}
function HE(e) {
  const t = e;
  return !!t.attributes && typeof t.attributes == "object";
}
function MB(e) {
  return typeof e.kind == "number";
}
function vB(e) {
  return !!e.status;
}
function nM(e) {
  return !!e.name;
}
function LB(e) {
  if (!HE(e)) return {};
  const t = e.attributes[Q.ATTR_URL_FULL] || e.attributes[Q.SEMATTRS_HTTP_URL],
    n = {
      url: t,
      "http.method":
        e.attributes[Q.ATTR_HTTP_REQUEST_METHOD] ||
        e.attributes[Q.SEMATTRS_HTTP_METHOD],
    };
  !n["http.method"] && n.url && (n["http.method"] = "GET");
  try {
    if (typeof t == "string") {
      const r = El(t);
      ((n.url = hl(r)),
        r.search && (n["http.query"] = r.search),
        r.hash && (n["http.fragment"] = r.hash));
    }
  } catch {}
  return n;
}
function DB(e) {
  return MB(e) ? e.kind : C.SpanKind.INTERNAL;
}
const Id = "sentry-trace",
  gp = "baggage",
  FE = "sentry.dsc",
  YE = "sentry.sampled_not_recording",
  rM = "sentry.url",
  wB = "sentry.sample_rand",
  UB = "sentry.sample_rate",
  oM = C.createContextKey("sentry_scopes"),
  Rp = C.createContextKey("sentry_fork_isolation_scope"),
  Np = C.createContextKey("sentry_fork_set_scope"),
  yp = C.createContextKey("sentry_fork_set_isolation_scope"),
  sM = "_scopeContext";
function ts(e) {
  return e.getValue(oM);
}
function iM(e, t) {
  return e.setValue(oM, t);
}
function kB(e, t) {
  sn(e, sM, t);
}
function ac(e) {
  return e[sM];
}
function Bo(e) {
  const { traceFlags: t, traceState: n } = e,
    r = n ? n.get(YE) === "1" : !1;
  if (t === C.TraceFlags.SAMPLED) return !0;
  if (r) return !1;
  const o = n ? n.get(FE) : void 0,
    s = o ? Ac(o) : void 0;
  if (s?.sampled === "true") return !0;
  if (s?.sampled === "false") return !1;
}
function aM(e, t, n) {
  const r = t[Q.ATTR_HTTP_REQUEST_METHOD] || t[Q.SEMATTRS_HTTP_METHOD];
  if (r)
    return VB(
      {
        attributes: t,
        name: e,
        kind: n,
      },
      r,
    );
  const o = t[Q.SEMATTRS_DB_SYSTEM],
    s = typeof t[Ee] == "string" && t[Ee].startsWith("cache.");
  if (o && !s)
    return GB({
      attributes: t,
      name: e,
    });
  const i = t[Kt] === "custom" ? "custom" : "route";
  if (t[Q.SEMATTRS_RPC_SERVICE])
    return {
      ...Ka(e, t, "route"),
      op: "rpc",
    };
  if (t[Q.SEMATTRS_MESSAGING_SYSTEM])
    return {
      ...Ka(e, t, i),
      op: "message",
    };
  const l = t[Q.SEMATTRS_FAAS_TRIGGER];
  return l
    ? {
        ...Ka(e, t, i),
        op: l.toString(),
      }
    : {
        op: void 0,
        description: e,
        source: "custom",
      };
}
function cM(e) {
  const t = HE(e) ? e.attributes : {},
    n = nM(e) ? e.name : "<unknown>",
    r = DB(e);
  return aM(n, t, r);
}
function GB({ attributes: e, name: t }) {
  const n = e[Vo];
  if (typeof n == "string")
    return {
      op: "db",
      description: n,
      source: e[Kt] || "custom",
    };
  if (e[Kt] === "custom")
    return {
      op: "db",
      description: t,
      source: "custom",
    };
  const r = e[Q.SEMATTRS_DB_STATEMENT];
  return {
    op: "db",
    description: r ? r.toString() : t,
    source: "task",
  };
}
function VB({ name: e, kind: t, attributes: n }, r) {
  const o = ["http"];
  switch (t) {
    case C.SpanKind.CLIENT:
      o.push("client");
      break;
    case C.SpanKind.SERVER:
      o.push("server");
      break;
  }
  n["sentry.http.prefetch"] && o.push("prefetch");
  const { urlPath: s, url: i, query: a, fragment: c, hasRoute: l } = $B(n, t);
  if (!s)
    return {
      ...Ka(e, n),
      op: o.join("."),
    };
  const f = n[Ha],
    d = `${r} ${s}`,
    u = f ? `${d} (${xB(f)})` : d,
    _ = l || s === "/" ? "route" : "url",
    p = {};
  (i && (p.url = i), a && (p["http.query"] = a), c && (p["http.fragment"] = c));
  const E = t === C.SpanKind.CLIENT || t === C.SpanKind.SERVER,
    T = !`${n[Ge] || "manual"}`.startsWith("auto"),
    m = n[Kt] === "custom",
    A = n[Vo],
    g = !m && A == null && (E || !T),
    { description: N, source: O } = g
      ? {
          description: u,
          source: _,
        }
      : Ka(e, n);
  return {
    op: o.join("."),
    description: N,
    source: O,
    data: p,
  };
}
function xB(e) {
  if (Array.isArray(e)) {
    const t = e.slice().sort();
    return t.length <= 5
      ? t.join(", ")
      : `${t.slice(0, 5).join(", ")}, +${t.length - 5}`;
  }
  return `${e}`;
}
function $B(e, t) {
  const n = e[Q.SEMATTRS_HTTP_TARGET],
    r = e[Q.SEMATTRS_HTTP_URL] || e[Q.ATTR_URL_FULL],
    o = e[Q.ATTR_HTTP_ROUTE],
    s = typeof r == "string" ? El(r) : void 0,
    i = s ? hl(s) : void 0,
    a = s?.search || void 0,
    c = s?.hash || void 0;
  return typeof o == "string"
    ? {
        urlPath: o,
        url: i,
        query: a,
        fragment: c,
        hasRoute: !0,
      }
    : t === C.SpanKind.SERVER && typeof n == "string"
      ? {
          urlPath: ic(n),
          url: i,
          query: a,
          fragment: c,
          hasRoute: !1,
        }
      : s
        ? {
            urlPath: i,
            url: i,
            query: a,
            fragment: c,
            hasRoute: !1,
          }
        : typeof n == "string"
          ? {
              urlPath: ic(n),
              url: i,
              query: a,
              fragment: c,
              hasRoute: !1,
            }
          : {
              urlPath: void 0,
              url: i,
              query: a,
              fragment: c,
              hasRoute: !1,
            };
}
function Ka(e, t, n = "custom") {
  const r = t[Kt] || n,
    o = t[Vo];
  return o && typeof o == "string"
    ? {
        description: o,
        source: r,
      }
    : {
        description: e,
        source: r,
      };
}
function BB(e) {
  e.on("createDsc", (t, n) => {
    if (!n) return;
    const s = Re(n).data[Kt],
      { description: i } = nM(n)
        ? cM(n)
        : {
            description: void 0,
          };
    if ((s !== "url" && i && (t.transaction = i), zt())) {
      const a = Bo(n.spanContext());
      t.sampled = a == null ? void 0 : String(a);
    }
  });
}
function uM() {
  return C.trace.getActiveSpan();
}
const gn = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__;
function lM({ dsc: e, sampled: t }) {
  const n = e ? AE(e) : void 0,
    r = new zo(),
    o = n ? r.set(FE, n) : r;
  return t === !1 ? o.set(YE, "1") : o;
}
const dM = new Set();
function HB() {
  return Array.from(dM);
}
function bl(e) {
  dM.add(e);
}
class FB extends tI {
  constructor() {
    (super(),
      bl("SentryPropagator"),
      (this._urlMatchesTargetsMap = new es(100)));
  }
  inject(t, n, r) {
    if (Rn(t)) {
      gn &&
        $.log(
          "[Tracing] Not injecting trace data for url because tracing is suppressed.",
        );
      return;
    }
    const o = C.trace.getSpan(t),
      s = o && qB(o),
      i = he()?.getOptions()?.tracePropagationTargets;
    if (!jE(s, i, this._urlMatchesTargetsMap)) {
      gn &&
        $.log(
          "[Tracing] Not injecting trace data for url because it does not match tracePropagationTargets:",
          s,
        );
      return;
    }
    const a = jB(n);
    let c = C.propagation.getBaggage(t) || C.propagation.createBaggage({});
    const {
      dynamicSamplingContext: l,
      traceId: f,
      spanId: d,
      sampled: u,
    } = fM(t);
    if (a) {
      const _ = mu(a);
      _ &&
        Object.entries(_).forEach(([p, E]) => {
          c = c.setEntry(p, {
            value: E,
          });
        });
    }
    (l &&
      (c = Object.entries(l).reduce(
        (_, [p, E]) =>
          E
            ? _.setEntry(`${mE}${p}`, {
                value: E,
              })
            : _,
        c,
      )),
      f && f !== C.INVALID_TRACEID && r.set(n, Id, cl(f, d, u)),
      super.inject(C.propagation.setBaggage(t, c), n, r));
  }
  extract(t, n, r) {
    const o = r.get(n, Id),
      s = r.get(n, gp),
      i = o ? (Array.isArray(o) ? o[0] : o) : void 0;
    return pM(
      _M(t, {
        sentryTrace: i,
        baggage: s,
      }),
    );
  }
  fields() {
    return [Id, gp];
  }
}
const Xg =
  "[Tracing] Not injecting trace data for url because it does not match tracePropagationTargets:";
function jE(e, t, n) {
  if (typeof e != "string" || !t) return !0;
  const r = n?.get(e);
  if (r !== void 0) return (gn && !r && $.log(Xg, e), r);
  const o = Tc(e, t);
  return (n?.set(e, o), gn && !o && $.log(Xg, e), o);
}
function fM(e, t = {}) {
  const n = C.trace.getSpan(e);
  if (n?.spanContext().isRemote) {
    const a = n.spanContext();
    return {
      dynamicSamplingContext: Vt(n),
      traceId: a.traceId,
      spanId: void 0,
      sampled: Bo(a),
    };
  }
  if (n) {
    const a = n.spanContext();
    return {
      dynamicSamplingContext: Vt(n),
      traceId: a.traceId,
      spanId: a.spanId,
      sampled: Bo(a),
    };
  }
  const r = t.scope || ts(e)?.scope || Ke(),
    o = t.client || he(),
    s = r.getPropagationContext();
  return {
    dynamicSamplingContext: o ? gc(o, r) : void 0,
    traceId: s.traceId,
    spanId: s.propagationSpanId,
    sampled: s.sampled,
  };
}
function _M(e, { sentryTrace: t, baggage: n }) {
  const r = zI(t, n),
    { traceId: o, parentSpanId: s, sampled: i, dsc: a } = r,
    c = he(),
    l = Ac(n);
  if (!s || (c && !Jk(c, l?.org_id))) return e;
  const f = WB({
    traceId: o,
    spanId: s,
    sampled: i,
    dsc: a,
  });
  return C.trace.setSpanContext(e, f);
}
function YB(e, t, n) {
  const r = pM(_M(e, t));
  return C.context.with(r, n);
}
function pM(e) {
  const t = ts(e),
    n = {
      scope: t ? t.scope : Ke().clone(),
      isolationScope: t ? t.isolationScope : je(),
    };
  return iM(e, n);
}
function jB(e) {
  try {
    const t = e[gp];
    return Array.isArray(t) ? t.join(",") : t;
  } catch {
    return;
  }
}
function qB(e) {
  const t = Re(e).data,
    n = t[Q.SEMATTRS_HTTP_URL] || t[Q.ATTR_URL_FULL];
  if (typeof n == "string") return n;
  const r = e.spanContext().traceState?.get(rM);
  if (r) return r;
}
function WB({ spanId: e, traceId: t, sampled: n, dsc: r }) {
  const o = lM({
    dsc: r,
    sampled: n,
  });
  return {
    traceId: t,
    spanId: e,
    isRemote: !0,
    traceFlags: n ? C.TraceFlags.SAMPLED : C.TraceFlags.NONE,
    traceState: o,
  };
}
function EM(e, t, n) {
  const r = TM(),
    { name: o, parentSpan: s } = e;
  return AM(s)(() => {
    const a = mM(e.scope, e.forceTransaction),
      l = e.onlyIfParent && !C.trace.getSpan(a) ? zr(a) : a,
      f = SM(e);
    if (!zt()) {
      const d = Rn(l) ? l : zr(l);
      return C.context.with(d, () =>
        r.startActiveSpan(o, f, d, (u) =>
          C.context.with(a, () =>
            to(
              () => t(u),
              () => {
                Re(u).status === void 0 &&
                  u.setStatus({
                    code: C.SpanStatusCode.ERROR,
                  });
              },
              n ? () => u.end() : void 0,
            ),
          ),
        ),
      );
    }
    return r.startActiveSpan(o, f, l, (d) =>
      to(
        () => t(d),
        () => {
          Re(d).status === void 0 &&
            d.setStatus({
              code: C.SpanStatusCode.ERROR,
            });
        },
        n ? () => d.end() : void 0,
      ),
    );
  });
}
function KB(e, t) {
  return EM(e, t, !0);
}
function zB(e, t) {
  return EM(e, (n) => t(n, () => n.end()), !1);
}
function ZB(e) {
  const t = TM(),
    { name: n, parentSpan: r } = e;
  return AM(r)(() => {
    const s = mM(e.scope, e.forceTransaction);
    let a = e.onlyIfParent && !C.trace.getSpan(s) ? zr(s) : s;
    const c = SM(e);
    return (zt() || (a = Rn(a) ? a : zr(a)), t.startSpan(n, c, a));
  });
}
function hM(e, t) {
  const n = e
    ? C.trace.setSpan(C.context.active(), e)
    : C.trace.deleteSpan(C.context.active());
  return C.context.with(n, () => t(Ke()));
}
function TM() {
  return he()?.tracer || C.trace.getTracer("@sentry/opentelemetry", Ze);
}
function SM(e) {
  const { startTime: t, attributes: n, kind: r, op: o, links: s } = e,
    i = typeof t == "number" ? XB(t) : t;
  return {
    attributes: o
      ? {
          [Ee]: o,
          ...n,
        }
      : n,
    kind: r,
    links: s,
    startTime: i,
  };
}
function XB(e) {
  return e < 9999999999 ? e * 1e3 : e;
}
function mM(e, t) {
  const n = QB(e),
    r = C.trace.getSpan(n);
  if (!r || !t) return n;
  const o = C.trace.deleteSpan(n),
    { spanId: s, traceId: i } = r.spanContext(),
    a = Bo(r.spanContext()),
    c = Yt(r),
    l = Vt(c),
    f = lM({
      dsc: l,
      sampled: a,
    }),
    d = {
      traceId: i,
      spanId: s,
      isRemote: !0,
      traceFlags: a ? C.TraceFlags.SAMPLED : C.TraceFlags.NONE,
      traceState: f,
    };
  return C.trace.setSpanContext(o, d);
}
function QB(e) {
  if (e) {
    const t = ac(e);
    if (t) return t;
  }
  return C.context.active();
}
function JB(e, t) {
  return YB(C.context.active(), e, t);
}
function eH(e, t) {
  const n = ac(t),
    r = n && C.trace.getSpan(n),
    o = r ? ul(r) : hE(t);
  return [r ? Vt(r) : gc(e, t), o];
}
function AM(e) {
  return e !== void 0 ? (t) => hM(e, t) : (t) => t();
}
function tH(e) {
  const t = zr(C.context.active());
  return C.context.with(t, e);
}
function nH(e) {
  e.on("preprocessEvent", (t) => {
    const n = uM();
    if (!n || t.type === "transaction") return;
    t.contexts = {
      trace: ul(n),
      ...t.contexts,
    };
    const r = Yt(n);
    return (
      (t.sdkProcessingMetadata = {
        dynamicSamplingContext: Vt(r),
        ...t.sdkProcessingMetadata,
      }),
      t
    );
  });
}
function rH({ span: e, scope: t, client: n } = {}) {
  let r = (t && ac(t)) ?? C.context.active();
  if (e) {
    const { scope: c } = xo(e);
    r = (c && ac(c)) || C.trace.setSpan(C.context.active(), e);
  }
  const {
    traceId: o,
    spanId: s,
    sampled: i,
    dynamicSamplingContext: a,
  } = fM(r, {
    scope: t,
    client: n,
  });
  return {
    "sentry-trace": cl(o, s, i),
    baggage: AE(a),
  };
}
function oH() {
  function e() {
    const a = C.context.active(),
      c = ts(a);
    return (
      c || {
        scope: EE(),
        isolationScope: Xo(),
      }
    );
  }
  function t(a) {
    const c = C.context.active();
    return C.context.with(c, () => a(s()));
  }
  function n(a, c) {
    const l = ac(a) || C.context.active();
    return C.context.with(l.setValue(Np, a), () => c(a));
  }
  function r(a) {
    const c = C.context.active();
    return C.context.with(c.setValue(Rp, !0), () => a(i()));
  }
  function o(a, c) {
    const l = C.context.active();
    return C.context.with(l.setValue(yp, a), () => c(i()));
  }
  function s() {
    return e().scope;
  }
  function i() {
    return e().isolationScope;
  }
  Mk({
    withScope: t,
    withSetScope: n,
    withSetIsolationScope: o,
    withIsolationScope: r,
    getCurrentScope: s,
    getIsolationScope: i,
    startSpan: KB,
    startSpanManual: zB,
    startInactiveSpan: ZB,
    getActiveSpan: uM,
    suppressTracing: tH,
    getTraceData: rH,
    continueTrace: JB,
    withActiveSpan: hM,
  });
}
function sH(e) {
  class t extends e {
    constructor(...r) {
      (super(...r), bl("SentryContextManager"));
    }
    with(r, o, s, ...i) {
      const a = ts(r),
        c = a?.scope || Ke(),
        l = a?.isolationScope || je(),
        f = r.getValue(Rp) === !0,
        d = r.getValue(Np),
        u = r.getValue(yp),
        _ = d || c.clone(),
        p = u || (f ? l.clone() : l),
        T = iM(r, {
          scope: _,
          isolationScope: p,
        })
          .deleteValue(Rp)
          .deleteValue(Np)
          .deleteValue(yp);
      return (kB(_, T), super.with(T, o, s, ...i));
    }
  }
  return t;
}
function iH(e) {
  const t = new Map();
  for (const n of e) aH(t, n);
  return Array.from(t, function ([n, r]) {
    return r;
  });
}
function gM(e) {
  return e.attributes[$E] === !0 ? void 0 : BE(e);
}
function aH(e, t) {
  const n = t.spanContext().spanId,
    r = gM(t);
  if (!r) {
    Op(e, {
      id: n,
      span: t,
      children: [],
    });
    return;
  }
  const o = cH(e, r),
    s = Op(e, {
      id: n,
      span: t,
      parentNode: o,
      children: [],
    });
  o.children.push(s);
}
function cH(e, t) {
  const n = e.get(t);
  return (
    n ||
    Op(e, {
      id: t,
      children: [],
    })
  );
}
function Op(e, t) {
  const n = e.get(t.id);
  return n?.span
    ? n
    : n && !n.span
      ? ((n.span = t.span), (n.parentNode = t.parentNode), n)
      : (e.set(t.id, t), t);
}
const RM = {
    1: "cancelled",
    2: "unknown_error",
    3: "invalid_argument",
    4: "deadline_exceeded",
    5: "not_found",
    6: "already_exists",
    7: "permission_denied",
    8: "resource_exhausted",
    9: "failed_precondition",
    10: "aborted",
    11: "out_of_range",
    12: "unimplemented",
    13: "internal_error",
    14: "unavailable",
    15: "data_loss",
    16: "unauthenticated",
  },
  uH = (e) => Object.values(RM).includes(e);
function NM(e) {
  const t = HE(e) ? e.attributes : {},
    n = vB(e) ? e.status : void 0;
  if (n) {
    if (n.code === C.SpanStatusCode.OK)
      return {
        code: Su,
      };
    if (n.code === C.SpanStatusCode.ERROR) {
      if (typeof n.message > "u") {
        const o = Qg(t);
        if (o) return o;
      }
      return n.message && uH(n.message)
        ? {
            code: Ae,
            message: n.message,
          }
        : {
            code: Ae,
            message: "internal_error",
          };
    }
  }
  const r = Qg(t);
  return (
    r ||
    (n?.code === C.SpanStatusCode.UNSET
      ? {
          code: Su,
        }
      : {
          code: Ae,
          message: "unknown_error",
        })
  );
}
function Qg(e) {
  const t =
      e[Q.ATTR_HTTP_RESPONSE_STATUS_CODE] || e[Q.SEMATTRS_HTTP_STATUS_CODE],
    n = e[Q.SEMATTRS_RPC_GRPC_STATUS_CODE],
    r = typeof t == "number" ? t : typeof t == "string" ? parseInt(t) : void 0;
  if (typeof r == "number") return lp(r);
  if (typeof n == "string")
    return {
      code: Ae,
      message: RM[n] || "unknown_error",
    };
}
const Jg = 1e3,
  eR = 300;
class lH {
  constructor(t) {
    ((this._finishedSpanBucketSize = t?.timeout || eR),
      (this._finishedSpanBuckets = new Array(this._finishedSpanBucketSize).fill(
        void 0,
      )),
      (this._lastCleanupTimestampInS = Math.floor(Date.now() / 1e3)),
      (this._spansToBucketEntry = new WeakMap()),
      (this._sentSpans = new Map()),
      (this._debouncedFlush = jG(this.flush.bind(this), 1, {
        maxWait: 100,
      })));
  }
  export(t) {
    const n = Math.floor(Date.now() / 1e3);
    if (this._lastCleanupTimestampInS !== n) {
      let i = 0;
      (this._finishedSpanBuckets.forEach((a, c) => {
        a &&
          a.timestampInS <= n - this._finishedSpanBucketSize &&
          ((i += a.spans.size), (this._finishedSpanBuckets[c] = void 0));
      }),
        i > 0 &&
          gn &&
          $.log(
            `SpanExporter dropped ${i} spans because they were pending for more than ${this._finishedSpanBucketSize} seconds.`,
          ),
        (this._lastCleanupTimestampInS = n));
    }
    const r = n % this._finishedSpanBucketSize,
      o = this._finishedSpanBuckets[r] || {
        timestampInS: n,
        spans: new Set(),
      };
    ((this._finishedSpanBuckets[r] = o),
      o.spans.add(t),
      this._spansToBucketEntry.set(t, o));
    const s = gM(t);
    (!s || this._sentSpans.has(s)) && this._debouncedFlush();
  }
  flush() {
    const t = this._finishedSpanBuckets.flatMap((i) =>
      i ? Array.from(i.spans) : [],
    );
    this._flushSentSpanCache();
    const n = this._maybeSend(t),
      r = n.size,
      o = t.length - r;
    gn &&
      $.log(
        `SpanExporter exported ${r} spans, ${o} spans are waiting for their parent spans to finish`,
      );
    const s = Date.now() + eR * 1e3;
    for (const i of n) {
      this._sentSpans.set(i.spanContext().spanId, s);
      const a = this._spansToBucketEntry.get(i);
      a && a.spans.delete(i);
    }
    this._debouncedFlush.cancel();
  }
  clear() {
    ((this._finishedSpanBuckets = this._finishedSpanBuckets.fill(void 0)),
      this._sentSpans.clear(),
      this._debouncedFlush.cancel());
  }
  _maybeSend(t) {
    const n = iH(t),
      r = new Set(),
      o = this._getCompletedRootNodes(n);
    for (const s of o) {
      const i = s.span;
      r.add(i);
      const a = fH(i);
      if (s.parentNode && this._sentSpans.has(s.parentNode.id)) {
        const f = a.contexts?.trace?.data;
        f && (f["sentry.parent_span_already_sent"] = !0);
      }
      const c = a.spans || [];
      for (const f of s.children) Cp(f, c, r);
      a.spans =
        c.length > Jg
          ? c.sort((f, d) => f.start_timestamp - d.start_timestamp).slice(0, Jg)
          : c;
      const l = Au(i.events);
      (l && (a.measurements = l), W1(a));
    }
    return r;
  }
  _flushSentSpanCache() {
    const t = Date.now();
    for (const [n, r] of this._sentSpans.entries())
      r <= t && this._sentSpans.delete(n);
  }
  _nodeIsCompletedRootNodeOrHasSentParent(t) {
    return !!t.span && (!t.parentNode || this._sentSpans.has(t.parentNode.id));
  }
  _getCompletedRootNodes(t) {
    return t.filter((n) => this._nodeIsCompletedRootNodeOrHasSentParent(n));
  }
}
function dH(e) {
  const t = e.attributes,
    n = t[Ge],
    r = t[Ee],
    o = t[Kt];
  return {
    origin: n,
    op: r,
    source: o,
  };
}
function fH(e) {
  const {
      op: t,
      description: n,
      data: r,
      origin: o = "manual",
      source: s,
    } = yM(e),
    i = xo(e),
    a = e.attributes[Go],
    c = {
      [Kt]: s,
      [Go]: a,
      [Ee]: t,
      [Ge]: o,
      ...r,
      ...OM(e.attributes),
    },
    { links: l } = e,
    { traceId: f, spanId: d } = e.spanContext(),
    u = BE(e),
    _ = NM(e),
    p = {
      parent_span_id: u,
      span_id: d,
      trace_id: f,
      data: c,
      origin: o,
      op: t,
      status: dl(_),
      links: ll(l),
    },
    E = c[Q.ATTR_HTTP_RESPONSE_STATUS_CODE],
    h =
      typeof E == "number"
        ? {
            response: {
              status_code: E,
            },
          }
        : void 0;
  return {
    contexts: {
      trace: p,
      otel: {
        resource: e.resource.attributes,
      },
      ...h,
    },
    spans: [],
    start_timestamp: Sn(e.startTime),
    timestamp: Sn(e.endTime),
    transaction: n,
    type: "transaction",
    sdkProcessingMetadata: {
      capturedSpanScope: i.scope,
      capturedSpanIsolationScope: i.isolationScope,
      sampleRate: a,
      dynamicSamplingContext: Vt(e),
    },
    ...(s && {
      transaction_info: {
        source: s,
      },
    }),
  };
}
function Cp(e, t, n) {
  const r = e.span;
  if ((r && n.add(r), !r)) {
    e.children.forEach((A) => {
      Cp(A, t, n);
    });
    return;
  }
  const s = r.spanContext().spanId,
    i = r.spanContext().traceId,
    a = BE(r),
    { attributes: c, startTime: l, endTime: f, links: d } = r,
    { op: u, description: _, data: p, origin: E = "manual" } = yM(r),
    h = {
      [Ge]: E,
      [Ee]: u,
      ...OM(c),
      ...p,
    },
    T = NM(r),
    m = {
      span_id: s,
      trace_id: i,
      data: h,
      description: _,
      parent_span_id: a,
      start_timestamp: Sn(l),
      timestamp: Sn(f) || void 0,
      status: dl(T),
      op: u,
      origin: E,
      measurements: Au(r.events),
      links: ll(d),
    };
  (t.push(m),
    e.children.forEach((A) => {
      Cp(A, t, n);
    }));
}
function yM(e) {
  const { op: t, source: n, origin: r } = dH(e),
    { op: o, description: s, source: i, data: a } = cM(e),
    c = t || o,
    l = n || i,
    f = {
      ...a,
      ..._H(e),
    };
  return {
    op: c,
    description: s,
    source: l,
    origin: r,
    data: f,
  };
}
function OM(e) {
  const t = {
    ...e,
  };
  return (delete t[Go], delete t[$E], delete t[Vo], t);
}
function _H(e) {
  const t = e.attributes,
    n = {};
  e.kind !== C.SpanKind.INTERNAL && (n["otel.kind"] = C.SpanKind[e.kind]);
  const r = t[Q.SEMATTRS_HTTP_STATUS_CODE];
  r && (n[Q.ATTR_HTTP_RESPONSE_STATUS_CODE] = r);
  const o = LB(e);
  return (
    o.url && (n.url = o.url),
    o["http.query"] && (n["http.query"] = o["http.query"].slice(1)),
    o["http.fragment"] && (n["http.fragment"] = o["http.fragment"].slice(1)),
    n
  );
}
function pH(e, t) {
  const n = C.trace.getSpan(t);
  let r = ts(t);
  (n && !n.spanContext().isRemote && RE(n, e),
    n?.spanContext().isRemote && e.setAttribute($E, !0),
    t === C.ROOT_CONTEXT &&
      (r = {
        scope: EE(),
        isolationScope: Xo(),
      }),
    r && YI(e, r.scope, r.isolationScope),
    rP(e),
    he()?.emit("spanStart", e));
}
function EH(e) {
  (oP(e), he()?.emit("spanEnd", e));
}
class hH {
  constructor(t) {
    (bl("SentrySpanProcessor"), (this._exporter = new lH(t)));
  }
  async forceFlush() {
    this._exporter.flush();
  }
  async shutdown() {
    this._exporter.clear();
  }
  onStart(t, n) {
    pH(t, n);
  }
  onEnd(t) {
    (EH(t), this._exporter.export(t));
  }
}
class TH {
  constructor(t) {
    ((this._client = t), bl("SentrySampler"));
  }
  shouldSample(t, n, r, o, s, i) {
    const a = this._client.getOptions(),
      c = AH(t),
      l = c?.spanContext();
    if (!zt(a))
      return So({
        decision: void 0,
        context: t,
        spanAttributes: s,
      });
    const f = s[Q.SEMATTRS_HTTP_METHOD] || s[Q.ATTR_HTTP_REQUEST_METHOD];
    if (o === C.SpanKind.CLIENT && f && (!c || l?.isRemote))
      return So({
        decision: void 0,
        context: t,
        spanAttributes: s,
      });
    const d = c ? SH(c, n, r) : void 0;
    if (!(!c || l?.isRemote))
      return So({
        decision: d ? wt.RECORD_AND_SAMPLED : wt.NOT_RECORD,
        context: t,
        spanAttributes: s,
      });
    const { description: _, data: p, op: E } = aM(r, s, o),
      h = {
        ...p,
        ...s,
      };
    E && (h[Ee] = E);
    const T = {
      decision: !0,
    };
    if (
      (this._client.emit(
        "beforeSampling",
        {
          spanAttributes: h,
          spanName: _,
          parentSampled: d,
          parentContext: l,
        },
        T,
      ),
      !T.decision)
    )
      return So({
        decision: void 0,
        context: t,
        spanAttributes: s,
      });
    const { isolationScope: m } = ts(t) ?? {},
      A = l?.traceState ? l.traceState.get(FE) : void 0,
      g = A ? Ac(A) : void 0,
      N = eo(g?.sample_rand) ?? Math.random(),
      [O, I, b] = sP(
        a,
        {
          name: _,
          attributes: h,
          normalizedRequest:
            m?.getScopeData().sdkProcessingMetadata.normalizedRequest,
          parentSampled: d,
          parentSampleRate: eo(g?.sample_rate),
        },
        N,
      ),
      w = `${f}`.toUpperCase();
    return w === "OPTIONS" || w === "HEAD"
      ? (gn &&
          $.log(
            `[Tracing] Not sampling span because HTTP method is '${w}' for ${r}`,
          ),
        So({
          decision: wt.NOT_RECORD,
          context: t,
          spanAttributes: s,
          sampleRand: N,
          downstreamTraceSampleRate: 0,
        }))
      : (!O &&
          d === void 0 &&
          (gn &&
            $.log(
              "[Tracing] Discarding root span because its trace was not chosen to be sampled.",
            ),
          this._client.recordDroppedEvent("sample_rate", "transaction")),
        {
          ...So({
            decision: O ? wt.RECORD_AND_SAMPLED : wt.NOT_RECORD,
            context: t,
            spanAttributes: s,
            sampleRand: N,
            downstreamTraceSampleRate: b ? I : void 0,
          }),
          attributes: {
            [Go]: b ? I : void 0,
          },
        });
  }
  toString() {
    return "SentrySampler";
  }
}
function SH(e, t, n) {
  const r = e.spanContext();
  if (C.isSpanContextValid(r) && r.traceId === t) {
    if (r.isRemote) {
      const s = Bo(e.spanContext());
      return (
        gn &&
          $.log(
            `[Tracing] Inheriting remote parent's sampled decision for ${n}: ${s}`,
          ),
        s
      );
    }
    const o = Bo(r);
    return (
      gn &&
        $.log(`[Tracing] Inheriting parent's sampled decision for ${n}: ${o}`),
      o
    );
  }
}
function So({
  decision: e,
  context: t,
  spanAttributes: n,
  sampleRand: r,
  downstreamTraceSampleRate: o,
}) {
  let s = mH(t, n);
  return (
    o !== void 0 && (s = s.set(UB, `${o}`)),
    r !== void 0 && (s = s.set(wB, `${r}`)),
    e == null
      ? {
          decision: wt.NOT_RECORD,
          traceState: s,
        }
      : e === wt.NOT_RECORD
        ? {
            decision: e,
            traceState: s.set(YE, "1"),
          }
        : {
            decision: e,
            traceState: s,
          }
  );
}
function mH(e, t) {
  let o = C.trace.getSpan(e)?.spanContext()?.traceState || new zo();
  const s = t[Q.SEMATTRS_HTTP_URL] || t[Q.ATTR_URL_FULL];
  return (s && typeof s == "string" && (o = o.set(rM, s)), o);
}
function AH(e) {
  const t = C.trace.getSpan(e);
  return t && C.isSpanContextValid(t.spanContext()) ? t : void 0;
}
function bp(e, t) {
  if (!e) return t;
  const n = mu(e),
    r = mu(t);
  if (!r) return e;
  const o = {
    ...n,
  };
  return (
    Object.entries(r).forEach(([s, i]) => {
      o[s] || (o[s] = i);
    }),
    jI(o)
  );
}
function gH(e, t) {
  const n = NH(e),
    r = t?.statusCode,
    o = qP(r);
  $o(
    {
      category: "http",
      data: {
        status_code: r,
        ...n,
      },
      type: "http",
      level: o,
    },
    {
      event: "response",
      request: e,
      response: t,
    },
  );
}
function RH(e, t) {
  const n = OH(e),
    r = he()?.getOptions().tracePropagationTargets,
    o = jE(n, r, t) ? CP() : void 0;
  if (!o) return;
  const { "sentry-trace": s, baggage: i } = o;
  if (s && !e.getHeader("sentry-trace"))
    try {
      (e.setHeader("sentry-trace", s),
        Ie && $.log(No, "Added sentry-trace header to outgoing request"));
    } catch (a) {
      Ie &&
        $.error(
          No,
          "Failed to add sentry-trace header to outgoing request:",
          pu(a) ? a.message : "Unknown error",
        );
    }
  if (i) {
    const a = bp(e.getHeader("baggage"), i);
    if (a)
      try {
        (e.setHeader("baggage", a),
          Ie && $.log(No, "Added baggage header to outgoing request"));
      } catch (c) {
        Ie &&
          $.error(
            No,
            "Failed to add baggage header to outgoing request:",
            pu(c) ? c.message : "Unknown error",
          );
      }
  }
}
function NH(e) {
  try {
    const t = e.getHeader("host") || e.host,
      n = new URL(e.path, `${e.protocol}//${t}`),
      r = El(n.toString()),
      o = {
        url: hl(r),
        "http.method": e.method || "GET",
      };
    return (
      r.search && (o["http.query"] = r.search),
      r.hash && (o["http.fragment"] = r.hash),
      o
    );
  } catch {
    return {};
  }
}
function yH(e) {
  return {
    method: e.method,
    protocol: e.protocol,
    host: e.host,
    hostname: e.host,
    path: e.path,
    headers: e.getHeaders(),
  };
}
function OH(e) {
  const t = e.getHeader("host") || e.host,
    n = e.protocol,
    r = e.path;
  return `${n}//${t}${r}`;
}
class CM extends Ot {
  constructor(t = {}) {
    (super(No, Ze, t),
      (this._propagationDecisionMap = new es(100)),
      (this._ignoreOutgoingRequestsMap = new WeakMap()));
  }
  init() {
    let t = !1;
    const n = (a) => {
        const c = a;
        this._onOutgoingRequestFinish(c.request, c.response);
      },
      r = (a) => {
        const c = a;
        this._onOutgoingRequestFinish(c.request, void 0);
      },
      o = (a) => {
        const c = a;
        this._onOutgoingRequestCreated(c.request);
      },
      s = (a) => (
        t ||
          ((t = !0),
          diagnosticsChannel.subscribe("http.client.response.finish", n),
          diagnosticsChannel.subscribe("http.client.request.error", r),
          this.getConfig().propagateTraceInOutgoingRequests &&
            diagnosticsChannel.subscribe("http.client.request.created", o)),
        a
      ),
      i = () => {
        (diagnosticsChannel.unsubscribe("http.client.response.finish", n),
          diagnosticsChannel.unsubscribe("http.client.request.error", r),
          diagnosticsChannel.unsubscribe("http.client.request.created", o));
      };
    return [new ft("http", ["*"], s, i), new ft("https", ["*"], s, i)];
  }
  _onOutgoingRequestFinish(t, n) {
    Ie && $.log(No, "Handling finished outgoing request");
    const r = this.getConfig().breadcrumbs,
      o = typeof r > "u" ? !0 : r,
      s =
        this._ignoreOutgoingRequestsMap.get(t) ??
        this._shouldIgnoreOutgoingRequest(t);
    (this._ignoreOutgoingRequestsMap.set(t, s), o && !s && gH(t, n));
  }
  _onOutgoingRequestCreated(t) {
    const n =
      this._ignoreOutgoingRequestsMap.get(t) ??
      this._shouldIgnoreOutgoingRequest(t);
    (this._ignoreOutgoingRequestsMap.set(t, n),
      !n && RH(t, this._propagationDecisionMap));
  }
  _shouldIgnoreOutgoingRequest(t) {
    if (Rn(C.context.active())) return !0;
    const n = this.getConfig().ignoreOutgoingRequests;
    if (!n) return !1;
    const r = yH(t),
      o = ZP(t);
    return n(o, r);
  }
}
const bM = "Http",
  CH = Ne(`${bM}.sentry`, (e) => new CM(e)),
  bH = (e = {}) => {
    const t = {
        sessions: e.trackIncomingRequestsAsSessions,
        sessionFlushingDelayMS: e.sessionFlushingDelayMS,
        ignoreRequestBody: e.ignoreIncomingRequestBody,
        maxRequestBodySize: e.maxIncomingRequestBodySize,
      },
      n = {
        ignoreIncomingRequests: e.ignoreIncomingRequests,
        ignoreStaticAssets: e.ignoreStaticAssets,
        ignoreStatusCodes: e.dropSpansForIncomingRequestStatusCodes,
      },
      r = {
        breadcrumbs: e.breadcrumbs,
        propagateTraceInOutgoingRequests: !0,
        ignoreOutgoingRequests: e.ignoreOutgoingRequests,
      },
      o = KP(t),
      s = zP(n),
      i = e.spans ?? !1,
      a = e.disableIncomingRequestSpans ?? !1,
      c = i && !a;
    return {
      name: bM,
      setup(l) {
        c && s.setup(l);
      },
      setupOnce() {
        (o.setupOnce(), CH(r));
      },
      processEvent(l) {
        return s.processEvent(l);
      },
    };
  },
  Il = mk(process.versions.node),
  Do = Il.major,
  Ip = Il.minor,
  wc = "sentry-trace",
  Pd = "baggage",
  tR = /baggage: (.*)\r\n/;
class IM extends Ot {
  constructor(t = {}) {
    (super("@sentry/instrumentation-node-fetch", Ze, t),
      (this._channelSubs = []),
      (this._propagationDecisionMap = new es(100)),
      (this._ignoreOutgoingRequestsMap = new WeakMap()));
  }
  init() {}
  disable() {
    (super.disable(),
      this._channelSubs.forEach((t) => t.unsubscribe()),
      (this._channelSubs = []));
  }
  enable() {
    (super.enable(),
      (this._channelSubs = this._channelSubs || []),
      !(this._channelSubs.length > 0) &&
        (this._subscribeToChannel(
          "undici:request:create",
          this._onRequestCreated.bind(this),
        ),
        this._subscribeToChannel(
          "undici:request:headers",
          this._onResponseHeaders.bind(this),
        )));
  }
  _onRequestCreated({ request: t }) {
    if (!(this.getConfig().enabled !== !1)) return;
    const o = this._shouldIgnoreOutgoingRequest(t);
    if ((this._ignoreOutgoingRequestsMap.set(t, o), o)) return;
    const s = Pp(t.origin, t.path),
      i = he()?.getOptions().tracePropagationTargets,
      a = jE(s, i, this._propagationDecisionMap) ? CP() : void 0;
    if (!a) return;
    const { "sentry-trace": c, baggage: l } = a;
    if (Array.isArray(t.headers)) {
      const f = t.headers;
      c && !f.includes(wc) && f.push(wc, c);
      const d = f.findIndex((u) => u === Pd);
      if (l && d === -1) f.push(Pd, l);
      else if (l) {
        const u = f[d + 1],
          _ = bp(u, l);
        _ && (f[d + 1] = _);
      }
    } else {
      const f = t.headers;
      c &&
        !f.includes(`${wc}:`) &&
        (t.headers += `${wc}: ${c}\r
`);
      const d = t.headers.match(tR)?.[1];
      if (l && !d)
        t.headers += `${Pd}: ${l}\r
`;
      else if (l) {
        const u = bp(d, l);
        u &&
          (t.headers = t.headers.replace(
            tR,
            `baggage: ${u}\r
`,
          ));
      }
    }
  }
  _onResponseHeaders({ request: t, response: n }) {
    const r = this.getConfig();
    if (!(r.enabled !== !1)) return;
    const s = r.breadcrumbs,
      i = typeof s > "u" ? !0 : s,
      a = this._ignoreOutgoingRequestsMap.get(t);
    i && !a && IH(t, n);
  }
  _subscribeToChannel(t, n) {
    const r = Do > 18 || (Do === 18 && Ip >= 19);
    let o;
    if (r) (ql.subscribe?.(t, n), (o = () => ql.unsubscribe?.(t, n)));
    else {
      const s = ql.channel(t);
      (s.subscribe(n), (o = () => s.unsubscribe(n)));
    }
    this._channelSubs.push({
      name: t,
      unsubscribe: o,
    });
  }
  _shouldIgnoreOutgoingRequest(t) {
    if (Rn(C.context.active())) return !0;
    const n = Pp(t.origin, t.path),
      r = this.getConfig().ignoreOutgoingRequests;
    return typeof r != "function" || !n ? !1 : r(n);
  }
}
function IH(e, t) {
  const n = PH(e),
    r = t.statusCode,
    o = qP(r);
  $o(
    {
      category: "http",
      data: {
        status_code: r,
        ...n,
      },
      type: "http",
      level: o,
    },
    {
      event: "response",
      request: e,
      response: t,
    },
  );
}
function PH(e) {
  try {
    const t = Pp(e.origin, e.path),
      n = El(t),
      r = {
        url: hl(n),
        "http.method": e.method || "GET",
      };
    return (
      n.search && (r["http.query"] = n.search),
      n.hash && (r["http.fragment"] = n.hash),
      r
    );
  } catch {
    return {};
  }
}
function Pp(e, t = "/") {
  try {
    return new URL(t, e).toString();
  } catch {
    const n = `${e}`;
    return n.endsWith("/") && t.startsWith("/")
      ? `${n}${t.slice(1)}`
      : !n.endsWith("/") && !t.startsWith("/")
        ? `${n}/${t.slice(1)}`
        : `${n}${t}`;
  }
}
const MH = "NodeFetch",
  vH = Ne(`${MH}.sentry`, IM, (e) => e),
  LH = (e = {}) => ({
    name: "NodeFetch",
    setupOnce() {
      vH(e);
    },
  }),
  DH = LH,
  wH = util.promisify(fs.readFile),
  UH = util.promisify(fs.readdir),
  kH = "Context",
  GH = (e = {}) => {
    let t;
    const n = {
      app: !0,
      os: !0,
      device: !0,
      culture: !0,
      cloudResource: !0,
      ...e,
    };
    async function r(s) {
      t === void 0 && (t = o());
      const i = xH(await t);
      return (
        (s.contexts = {
          ...s.contexts,
          app: {
            ...i.app,
            ...s.contexts?.app,
          },
          os: {
            ...i.os,
            ...s.contexts?.os,
          },
          device: {
            ...i.device,
            ...s.contexts?.device,
          },
          culture: {
            ...i.culture,
            ...s.contexts?.culture,
          },
          cloud_resource: {
            ...i.cloud_resource,
            ...s.contexts?.cloud_resource,
          },
        }),
        s
      );
    }
    async function o() {
      const s = {};
      if (
        (n.os && (s.os = await $H()),
        n.app && (s.app = HH()),
        n.device && (s.device = FH(n.device)),
        n.culture)
      ) {
        const i = BH();
        i && (s.culture = i);
      }
      return (n.cloudResource && (s.cloud_resource = zH()), s);
    }
    return {
      name: kH,
      processEvent(s) {
        return r(s);
      },
    };
  },
  VH = GH;
function xH(e) {
  if (
    (e.app?.app_memory && (e.app.app_memory = process.memoryUsage().rss),
    e.app?.free_memory && typeof process.availableMemory == "function")
  ) {
    const t = process.availableMemory?.();
    t != null && (e.app.free_memory = t);
  }
  return (e.device?.free_memory && (e.device.free_memory = Dt.freemem()), e);
}
async function $H() {
  const e = Dt.platform();
  switch (e) {
    case "darwin":
      return WH();
    case "linux":
      return KH();
    default:
      return {
        name: YH[e] || e,
        version: Dt.release(),
      };
  }
}
function BH() {
  try {
    if (typeof process.versions.icu != "string") return;
    const e = new Date(9e8);
    if (
      new Intl.DateTimeFormat("es", {
        month: "long",
      }).format(e) === "enero"
    ) {
      const n = Intl.DateTimeFormat().resolvedOptions();
      return {
        locale: n.locale,
        timezone: n.timeZone,
      };
    }
  } catch {}
}
function HH() {
  const e = process.memoryUsage().rss,
    n = {
      app_start_time: new Date(
        Date.now() - process.uptime() * 1e3,
      ).toISOString(),
      app_memory: e,
    };
  if (typeof process.availableMemory == "function") {
    const r = process.availableMemory?.();
    r != null && (n.free_memory = r);
  }
  return n;
}
function FH(e) {
  const t = {};
  let n;
  try {
    n = Dt.uptime();
  } catch {}
  if (
    (typeof n == "number" &&
      (t.boot_time = new Date(Date.now() - n * 1e3).toISOString()),
    (t.arch = Dt.arch()),
    (e === !0 || e.memory) &&
      ((t.memory_size = Dt.totalmem()), (t.free_memory = Dt.freemem())),
    e === !0 || e.cpu)
  ) {
    const r = Dt.cpus(),
      o = r?.[0];
    o &&
      ((t.processor_count = r.length),
      (t.cpu_description = o.model),
      (t.processor_frequency = o.speed));
  }
  return t;
}
const YH = {
    aix: "IBM AIX",
    freebsd: "FreeBSD",
    openbsd: "OpenBSD",
    sunos: "SunOS",
    win32: "Windows",
    ohos: "OpenHarmony",
    android: "Android",
  },
  jH = [
    {
      name: "fedora-release",
      distros: ["Fedora"],
    },
    {
      name: "redhat-release",
      distros: ["Red Hat Linux", "Centos"],
    },
    {
      name: "redhat_version",
      distros: ["Red Hat Linux"],
    },
    {
      name: "SuSE-release",
      distros: ["SUSE Linux"],
    },
    {
      name: "lsb-release",
      distros: ["Ubuntu Linux", "Arch Linux"],
    },
    {
      name: "debian_version",
      distros: ["Debian"],
    },
    {
      name: "debian_release",
      distros: ["Debian"],
    },
    {
      name: "arch-release",
      distros: ["Arch Linux"],
    },
    {
      name: "gentoo-release",
      distros: ["Gentoo Linux"],
    },
    {
      name: "novell-release",
      distros: ["SUSE Linux"],
    },
    {
      name: "alpine-release",
      distros: ["Alpine Linux"],
    },
  ],
  qH = {
    alpine: (e) => e,
    arch: (e) => En(/distrib_release=(.*)/, e),
    centos: (e) => En(/release ([^ ]+)/, e),
    debian: (e) => e,
    fedora: (e) => En(/release (..)/, e),
    mint: (e) => En(/distrib_release=(.*)/, e),
    red: (e) => En(/release ([^ ]+)/, e),
    suse: (e) => En(/VERSION = (.*)\n/, e),
    ubuntu: (e) => En(/distrib_release=(.*)/, e),
  };
function En(e, t) {
  const n = e.exec(t);
  return n ? n[1] : void 0;
}
async function WH() {
  const e = {
    kernel_version: Dt.release(),
    name: "Mac OS X",
    version: `10.${Number(Dt.release().split(".")[0]) - 4}`,
  };
  try {
    const t = await new Promise((n, r) => {
      childProcess2.execFile("/usr/bin/sw_vers", (o, s) => {
        if (o) {
          r(o);
          return;
        }
        n(s);
      });
    });
    ((e.name = En(/^ProductName:\s+(.*)$/m, t)),
      (e.version = En(/^ProductVersion:\s+(.*)$/m, t)),
      (e.build = En(/^BuildVersion:\s+(.*)$/m, t)));
  } catch {}
  return e;
}
function nR(e) {
  return e.split(" ")[0].toLowerCase();
}
async function KH() {
  const e = {
    kernel_version: Dt.release(),
    name: "Linux",
  };
  try {
    const t = await UH("/etc"),
      n = jH.find((a) => t.includes(a.name));
    if (!n) return e;
    const r = path2.join("/etc", n.name),
      o = (
        await wH(r, {
          encoding: "utf-8",
        })
      ).toLowerCase(),
      { distros: s } = n;
    e.name = s.find((a) => o.indexOf(nR(a)) >= 0) || s[0];
    const i = nR(e.name);
    e.version = qH[i]?.(o);
  } catch {}
  return e;
}
function zH() {
  return process.env.VERCEL
    ? {
        "cloud.provider": "vercel",
        "cloud.region": process.env.VERCEL_REGION,
      }
    : process.env.AWS_REGION
      ? {
          "cloud.provider": "aws",
          "cloud.region": process.env.AWS_REGION,
          "cloud.platform": process.env.AWS_EXECUTION_ENV,
        }
      : process.env.GCP_PROJECT
        ? {
            "cloud.provider": "gcp",
          }
        : process.env.ALIYUN_REGION_ID
          ? {
              "cloud.provider": "alibaba_cloud",
              "cloud.region": process.env.ALIYUN_REGION_ID,
            }
          : process.env.WEBSITE_SITE_NAME && process.env.REGION_NAME
            ? {
                "cloud.provider": "azure",
                "cloud.region": process.env.REGION_NAME,
              }
            : process.env.IBM_CLOUD_REGION
              ? {
                  "cloud.provider": "ibm_cloud",
                  "cloud.region": process.env.IBM_CLOUD_REGION,
                }
              : process.env.TENCENTCLOUD_REGION
                ? {
                    "cloud.provider": "tencent_cloud",
                    "cloud.region": process.env.TENCENTCLOUD_REGION,
                    "cloud.account.id": process.env.TENCENTCLOUD_APPID,
                    "cloud.availability_zone": process.env.TENCENTCLOUD_ZONE,
                  }
                : process.env.NETLIFY
                  ? {
                      "cloud.provider": "netlify",
                    }
                  : process.env.FLY_REGION
                    ? {
                        "cloud.provider": "fly.io",
                        "cloud.region": process.env.FLY_REGION,
                      }
                    : process.env.DYNO
                      ? {
                          "cloud.provider": "heroku",
                        }
                      : void 0;
}
const Mp = new es(10),
  PM = new es(20),
  ZH = 7,
  XH = "ContextLines",
  QH = 1e3,
  JH = 1e4;
function eF(e, t, n) {
  const r = e.get(t);
  return r === void 0 ? (e.set(t, n), n) : r;
}
function tF(e) {
  return !!(
    e.startsWith("node:") ||
    e.endsWith(".min.js") ||
    e.endsWith(".min.cjs") ||
    e.endsWith(".min.mjs") ||
    e.startsWith("data:")
  );
}
function nF(e) {
  return (
    (e.lineno !== void 0 && e.lineno > JH) ||
    (e.colno !== void 0 && e.colno > QH)
  );
}
function rF(e, t) {
  const n = Mp.get(e);
  if (n === void 0) return !1;
  for (let r = t[0]; r <= t[1]; r++) if (n[r] === void 0) return !1;
  return !0;
}
function oF(e, t) {
  if (!e.length) return [];
  let n = 0;
  const r = e[0];
  if (typeof r != "number") return [];
  let o = oR(r, t);
  const s = [];
  for (;;) {
    if (n === e.length - 1) {
      s.push(o);
      break;
    }
    const i = e[n + 1];
    if (typeof i != "number") break;
    (i <= o[1] ? (o[1] = i + t) : (s.push(o), (o = oR(i, t))), n++);
  }
  return s;
}
function sF(e, t, n) {
  return new Promise((r, o) => {
    const s = fs.createReadStream(e),
      i = readline.createInterface({
        input: s,
      });
    function a() {
      (s.destroy(), r());
    }
    let c = 0,
      l = 0;
    const f = t[l];
    if (f === void 0) {
      a();
      return;
    }
    let d = f[0],
      u = f[1];
    function _(p) {
      (PM.set(e, 1),
        Ie && $.error(`Failed to read file: ${e}. Error: ${p}`),
        i.close(),
        i.removeAllListeners(),
        a());
    }
    (s.on("error", _),
      i.on("error", _),
      i.on("close", a),
      i.on("line", (p) => {
        if ((c++, !(c < d) && ((n[c] = _k(p, 0)), c >= u))) {
          if (l === t.length - 1) {
            (i.close(), i.removeAllListeners());
            return;
          }
          l++;
          const E = t[l];
          if (E === void 0) {
            (i.close(), i.removeAllListeners());
            return;
          }
          ((d = E[0]), (u = E[1]));
        }
      }));
  });
}
async function iF(e, t) {
  const n = {};
  if (t > 0 && e.exception?.values) {
    for (const s of e.exception.values)
      if (s.stacktrace?.frames?.length)
        for (let i = s.stacktrace.frames.length - 1; i >= 0; i--) {
          const a = s.stacktrace.frames[i],
            c = a?.filename;
          if (
            !a ||
            typeof c != "string" ||
            typeof a.lineno != "number" ||
            tF(c) ||
            nF(a)
          )
            continue;
          (n[c] || (n[c] = []), n[c].push(a.lineno));
        }
  }
  const r = Object.keys(n);
  if (r.length == 0) return e;
  const o = [];
  for (const s of r) {
    if (PM.get(s)) continue;
    const i = n[s];
    if (!i) continue;
    i.sort((l, f) => l - f);
    const a = oF(i, t);
    if (a.every((l) => rF(s, l))) continue;
    const c = eF(Mp, s, {});
    o.push(sF(s, a, c));
  }
  if (
    (await Promise.all(o).catch(() => {
      Ie &&
        $.log(
          "Failed to read one or more source files and resolve context lines",
        );
    }),
    t > 0 && e.exception?.values)
  )
    for (const s of e.exception.values)
      s.stacktrace?.frames &&
        s.stacktrace.frames.length > 0 &&
        aF(s.stacktrace.frames, t, Mp);
  return e;
}
function aF(e, t, n) {
  for (const r of e)
    if (
      r.filename &&
      r.context_line === void 0 &&
      typeof r.lineno == "number"
    ) {
      const o = n.get(r.filename);
      if (o === void 0) continue;
      cF(r.lineno, r, t, o);
    }
}
function rR(e) {
  (delete e.pre_context, delete e.context_line, delete e.post_context);
}
function cF(e, t, n, r) {
  if (t.lineno === void 0 || r === void 0) {
    Ie &&
      $.error(
        "Cannot resolve context for frame with no lineno or file contents",
      );
    return;
  }
  t.pre_context = [];
  for (let s = MM(e, n); s < e; s++) {
    const i = r[s];
    if (i === void 0) {
      (rR(t), Ie && $.error(`Could not find line ${s} in file ${t.filename}`));
      return;
    }
    t.pre_context.push(i);
  }
  if (r[e] === void 0) {
    (rR(t), Ie && $.error(`Could not find line ${e} in file ${t.filename}`));
    return;
  }
  t.context_line = r[e];
  const o = vM(e, n);
  t.post_context = [];
  for (let s = e + 1; s <= o; s++) {
    const i = r[s];
    if (i === void 0) break;
    t.post_context.push(i);
  }
}
function MM(e, t) {
  return Math.max(1, e - t);
}
function vM(e, t) {
  return e + t;
}
function oR(e, t) {
  return [MM(e, t), vM(e, t)];
}
const uF = (e = {}) => {
    const t = e.frameContextLines !== void 0 ? e.frameContextLines : ZH;
    return {
      name: XH,
      processEvent(n) {
        return iF(n, t);
      },
    };
  },
  lF = uF;
let Uc;
async function LM() {
  if (Uc === void 0)
    try {
      Uc = !!(await import("node:inspector")).url();
    } catch {
      Uc = !1;
    }
  return Uc;
}
const kc = "__SENTRY_ERROR_LOCAL_VARIABLES__";
function dF(e, t, n) {
  let r = 0,
    o = 5,
    s = 0;
  return (
    setInterval(() => {
      (s === 0
        ? r > e && ((o *= 2), n(o), o > 86400 && (o = 86400), (s = o))
        : ((s -= 1), s === 0 && t()),
        (r = 0));
    }, 1e3).unref(),
    () => {
      r += 1;
    }
  );
}
function sR(e) {
  return e !== void 0 && (e.length === 0 || e === "?" || e === "<anonymous>");
}
function DM(e, t) {
  return (
    e === t || `Object.${e}` === t || e === `Object.${t}` || (sR(e) && sR(t))
  );
}
const fF =
  "LyohIEBzZW50cnkvbm9kZS1jb3JlIDEwLjI5LjAgKDM1MjlkNDYpIHwgaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdCAqLwppbXBvcnR7U2Vzc2lvbiBhcyBlfWZyb20ibm9kZTppbnNwZWN0b3IvcHJvbWlzZXMiO2ltcG9ydHt3b3JrZXJEYXRhIGFzIHR9ZnJvbSJub2RlOndvcmtlcl90aHJlYWRzIjtjb25zdCBuPWdsb2JhbFRoaXMsaT17fTtjb25zdCBvPSJfX1NFTlRSWV9FUlJPUl9MT0NBTF9WQVJJQUJMRVNfXyI7Y29uc3QgYT10O2Z1bmN0aW9uIHMoLi4uZSl7YS5kZWJ1ZyYmZnVuY3Rpb24oZSl7aWYoISgiY29uc29sZSJpbiBuKSlyZXR1cm4gZSgpO2NvbnN0IHQ9bi5jb25zb2xlLG89e30sYT1PYmplY3Qua2V5cyhpKTthLmZvckVhY2goZT0+e2NvbnN0IG49aVtlXTtvW2VdPXRbZV0sdFtlXT1ufSk7dHJ5e3JldHVybiBlKCl9ZmluYWxseXthLmZvckVhY2goZT0+e3RbZV09b1tlXX0pfX0oKCk9PmNvbnNvbGUubG9nKCJbTG9jYWxWYXJpYWJsZXMgV29ya2VyXSIsLi4uZSkpfWFzeW5jIGZ1bmN0aW9uIGMoZSx0LG4saSl7Y29uc3Qgbz1hd2FpdCBlLnBvc3QoIlJ1bnRpbWUuZ2V0UHJvcGVydGllcyIse29iamVjdElkOnQsb3duUHJvcGVydGllczohMH0pO2lbbl09by5yZXN1bHQuZmlsdGVyKGU9PiJsZW5ndGgiIT09ZS5uYW1lJiYhaXNOYU4ocGFyc2VJbnQoZS5uYW1lLDEwKSkpLnNvcnQoKGUsdCk9PnBhcnNlSW50KGUubmFtZSwxMCktcGFyc2VJbnQodC5uYW1lLDEwKSkubWFwKGU9PmUudmFsdWU/LnZhbHVlKX1hc3luYyBmdW5jdGlvbiByKGUsdCxuLGkpe2NvbnN0IG89YXdhaXQgZS5wb3N0KCJSdW50aW1lLmdldFByb3BlcnRpZXMiLHtvYmplY3RJZDp0LG93blByb3BlcnRpZXM6ITB9KTtpW25dPW8ucmVzdWx0Lm1hcChlPT5bZS5uYW1lLGUudmFsdWU/LnZhbHVlXSkucmVkdWNlKChlLFt0LG5dKT0+KGVbdF09bixlKSx7fSl9ZnVuY3Rpb24gdShlLHQpe2UudmFsdWUmJigidmFsdWUiaW4gZS52YWx1ZT92b2lkIDA9PT1lLnZhbHVlLnZhbHVlfHxudWxsPT09ZS52YWx1ZS52YWx1ZT90W2UubmFtZV09YDwke2UudmFsdWUudmFsdWV9PmA6dFtlLm5hbWVdPWUudmFsdWUudmFsdWU6ImRlc2NyaXB0aW9uImluIGUudmFsdWUmJiJmdW5jdGlvbiIhPT1lLnZhbHVlLnR5cGU/dFtlLm5hbWVdPWA8JHtlLnZhbHVlLmRlc2NyaXB0aW9ufT5gOiJ1bmRlZmluZWQiPT09ZS52YWx1ZS50eXBlJiYodFtlLm5hbWVdPSI8dW5kZWZpbmVkPiIpKX1hc3luYyBmdW5jdGlvbiBsKGUsdCl7Y29uc3Qgbj1hd2FpdCBlLnBvc3QoIlJ1bnRpbWUuZ2V0UHJvcGVydGllcyIse29iamVjdElkOnQsb3duUHJvcGVydGllczohMH0pLGk9e307Zm9yKGNvbnN0IHQgb2Ygbi5yZXN1bHQpaWYodC52YWx1ZT8ub2JqZWN0SWQmJiJBcnJheSI9PT10LnZhbHVlLmNsYXNzTmFtZSl7Y29uc3Qgbj10LnZhbHVlLm9iamVjdElkO2F3YWl0IGMoZSxuLHQubmFtZSxpKX1lbHNlIGlmKHQudmFsdWU/Lm9iamVjdElkJiYiT2JqZWN0Ij09PXQudmFsdWUuY2xhc3NOYW1lKXtjb25zdCBuPXQudmFsdWUub2JqZWN0SWQ7YXdhaXQgcihlLG4sdC5uYW1lLGkpfWVsc2UgdC52YWx1ZSYmdSh0LGkpO3JldHVybiBpfWxldCBmOyhhc3luYyBmdW5jdGlvbigpe2NvbnN0IHQ9bmV3IGU7dC5jb25uZWN0VG9NYWluVGhyZWFkKCkscygiQ29ubmVjdGVkIHRvIG1haW4gdGhyZWFkIik7bGV0IG49ITE7dC5vbigiRGVidWdnZXIucmVzdW1lZCIsKCk9PntuPSExfSksdC5vbigiRGVidWdnZXIucGF1c2VkIixlPT57bj0hMCxhc3luYyBmdW5jdGlvbihlLHtyZWFzb246dCxkYXRhOntvYmplY3RJZDpufSxjYWxsRnJhbWVzOml9KXtpZigiZXhjZXB0aW9uIiE9PXQmJiJwcm9taXNlUmVqZWN0aW9uIiE9PXQpcmV0dXJuO2lmKGY/LigpLG51bGw9PW4pcmV0dXJuO2NvbnN0IGE9W107Zm9yKGxldCB0PTA7dDxpLmxlbmd0aDt0Kyspe2NvbnN0e3Njb3BlQ2hhaW46bixmdW5jdGlvbk5hbWU6byx0aGlzOnN9PWlbdF0sYz1uLmZpbmQoZT0+ImxvY2FsIj09PWUudHlwZSkscj0iZ2xvYmFsIiE9PXMuY2xhc3NOYW1lJiZzLmNsYXNzTmFtZT9gJHtzLmNsYXNzTmFtZX0uJHtvfWA6bztpZih2b2lkIDA9PT1jPy5vYmplY3Qub2JqZWN0SWQpYVt0XT17ZnVuY3Rpb246cn07ZWxzZXtjb25zdCBuPWF3YWl0IGwoZSxjLm9iamVjdC5vYmplY3RJZCk7YVt0XT17ZnVuY3Rpb246cix2YXJzOm59fX1hd2FpdCBlLnBvc3QoIlJ1bnRpbWUuY2FsbEZ1bmN0aW9uT24iLHtmdW5jdGlvbkRlY2xhcmF0aW9uOmBmdW5jdGlvbigpIHsgdGhpcy4ke299ID0gdGhpcy4ke299IHx8ICR7SlNPTi5zdHJpbmdpZnkoYSl9OyB9YCxzaWxlbnQ6ITAsb2JqZWN0SWQ6bn0pLGF3YWl0IGUucG9zdCgiUnVudGltZS5yZWxlYXNlT2JqZWN0Iix7b2JqZWN0SWQ6bn0pfSh0LGUucGFyYW1zKS50aGVuKGFzeW5jKCk9PntuJiZhd2FpdCB0LnBvc3QoIkRlYnVnZ2VyLnJlc3VtZSIpfSxhc3luYyBlPT57biYmYXdhaXQgdC5wb3N0KCJEZWJ1Z2dlci5yZXN1bWUiKX0pfSksYXdhaXQgdC5wb3N0KCJEZWJ1Z2dlci5lbmFibGUiKTtjb25zdCBpPSExIT09YS5jYXB0dXJlQWxsRXhjZXB0aW9ucztpZihhd2FpdCB0LnBvc3QoIkRlYnVnZ2VyLnNldFBhdXNlT25FeGNlcHRpb25zIix7c3RhdGU6aT8iYWxsIjoidW5jYXVnaHQifSksaSl7Y29uc3QgZT1hLm1heEV4Y2VwdGlvbnNQZXJTZWNvbmR8fDUwO2Y9ZnVuY3Rpb24oZSx0LG4pe2xldCBpPTAsbz01LGE9MDtyZXR1cm4gc2V0SW50ZXJ2YWwoKCk9PnswPT09YT9pPmUmJihvKj0yLG4obyksbz44NjQwMCYmKG89ODY0MDApLGE9byk6KGEtPTEsMD09PWEmJnQoKSksaT0wfSwxZTMpLnVucmVmKCksKCk9PntpKz0xfX0oZSxhc3luYygpPT57cygiUmF0ZS1saW1pdCBsaWZ0ZWQuIiksYXdhaXQgdC5wb3N0KCJEZWJ1Z2dlci5zZXRQYXVzZU9uRXhjZXB0aW9ucyIse3N0YXRlOiJhbGwifSl9LGFzeW5jIGU9PntzKGBSYXRlLWxpbWl0IGV4Y2VlZGVkLiBEaXNhYmxpbmcgY2FwdHVyaW5nIG9mIGNhdWdodCBleGNlcHRpb25zIGZvciAke2V9IHNlY29uZHMuYCksYXdhaXQgdC5wb3N0KCJEZWJ1Z2dlci5zZXRQYXVzZU9uRXhjZXB0aW9ucyIse3N0YXRlOiJ1bmNhdWdodCJ9KX0pfX0pKCkuY2F0Y2goZT0+e3MoIkZhaWxlZCB0byBzdGFydCBkZWJ1Z2dlciIsZSl9KSxzZXRJbnRlcnZhbCgoKT0+e30sMWU0KTs=";
function iR(...e) {
  $.log("[LocalVariables]", ...e);
}
const _F = (e = {}) => {
  function t(s, i) {
    const a = (s.stacktrace?.frames || []).filter(
      (c) => c.function !== "new Promise",
    );
    for (let c = 0; c < a.length; c++) {
      const l = a.length - c - 1,
        f = i[c],
        d = a[l];
      if (!d || !f) break;
      f.vars === void 0 ||
        (d.in_app === !1 && e.includeOutOfAppFrames !== !0) ||
        !DM(d.function, f.function) ||
        (d.vars = f.vars);
    }
  }
  function n(s, i) {
    if (
      i.originalException &&
      typeof i.originalException == "object" &&
      kc in i.originalException &&
      Array.isArray(i.originalException[kc])
    ) {
      for (const a of s.exception?.values || []) t(a, i.originalException[kc]);
      i.originalException[kc] = void 0;
    }
    return s;
  }
  async function r() {
    const s = await import("node:inspector");
    s.url() || s.open(0);
  }
  function o(s) {
    const i = new workerThreads.Worker(
      new URL(`data:application/javascript;base64,${fF}`),
      {
        workerData: s,
        execArgv: [],
        env: {
          ...process.env,
          NODE_OPTIONS: void 0,
        },
      },
    );
    (process.on("exit", () => {
      i.terminate();
    }),
      i.once("error", (a) => {
        iR("Worker error", a);
      }),
      i.once("exit", (a) => {
        iR("Worker exit", a);
      }),
      i.unref());
  }
  return {
    name: "LocalVariablesAsync",
    async setup(s) {
      if (!s.getOptions().includeLocalVariables) return;
      if (await LM()) {
        $.warn(
          "Local variables capture has been disabled because the debugger was already enabled",
        );
        return;
      }
      const a = {
        ...e,
        debug: $.isEnabled(),
      };
      r().then(
        () => {
          try {
            o(a);
          } catch (c) {
            $.error("Failed to start worker", c);
          }
        },
        (c) => {
          $.error("Failed to start inspector", c);
        },
      );
    },
    processEvent(s, i) {
      return n(s, i);
    },
  };
};
function wM(e) {
  if (e !== void 0)
    return e
      .slice(-10)
      .reduce((t, n) => `${t},${n.function},${n.lineno},${n.colno}`, "");
}
function pF(e, t) {
  if (t !== void 0) return wM(e(t, 1));
}
function UM(e) {
  let t = [],
    n = !1;
  function r(i) {
    ((t = []), !n && ((n = !0), e(i)));
  }
  t.push(r);
  function o(i) {
    t.push(i);
  }
  function s(i) {
    const a = t.pop() || r;
    try {
      a(i);
    } catch {
      r(i);
    }
  }
  return {
    add: o,
    next: s,
  };
}
class qE {
  constructor(t) {
    this._session = t;
  }
  static async create(t) {
    if (t) return t;
    const n = await import("node:inspector");
    return new qE(new n.Session());
  }
  configureAndConnect(t, n) {
    (this._session.connect(),
      this._session.on("Debugger.paused", (r) => {
        t(r, () => {
          this._session.post("Debugger.resume");
        });
      }),
      this._session.post("Debugger.enable"),
      this._session.post("Debugger.setPauseOnExceptions", {
        state: n ? "all" : "uncaught",
      }));
  }
  setPauseOnExceptions(t) {
    this._session.post("Debugger.setPauseOnExceptions", {
      state: t ? "all" : "uncaught",
    });
  }
  getLocalVariables(t, n) {
    this._getProperties(t, (r) => {
      const { add: o, next: s } = UM(n);
      for (const i of r)
        if (i.value?.objectId && i.value.className === "Array") {
          const a = i.value.objectId;
          o((c) => this._unrollArray(a, i.name, c, s));
        } else if (i.value?.objectId && i.value.className === "Object") {
          const a = i.value.objectId;
          o((c) => this._unrollObject(a, i.name, c, s));
        } else i.value && o((a) => this._unrollOther(i, a, s));
      s({});
    });
  }
  _getProperties(t, n) {
    this._session.post(
      "Runtime.getProperties",
      {
        objectId: t,
        ownProperties: !0,
      },
      (r, o) => {
        n(r ? [] : o.result);
      },
    );
  }
  _unrollArray(t, n, r, o) {
    this._getProperties(t, (s) => {
      ((r[n] = s
        .filter((i) => i.name !== "length" && !isNaN(parseInt(i.name, 10)))
        .sort((i, a) => parseInt(i.name, 10) - parseInt(a.name, 10))
        .map((i) => i.value?.value)),
        o(r));
    });
  }
  _unrollObject(t, n, r, o) {
    this._getProperties(t, (s) => {
      ((r[n] = s
        .map((i) => [i.name, i.value?.value])
        .reduce((i, [a, c]) => ((i[a] = c), i), {})),
        o(r));
    });
  }
  _unrollOther(t, n, r) {
    (t.value &&
      ("value" in t.value
        ? t.value.value === void 0 || t.value.value === null
          ? (n[t.name] = `<${t.value.value}>`)
          : (n[t.name] = t.value.value)
        : "description" in t.value && t.value.type !== "function"
          ? (n[t.name] = `<${t.value.description}>`)
          : t.value.type === "undefined" && (n[t.name] = "<undefined>")),
      r(n));
  }
}
const EF = "LocalVariables",
  hF = (e = {}, t) => {
    const n = new es(20);
    let r,
      o = !1;
    function s(l) {
      const f = wM(l.stacktrace?.frames);
      if (f === void 0) return;
      const d = n.remove(f);
      if (d === void 0) return;
      const u = (l.stacktrace?.frames || []).filter(
        (_) => _.function !== "new Promise",
      );
      for (let _ = 0; _ < u.length; _++) {
        const p = u.length - _ - 1,
          E = d[_],
          h = u[p];
        if (!h || !E) break;
        E.vars === void 0 ||
          (h.in_app === !1 && e.includeOutOfAppFrames !== !0) ||
          !DM(h.function, E.function) ||
          (h.vars = E.vars);
      }
    }
    function i(l) {
      for (const f of l.exception?.values || []) s(f);
      return l;
    }
    let a;
    async function c() {
      const f = he()?.getOptions();
      if (!f?.includeLocalVariables) return;
      if (Do < 18) {
        $.log(
          "The `LocalVariables` integration is only supported on Node >= v18.",
        );
        return;
      }
      if (await LM()) {
        $.warn(
          "Local variables capture has been disabled because the debugger was already enabled",
        );
        return;
      }
      try {
        const u = await qE.create(t),
          _ = (E, { params: { reason: h, data: T, callFrames: m } }, A) => {
            if (h !== "exception" && h !== "promiseRejection") {
              A();
              return;
            }
            r?.();
            const g = pF(E, T.description);
            if (g == null) {
              A();
              return;
            }
            const { add: N, next: O } = UM((I) => {
              (n.set(g, I), A());
            });
            for (let I = 0; I < Math.min(m.length, 5); I++) {
              const { scopeChain: b, functionName: w, this: L } = m[I],
                j = b.find((x) => x.type === "local"),
                H =
                  L.className === "global" || !L.className
                    ? w
                    : `${L.className}.${w}`;
              if (j?.object.objectId === void 0)
                N((x) => {
                  ((x[I] = {
                    function: H,
                  }),
                    O(x));
                });
              else {
                const x = j.object.objectId;
                N((B) =>
                  u.getLocalVariables(x, (F) => {
                    ((B[I] = {
                      function: H,
                      vars: F,
                    }),
                      O(B));
                  }),
                );
              }
            }
            O([]);
          },
          p = e.captureAllExceptions !== !1;
        if ((u.configureAndConnect((E, h) => _(f.stackParser, E, h), p), p)) {
          const E = e.maxExceptionsPerSecond || 50;
          r = dF(
            E,
            () => {
              ($.log("Local variables rate-limit lifted."),
                u.setPauseOnExceptions(!0));
            },
            (h) => {
              ($.log(
                `Local variables rate-limit exceeded. Disabling capturing of caught exceptions for ${h} seconds.`,
              ),
                u.setPauseOnExceptions(!1));
            },
          );
        }
        o = !0;
      } catch (u) {
        $.log("The `LocalVariables` integration failed to start.", u);
      }
    }
    return {
      name: EF,
      setupOnce() {
        a = c();
      },
      async processEvent(l) {
        return (await a, o ? i(l) : l);
      },
      _getCachedFramesCount() {
        return n.size;
      },
      _getFirstCachedFrame() {
        return n.values()[0];
      },
    };
  },
  TF = hF,
  SF = (e = {}) => (Il.major < 19 ? TF(e) : _F(e));
function WE() {
  try {
    return typeof module < "u" && typeof module.exports < "u";
  } catch {
    return !1;
  }
}
let aR;
function mF() {
  return WE()
    ? !1
    : Do >= 21 || (Do === 20 && Ip >= 6) || (Do === 18 && Ip >= 19)
      ? !0
      : (aR ||
          ((aR = !0),
          on(() => {
            console.warn(
              `[Sentry] You are using Node.js v${process.versions.node} in ESM mode ("import syntax"). The Sentry Node.js SDK is not compatible with ESM in Node.js versions before 18.19.0 or before 20.6.0. Please either build your application with CommonJS ("require() syntax"), or upgrade your Node.js version.`,
            );
          })),
        !1);
}
let Md;
const AF = "Modules",
  gF = typeof __SENTRY_SERVER_MODULES__ > "u" ? {} : __SENTRY_SERVER_MODULES__,
  RF = () => ({
    name: AF,
    processEvent(e) {
      return (
        (e.modules = {
          ...e.modules,
          ...cR(),
        }),
        e
      );
    },
    getModules: cR,
  }),
  NF = RF;
function yF() {
  try {
    return require.cache ? Object.keys(require.cache) : [];
  } catch {
    return [];
  }
}
function OF() {
  return {
    ...gF,
    ...IF(),
    ...(WE() ? CF() : {}),
  };
}
function CF() {
  const e = require.main?.paths || [],
    t = yF(),
    n = {},
    r = new Set();
  return (
    t.forEach((o) => {
      let s = o;
      const i = () => {
        const a = s;
        if (((s = path2.dirname(a)), !s || a === s || r.has(a))) return;
        if (e.indexOf(s) < 0) return i();
        const c = path2.join(a, "package.json");
        if ((r.add(a), !fs.existsSync(c))) return i();
        try {
          const l = JSON.parse(fs.readFileSync(c, "utf8"));
          n[l.name] = l.version;
        } catch {}
      };
      i();
    }),
    n
  );
}
function cR() {
  return (Md || (Md = OF()), Md);
}
function bF() {
  try {
    const e = path2.join(process.cwd(), "package.json");
    return JSON.parse(fs.readFileSync(e, "utf8"));
  } catch {
    return {};
  }
}
function IF() {
  const e = bF();
  return {
    ...e.dependencies,
    ...e.devDependencies,
  };
}
const PF = 2e3;
function vp(e) {
  on(() => {
    console.error(e);
  });
  const t = he();
  if (t === void 0) {
    (Ie && $.warn("No NodeClient was defined, we are exiting the process now."),
      global.process.exit(1));
    return;
  }
  const n = t.getOptions(),
    r = n?.shutdownTimeout && n.shutdownTimeout > 0 ? n.shutdownTimeout : PF;
  t.close(r).then(
    (o) => {
      (o ||
        (Ie &&
          $.warn(
            "We reached the timeout for emptying the request buffer, still exiting now!",
          )),
        global.process.exit(1));
    },
    (o) => {
      Ie && $.error(o);
    },
  );
}
const MF = "OnUncaughtException",
  vF = (e = {}) => {
    const t = {
      exitEvenIfOtherHandlersAreRegistered: !1,
      ...e,
    };
    return {
      name: MF,
      setup(n) {
        global.process.on("uncaughtException", LF(n, t));
      },
    };
  };
function LF(e, t) {
  let r = !1,
    o = !1,
    s = !1,
    i;
  const a = e.getOptions();
  return Object.assign(
    (c) => {
      let l = vp;
      t.onFatalError
        ? (l = t.onFatalError)
        : a.onFatalError && (l = a.onFatalError);
      const d =
          global.process
            .listeners("uncaughtException")
            .filter(
              (_) =>
                _.name !== "domainUncaughtExceptionClear" &&
                _.tag !== "sentry_tracingErrorCallback" &&
                _._errorHandler !== !0,
            ).length === 0,
        u = t.exitEvenIfOtherHandlersAreRegistered || d;
      r
        ? u &&
          (s
            ? (Ie &&
                $.warn(
                  "uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown",
                ),
              vp(c))
            : o ||
              ((o = !0),
              setTimeout(() => {
                s || ((s = !0), l(i, c));
              }, 2e3)))
        : ((i = c),
          (r = !0),
          he() === e &&
            xe(c, {
              originalException: c,
              captureContext: {
                level: "fatal",
              },
              mechanism: {
                handled: !1,
                type: "auto.node.onuncaughtexception",
              },
            }),
          !s && u && ((s = !0), l(c)));
    },
    {
      _errorHandler: !0,
    },
  );
}
const DF = "OnUnhandledRejection",
  wF = [
    {
      name: "AI_NoOutputGeneratedError",
    },
  ],
  UF = (e = {}) => {
    const t = {
      mode: e.mode ?? "warn",
      ignore: [...wF, ...(e.ignore ?? [])],
    };
    return {
      name: DF,
      setup(n) {
        global.process.on("unhandledRejection", $F(n, t));
      },
    };
  },
  kF = UF;
function GF(e) {
  if (typeof e != "object" || e === null)
    return {
      name: "",
      message: String(e ?? ""),
    };
  const t = e,
    n = typeof t.name == "string" ? t.name : "",
    r = typeof t.message == "string" ? t.message : String(e);
  return {
    name: n,
    message: r,
  };
}
function VF(e, t) {
  const n = e.name === void 0 || vo(t.name, e.name, !0),
    r = e.message === void 0 || vo(t.message, e.message);
  return n && r;
}
function xF(e, t) {
  const n = GF(t);
  return e.some((r) => VF(r, n));
}
function $F(e, t) {
  return function (r, o) {
    if (he() !== e || xF(t.ignore ?? [], r)) return;
    const s = t.mode === "strict" ? "fatal" : "error",
      i = r && typeof r == "object" ? r._sentry_active_span : void 0;
    ((i ? (c) => iP(i, c) : (c) => c())(() => {
      xe(r, {
        originalException: o,
        captureContext: {
          extra: {
            unhandledPromiseRejection: !0,
          },
          level: s,
        },
        mechanism: {
          handled: !1,
          type: "auto.node.onunhandledrejection",
        },
      });
    }),
      BF(r, t.mode));
  };
}
function BF(e, t) {
  const n =
    "This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason:";
  t === "warn"
    ? on(() => {
        (console.warn(n),
          console.error(
            e && typeof e == "object" && "stack" in e ? e.stack : e,
          ));
      })
    : t === "strict" &&
      (on(() => {
        console.warn(n);
      }),
      vp(e));
}
const kM = "Spotlight",
  HF = (e = {}) => {
    const t = {
      sidecarUrl: e.sidecarUrl || "http://localhost:8969/stream",
    };
    return {
      name: kM,
      setup(n) {
        try {
          process.env.NODE_ENV &&
            process.env.NODE_ENV !== "development" &&
            $.warn(
              "[Spotlight] It seems you're not in dev mode. Do you really want to have Spotlight enabled?",
            );
        } catch {}
        YF(n, t);
      },
    };
  },
  FF = HF;
function YF(e, t) {
  const n = jF(t.sidecarUrl);
  if (!n) return;
  let r = 0;
  e.on("beforeEnvelope", (o) => {
    if (r > 3) {
      $.warn(
        "[Spotlight] Disabled Sentry -> Spotlight integration due to too many failed requests",
      );
      return;
    }
    const s = tP(o);
    aP(() => {
      const i = su.request(
        {
          method: "POST",
          path: n.pathname,
          hostname: n.hostname,
          port: n.port,
          headers: {
            "Content-Type": "application/x-sentry-envelope",
          },
        },
        (a) => {
          (a.statusCode && a.statusCode >= 200 && a.statusCode < 400 && (r = 0),
            a.on("data", () => {}),
            a.on("end", () => {}),
            a.setEncoding("utf8"));
        },
      );
      (i.on("error", () => {
        (r++,
          $.warn("[Spotlight] Failed to send envelope to Spotlight Sidecar"));
      }),
        i.write(s),
        i.end());
    });
  });
}
function jF(e) {
  try {
    return new URL(`${e}`);
  } catch {
    $.warn(`[Spotlight] Invalid sidecar URL: ${e}`);
    return;
  }
}
const qF = "NodeSystemError";
function WF(e) {
  return !(e instanceof Error) || !("errno" in e) || typeof e.errno != "number"
    ? !1
    : GD.getSystemErrorMap().has(e.errno);
}
const KF = (e = {}) => ({
    name: qF,
    processEvent: (t, n, r) => {
      if (!WF(n.originalException)) return t;
      const o = n.originalException,
        s = {
          ...o,
        };
      (!r.getOptions().sendDefaultPii &&
        e.includePaths !== !0 &&
        (delete s.path, delete s.dest),
        (t.contexts = {
          ...t.contexts,
          node_system_error: s,
        }));
      for (const i of t.exception?.values || [])
        i.value &&
          (o.path &&
            i.value.includes(o.path) &&
            (i.value = i.value.replace(`'${o.path}'`, "").trim()),
          o.dest &&
            i.value.includes(o.dest) &&
            (i.value = i.value.replace(`'${o.dest}'`, "").trim()));
      return t;
    },
  }),
  zF = "ChildProcess",
  ZF = (e = {}) => ({
    name: zF,
    setup() {
      (ou.channel("child_process").subscribe((t) => {
        t && typeof t == "object" && "process" in t && XF(t.process, e);
      }),
        ou.channel("worker_threads").subscribe((t) => {
          t && typeof t == "object" && "worker" in t && QF(t.worker, e);
        }));
    },
  });
function XF(e, t) {
  let n = !1,
    r;
  e.on("spawn", () => {
    if (e.spawnfile === "/usr/bin/sw_vers") {
      n = !0;
      return;
    }
    ((r = {
      spawnfile: e.spawnfile,
    }),
      t.includeChildProcessArgs && (r.spawnargs = e.spawnargs));
  })
    .on("exit", (o) => {
      n ||
        ((n = !0),
        o !== null &&
          o !== 0 &&
          $o({
            category: "child_process",
            message: `Child process exited with code '${o}'`,
            level: o === 0 ? "info" : "warning",
            data: r,
          }));
    })
    .on("error", (o) => {
      n ||
        ((n = !0),
        $o({
          category: "child_process",
          message: `Child process errored with '${o.message}'`,
          level: "error",
          data: r,
        }));
    });
}
function QF(e, t) {
  let n;
  e.on("online", () => {
    n = e.threadId;
  }).on("error", (r) => {
    t.captureWorkerErrors !== !1
      ? xe(r, {
          mechanism: {
            type: "auto.child_process.worker_thread",
            handled: !1,
            data: {
              threadId: String(n),
            },
          },
        })
      : $o({
          category: "worker_thread",
          message: `Worker thread errored with '${r.message}'`,
          level: "error",
          data: {
            threadId: n,
          },
        });
  });
}
var vd = {},
  oa = {},
  sa = {},
  uR;
function GM() {
  if (uR) return sa;
  ((uR = 1),
    Object.defineProperty(sa, "__esModule", {
      value: !0,
    }),
    (sa.AbstractAsyncHooksContextManager = void 0));
  const e = events,
    t = ["addListener", "on", "once", "prependListener", "prependOnceListener"];
  let n = class {
    bind(o, s) {
      return s instanceof e.EventEmitter
        ? this._bindEventEmitter(o, s)
        : typeof s == "function"
          ? this._bindFunction(o, s)
          : s;
    }
    _bindFunction(o, s) {
      const i = this,
        a = function (...c) {
          return i.with(o, () => s.apply(this, c));
        };
      return (
        Object.defineProperty(a, "length", {
          enumerable: !1,
          configurable: !0,
          writable: !1,
          value: s.length,
        }),
        a
      );
    }
    _bindEventEmitter(o, s) {
      return (
        this._getPatchMap(s) !== void 0 ||
          (this._createPatchMap(s),
          t.forEach((a) => {
            s[a] !== void 0 && (s[a] = this._patchAddListener(s, s[a], o));
          }),
          typeof s.removeListener == "function" &&
            (s.removeListener = this._patchRemoveListener(s, s.removeListener)),
          typeof s.off == "function" &&
            (s.off = this._patchRemoveListener(s, s.off)),
          typeof s.removeAllListeners == "function" &&
            (s.removeAllListeners = this._patchRemoveAllListeners(
              s,
              s.removeAllListeners,
            ))),
        s
      );
    }
    _patchRemoveListener(o, s) {
      const i = this;
      return function (a, c) {
        const l = i._getPatchMap(o)?.[a];
        if (l === void 0) return s.call(this, a, c);
        const f = l.get(c);
        return s.call(this, a, f || c);
      };
    }
    _patchRemoveAllListeners(o, s) {
      const i = this;
      return function (a) {
        const c = i._getPatchMap(o);
        return (
          c !== void 0 &&
            (arguments.length === 0
              ? i._createPatchMap(o)
              : c[a] !== void 0 && delete c[a]),
          s.apply(this, arguments)
        );
      };
    }
    _patchAddListener(o, s, i) {
      const a = this;
      return function (c, l) {
        if (a._wrapped) return s.call(this, c, l);
        let f = a._getPatchMap(o);
        f === void 0 && (f = a._createPatchMap(o));
        let d = f[c];
        d === void 0 && ((d = new WeakMap()), (f[c] = d));
        const u = a.bind(i, l);
        (d.set(l, u), (a._wrapped = !0));
        try {
          return s.call(this, c, u);
        } finally {
          a._wrapped = !1;
        }
      };
    }
    _createPatchMap(o) {
      const s = Object.create(null);
      return ((o[this._kOtListeners] = s), s);
    }
    _getPatchMap(o) {
      return o[this._kOtListeners];
    }
    _kOtListeners = Symbol("OtListeners");
    _wrapped = !1;
  };
  return ((sa.AbstractAsyncHooksContextManager = n), sa);
}
var lR;
function JF() {
  if (lR) return oa;
  ((lR = 1),
    Object.defineProperty(oa, "__esModule", {
      value: !0,
    }),
    (oa.AsyncHooksContextManager = void 0));
  const e = Pe(),
    t = asyncHooks,
    n = GM();
  let r = class extends n.AbstractAsyncHooksContextManager {
    _asyncHook;
    _contexts = new Map();
    _stack = [];
    constructor() {
      (super(),
        (this._asyncHook = t.createHook({
          init: this._init.bind(this),
          before: this._before.bind(this),
          after: this._after.bind(this),
          destroy: this._destroy.bind(this),
          promiseResolve: this._destroy.bind(this),
        })));
    }
    active() {
      return this._stack[this._stack.length - 1] ?? e.ROOT_CONTEXT;
    }
    with(s, i, a, ...c) {
      this._enterContext(s);
      try {
        return i.call(a, ...c);
      } finally {
        this._exitContext();
      }
    }
    enable() {
      return (this._asyncHook.enable(), this);
    }
    disable() {
      return (
        this._asyncHook.disable(),
        this._contexts.clear(),
        (this._stack = []),
        this
      );
    }
    _init(s, i) {
      if (i === "TIMERWRAP") return;
      const a = this._stack[this._stack.length - 1];
      a !== void 0 && this._contexts.set(s, a);
    }
    _destroy(s) {
      this._contexts.delete(s);
    }
    _before(s) {
      const i = this._contexts.get(s);
      i !== void 0 && this._enterContext(i);
    }
    _after() {
      this._exitContext();
    }
    _enterContext(s) {
      this._stack.push(s);
    }
    _exitContext() {
      this._stack.pop();
    }
  };
  return ((oa.AsyncHooksContextManager = r), oa);
}
var ia = {},
  dR;
function eY() {
  if (dR) return ia;
  ((dR = 1),
    Object.defineProperty(ia, "__esModule", {
      value: !0,
    }),
    (ia.AsyncLocalStorageContextManager = void 0));
  const e = Pe(),
    t = asyncHooks,
    n = GM();
  let r = class extends n.AbstractAsyncHooksContextManager {
    _asyncLocalStorage;
    constructor() {
      (super(), (this._asyncLocalStorage = new t.AsyncLocalStorage()));
    }
    active() {
      return this._asyncLocalStorage.getStore() ?? e.ROOT_CONTEXT;
    }
    with(s, i, a, ...c) {
      const l = a == null ? i : i.bind(a);
      return this._asyncLocalStorage.run(s, l, ...c);
    }
    enable() {
      return this;
    }
    disable() {
      return (this._asyncLocalStorage.disable(), this);
    }
  };
  return ((ia.AsyncLocalStorageContextManager = r), ia);
}
var fR;
function tY() {
  return (
    fR ||
      ((fR = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.AsyncLocalStorageContextManager = e.AsyncHooksContextManager =
            void 0));
        var t = JF();
        Object.defineProperty(e, "AsyncHooksContextManager", {
          enumerable: !0,
          get: function () {
            return t.AsyncHooksContextManager;
          },
        });
        var n = eY();
        Object.defineProperty(e, "AsyncLocalStorageContextManager", {
          enumerable: !0,
          get: function () {
            return n.AsyncLocalStorageContextManager;
          },
        });
      })(vd)),
    vd
  );
}
var nY = tY();
const rY = sH(nY.AsyncLocalStorageContextManager);
function oY() {
  (C.diag.disable(),
    C.diag.setLogger(
      {
        error: $.error,
        warn: $.warn,
        info: $.log,
        debug: $.log,
        verbose: $.log,
      },
      C.DiagLogLevel.DEBUG,
    ));
}
const sY = "ProcessSession",
  iY = () => ({
    name: sY,
    setupOnce() {
      (X1(),
        process.on("beforeExit", () => {
          je().getSession()?.status !== "ok" && fP();
        }));
    },
  }),
  dn = Symbol("AgentBaseInternalState");
class aY extends su.Agent {
  constructor(t) {
    (super(t), (this[dn] = {}));
  }
  isSecureEndpoint(t) {
    if (t) {
      if (typeof t.secureEndpoint == "boolean") return t.secureEndpoint;
      if (typeof t.protocol == "string") return t.protocol === "https:";
    }
    const { stack: n } = new Error();
    return typeof n != "string"
      ? !1
      : n
          .split(
            `
`,
          )
          .some(
            (r) =>
              r.indexOf("(https.js:") !== -1 || r.indexOf("node:https:") !== -1,
          );
  }
  createSocket(t, n, r) {
    const o = {
      ...n,
      secureEndpoint: this.isSecureEndpoint(n),
    };
    Promise.resolve()
      .then(() => this.connect(t, o))
      .then((s) => {
        if (s instanceof su.Agent) return s.addRequest(t, o);
        ((this[dn].currentSocket = s), super.createSocket(t, n, r));
      }, r);
  }
  createConnection() {
    const t = this[dn].currentSocket;
    if (((this[dn].currentSocket = void 0), !t))
      throw new Error("No socket was returned in the `connect()` function");
    return t;
  }
  get defaultPort() {
    return this[dn].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
  }
  set defaultPort(t) {
    this[dn] && (this[dn].defaultPort = t);
  }
  get protocol() {
    return this[dn].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
  }
  set protocol(t) {
    this[dn] && (this[dn].protocol = t);
  }
}
function Gc(...e) {
  $.log("[https-proxy-agent:parse-proxy-response]", ...e);
}
function cY(e) {
  return new Promise((t, n) => {
    let r = 0;
    const o = [];
    function s() {
      const f = e.read();
      f ? l(f) : e.once("readable", s);
    }
    function i() {
      (e.removeListener("end", a),
        e.removeListener("error", c),
        e.removeListener("readable", s));
    }
    function a() {
      (i(),
        Gc("onend"),
        n(
          new Error("Proxy connection ended before receiving CONNECT response"),
        ));
    }
    function c(f) {
      (i(), Gc("onerror %o", f), n(f));
    }
    function l(f) {
      (o.push(f), (r += f.length));
      const d = Buffer.concat(o, r),
        u = d.indexOf(`\r
\r
`);
      if (u === -1) {
        (Gc("have not received end of HTTP headers yet..."), s());
        return;
      }
      const _ = d.subarray(0, u).toString("ascii").split(`\r
`),
        p = _.shift();
      if (!p)
        return (
          e.destroy(),
          n(new Error("No header received from proxy CONNECT response"))
        );
      const E = p.split(" "),
        h = +(E[1] || 0),
        T = E.slice(2).join(" "),
        m = {};
      for (const A of _) {
        if (!A) continue;
        const g = A.indexOf(":");
        if (g === -1)
          return (
            e.destroy(),
            n(new Error(`Invalid header from proxy CONNECT response: "${A}"`))
          );
        const N = A.slice(0, g).toLowerCase(),
          O = A.slice(g + 1).trimStart(),
          I = m[N];
        typeof I == "string"
          ? (m[N] = [I, O])
          : Array.isArray(I)
            ? I.push(O)
            : (m[N] = O);
      }
      (Gc("got proxy server response: %o %o", p, m),
        i(),
        t({
          connect: {
            statusCode: h,
            statusText: T,
            headers: m,
          },
          buffered: d,
        }));
    }
    (e.on("error", c), e.on("end", a), s());
  });
}
function aa(...e) {
  $.log("[https-proxy-agent]", ...e);
}
class VM extends aY {
  static __initStatic() {
    this.protocols = ["http", "https"];
  }
  constructor(t, n) {
    (super(n),
      (this.options = {}),
      (this.proxy = typeof t == "string" ? new URL(t) : t),
      (this.proxyHeaders = n?.headers ?? {}),
      aa("Creating new HttpsProxyAgent instance: %o", this.proxy.href));
    const r = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, ""),
      o = this.proxy.port
        ? parseInt(this.proxy.port, 10)
        : this.proxy.protocol === "https:"
          ? 443
          : 80;
    this.connectOpts = {
      ALPNProtocols: ["http/1.1"],
      ...(n ? _R(n, "headers") : null),
      host: r,
      port: o,
    };
  }
  async connect(t, n) {
    const { proxy: r } = this;
    if (!n.host) throw new TypeError('No "host" provided');
    let o;
    if (r.protocol === "https:") {
      aa("Creating `tls.Socket`: %o", this.connectOpts);
      const u = this.connectOpts.servername || this.connectOpts.host;
      o = em.connect({
        ...this.connectOpts,
        servername: u && Ao.isIP(u) ? void 0 : u,
      });
    } else
      (aa("Creating `net.Socket`: %o", this.connectOpts),
        (o = Ao.connect(this.connectOpts)));
    const s =
        typeof this.proxyHeaders == "function"
          ? this.proxyHeaders()
          : {
              ...this.proxyHeaders,
            },
      i = Ao.isIPv6(n.host) ? `[${n.host}]` : n.host;
    let a = `CONNECT ${i}:${n.port} HTTP/1.1\r
`;
    if (r.username || r.password) {
      const u = `${decodeURIComponent(r.username)}:${decodeURIComponent(r.password)}`;
      s["Proxy-Authorization"] = `Basic ${Buffer.from(u).toString("base64")}`;
    }
    ((s.Host = `${i}:${n.port}`),
      s["Proxy-Connection"] ||
        (s["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close"));
    for (const u of Object.keys(s))
      a += `${u}: ${s[u]}\r
`;
    const c = cY(o);
    o.write(`${a}\r
`);
    const { connect: l, buffered: f } = await c;
    if (
      (t.emit("proxyConnect", l),
      this.emit("proxyConnect", l, t),
      l.statusCode === 200)
    ) {
      if ((t.once("socket", uY), n.secureEndpoint)) {
        aa("Upgrading socket connection to TLS");
        const u = n.servername || n.host;
        return em.connect({
          ..._R(n, "host", "path", "port"),
          socket: o,
          servername: Ao.isIP(u) ? void 0 : u,
        });
      }
      return o;
    }
    o.destroy();
    const d = new Ao.Socket({
      writable: !1,
    });
    return (
      (d.readable = !0),
      t.once("socket", (u) => {
        (aa("Replaying proxy buffer for failed request"),
          u.push(f),
          u.push(null));
      }),
      d
    );
  }
}
VM.__initStatic();
function uY(e) {
  e.resume();
}
function _R(e, ...t) {
  const n = {};
  let r;
  for (r in e) t.includes(r) || (n[r] = e[r]);
  return n;
}
const lY = 1024 * 32;
function dY(e) {
  return new stream.Readable({
    read() {
      (this.push(e), this.push(null));
    },
  });
}
function fY(e) {
  let t;
  try {
    t = new URL(e.url);
  } catch {
    return (
      on(() => {
        console.warn(
          "[@sentry/node]: Invalid dsn or tunnel option, will not send any events. The tunnel option must be a full URL when used.",
        );
      }),
      fg(e, () => Promise.resolve({}))
    );
  }
  const n = t.protocol === "https:",
    r = _Y(
      t,
      e.proxy ||
        (n ? process.env.https_proxy : void 0) ||
        process.env.http_proxy,
    ),
    o = n ? xD : su,
    s = e.keepAlive === void 0 ? !1 : e.keepAlive,
    i = r
      ? new VM(r)
      : new o.Agent({
          keepAlive: s,
          maxSockets: 30,
          timeout: 2e3,
        }),
    a = pY(e, e.httpModule ?? o, i);
  return fg(e, a);
}
function _Y(e, t) {
  const { no_proxy: n } = process.env;
  if (!n?.split(",").some((o) => e.host.endsWith(o) || e.hostname.endsWith(o)))
    return t;
}
function pY(e, t, n) {
  const {
    hostname: r,
    pathname: o,
    port: s,
    protocol: i,
    search: a,
  } = new URL(e.url);
  return function (l) {
    return new Promise((f, d) => {
      aP(() => {
        let u = dY(l.body);
        const _ = {
          ...e.headers,
        };
        l.body.length > lY &&
          ((_["content-encoding"] = "gzip"), (u = u.pipe(zlib.createGzip())));
        const p = t.request(
          {
            method: "POST",
            agent: n,
            headers: _,
            hostname: r,
            path: `${o}${a}`,
            port: s,
            protocol: i,
            ca: e.caCerts,
          },
          (E) => {
            (E.on("data", () => {}),
              E.on("end", () => {}),
              E.setEncoding("utf8"));
            const h = E.headers["retry-after"] ?? null,
              T = E.headers["x-sentry-rate-limits"] ?? null;
            f({
              statusCode: E.statusCode,
              headers: {
                "retry-after": h,
                "x-sentry-rate-limits": Array.isArray(T) ? T[0] || null : T,
              },
            });
          },
        );
        (p.on("error", d), u.pipe(p));
      });
    });
  };
}
const EY = new Set(["false", "f", "n", "no", "off", "0"]),
  hY = new Set(["true", "t", "y", "yes", "on", "1"]);
function Lp(e, t) {
  const n = String(e).toLowerCase();
  return EY.has(n) ? !1 : hY.has(n) ? !0 : t?.strict ? null : !!e;
}
function pR(e) {
  return e.replace(/^[A-Z]:/, "").replace(/\\/g, "/");
}
function TY(
  e = process.argv[1] ? UV(process.argv[1]) : process.cwd(),
  t = path2.sep === "\\",
) {
  const n = t ? pR(e) : e;
  return (r) => {
    if (!r) return;
    const o = t ? pR(r) : r;
    let { dir: s, base: i, ext: a } = path2.posix.parse(o);
    (a === ".js" || a === ".mjs" || a === ".cjs") &&
      (i = i.slice(0, a.length * -1));
    const c = decodeURIComponent(i);
    s || (s = ".");
    const l = s.lastIndexOf("/node_modules");
    if (l > -1) return `${s.slice(l + 14).replace(/\//g, ".")}:${c}`;
    if (s.startsWith(n)) {
      const f = s.slice(n.length + 1).replace(/\//g, ".");
      return f ? `${f}:${c}` : c;
    }
    return c;
  };
}
function SY(e) {
  if (process.env.SENTRY_RELEASE) return process.env.SENTRY_RELEASE;
  if (ye.SENTRY_RELEASE?.id) return ye.SENTRY_RELEASE.id;
  const t =
      process.env.GITHUB_SHA ||
      process.env.CI_MERGE_REQUEST_SOURCE_BRANCH_SHA ||
      process.env.CI_BUILD_REF ||
      process.env.CI_COMMIT_SHA ||
      process.env.BITBUCKET_COMMIT,
    n =
      process.env.APPVEYOR_PULL_REQUEST_HEAD_COMMIT ||
      process.env.APPVEYOR_REPO_COMMIT ||
      process.env.CODEBUILD_RESOLVED_SOURCE_VERSION ||
      process.env.AWS_COMMIT_ID ||
      process.env.BUILD_SOURCEVERSION ||
      process.env.GIT_CLONE_COMMIT_HASH ||
      process.env.BUDDY_EXECUTION_REVISION ||
      process.env.BUILDKITE_COMMIT ||
      process.env.CIRCLE_SHA1 ||
      process.env.CIRRUS_CHANGE_IN_REPO ||
      process.env.CF_REVISION ||
      process.env.CM_COMMIT ||
      process.env.CF_PAGES_COMMIT_SHA ||
      process.env.DRONE_COMMIT_SHA ||
      process.env.FC_GIT_COMMIT_SHA ||
      process.env.HEROKU_TEST_RUN_COMMIT_VERSION ||
      process.env.HEROKU_SLUG_COMMIT ||
      process.env.RAILWAY_GIT_COMMIT_SHA ||
      process.env.RENDER_GIT_COMMIT ||
      process.env.SEMAPHORE_GIT_SHA ||
      process.env.TRAVIS_PULL_REQUEST_SHA ||
      process.env.VERCEL_GIT_COMMIT_SHA ||
      process.env.VERCEL_GITHUB_COMMIT_SHA ||
      process.env.VERCEL_GITLAB_COMMIT_SHA ||
      process.env.VERCEL_BITBUCKET_COMMIT_SHA ||
      process.env.ZEIT_GITHUB_COMMIT_SHA ||
      process.env.ZEIT_GITLAB_COMMIT_SHA ||
      process.env.ZEIT_BITBUCKET_COMMIT_SHA,
    r =
      process.env.CI_COMMIT_ID ||
      process.env.SOURCE_COMMIT ||
      process.env.SOURCE_VERSION ||
      process.env.GIT_COMMIT ||
      process.env.COMMIT_REF ||
      process.env.BUILD_VCS_NUMBER ||
      process.env.CI_COMMIT_SHA;
  return t || n || r || e;
}
const mY = DI(X$(TY())),
  AY = 6e4;
class gY extends VG {
  constructor(t) {
    const n =
        t.includeServerName === !1
          ? void 0
          : t.serverName || global.process.env.SENTRY_NAME || Dt.hostname(),
      r = {
        ...t,
        platform: "node",
        runtime: {
          name: "node",
          version: global.process.version,
        },
        serverName: n,
      };
    (t.openTelemetryInstrumentations &&
      sl({
        instrumentations: t.openTelemetryInstrumentations,
      }),
      PE(r, "node"),
      $.log(
        `Initializing Sentry: process: ${process.pid}, thread: ${workerThreads2.isMainThread ? "main" : `worker-${workerThreads2.threadId}`}.`,
      ),
      super(r),
      this.getOptions().enableLogs &&
        ((this._logOnExitFlushListener = () => {
          pP(this);
        }),
        n &&
          this.on("beforeCaptureLog", (o) => {
            o.attributes = {
              ...o.attributes,
              "server.address": n,
            };
          }),
        process.on("beforeExit", this._logOnExitFlushListener)));
  }
  get tracer() {
    if (this._tracer) return this._tracer;
    const t = "@sentry/node",
      n = Ze,
      r = C.trace.getTracer(t, n);
    return ((this._tracer = r), r);
  }
  async flush(t) {
    return (
      await this.traceProvider?.forceFlush(),
      this.getOptions().sendClientReports && this._flushOutcomes(),
      super.flush(t)
    );
  }
  async close(t) {
    (this._clientReportInterval && clearInterval(this._clientReportInterval),
      this._clientReportOnExitFlushListener &&
        process.off("beforeExit", this._clientReportOnExitFlushListener),
      this._logOnExitFlushListener &&
        process.off("beforeExit", this._logOnExitFlushListener));
    const n = await super.close(t);
    return (this.traceProvider && (await this.traceProvider.shutdown()), n);
  }
  startClientReportTracking() {
    const t = this.getOptions();
    t.sendClientReports &&
      ((this._clientReportOnExitFlushListener = () => {
        this._flushOutcomes();
      }),
      (this._clientReportInterval = setInterval(() => {
        (Ie && $.log("Flushing client reports based on interval."),
          this._flushOutcomes());
      }, t.clientReportFlushInterval ?? AY).unref()),
      process.on("beforeExit", this._clientReportOnExitFlushListener));
  }
  _setupIntegrations() {
    ($G(), super._setupIntegrations());
  }
  _getTraceInfoFromScope(t) {
    return t ? eH(this, t) : [void 0, void 0];
  }
}
function RY() {
  if (mF() && !ye._sentryEsmLoaderHookRegistered) {
    ye._sentryEsmLoaderHookRegistered = !0;
    try {
      const { addHookMessagePort: e } = II.createAddHookMessageChannel();
      VD.register(
        "import-in-the-middle/hook.mjs",
        typeof document > "u"
          ? require("url").pathToFileURL(__filename).href
          : (jl && jl.tagName.toUpperCase() === "SCRIPT" && jl.src) ||
              new URL("worker-C_GFIvBQ.js", document.baseURI).href,
        {
          data: {
            addHookMessagePort: e,
            include: [],
          },
          transferList: [e],
        },
      );
    } catch (e) {
      $.warn("Failed to register 'import-in-the-middle' hook", e);
    }
  }
}
function xM() {
  return [
    sV(),
    tV(),
    SV(),
    CV(),
    KF(),
    BV(),
    bH(),
    DH(),
    vF(),
    kF(),
    lF(),
    SF(),
    VH(),
    ZF(),
    iY(),
    NF(),
  ];
}
function NY(e = {}) {
  return yY(e, xM);
}
function yY(e = {}, t) {
  const n = CY(e, t);
  (n.debug === !0 &&
    (Ie
      ? $.enable()
      : on(() => {
          console.warn(
            "[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.",
          );
        })),
    n.registerEsmLoaderHooks !== !1 && RY(),
    oH(),
    Ke().update(n.initialScope),
    n.spotlight &&
      !n.integrations.some(({ name: s }) => s === kM) &&
      n.integrations.push(
        FF({
          sidecarUrl: typeof n.spotlight == "string" ? n.spotlight : void 0,
        }),
      ),
    PE(n, "node-core"));
  const o = new gY(n);
  return (
    Ke().setClient(o),
    o.init(),
    ye._sentryInjectLoaderHookRegister?.(),
    $.log(`SDK initialized from ${WE() ? "CommonJS" : "ESM"}`),
    o.startClientReportTracking(),
    PY(),
    BB(o),
    nH(o),
    o
  );
}
function OY() {
  if (!Ie) return;
  const e = HB(),
    t = ["SentryContextManager", "SentryPropagator"];
  zt() && t.push("SentrySpanProcessor");
  for (const n of t)
    e.includes(n) ||
      $.error(
        `You have to set up the ${n}. Without this, the OpenTelemetry & Sentry integration will not work properly.`,
      );
  e.includes("SentrySampler") ||
    $.warn(
      "You have to set up the SentrySampler. Without this, the OpenTelemetry & Sentry integration may still work, but sample rates set for the Sentry SDK will not be respected. If you use a custom sampler, make sure to use `wrapSamplingDecision`.",
    );
}
function CY(e, t) {
  const n = bY(e.release);
  let r;
  if (e.spotlight === !1) r = !1;
  else if (typeof e.spotlight == "string") r = e.spotlight;
  else {
    const c = Lp(process.env.SENTRY_SPOTLIGHT, {
        strict: !0,
      }),
      l =
        c === null && process.env.SENTRY_SPOTLIGHT
          ? process.env.SENTRY_SPOTLIGHT
          : void 0;
    r = e.spotlight === !0 ? (l ?? !0) : (c ?? l);
  }
  const o = IY(e.tracesSampleRate),
    s = {
      ...e,
      dsn: e.dsn ?? process.env.SENTRY_DSN,
      environment: e.environment ?? process.env.SENTRY_ENVIRONMENT,
      sendClientReports: e.sendClientReports ?? !0,
      transport: e.transport ?? fY,
      stackParser: KU(e.stackParser || mY),
      release: n,
      tracesSampleRate: o,
      spotlight: r,
      debug: Lp(e.debug ?? process.env.SENTRY_DEBUG),
    },
    i = e.integrations,
    a = e.defaultIntegrations ?? t(s);
  return {
    ...s,
    integrations: sG({
      defaultIntegrations: a,
      integrations: i,
    }),
  };
}
function bY(e) {
  if (e !== void 0) return e;
  const t = SY();
  if (t !== void 0) return t;
}
function IY(e) {
  if (e !== void 0) return e;
  const t = process.env.SENTRY_TRACES_SAMPLE_RATE;
  if (!t) return;
  const n = parseFloat(t);
  return isFinite(n) ? n : void 0;
}
function PY() {
  if (Lp(process.env.SENTRY_USE_ENVIRONMENT) !== !1) {
    const e = process.env.SENTRY_TRACE,
      t = process.env.SENTRY_BAGGAGE,
      n = zI(e, t);
    Ke().setPropagationContext(n);
  }
}
function yt(e, t) {
  e.setAttribute(Ge, t);
}
const KE = "Http",
  ER = "@opentelemetry_sentry-patched/instrumentation-http",
  MY = Ne(`${KE}.sentry`, (e) => new CM(e)),
  vY = Ne(KE, (e) => {
    const t = new BU.HttpInstrumentation({
      ...e,
      disableIncomingRequestInstrumentation: !0,
    });
    try {
      ((t._diag = C.diag.createComponentLogger({
        namespace: ER,
      })),
        (t.instrumentationName = ER));
    } catch {}
    return t;
  });
function LY(e, t = {}) {
  return typeof e.spans == "boolean"
    ? e.spans
    : !(t.skipOpenTelemetrySetup || (!zt(t) && Il.major >= 22));
}
const DY = (e = {}) => {
  const t = e.spans ?? !0,
    n = e.disableIncomingRequestSpans,
    r = {
      sessions: e.trackIncomingRequestsAsSessions,
      sessionFlushingDelayMS: e.sessionFlushingDelayMS,
      ignoreRequestBody: e.ignoreIncomingRequestBody,
      maxRequestBodySize: e.maxIncomingRequestBodySize,
    },
    o = {
      ignoreIncomingRequests: e.ignoreIncomingRequests,
      ignoreStaticAssets: e.ignoreStaticAssets,
      ignoreStatusCodes: e.dropSpansForIncomingRequestStatusCodes,
      instrumentation: e.instrumentation,
      onSpanCreated: e.incomingRequestSpanHook,
    },
    s = KP(r),
    i = zP(o),
    a = t && !n;
  return {
    name: KE,
    setup(c) {
      const l = c.getOptions();
      a && zt(l) && i.setup(c);
    },
    setupOnce() {
      const c = he()?.getOptions() || {},
        l = LY(e, c);
      s.setupOnce();
      const f = {
        breadcrumbs: e.breadcrumbs,
        propagateTraceInOutgoingRequests: !l,
        ignoreOutgoingRequests: e.ignoreOutgoingRequests,
      };
      if ((MY(f), l)) {
        const d = wY(e);
        vY(d);
      }
    },
    processEvent(c) {
      return i.processEvent(c);
    },
  };
};
function wY(e = {}) {
  return {
    ignoreOutgoingRequestHook: (n) => {
      const r = ZP(n);
      if (!r) return !1;
      const o = e.ignoreOutgoingRequests;
      return !!o?.(r, n);
    },
    requireParentforOutgoingSpans: !1,
    requestHook: (n, r) => {
      (yt(n, "auto.http.otel.http"), e.instrumentation?.requestHook?.(n, r));
    },
    responseHook: (n, r) => {
      e.instrumentation?.responseHook?.(n, r);
    },
    applyCustomAttributesOnSpan: (n, r, o) => {
      e.instrumentation?.applyCustomAttributesOnSpan?.(n, r, o);
    },
  };
}
var Ld = {},
  ca = {},
  Rr = {},
  hR;
function UY() {
  return (
    hR ||
      ((hR = 1),
      Object.defineProperty(Rr, "__esModule", {
        value: !0,
      }),
      (Rr.PACKAGE_NAME = Rr.PACKAGE_VERSION = void 0),
      (Rr.PACKAGE_VERSION = "0.19.0"),
      (Rr.PACKAGE_NAME = "@opentelemetry/instrumentation-undici")),
    Rr
  );
}
var TR;
function kY() {
  if (TR) return ca;
  ((TR = 1),
    Object.defineProperty(ca, "__esModule", {
      value: !0,
    }),
    (ca.UndiciInstrumentation = void 0));
  const e = diagnosticsChannel2,
    t = url,
    n = Le,
    r = Pe(),
    o = un,
    s = pt(),
    i = UY();
  class a extends n.InstrumentationBase {
    _recordFromReq = new WeakMap();
    constructor(l = {}) {
      super(i.PACKAGE_NAME, i.PACKAGE_VERSION, l);
    }
    init() {}
    disable() {
      (super.disable(),
        this._channelSubs.forEach((l) => l.unsubscribe()),
        (this._channelSubs.length = 0));
    }
    enable() {
      (super.enable(),
        (this._channelSubs = this._channelSubs || []),
        !(this._channelSubs.length > 0) &&
          (this.subscribeToChannel(
            "undici:request:create",
            this.onRequestCreated.bind(this),
          ),
          this.subscribeToChannel(
            "undici:client:sendHeaders",
            this.onRequestHeaders.bind(this),
          ),
          this.subscribeToChannel(
            "undici:request:headers",
            this.onResponseHeaders.bind(this),
          ),
          this.subscribeToChannel(
            "undici:request:trailers",
            this.onDone.bind(this),
          ),
          this.subscribeToChannel(
            "undici:request:error",
            this.onError.bind(this),
          )));
    }
    _updateMetricInstruments() {
      this._httpClientDurationHistogram = this.meter.createHistogram(
        s.METRIC_HTTP_CLIENT_REQUEST_DURATION,
        {
          description: "Measures the duration of outbound HTTP requests.",
          unit: "s",
          valueType: r.ValueType.DOUBLE,
          advice: {
            explicitBucketBoundaries: [
              0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 2.5, 5,
              7.5, 10,
            ],
          },
        },
      );
    }
    subscribeToChannel(l, f) {
      const [d, u] = process.version
          .replace("v", "")
          .split(".")
          .map((E) => Number(E)),
        _ = d > 18 || (d === 18 && u >= 19);
      let p;
      if (_) (e.subscribe?.(l, f), (p = () => e.unsubscribe?.(l, f)));
      else {
        const E = e.channel(l);
        (E.subscribe(f), (p = () => E.unsubscribe(f)));
      }
      this._channelSubs.push({
        name: l,
        unsubscribe: p,
      });
    }
    parseRequestHeaders(l) {
      const f = new Map();
      if (Array.isArray(l.headers))
        for (let d = 0; d < l.headers.length; d += 2) {
          const u = l.headers[d],
            _ = l.headers[d + 1];
          typeof u == "string" && f.set(u.toLowerCase(), _);
        }
      else if (typeof l.headers == "string") {
        const d = l.headers.split(`\r
`);
        for (const u of d) {
          if (!u) continue;
          const _ = u.indexOf(":");
          if (_ === -1) continue;
          const p = u.substring(0, _).toLowerCase(),
            E = u.substring(_ + 1).trim(),
            h = f.get(p);
          h && Array.isArray(h)
            ? h.push(E)
            : h
              ? f.set(p, [h, E])
              : f.set(p, E);
        }
      }
      return f;
    }
    onRequestCreated({ request: l }) {
      const f = this.getConfig(),
        d = f.enabled !== !1;
      if (
        (0, n.safeExecuteInTheMiddle)(
          () => !d || l.method === "CONNECT" || f.ignoreRequestHook?.(l),
          (B) => B && this._diag.error("caught ignoreRequestHook error: ", B),
          !0,
        )
      )
        return;
      const _ = (0, o.hrTime)();
      let p;
      try {
        p = new t.URL(l.path, l.origin);
      } catch (B) {
        this._diag.warn("could not determine url.full:", B);
        return;
      }
      const E = p.protocol.replace(":", ""),
        h = this.getRequestMethod(l.method),
        T = {
          [s.ATTR_HTTP_REQUEST_METHOD]: h,
          [s.ATTR_HTTP_REQUEST_METHOD_ORIGINAL]: l.method,
          [s.ATTR_URL_FULL]: p.toString(),
          [s.ATTR_URL_PATH]: p.pathname,
          [s.ATTR_URL_QUERY]: p.search,
          [s.ATTR_URL_SCHEME]: E,
        },
        m = {
          https: "443",
          http: "80",
        },
        A = p.hostname,
        g = p.port || m[E];
      ((T[s.ATTR_SERVER_ADDRESS] = A),
        g && !isNaN(Number(g)) && (T[s.ATTR_SERVER_PORT] = Number(g)));
      const O = this.parseRequestHeaders(l).get("user-agent");
      if (O) {
        const B = Array.isArray(O) ? O[O.length - 1] : O;
        T[s.ATTR_USER_AGENT_ORIGINAL] = B;
      }
      const I = (0, n.safeExecuteInTheMiddle)(
        () => f.startSpanHook?.(l),
        (B) => B && this._diag.error("caught startSpanHook error: ", B),
        !0,
      );
      I &&
        Object.entries(I).forEach(([B, F]) => {
          T[B] = F;
        });
      const b = r.context.active(),
        w = r.trace.getSpan(b);
      let L;
      (f.requireParentforSpans &&
      (!w || !r.trace.isSpanContextValid(w.spanContext()))
        ? (L = r.trace.wrapSpanContext(r.INVALID_SPAN_CONTEXT))
        : (L = this.tracer.startSpan(
            h === "_OTHER" ? "HTTP" : h,
            {
              kind: r.SpanKind.CLIENT,
              attributes: T,
            },
            b,
          )),
        (0, n.safeExecuteInTheMiddle)(
          () => f.requestHook?.(L, l),
          (B) => B && this._diag.error("caught requestHook error: ", B),
          !0,
        ));
      const j = r.trace.setSpan(r.context.active(), L),
        H = {};
      r.propagation.inject(j, H);
      const x = Object.entries(H);
      for (let B = 0; B < x.length; B++) {
        const [F, U] = x[B];
        typeof l.addHeader == "function"
          ? l.addHeader(F, U)
          : typeof l.headers == "string"
            ? (l.headers += `${F}: ${U}\r
`)
            : Array.isArray(l.headers) && l.headers.push(F, U);
      }
      this._recordFromReq.set(l, {
        span: L,
        attributes: T,
        startTime: _,
      });
    }
    onRequestHeaders({ request: l, socket: f }) {
      const d = this._recordFromReq.get(l);
      if (!d) return;
      const u = this.getConfig(),
        { span: _ } = d,
        { remoteAddress: p, remotePort: E } = f,
        h = {
          [s.ATTR_NETWORK_PEER_ADDRESS]: p,
          [s.ATTR_NETWORK_PEER_PORT]: E,
        };
      if (u.headersToSpanAttributes?.requestHeaders) {
        const T = new Set(
            u.headersToSpanAttributes.requestHeaders.map((A) =>
              A.toLowerCase(),
            ),
          ),
          m = this.parseRequestHeaders(l);
        for (const [A, g] of m.entries())
          if (T.has(A)) {
            const N = Array.isArray(g) ? g.join(", ") : g;
            h[`http.request.header.${A}`] = N;
          }
      }
      _.setAttributes(h);
    }
    onResponseHeaders({ request: l, response: f }) {
      const d = this._recordFromReq.get(l);
      if (!d) return;
      const { span: u, attributes: _ } = d,
        p = {
          [s.ATTR_HTTP_RESPONSE_STATUS_CODE]: f.statusCode,
        },
        E = this.getConfig();
      (0, n.safeExecuteInTheMiddle)(
        () =>
          E.responseHook?.(u, {
            request: l,
            response: f,
          }),
        (T) => T && this._diag.error("caught responseHook error: ", T),
        !0,
      );
      const h = new Set();
      E.headersToSpanAttributes?.responseHeaders &&
        E.headersToSpanAttributes?.responseHeaders.forEach((T) =>
          h.add(T.toLowerCase()),
        );
      for (let T = 0; T < f.headers.length; T = T + 2) {
        const m = f.headers[T].toString().toLowerCase(),
          A = f.headers[T + 1];
        if (
          (h.has(m) && (p[`http.response.header.${m}`] = A.toString()),
          m === "content-length")
        ) {
          const g = Number(A.toString());
          isNaN(g) || (p["http.response.header.content-length"] = g);
        }
      }
      (u.setAttributes(p),
        u.setStatus({
          code:
            f.statusCode >= 400
              ? r.SpanStatusCode.ERROR
              : r.SpanStatusCode.UNSET,
        }),
        (d.attributes = Object.assign(_, p)));
    }
    onDone({ request: l }) {
      const f = this._recordFromReq.get(l);
      if (!f) return;
      const { span: d, attributes: u, startTime: _ } = f;
      (d.end(),
        this._recordFromReq.delete(l),
        this.recordRequestDuration(u, _));
    }
    onError({ request: l, error: f }) {
      const d = this._recordFromReq.get(l);
      if (!d) return;
      const { span: u, attributes: _, startTime: p } = d;
      (u.recordException(f),
        u.setStatus({
          code: r.SpanStatusCode.ERROR,
          message: f.message,
        }),
        u.end(),
        this._recordFromReq.delete(l),
        (_[s.ATTR_ERROR_TYPE] = f.message),
        this.recordRequestDuration(_, p));
    }
    recordRequestDuration(l, f) {
      const d = {};
      [
        s.ATTR_HTTP_RESPONSE_STATUS_CODE,
        s.ATTR_HTTP_REQUEST_METHOD,
        s.ATTR_SERVER_ADDRESS,
        s.ATTR_SERVER_PORT,
        s.ATTR_URL_SCHEME,
        s.ATTR_ERROR_TYPE,
      ].forEach((p) => {
        p in l && (d[p] = l[p]);
      });
      const _ =
        (0, o.hrTimeToMilliseconds)((0, o.hrTimeDuration)(f, (0, o.hrTime)())) /
        1e3;
      this._httpClientDurationHistogram.record(_, d);
    }
    getRequestMethod(l) {
      const f = {
        CONNECT: !0,
        OPTIONS: !0,
        HEAD: !0,
        GET: !0,
        POST: !0,
        PUT: !0,
        PATCH: !0,
        DELETE: !0,
        TRACE: !0,
      };
      return l.toUpperCase() in f ? l.toUpperCase() : "_OTHER";
    }
  }
  return ((ca.UndiciInstrumentation = a), ca);
}
var SR;
function GY() {
  return (
    SR ||
      ((SR = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.UndiciInstrumentation = void 0));
        var t = kY();
        Object.defineProperty(e, "UndiciInstrumentation", {
          enumerable: !0,
          get: function () {
            return t.UndiciInstrumentation;
          },
        });
      })(Ld)),
    Ld
  );
}
var VY = GY();
const $M = "NodeFetch",
  xY = Ne($M, VY.UndiciInstrumentation, (e) => jY(e)),
  $Y = Ne(`${$M}.sentry`, IM, (e) => e),
  BY = (e = {}) => ({
    name: "NodeFetch",
    setupOnce() {
      (YY(e, he()?.getOptions()) && xY(e), $Y(e));
    },
  }),
  HY = BY;
function FY(e, t = "/") {
  const n = `${e}`;
  return n.endsWith("/") && t.startsWith("/")
    ? `${n}${t.slice(1)}`
    : !n.endsWith("/") && !t.startsWith("/")
      ? `${n}/${t.slice(1)}`
      : `${n}${t}`;
}
function YY(e, t = {}) {
  return typeof e.spans == "boolean"
    ? e.spans
    : !t.skipOpenTelemetrySetup && zt(t);
}
function jY(e = {}) {
  return {
    requireParentforSpans: !1,
    ignoreRequestHook: (n) => {
      const r = FY(n.origin, n.path),
        o = e.ignoreOutgoingRequests;
      return !!(o && r && o(r));
    },
    startSpanHook: () => ({
      [Ge]: "auto.http.otel.node_fetch",
    }),
    requestHook: e.requestHook,
    responseHook: e.responseHook,
  };
}
var Dd = {},
  ua = {},
  wd = {},
  mR;
function zE() {
  return (
    mR ||
      ((mR = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.ExpressLayerType = void 0),
          (function (t) {
            ((t.ROUTER = "router"),
              (t.MIDDLEWARE = "middleware"),
              (t.REQUEST_HANDLER = "request_handler"));
          })(e.ExpressLayerType || (e.ExpressLayerType = {})));
      })(wd)),
    wd
  );
}
var Ud = {},
  AR;
function ZE() {
  return (
    AR ||
      ((AR = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.AttributeNames = void 0),
          (function (t) {
            ((t.EXPRESS_TYPE = "express.type"),
              (t.EXPRESS_NAME = "express.name"));
          })(e.AttributeNames || (e.AttributeNames = {})));
      })(Ud)),
    Ud
  );
}
var kd = {},
  Nr = {},
  gR;
function BM() {
  return (
    gR ||
      ((gR = 1),
      Object.defineProperty(Nr, "__esModule", {
        value: !0,
      }),
      (Nr._LAYERS_STORE_PROPERTY = Nr.kLayerPatched = void 0),
      (Nr.kLayerPatched = Symbol("express-layer-patched")),
      (Nr._LAYERS_STORE_PROPERTY = "__ot_middlewares")),
    Nr
  );
}
var RR;
function qY() {
  return (
    RR ||
      ((RR = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.getActualMatchedRoute =
            e.getConstructedRoute =
            e.getLayerPath =
            e.asErrorAndMessage =
            e.isLayerIgnored =
            e.getLayerMetadata =
            e.getRouterPath =
            e.storeLayerPath =
              void 0));
        const t = zE(),
          n = ZE(),
          r = BM(),
          o = (E, h) => (
            Array.isArray(E[r._LAYERS_STORE_PROPERTY]) === !1 &&
              Object.defineProperty(E, r._LAYERS_STORE_PROPERTY, {
                enumerable: !1,
                value: [],
              }),
            h === void 0
              ? {
                  isLayerPathStored: !1,
                }
              : (E[r._LAYERS_STORE_PROPERTY].push(h),
                {
                  isLayerPathStored: !0,
                })
          );
        e.storeLayerPath = o;
        const s = (E, h) => {
          const T = h.handle?.stack?.[0];
          return T?.route?.path
            ? `${E}${T.route.path}`
            : T?.handle?.stack
              ? (0, e.getRouterPath)(E, T)
              : E;
        };
        e.getRouterPath = s;
        const i = (E, h, T) => {
          if (h.name === "router") {
            const m = (0, e.getRouterPath)("", h),
              A = m || T || E || "/";
            return {
              attributes: {
                [n.AttributeNames.EXPRESS_NAME]: A,
                [n.AttributeNames.EXPRESS_TYPE]: t.ExpressLayerType.ROUTER,
              },
              name: `router - ${A}`,
            };
          } else
            return h.name === "bound dispatch" || h.name === "handle"
              ? {
                  attributes: {
                    [n.AttributeNames.EXPRESS_NAME]:
                      (E || T) ?? "request handler",
                    [n.AttributeNames.EXPRESS_TYPE]:
                      t.ExpressLayerType.REQUEST_HANDLER,
                  },
                  name: `request handler${h.path ? ` - ${E || T}` : ""}`,
                }
              : {
                  attributes: {
                    [n.AttributeNames.EXPRESS_NAME]: h.name,
                    [n.AttributeNames.EXPRESS_TYPE]:
                      t.ExpressLayerType.MIDDLEWARE,
                  },
                  name: `middleware - ${h.name}`,
                };
        };
        e.getLayerMetadata = i;
        const a = (E, h) => {
            if (typeof h == "string") return h === E;
            if (h instanceof RegExp) return h.test(E);
            if (typeof h == "function") return h(E);
            throw new TypeError("Pattern is in unsupported datatype");
          },
          c = (E, h, T) => {
            if (
              Array.isArray(T?.ignoreLayersType) &&
              T?.ignoreLayersType?.includes(h)
            )
              return !0;
            if (Array.isArray(T?.ignoreLayers) === !1) return !1;
            try {
              for (const m of T.ignoreLayers) if (a(E, m)) return !0;
            } catch {}
            return !1;
          };
        e.isLayerIgnored = c;
        const l = (E) =>
          E instanceof Error ? [E, E.message] : [String(E), String(E)];
        e.asErrorAndMessage = l;
        const f = (E) => {
          const h = E[0];
          return Array.isArray(h) ? h.map((T) => d(T) || "").join(",") : d(h);
        };
        e.getLayerPath = f;
        const d = (E) => {
          if (typeof E == "string") return E;
          if (E instanceof RegExp || typeof E == "number") return E.toString();
        };
        function u(E) {
          const T = (
            Array.isArray(E[r._LAYERS_STORE_PROPERTY])
              ? E[r._LAYERS_STORE_PROPERTY]
              : []
          ).filter((m) => m !== "/" && m !== "/*");
          return T.length === 1 && T[0] === "*"
            ? "*"
            : T.join("").replace(/\/{2,}/g, "/");
        }
        e.getConstructedRoute = u;
        function _(E) {
          const h = Array.isArray(E[r._LAYERS_STORE_PROPERTY])
            ? E[r._LAYERS_STORE_PROPERTY]
            : [];
          if (h.length === 0) return;
          if (h.every((g) => g === "/"))
            return E.originalUrl === "/" ? "/" : void 0;
          const T = u(E);
          if (
            T === "*" ||
            (T.includes("/") &&
              (T.includes(",") ||
                T.includes("\\") ||
                T.includes("*") ||
                T.includes("[")))
          )
            return T;
          const m = T.startsWith("/") ? T : `/${T}`;
          return m.length > 0 &&
            (E.originalUrl === m || E.originalUrl.startsWith(m) || p(m))
            ? m
            : void 0;
        }
        e.getActualMatchedRoute = _;
        function p(E) {
          return E.includes(":") || E.includes("*");
        }
      })(kd)),
    kd
  );
}
var yr = {},
  NR;
function WY() {
  return (
    NR ||
      ((NR = 1),
      Object.defineProperty(yr, "__esModule", {
        value: !0,
      }),
      (yr.PACKAGE_NAME = yr.PACKAGE_VERSION = void 0),
      (yr.PACKAGE_VERSION = "0.57.0"),
      (yr.PACKAGE_NAME = "@opentelemetry/instrumentation-express")),
    yr
  );
}
var yR;
function KY() {
  if (yR) return ua;
  ((yR = 1),
    Object.defineProperty(ua, "__esModule", {
      value: !0,
    }),
    (ua.ExpressInstrumentation = void 0));
  const e = un,
    t = Pe(),
    n = zE(),
    r = ZE(),
    o = qY(),
    s = WY(),
    i = Le,
    a = pt(),
    c = BM();
  class l extends i.InstrumentationBase {
    constructor(d = {}) {
      super(s.PACKAGE_NAME, s.PACKAGE_VERSION, d);
    }
    init() {
      return [
        new i.InstrumentationNodeModuleDefinition(
          "express",
          [">=4.0.0 <6"],
          (d) => {
            const u = typeof d?.Router?.prototype?.route == "function",
              _ = u ? d.Router.prototype : d.Router;
            return (
              (0, i.isWrapped)(_.route) && this._unwrap(_, "route"),
              this._wrap(_, "route", this._getRoutePatch()),
              (0, i.isWrapped)(_.use) && this._unwrap(_, "use"),
              this._wrap(_, "use", this._getRouterUsePatch()),
              (0, i.isWrapped)(d.application.use) &&
                this._unwrap(d.application, "use"),
              this._wrap(d.application, "use", this._getAppUsePatch(u)),
              d
            );
          },
          (d) => {
            if (d === void 0) return;
            const _ =
              typeof d?.Router?.prototype?.route == "function"
                ? d.Router.prototype
                : d.Router;
            (this._unwrap(_, "route"),
              this._unwrap(_, "use"),
              this._unwrap(d.application, "use"));
          },
        ),
      ];
    }
    _getRoutePatch() {
      const d = this;
      return function (u) {
        return function (...p) {
          const E = u.apply(this, p),
            h = this.stack[this.stack.length - 1];
          return (d._applyPatch(h, (0, o.getLayerPath)(p)), E);
        };
      };
    }
    _getRouterUsePatch() {
      const d = this;
      return function (u) {
        return function (...p) {
          const E = u.apply(this, p),
            h = this.stack[this.stack.length - 1];
          return (d._applyPatch(h, (0, o.getLayerPath)(p)), E);
        };
      };
    }
    _getAppUsePatch(d) {
      const u = this;
      return function (_) {
        return function (...E) {
          const h = d ? this.router : this._router,
            T = _.apply(this, E);
          if (h) {
            const m = h.stack[h.stack.length - 1];
            u._applyPatch(m, (0, o.getLayerPath)(E));
          }
          return T;
        };
      };
    }
    _applyPatch(d, u) {
      const _ = this;
      d[c.kLayerPatched] !== !0 &&
        ((d[c.kLayerPatched] = !0),
        this._wrap(d, "handle", (p) => {
          if (p.length === 4) return p;
          const E = function (h, T) {
            const { isLayerPathStored: m } = (0, o.storeLayerPath)(h, u),
              A = (0, o.getConstructedRoute)(h),
              g = (0, o.getActualMatchedRoute)(h),
              N = {
                [a.ATTR_HTTP_ROUTE]: g,
              },
              O = (0, o.getLayerMetadata)(A, d, u),
              I = O.attributes[r.AttributeNames.EXPRESS_TYPE],
              b = (0, e.getRPCMetadata)(t.context.active());
            if (
              (b?.type === e.RPCType.HTTP && (b.route = g),
              (0, o.isLayerIgnored)(O.name, I, _.getConfig()))
            )
              return (
                I === n.ExpressLayerType.MIDDLEWARE &&
                  h[c._LAYERS_STORE_PROPERTY].pop(),
                p.apply(this, arguments)
              );
            if (t.trace.getSpan(t.context.active()) === void 0)
              return p.apply(this, arguments);
            const w = _._getSpanName(
                {
                  request: h,
                  layerType: I,
                  route: A,
                },
                O.name,
              ),
              L = _.tracer.startSpan(w, {
                attributes: Object.assign(N, O.attributes),
              }),
              j = t.context.active();
            let H = t.trace.setSpan(j, L);
            const { requestHook: x } = _.getConfig();
            x &&
              (0, i.safeExecuteInTheMiddle)(
                () =>
                  x(L, {
                    request: h,
                    layerType: I,
                    route: A,
                  }),
                (Y) => {
                  Y &&
                    t.diag.error(
                      "express instrumentation: request hook failed",
                      Y,
                    );
                },
                !0,
              );
            let B = !1;
            O.attributes[r.AttributeNames.EXPRESS_TYPE] ===
              n.ExpressLayerType.ROUTER && (L.end(), (B = !0), (H = j));
            const F = () => {
                B === !1 && ((B = !0), L.end());
              },
              U = Array.from(arguments),
              k = U.findIndex((Y) => typeof Y == "function");
            k >= 0 &&
              (arguments[k] = function () {
                const Y = arguments[0],
                  oe = ![void 0, null, "route", "router"].includes(Y);
                if (!B && oe) {
                  const [ne, P] = (0, o.asErrorAndMessage)(Y);
                  (L.recordException(ne),
                    L.setStatus({
                      code: t.SpanStatusCode.ERROR,
                      message: P,
                    }));
                }
                (B === !1 &&
                  ((B = !0), h.res?.removeListener("finish", F), L.end()),
                  !(h.route && oe) && m && h[c._LAYERS_STORE_PROPERTY].pop());
                const ae = U[k];
                return t.context.bind(j, ae).apply(this, arguments);
              });
            try {
              return t.context.bind(H, p).apply(this, arguments);
            } catch (Y) {
              const [oe, ae] = (0, o.asErrorAndMessage)(Y);
              throw (
                L.recordException(oe),
                L.setStatus({
                  code: t.SpanStatusCode.ERROR,
                  message: ae,
                }),
                Y
              );
            } finally {
              B || T.once("finish", F);
            }
          };
          for (const h in p)
            Object.defineProperty(E, h, {
              get() {
                return p[h];
              },
              set(T) {
                p[h] = T;
              },
            });
          return E;
        }));
    }
    _getSpanName(d, u) {
      const { spanNameHook: _ } = this.getConfig();
      if (!(_ instanceof Function)) return u;
      try {
        return _(d, u) ?? u;
      } catch (p) {
        return (
          t.diag.error(
            "express instrumentation: error calling span name rewrite hook",
            p,
          ),
          u
        );
      }
    }
  }
  return ((ua.ExpressInstrumentation = l), ua);
}
var OR;
function zY() {
  return (
    OR ||
      ((OR = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.AttributeNames =
            e.ExpressLayerType =
            e.ExpressInstrumentation =
              void 0));
        var t = KY();
        Object.defineProperty(e, "ExpressInstrumentation", {
          enumerable: !0,
          get: function () {
            return t.ExpressInstrumentation;
          },
        });
        var n = zE();
        Object.defineProperty(e, "ExpressLayerType", {
          enumerable: !0,
          get: function () {
            return n.ExpressLayerType;
          },
        });
        var r = ZE();
        Object.defineProperty(e, "AttributeNames", {
          enumerable: !0,
          get: function () {
            return r.AttributeNames;
          },
        });
      })(Dd)),
    Dd
  );
}
var ZY = zY();
const ro = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__,
  HM = "Express";
function XY(e) {
  yt(e, "auto.http.otel.express");
  const t = Re(e).data,
    n = t["express.type"];
  n && e.setAttribute(Ee, `${n}.express`);
  const r = t["express.name"];
  typeof r == "string" && e.updateName(r);
}
function QY(e, t) {
  if (je() === Xo())
    return (
      ro &&
        $.warn(
          "Isolation scope is still default isolation scope - skipping setting transactionName",
        ),
      t
    );
  if (e.layerType === "request_handler") {
    const n = e.request,
      r = n.method ? n.method.toUpperCase() : "GET";
    je().setTransactionName(`${r} ${e.route}`);
  }
  return t;
}
const JY = Ne(
    HM,
    () =>
      new ZY.ExpressInstrumentation({
        requestHook: (e) => XY(e),
        spanNameHook: (e, t) => QY(e, t),
      }),
  ),
  ej = () => ({
    name: HM,
    setupOnce() {
      JY();
    },
  }),
  tj = ej;
var Gd, CR;
function nj() {
  if (CR) return Gd;
  ((CR = 1), (Gd = e));
  function e(r, o, s) {
    (r instanceof RegExp && (r = t(r, s)),
      o instanceof RegExp && (o = t(o, s)));
    var i = n(r, o, s);
    return (
      i && {
        start: i[0],
        end: i[1],
        pre: s.slice(0, i[0]),
        body: s.slice(i[0] + r.length, i[1]),
        post: s.slice(i[1] + o.length),
      }
    );
  }
  function t(r, o) {
    var s = o.match(r);
    return s ? s[0] : null;
  }
  e.range = n;
  function n(r, o, s) {
    var i,
      a,
      c,
      l,
      f,
      d = s.indexOf(r),
      u = s.indexOf(o, d + 1),
      _ = d;
    if (d >= 0 && u > 0) {
      if (r === o) return [d, u];
      for (i = [], c = s.length; _ >= 0 && !f; )
        (_ == d
          ? (i.push(_), (d = s.indexOf(r, _ + 1)))
          : i.length == 1
            ? (f = [i.pop(), u])
            : ((a = i.pop()),
              a < c && ((c = a), (l = u)),
              (u = s.indexOf(o, _ + 1))),
          (_ = d < u && d >= 0 ? d : u));
      i.length && (f = [c, l]);
    }
    return f;
  }
  return Gd;
}
var Vd, bR;
function rj() {
  if (bR) return Vd;
  bR = 1;
  var e = nj();
  Vd = f;
  var t = "\0SLASH" + Math.random() + "\0",
    n = "\0OPEN" + Math.random() + "\0",
    r = "\0CLOSE" + Math.random() + "\0",
    o = "\0COMMA" + Math.random() + "\0",
    s = "\0PERIOD" + Math.random() + "\0";
  function i(h) {
    return parseInt(h, 10) == h ? parseInt(h, 10) : h.charCodeAt(0);
  }
  function a(h) {
    return h
      .split("\\\\")
      .join(t)
      .split("\\{")
      .join(n)
      .split("\\}")
      .join(r)
      .split("\\,")
      .join(o)
      .split("\\.")
      .join(s);
  }
  function c(h) {
    return h
      .split(t)
      .join("\\")
      .split(n)
      .join("{")
      .split(r)
      .join("}")
      .split(o)
      .join(",")
      .split(s)
      .join(".");
  }
  function l(h) {
    if (!h) return [""];
    var T = [],
      m = e("{", "}", h);
    if (!m) return h.split(",");
    var A = m.pre,
      g = m.body,
      N = m.post,
      O = A.split(",");
    O[O.length - 1] += "{" + g + "}";
    var I = l(N);
    return (
      N.length && ((O[O.length - 1] += I.shift()), O.push.apply(O, I)),
      T.push.apply(T, O),
      T
    );
  }
  function f(h) {
    return h
      ? (h.substr(0, 2) === "{}" && (h = "\\{\\}" + h.substr(2)),
        E(a(h), !0).map(c))
      : [];
  }
  function d(h) {
    return "{" + h + "}";
  }
  function u(h) {
    return /^-?0\d/.test(h);
  }
  function _(h, T) {
    return h <= T;
  }
  function p(h, T) {
    return h >= T;
  }
  function E(h, T) {
    var m = [],
      A = e("{", "}", h);
    if (!A) return [h];
    var g = A.pre,
      N = A.post.length ? E(A.post, !1) : [""];
    if (/\$$/.test(A.pre))
      for (var O = 0; O < N.length; O++) {
        var I = g + "{" + A.body + "}" + N[O];
        m.push(I);
      }
    else {
      var b = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(A.body),
        w = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(A.body),
        L = b || w,
        j = A.body.indexOf(",") >= 0;
      if (!L && !j)
        return A.post.match(/,(?!,).*\}/)
          ? ((h = A.pre + "{" + A.body + r + A.post), E(h))
          : [h];
      var H;
      if (L) H = A.body.split(/\.\./);
      else if (
        ((H = l(A.body)),
        H.length === 1 && ((H = E(H[0], !1).map(d)), H.length === 1))
      )
        return N.map(function (K) {
          return A.pre + H[0] + K;
        });
      var x;
      if (L) {
        var B = i(H[0]),
          F = i(H[1]),
          U = Math.max(H[0].length, H[1].length),
          k = H.length == 3 ? Math.abs(i(H[2])) : 1,
          Y = _,
          oe = F < B;
        oe && ((k *= -1), (Y = p));
        var ae = H.some(u);
        x = [];
        for (var ne = B; Y(ne, F); ne += k) {
          var P;
          if (w) ((P = String.fromCharCode(ne)), P === "\\" && (P = ""));
          else if (((P = String(ne)), ae)) {
            var M = U - P.length;
            if (M > 0) {
              var G = new Array(M + 1).join("0");
              ne < 0 ? (P = "-" + G + P.slice(1)) : (P = G + P);
            }
          }
          x.push(P);
        }
      } else {
        x = [];
        for (var V = 0; V < H.length; V++) x.push.apply(x, E(H[V], !1));
      }
      for (var V = 0; V < x.length; V++)
        for (var O = 0; O < N.length; O++) {
          var I = g + x[V] + N[O];
          (!T || L || I) && m.push(I);
        }
    }
    return m;
  }
  return Vd;
}
var oj = rj();
const sj = Qu(oj),
  ij = 1024 * 64,
  Mu = (e) => {
    if (typeof e != "string") throw new TypeError("invalid pattern");
    if (e.length > ij) throw new TypeError("pattern is too long");
  },
  aj = {
    "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", !0],
    "[:alpha:]": ["\\p{L}\\p{Nl}", !0],
    "[:ascii:]": ["\\x00-\\x7f", !1],
    "[:blank:]": ["\\p{Zs}\\t", !0],
    "[:cntrl:]": ["\\p{Cc}", !0],
    "[:digit:]": ["\\p{Nd}", !0],
    "[:graph:]": ["\\p{Z}\\p{C}", !0, !0],
    "[:lower:]": ["\\p{Ll}", !0],
    "[:print:]": ["\\p{C}", !0],
    "[:punct:]": ["\\p{P}", !0],
    "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", !0],
    "[:upper:]": ["\\p{Lu}", !0],
    "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", !0],
    "[:xdigit:]": ["A-Fa-f0-9", !1],
  },
  la = (e) => e.replace(/[[\]\\-]/g, "\\$&"),
  cj = (e) => e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"),
  IR = (e) => e.join(""),
  uj = (e, t) => {
    const n = t;
    if (e.charAt(n) !== "[") throw new Error("not in a brace expression");
    const r = [],
      o = [];
    let s = n + 1,
      i = !1,
      a = !1,
      c = !1,
      l = !1,
      f = n,
      d = "";
    e: for (; s < e.length; ) {
      const E = e.charAt(s);
      if ((E === "!" || E === "^") && s === n + 1) {
        ((l = !0), s++);
        continue;
      }
      if (E === "]" && i && !c) {
        f = s + 1;
        break;
      }
      if (((i = !0), E === "\\" && !c)) {
        ((c = !0), s++);
        continue;
      }
      if (E === "[" && !c) {
        for (const [h, [T, m, A]] of Object.entries(aj))
          if (e.startsWith(h, s)) {
            if (d) return ["$.", !1, e.length - n, !0];
            ((s += h.length), A ? o.push(T) : r.push(T), (a = a || m));
            continue e;
          }
      }
      if (((c = !1), d)) {
        (E > d ? r.push(la(d) + "-" + la(E)) : E === d && r.push(la(E)),
          (d = ""),
          s++);
        continue;
      }
      if (e.startsWith("-]", s + 1)) {
        (r.push(la(E + "-")), (s += 2));
        continue;
      }
      if (e.startsWith("-", s + 1)) {
        ((d = E), (s += 2));
        continue;
      }
      (r.push(la(E)), s++);
    }
    if (f < s) return ["", !1, 0, !1];
    if (!r.length && !o.length) return ["$.", !1, e.length - n, !0];
    if (o.length === 0 && r.length === 1 && /^\\?.$/.test(r[0]) && !l) {
      const E = r[0].length === 2 ? r[0].slice(-1) : r[0];
      return [cj(E), !1, f - n, !1];
    }
    const u = "[" + (l ? "^" : "") + IR(r) + "]",
      _ = "[" + (l ? "" : "^") + IR(o) + "]";
    return [
      r.length && o.length ? "(" + u + "|" + _ + ")" : r.length ? u : _,
      a,
      f - n,
      !0,
    ];
  },
  Fa = (e, { windowsPathsNoEscape: t = !1 } = {}) =>
    t
      ? e.replace(/\[([^\/\\])\]/g, "$1")
      : e
          .replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2")
          .replace(/\\([^\/])/g, "$1"),
  lj = new Set(["!", "?", "+", "*", "@"]),
  PR = (e) => lj.has(e),
  dj = "(?!(?:^|/)\\.\\.?(?:$|/))",
  Vc = "(?!\\.)",
  fj = new Set(["[", "."]),
  _j = new Set(["..", "."]),
  pj = new Set("().*{}+?[]^$\\!"),
  Ej = (e) => e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"),
  XE = "[^/]",
  MR = XE + "*?",
  vR = XE + "+?";
class At {
  type;
  #e;
  #t;
  #r = !1;
  #n = [];
  #o;
  #i;
  #c;
  #a = !1;
  #s;
  #u;
  #d = !1;
  constructor(t, n, r = {}) {
    ((this.type = t),
      t && (this.#t = !0),
      (this.#o = n),
      (this.#e = this.#o ? this.#o.#e : this),
      (this.#s = this.#e === this ? r : this.#e.#s),
      (this.#c = this.#e === this ? [] : this.#e.#c),
      t === "!" && !this.#e.#a && this.#c.push(this),
      (this.#i = this.#o ? this.#o.#n.length : 0));
  }
  get hasMagic() {
    if (this.#t !== void 0) return this.#t;
    for (const t of this.#n)
      if (typeof t != "string" && (t.type || t.hasMagic)) return (this.#t = !0);
    return this.#t;
  }
  toString() {
    return this.#u !== void 0
      ? this.#u
      : this.type
        ? (this.#u =
            this.type + "(" + this.#n.map((t) => String(t)).join("|") + ")")
        : (this.#u = this.#n.map((t) => String(t)).join(""));
  }
  #_() {
    if (this !== this.#e) throw new Error("should only call on root");
    if (this.#a) return this;
    (this.toString(), (this.#a = !0));
    let t;
    for (; (t = this.#c.pop()); ) {
      if (t.type !== "!") continue;
      let n = t,
        r = n.#o;
      for (; r; ) {
        for (let o = n.#i + 1; !r.type && o < r.#n.length; o++)
          for (const s of t.#n) {
            if (typeof s == "string")
              throw new Error("string part in extglob AST??");
            s.copyIn(r.#n[o]);
          }
        ((n = r), (r = n.#o));
      }
    }
    return this;
  }
  push(...t) {
    for (const n of t)
      if (n !== "") {
        if (typeof n != "string" && !(n instanceof At && n.#o === this))
          throw new Error("invalid part: " + n);
        this.#n.push(n);
      }
  }
  toJSON() {
    const t =
      this.type === null
        ? this.#n.slice().map((n) => (typeof n == "string" ? n : n.toJSON()))
        : [this.type, ...this.#n.map((n) => n.toJSON())];
    return (
      this.isStart() && !this.type && t.unshift([]),
      this.isEnd() &&
        (this === this.#e || (this.#e.#a && this.#o?.type === "!")) &&
        t.push({}),
      t
    );
  }
  isStart() {
    if (this.#e === this) return !0;
    if (!this.#o?.isStart()) return !1;
    if (this.#i === 0) return !0;
    const t = this.#o;
    for (let n = 0; n < this.#i; n++) {
      const r = t.#n[n];
      if (!(r instanceof At && r.type === "!")) return !1;
    }
    return !0;
  }
  isEnd() {
    if (this.#e === this || this.#o?.type === "!") return !0;
    if (!this.#o?.isEnd()) return !1;
    if (!this.type) return this.#o?.isEnd();
    const t = this.#o ? this.#o.#n.length : 0;
    return this.#i === t - 1;
  }
  copyIn(t) {
    typeof t == "string" ? this.push(t) : this.push(t.clone(this));
  }
  clone(t) {
    const n = new At(this.type, t);
    for (const r of this.#n) n.copyIn(r);
    return n;
  }
  static #l(t, n, r, o) {
    let s = !1,
      i = !1,
      a = -1,
      c = !1;
    if (n.type === null) {
      let _ = r,
        p = "";
      for (; _ < t.length; ) {
        const E = t.charAt(_++);
        if (s || E === "\\") {
          ((s = !s), (p += E));
          continue;
        }
        if (i) {
          (_ === a + 1
            ? (E === "^" || E === "!") && (c = !0)
            : E === "]" && !(_ === a + 2 && c) && (i = !1),
            (p += E));
          continue;
        } else if (E === "[") {
          ((i = !0), (a = _), (c = !1), (p += E));
          continue;
        }
        if (!o.noext && PR(E) && t.charAt(_) === "(") {
          (n.push(p), (p = ""));
          const h = new At(E, n);
          ((_ = At.#l(t, h, _, o)), n.push(h));
          continue;
        }
        p += E;
      }
      return (n.push(p), _);
    }
    let l = r + 1,
      f = new At(null, n);
    const d = [];
    let u = "";
    for (; l < t.length; ) {
      const _ = t.charAt(l++);
      if (s || _ === "\\") {
        ((s = !s), (u += _));
        continue;
      }
      if (i) {
        (l === a + 1
          ? (_ === "^" || _ === "!") && (c = !0)
          : _ === "]" && !(l === a + 2 && c) && (i = !1),
          (u += _));
        continue;
      } else if (_ === "[") {
        ((i = !0), (a = l), (c = !1), (u += _));
        continue;
      }
      if (PR(_) && t.charAt(l) === "(") {
        (f.push(u), (u = ""));
        const p = new At(_, f);
        (f.push(p), (l = At.#l(t, p, l, o)));
        continue;
      }
      if (_ === "|") {
        (f.push(u), (u = ""), d.push(f), (f = new At(null, n)));
        continue;
      }
      if (_ === ")")
        return (
          u === "" && n.#n.length === 0 && (n.#d = !0),
          f.push(u),
          (u = ""),
          n.push(...d, f),
          l
        );
      u += _;
    }
    return ((n.type = null), (n.#t = void 0), (n.#n = [t.substring(r - 1)]), l);
  }
  static fromGlob(t, n = {}) {
    const r = new At(null, void 0, n);
    return (At.#l(t, r, 0, n), r);
  }
  toMMPattern() {
    if (this !== this.#e) return this.#e.toMMPattern();
    const t = this.toString(),
      [n, r, o, s] = this.toRegExpSource();
    if (
      !(
        o ||
        this.#t ||
        (this.#s.nocase &&
          !this.#s.nocaseMagicOnly &&
          t.toUpperCase() !== t.toLowerCase())
      )
    )
      return r;
    const a = (this.#s.nocase ? "i" : "") + (s ? "u" : "");
    return Object.assign(new RegExp(`^${n}$`, a), {
      _src: n,
      _glob: t,
    });
  }
  get options() {
    return this.#s;
  }
  toRegExpSource(t) {
    const n = t ?? !!this.#s.dot;
    if ((this.#e === this && this.#_(), !this.type)) {
      const c = this.isStart() && this.isEnd(),
        l = this.#n
          .map((_) => {
            const [p, E, h, T] =
              typeof _ == "string" ? At.#p(_, this.#t, c) : _.toRegExpSource(t);
            return ((this.#t = this.#t || h), (this.#r = this.#r || T), p);
          })
          .join("");
      let f = "";
      if (
        this.isStart() &&
        typeof this.#n[0] == "string" &&
        !(this.#n.length === 1 && _j.has(this.#n[0]))
      ) {
        const p = fj,
          E =
            (n && p.has(l.charAt(0))) ||
            (l.startsWith("\\.") && p.has(l.charAt(2))) ||
            (l.startsWith("\\.\\.") && p.has(l.charAt(4))),
          h = !n && !t && p.has(l.charAt(0));
        f = E ? dj : h ? Vc : "";
      }
      let d = "";
      return (
        this.isEnd() &&
          this.#e.#a &&
          this.#o?.type === "!" &&
          (d = "(?:$|\\/)"),
        [f + l + d, Fa(l), (this.#t = !!this.#t), this.#r]
      );
    }
    const r = this.type === "*" || this.type === "+",
      o = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let s = this.#f(n);
    if (this.isStart() && this.isEnd() && !s && this.type !== "!") {
      const c = this.toString();
      return (
        (this.#n = [c]),
        (this.type = null),
        (this.#t = void 0),
        [c, Fa(this.toString()), !1, !1]
      );
    }
    let i = !r || t || n || !Vc ? "" : this.#f(!0);
    (i === s && (i = ""), i && (s = `(?:${s})(?:${i})*?`));
    let a = "";
    if (this.type === "!" && this.#d) a = (this.isStart() && !n ? Vc : "") + vR;
    else {
      const c =
        this.type === "!"
          ? "))" + (this.isStart() && !n && !t ? Vc : "") + MR + ")"
          : this.type === "@"
            ? ")"
            : this.type === "?"
              ? ")?"
              : this.type === "+" && i
                ? ")"
                : this.type === "*" && i
                  ? ")?"
                  : `)${this.type}`;
      a = o + s + c;
    }
    return [a, Fa(s), (this.#t = !!this.#t), this.#r];
  }
  #f(t) {
    return this.#n
      .map((n) => {
        if (typeof n == "string")
          throw new Error("string type in extglob ast??");
        const [r, o, s, i] = n.toRegExpSource(t);
        return ((this.#r = this.#r || i), r);
      })
      .filter((n) => !(this.isStart() && this.isEnd()) || !!n)
      .join("|");
  }
  static #p(t, n, r = !1) {
    let o = !1,
      s = "",
      i = !1;
    for (let a = 0; a < t.length; a++) {
      const c = t.charAt(a);
      if (o) {
        ((o = !1), (s += (pj.has(c) ? "\\" : "") + c));
        continue;
      }
      if (c === "\\") {
        a === t.length - 1 ? (s += "\\\\") : (o = !0);
        continue;
      }
      if (c === "[") {
        const [l, f, d, u] = uj(t, a);
        if (d) {
          ((s += l), (i = i || f), (a += d - 1), (n = n || u));
          continue;
        }
      }
      if (c === "*") {
        (r && t === "*" ? (s += vR) : (s += MR), (n = !0));
        continue;
      }
      if (c === "?") {
        ((s += XE), (n = !0));
        continue;
      }
      s += Ej(c);
    }
    return [s, Fa(t), !!n, i];
  }
}
const hj = (e, { windowsPathsNoEscape: t = !1 } = {}) =>
    t ? e.replace(/[?*()[\]]/g, "[$&]") : e.replace(/[?*()[\]\\]/g, "\\$&"),
  _t = (e, t, n = {}) => (
    Mu(t),
    !n.nocomment && t.charAt(0) === "#" ? !1 : new Pl(t, n).match(e)
  ),
  Tj = /^\*+([^+@!?\*\[\(]*)$/,
  Sj = (e) => (t) => !t.startsWith(".") && t.endsWith(e),
  mj = (e) => (t) => t.endsWith(e),
  Aj = (e) => (
    (e = e.toLowerCase()),
    (t) => !t.startsWith(".") && t.toLowerCase().endsWith(e)
  ),
  gj = (e) => ((e = e.toLowerCase()), (t) => t.toLowerCase().endsWith(e)),
  Rj = /^\*+\.\*+$/,
  Nj = (e) => !e.startsWith(".") && e.includes("."),
  yj = (e) => e !== "." && e !== ".." && e.includes("."),
  Oj = /^\.\*+$/,
  Cj = (e) => e !== "." && e !== ".." && e.startsWith("."),
  bj = /^\*+$/,
  Ij = (e) => e.length !== 0 && !e.startsWith("."),
  Pj = (e) => e.length !== 0 && e !== "." && e !== "..",
  Mj = /^\?+([^+@!?\*\[\(]*)?$/,
  vj = ([e, t = ""]) => {
    const n = FM([e]);
    return t
      ? ((t = t.toLowerCase()), (r) => n(r) && r.toLowerCase().endsWith(t))
      : n;
  },
  Lj = ([e, t = ""]) => {
    const n = YM([e]);
    return t
      ? ((t = t.toLowerCase()), (r) => n(r) && r.toLowerCase().endsWith(t))
      : n;
  },
  Dj = ([e, t = ""]) => {
    const n = YM([e]);
    return t ? (r) => n(r) && r.endsWith(t) : n;
  },
  wj = ([e, t = ""]) => {
    const n = FM([e]);
    return t ? (r) => n(r) && r.endsWith(t) : n;
  },
  FM = ([e]) => {
    const t = e.length;
    return (n) => n.length === t && !n.startsWith(".");
  },
  YM = ([e]) => {
    const t = e.length;
    return (n) => n.length === t && n !== "." && n !== "..";
  },
  jM =
    typeof process == "object" && process
      ? (typeof process.env == "object" &&
          process.env &&
          process.env.__MINIMATCH_TESTING_PLATFORM__) ||
        process.platform
      : "posix",
  LR = {
    win32: {
      sep: "\\",
    },
    posix: {
      sep: "/",
    },
  },
  Uj = jM === "win32" ? LR.win32.sep : LR.posix.sep;
_t.sep = Uj;
const Bt = Symbol("globstar **");
_t.GLOBSTAR = Bt;
const kj = "[^/]",
  Gj = kj + "*?",
  Vj = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?",
  xj = "(?:(?!(?:\\/|^)\\.).)*?",
  $j =
    (e, t = {}) =>
    (n) =>
      _t(n, e, t);
_t.filter = $j;
const $t = (e, t = {}) => Object.assign({}, e, t),
  Bj = (e) => {
    if (!e || typeof e != "object" || !Object.keys(e).length) return _t;
    const t = _t;
    return Object.assign((r, o, s = {}) => t(r, o, $t(e, s)), {
      Minimatch: class extends t.Minimatch {
        constructor(o, s = {}) {
          super(o, $t(e, s));
        }
        static defaults(o) {
          return t.defaults($t(e, o)).Minimatch;
        }
      },
      AST: class extends t.AST {
        constructor(o, s, i = {}) {
          super(o, s, $t(e, i));
        }
        static fromGlob(o, s = {}) {
          return t.AST.fromGlob(o, $t(e, s));
        }
      },
      unescape: (r, o = {}) => t.unescape(r, $t(e, o)),
      escape: (r, o = {}) => t.escape(r, $t(e, o)),
      filter: (r, o = {}) => t.filter(r, $t(e, o)),
      defaults: (r) => t.defaults($t(e, r)),
      makeRe: (r, o = {}) => t.makeRe(r, $t(e, o)),
      braceExpand: (r, o = {}) => t.braceExpand(r, $t(e, o)),
      match: (r, o, s = {}) => t.match(r, o, $t(e, s)),
      sep: t.sep,
      GLOBSTAR: Bt,
    });
  };
_t.defaults = Bj;
const qM = (e, t = {}) => (
  Mu(e),
  t.nobrace || !/\{(?:(?!\{).)*\}/.test(e) ? [e] : sj(e)
);
_t.braceExpand = qM;
const Hj = (e, t = {}) => new Pl(e, t).makeRe();
_t.makeRe = Hj;
const Fj = (e, t, n = {}) => {
  const r = new Pl(t, n);
  return (
    (e = e.filter((o) => r.match(o))),
    r.options.nonull && !e.length && e.push(t),
    e
  );
};
_t.match = Fj;
const DR = /[?*]|[+@!]\(.*?\)|\[|\]/,
  Yj = (e) => e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
class Pl {
  options;
  set;
  pattern;
  windowsPathsNoEscape;
  nonegate;
  negate;
  comment;
  empty;
  preserveMultipleSlashes;
  partial;
  globSet;
  globParts;
  nocase;
  isWindows;
  platform;
  windowsNoMagicRoot;
  regexp;
  constructor(t, n = {}) {
    (Mu(t),
      (n = n || {}),
      (this.options = n),
      (this.pattern = t),
      (this.platform = n.platform || jM),
      (this.isWindows = this.platform === "win32"),
      (this.windowsPathsNoEscape =
        !!n.windowsPathsNoEscape || n.allowWindowsEscape === !1),
      this.windowsPathsNoEscape &&
        (this.pattern = this.pattern.replace(/\\/g, "/")),
      (this.preserveMultipleSlashes = !!n.preserveMultipleSlashes),
      (this.regexp = null),
      (this.negate = !1),
      (this.nonegate = !!n.nonegate),
      (this.comment = !1),
      (this.empty = !1),
      (this.partial = !!n.partial),
      (this.nocase = !!this.options.nocase),
      (this.windowsNoMagicRoot =
        n.windowsNoMagicRoot !== void 0
          ? n.windowsNoMagicRoot
          : !!(this.isWindows && this.nocase)),
      (this.globSet = []),
      (this.globParts = []),
      (this.set = []),
      this.make());
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1) return !0;
    for (const t of this.set)
      for (const n of t) if (typeof n != "string") return !0;
    return !1;
  }
  debug(...t) {}
  make() {
    const t = this.pattern,
      n = this.options;
    if (!n.nocomment && t.charAt(0) === "#") {
      this.comment = !0;
      return;
    }
    if (!t) {
      this.empty = !0;
      return;
    }
    (this.parseNegate(),
      (this.globSet = [...new Set(this.braceExpand())]),
      n.debug && (this.debug = (...s) => console.error(...s)),
      this.debug(this.pattern, this.globSet));
    const r = this.globSet.map((s) => this.slashSplit(s));
    ((this.globParts = this.preprocess(r)),
      this.debug(this.pattern, this.globParts));
    let o = this.globParts.map((s, i, a) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const c =
            s[0] === "" &&
            s[1] === "" &&
            (s[2] === "?" || !DR.test(s[2])) &&
            !DR.test(s[3]),
          l = /^[a-z]:/i.test(s[0]);
        if (c)
          return [...s.slice(0, 4), ...s.slice(4).map((f) => this.parse(f))];
        if (l) return [s[0], ...s.slice(1).map((f) => this.parse(f))];
      }
      return s.map((c) => this.parse(c));
    });
    if (
      (this.debug(this.pattern, o),
      (this.set = o.filter((s) => s.indexOf(!1) === -1)),
      this.isWindows)
    )
      for (let s = 0; s < this.set.length; s++) {
        const i = this.set[s];
        i[0] === "" &&
          i[1] === "" &&
          this.globParts[s][2] === "?" &&
          typeof i[3] == "string" &&
          /^[a-z]:$/i.test(i[3]) &&
          (i[2] = "?");
      }
    this.debug(this.pattern, this.set);
  }
  preprocess(t) {
    if (this.options.noglobstar)
      for (let r = 0; r < t.length; r++)
        for (let o = 0; o < t[r].length; o++)
          t[r][o] === "**" && (t[r][o] = "*");
    const { optimizationLevel: n = 1 } = this.options;
    return (
      n >= 2
        ? ((t = this.firstPhasePreProcess(t)),
          (t = this.secondPhasePreProcess(t)))
        : n >= 1
          ? (t = this.levelOneOptimize(t))
          : (t = this.adjascentGlobstarOptimize(t)),
      t
    );
  }
  adjascentGlobstarOptimize(t) {
    return t.map((n) => {
      let r = -1;
      for (; (r = n.indexOf("**", r + 1)) !== -1; ) {
        let o = r;
        for (; n[o + 1] === "**"; ) o++;
        o !== r && n.splice(r, o - r);
      }
      return n;
    });
  }
  levelOneOptimize(t) {
    return t.map(
      (n) => (
        (n = n.reduce((r, o) => {
          const s = r[r.length - 1];
          return o === "**" && s === "**"
            ? r
            : o === ".." && s && s !== ".." && s !== "." && s !== "**"
              ? (r.pop(), r)
              : (r.push(o), r);
        }, [])),
        n.length === 0 ? [""] : n
      ),
    );
  }
  levelTwoFileOptimize(t) {
    Array.isArray(t) || (t = this.slashSplit(t));
    let n = !1;
    do {
      if (((n = !1), !this.preserveMultipleSlashes)) {
        for (let o = 1; o < t.length - 1; o++) {
          const s = t[o];
          (o === 1 && s === "" && t[0] === "") ||
            ((s === "." || s === "") && ((n = !0), t.splice(o, 1), o--));
        }
        t[0] === "." &&
          t.length === 2 &&
          (t[1] === "." || t[1] === "") &&
          ((n = !0), t.pop());
      }
      let r = 0;
      for (; (r = t.indexOf("..", r + 1)) !== -1; ) {
        const o = t[r - 1];
        o &&
          o !== "." &&
          o !== ".." &&
          o !== "**" &&
          ((n = !0), t.splice(r - 1, 2), (r -= 2));
      }
    } while (n);
    return t.length === 0 ? [""] : t;
  }
  firstPhasePreProcess(t) {
    let n = !1;
    do {
      n = !1;
      for (let r of t) {
        let o = -1;
        for (; (o = r.indexOf("**", o + 1)) !== -1; ) {
          let i = o;
          for (; r[i + 1] === "**"; ) i++;
          i > o && r.splice(o + 1, i - o);
          let a = r[o + 1];
          const c = r[o + 2],
            l = r[o + 3];
          if (
            a !== ".." ||
            !c ||
            c === "." ||
            c === ".." ||
            !l ||
            l === "." ||
            l === ".."
          )
            continue;
          ((n = !0), r.splice(o, 1));
          const f = r.slice(0);
          ((f[o] = "**"), t.push(f), o--);
        }
        if (!this.preserveMultipleSlashes) {
          for (let i = 1; i < r.length - 1; i++) {
            const a = r[i];
            (i === 1 && a === "" && r[0] === "") ||
              ((a === "." || a === "") && ((n = !0), r.splice(i, 1), i--));
          }
          r[0] === "." &&
            r.length === 2 &&
            (r[1] === "." || r[1] === "") &&
            ((n = !0), r.pop());
        }
        let s = 0;
        for (; (s = r.indexOf("..", s + 1)) !== -1; ) {
          const i = r[s - 1];
          if (i && i !== "." && i !== ".." && i !== "**") {
            n = !0;
            const c = s === 1 && r[s + 1] === "**" ? ["."] : [];
            (r.splice(s - 1, 2, ...c), r.length === 0 && r.push(""), (s -= 2));
          }
        }
      }
    } while (n);
    return t;
  }
  secondPhasePreProcess(t) {
    for (let n = 0; n < t.length - 1; n++)
      for (let r = n + 1; r < t.length; r++) {
        const o = this.partsMatch(t[n], t[r], !this.preserveMultipleSlashes);
        if (o) {
          ((t[n] = []), (t[r] = o));
          break;
        }
      }
    return t.filter((n) => n.length);
  }
  partsMatch(t, n, r = !1) {
    let o = 0,
      s = 0,
      i = [],
      a = "";
    for (; o < t.length && s < n.length; )
      if (t[o] === n[s]) (i.push(a === "b" ? n[s] : t[o]), o++, s++);
      else if (r && t[o] === "**" && n[s] === t[o + 1]) (i.push(t[o]), o++);
      else if (r && n[s] === "**" && t[o] === n[s + 1]) (i.push(n[s]), s++);
      else if (
        t[o] === "*" &&
        n[s] &&
        (this.options.dot || !n[s].startsWith(".")) &&
        n[s] !== "**"
      ) {
        if (a === "b") return !1;
        ((a = "a"), i.push(t[o]), o++, s++);
      } else if (
        n[s] === "*" &&
        t[o] &&
        (this.options.dot || !t[o].startsWith(".")) &&
        t[o] !== "**"
      ) {
        if (a === "a") return !1;
        ((a = "b"), i.push(n[s]), o++, s++);
      } else return !1;
    return t.length === n.length && i;
  }
  parseNegate() {
    if (this.nonegate) return;
    const t = this.pattern;
    let n = !1,
      r = 0;
    for (let o = 0; o < t.length && t.charAt(o) === "!"; o++) ((n = !n), r++);
    (r && (this.pattern = t.slice(r)), (this.negate = n));
  }
  matchOne(t, n, r = !1) {
    const o = this.options;
    if (this.isWindows) {
      const E = typeof t[0] == "string" && /^[a-z]:$/i.test(t[0]),
        h =
          !E &&
          t[0] === "" &&
          t[1] === "" &&
          t[2] === "?" &&
          /^[a-z]:$/i.test(t[3]),
        T = typeof n[0] == "string" && /^[a-z]:$/i.test(n[0]),
        m =
          !T &&
          n[0] === "" &&
          n[1] === "" &&
          n[2] === "?" &&
          typeof n[3] == "string" &&
          /^[a-z]:$/i.test(n[3]),
        A = h ? 3 : E ? 0 : void 0,
        g = m ? 3 : T ? 0 : void 0;
      if (typeof A == "number" && typeof g == "number") {
        const [N, O] = [t[A], n[g]];
        N.toLowerCase() === O.toLowerCase() &&
          ((n[g] = N), g > A ? (n = n.slice(g)) : A > g && (t = t.slice(A)));
      }
    }
    const { optimizationLevel: s = 1 } = this.options;
    (s >= 2 && (t = this.levelTwoFileOptimize(t)),
      this.debug("matchOne", this, {
        file: t,
        pattern: n,
      }),
      this.debug("matchOne", t.length, n.length));
    for (
      var i = 0, a = 0, c = t.length, l = n.length;
      i < c && a < l;
      i++, a++
    ) {
      this.debug("matchOne loop");
      var f = n[a],
        d = t[i];
      if ((this.debug(n, f, d), f === !1)) return !1;
      if (f === Bt) {
        this.debug("GLOBSTAR", [n, f, d]);
        var u = i,
          _ = a + 1;
        if (_ === l) {
          for (this.debug("** at the end"); i < c; i++)
            if (
              t[i] === "." ||
              t[i] === ".." ||
              (!o.dot && t[i].charAt(0) === ".")
            )
              return !1;
          return !0;
        }
        for (; u < c; ) {
          var p = t[u];
          if (
            (this.debug(
              `
globstar while`,
              t,
              u,
              n,
              _,
              p,
            ),
            this.matchOne(t.slice(u), n.slice(_), r))
          )
            return (this.debug("globstar found match!", u, c, p), !0);
          if (p === "." || p === ".." || (!o.dot && p.charAt(0) === ".")) {
            this.debug("dot detected!", t, u, n, _);
            break;
          }
          (this.debug("globstar swallow a segment, and continue"), u++);
        }
        return !!(
          r &&
          (this.debug(
            `
>>> no match, partial?`,
            t,
            u,
            n,
            _,
          ),
          u === c)
        );
      }
      let E;
      if (
        (typeof f == "string"
          ? ((E = d === f), this.debug("string match", f, d, E))
          : ((E = f.test(d)), this.debug("pattern match", f, d, E)),
        !E)
      )
        return !1;
    }
    if (i === c && a === l) return !0;
    if (i === c) return r;
    if (a === l) return i === c - 1 && t[i] === "";
    throw new Error("wtf?");
  }
  braceExpand() {
    return qM(this.pattern, this.options);
  }
  parse(t) {
    Mu(t);
    const n = this.options;
    if (t === "**") return Bt;
    if (t === "") return "";
    let r,
      o = null;
    (r = t.match(bj))
      ? (o = n.dot ? Pj : Ij)
      : (r = t.match(Tj))
        ? (o = (n.nocase ? (n.dot ? gj : Aj) : n.dot ? mj : Sj)(r[1]))
        : (r = t.match(Mj))
          ? (o = (n.nocase ? (n.dot ? Lj : vj) : n.dot ? Dj : wj)(r))
          : (r = t.match(Rj))
            ? (o = n.dot ? yj : Nj)
            : (r = t.match(Oj)) && (o = Cj);
    const s = At.fromGlob(t, this.options).toMMPattern();
    return (
      o &&
        typeof s == "object" &&
        Reflect.defineProperty(s, "test", {
          value: o,
        }),
      s
    );
  }
  makeRe() {
    if (this.regexp || this.regexp === !1) return this.regexp;
    const t = this.set;
    if (!t.length) return ((this.regexp = !1), this.regexp);
    const n = this.options,
      r = n.noglobstar ? Gj : n.dot ? Vj : xj,
      o = new Set(n.nocase ? ["i"] : []);
    let s = t
      .map((c) => {
        const l = c.map((f) => {
          if (f instanceof RegExp) for (const d of f.flags.split("")) o.add(d);
          return typeof f == "string" ? Yj(f) : f === Bt ? Bt : f._src;
        });
        return (
          l.forEach((f, d) => {
            const u = l[d + 1],
              _ = l[d - 1];
            f !== Bt ||
              _ === Bt ||
              (_ === void 0
                ? u !== void 0 && u !== Bt
                  ? (l[d + 1] = "(?:\\/|" + r + "\\/)?" + u)
                  : (l[d] = r)
                : u === void 0
                  ? (l[d - 1] = _ + "(?:\\/|" + r + ")?")
                  : u !== Bt &&
                    ((l[d - 1] = _ + "(?:\\/|\\/" + r + "\\/)" + u),
                    (l[d + 1] = Bt)));
          }),
          l.filter((f) => f !== Bt).join("/")
        );
      })
      .join("|");
    const [i, a] = t.length > 1 ? ["(?:", ")"] : ["", ""];
    ((s = "^" + i + s + a + "$"), this.negate && (s = "^(?!" + s + ").+$"));
    try {
      this.regexp = new RegExp(s, [...o].join(""));
    } catch {
      this.regexp = !1;
    }
    return this.regexp;
  }
  slashSplit(t) {
    return this.preserveMultipleSlashes
      ? t.split("/")
      : this.isWindows && /^\/\/[^\/]+/.test(t)
        ? ["", ...t.split(/\/+/)]
        : t.split(/\/+/);
  }
  match(t, n = this.partial) {
    if ((this.debug("match", t, this.pattern), this.comment)) return !1;
    if (this.empty) return t === "";
    if (t === "/" && n) return !0;
    const r = this.options;
    this.isWindows && (t = t.split("\\").join("/"));
    const o = this.slashSplit(t);
    this.debug(this.pattern, "split", o);
    const s = this.set;
    this.debug(this.pattern, "set", s);
    let i = o[o.length - 1];
    if (!i) for (let a = o.length - 2; !i && a >= 0; a--) i = o[a];
    for (let a = 0; a < s.length; a++) {
      const c = s[a];
      let l = o;
      if ((r.matchBase && c.length === 1 && (l = [i]), this.matchOne(l, c, n)))
        return r.flipNegate ? !0 : !this.negate;
    }
    return r.flipNegate ? !1 : this.negate;
  }
  static defaults(t) {
    return _t.defaults(t).Minimatch;
  }
}
_t.AST = At;
_t.Minimatch = Pl;
_t.escape = hj;
_t.unescape = Fa;
const wR = "@fastify/otel",
  jj = "0.8.0",
  qj = ">=4.0.0 <6",
  UR = [
    "onRequest",
    "preParsing",
    "preValidation",
    "preHandler",
    "preSerialization",
    "onSend",
    "onResponse",
    "onError",
  ],
  Ve = {
    HOOK_NAME: "hook.name",
    FASTIFY_TYPE: "fastify.type",
    HOOK_CALLBACK_NAME: "hook.callback.name",
    ROOT: "fastify.root",
  },
  Wn = {
    ROUTE: "route-hook",
    INSTANCE: "hook",
    HANDLER: "request-handler",
  },
  Cn = "anonymous",
  ht = Symbol("fastify otel instance"),
  Kn = Symbol("fastify otel request spans"),
  da = Symbol("fastify otel request context"),
  kR = Symbol("fastify otel addhook original"),
  GR = Symbol("fastify otel setnotfound original"),
  xc = Symbol("fastify otel ignore path");
class Wj extends Ot {
  constructor(t) {
    if (
      (super(wR, jj, t),
      (this.servername =
        t?.servername ?? process.env.OTEL_SERVICE_NAME ?? "fastify"),
      (this[xc] = null),
      (this._logger = C.diag.createComponentLogger({
        namespace: wR,
      })),
      t?.ignorePaths != null || process.env.OTEL_FASTIFY_IGNORE_PATHS != null)
    ) {
      const n = t?.ignorePaths ?? process.env.OTEL_FASTIFY_IGNORE_PATHS;
      if ((typeof n != "string" || n.length === 0) && typeof n != "function")
        throw new TypeError("ignorePaths must be a string or a function");
      const r = _t;
      this[xc] = (o) => (typeof n == "function" ? n(o) : r(o.url, n));
    }
  }
  enable() {
    if (
      this._handleInitialization === void 0 &&
      this.getConfig().registerOnInitialization
    ) {
      const t = this.plugin();
      ((this._handleInitialization = (n) => {
        n.fastify.register(t);
      }),
        diagnosticsChannel.subscribe(
          "fastify.initialization",
          this._handleInitialization,
        ));
    }
    return super.enable();
  }
  disable() {
    return (
      this._handleInitialization &&
        (diagnosticsChannel.unsubscribe(
          "fastify.initialization",
          this._handleInitialization,
        ),
        (this._handleInitialization = void 0)),
      super.disable()
    );
  }
  init() {
    return [];
  }
  plugin() {
    const t = this;
    return (
      (n[Symbol.for("skip-override")] = !0),
      (n[Symbol.for("fastify.display-name")] = "@fastify/otel"),
      (n[Symbol.for("plugin-meta")] = {
        fastify: qj,
        name: "@fastify/otel",
      }),
      n
    );
    function n(r, o, s) {
      (r.decorate(ht, t),
        r.decorate(kR, r.addHook),
        r.decorate(GR, r.setNotFoundHandler),
        r.decorateRequest("opentelemetry", function () {
          const u = this[da];
          return {
            span: this[Kn],
            tracer: t.tracer,
            context: u,
            inject: (p, E) => C.propagation.inject(u, p, E),
            extract: (p, E) => C.propagation.extract(u, p, E),
          };
        }),
        r.decorateRequest(Kn, null),
        r.decorateRequest(da, null),
        r.addHook("onRoute", function (d) {
          if (t[xc]?.(d) === !0) {
            t._logger.debug(
              `Ignoring route instrumentation ${d.method} ${d.url} because it matches the ignore path`,
            );
            return;
          }
          for (const u of UR)
            if (d[u] != null) {
              const _ = d[u];
              if (typeof _ == "function")
                d[u] = f(_, {
                  [Q.ATTR_SERVICE_NAME]: r[ht].servername,
                  [Ve.HOOK_NAME]: `${this.pluginName} - route -> ${u}`,
                  [Ve.FASTIFY_TYPE]: Wn.ROUTE,
                  [Q.ATTR_HTTP_ROUTE]: d.url,
                  [Ve.HOOK_CALLBACK_NAME]: _.name?.length > 0 ? _.name : Cn,
                });
              else if (Array.isArray(_)) {
                const p = [];
                for (const E of _)
                  p.push(
                    f(E, {
                      [Q.ATTR_SERVICE_NAME]: r[ht].servername,
                      [Ve.HOOK_NAME]: `${this.pluginName} - route -> ${u}`,
                      [Ve.FASTIFY_TYPE]: Wn.ROUTE,
                      [Q.ATTR_HTTP_ROUTE]: d.url,
                      [Ve.HOOK_CALLBACK_NAME]: E.name?.length > 0 ? E.name : Cn,
                    }),
                  );
                d[u] = p;
              }
            }
          (d.onSend != null
            ? (d.onSend = Array.isArray(d.onSend)
                ? [...d.onSend, i]
                : [d.onSend, i])
            : (d.onSend = i),
            d.onError != null
              ? (d.onError = Array.isArray(d.onError)
                  ? [...d.onError, a]
                  : [d.onError, a])
              : (d.onError = a),
            (d.handler = f(d.handler, {
              [Q.ATTR_SERVICE_NAME]: r[ht].servername,
              [Ve.HOOK_NAME]: `${this.pluginName} - route-handler`,
              [Ve.FASTIFY_TYPE]: Wn.HANDLER,
              [Q.ATTR_HTTP_ROUTE]: d.url,
              [Ve.HOOK_CALLBACK_NAME]:
                d.handler.name.length > 0 ? d.handler.name : Cn,
            })));
        }),
        r.addHook("onRequest", function (d, u, _) {
          if (this[ht].isEnabled() === !1) return _();
          if (
            this[ht][xc]?.({
              url: d.url,
              method: d.method,
            }) === !0
          )
            return (
              this[ht]._logger.debug(
                `Ignoring request ${d.method} ${d.url} because it matches the ignore path`,
              ),
              _()
            );
          let p = C.context.active();
          C.trace.getSpan(p) == null &&
            (p = C.propagation.extract(p, d.headers));
          const E = rl(p);
          d.routeOptions.url != null &&
            E?.type === Zr.HTTP &&
            (E.route = d.routeOptions.url);
          const h = this[ht].tracer.startSpan(
            "request",
            {
              attributes: {
                [Q.ATTR_SERVICE_NAME]: r[ht].servername,
                [Ve.ROOT]: "@fastify/otel",
                [Q.ATTR_HTTP_ROUTE]: d.url,
                [Q.ATTR_HTTP_REQUEST_METHOD]: d.method,
              },
            },
            p,
          );
          ((d[da] = C.trace.setSpan(p, h)),
            (d[Kn] = h),
            C.context.with(d[da], () => {
              _();
            }));
        }),
        r.addHook("onResponse", function (d, u, _) {
          const p = d[Kn];
          (p != null &&
            (p.setStatus({
              code: C.SpanStatusCode.OK,
              message: "OK",
            }),
            p.setAttributes({
              [Q.ATTR_HTTP_RESPONSE_STATUS_CODE]: 404,
            }),
            p.end()),
            (d[Kn] = null),
            _());
        }),
        (r.addHook = c),
        (r.setNotFoundHandler = l),
        s());
      function i(d, u, _, p) {
        const E = d[Kn];
        (E != null &&
          (u.statusCode < 500 &&
            E.setStatus({
              code: C.SpanStatusCode.OK,
              message: "OK",
            }),
          E.setAttributes({
            [Q.ATTR_HTTP_RESPONSE_STATUS_CODE]: u.statusCode,
          }),
          E.end()),
          (d[Kn] = null),
          p(null, _));
      }
      function a(d, u, _, p) {
        const E = d[Kn];
        (E != null &&
          (E.setStatus({
            code: C.SpanStatusCode.ERROR,
            message: _.message,
          }),
          E.recordException(_)),
          p());
      }
      function c(d, u) {
        const _ = this[kR];
        return UR.includes(d)
          ? _.call(
              this,
              d,
              f(u, {
                [Q.ATTR_SERVICE_NAME]: r[ht].servername,
                [Ve.HOOK_NAME]: `${this.pluginName} - ${d}`,
                [Ve.FASTIFY_TYPE]: Wn.INSTANCE,
                [Ve.HOOK_CALLBACK_NAME]: u.name?.length > 0 ? u.name : Cn,
              }),
            )
          : _.call(this, d, u);
      }
      function l(d, u) {
        const _ = this[GR];
        typeof d == "function"
          ? ((u = f(d, {
              [Q.ATTR_SERVICE_NAME]: r[ht].servername,
              [Ve.HOOK_NAME]: `${this.pluginName} - not-found-handler`,
              [Ve.FASTIFY_TYPE]: Wn.INSTANCE,
              [Ve.HOOK_CALLBACK_NAME]: d.name?.length > 0 ? d.name : Cn,
            })),
            _.call(this, u))
          : (d.preValidation != null &&
              (d.preValidation = f(d.preValidation, {
                [Q.ATTR_SERVICE_NAME]: r[ht].servername,
                [Ve.HOOK_NAME]: `${this.pluginName} - not-found-handler - preValidation`,
                [Ve.FASTIFY_TYPE]: Wn.INSTANCE,
                [Ve.HOOK_CALLBACK_NAME]:
                  d.preValidation.name?.length > 0 ? d.preValidation.name : Cn,
              })),
            d.preHandler != null &&
              (d.preHandler = f(d.preHandler, {
                [Q.ATTR_SERVICE_NAME]: r[ht].servername,
                [Ve.HOOK_NAME]: `${this.pluginName} - not-found-handler - preHandler`,
                [Ve.FASTIFY_TYPE]: Wn.INSTANCE,
                [Ve.HOOK_CALLBACK_NAME]:
                  d.preHandler.name?.length > 0 ? d.preHandler.name : Cn,
              })),
            (u = f(u, {
              [Q.ATTR_SERVICE_NAME]: r[ht].servername,
              [Ve.HOOK_NAME]: `${this.pluginName} - not-found-handler`,
              [Ve.FASTIFY_TYPE]: Wn.INSTANCE,
              [Ve.HOOK_CALLBACK_NAME]: u.name?.length > 0 ? u.name : Cn,
            })),
            _.call(this, d, u));
      }
      function f(d, u = {}) {
        return function (...p) {
          const E = this[ht],
            [h] = p;
          if (E.isEnabled() === !1) return d.call(this, ...p);
          const T = h[da] ?? C.context.active(),
            m = E.tracer.startSpan(
              `handler - ${d.name?.length > 0 ? d.name : (this.pluginName ?? Cn)}`,
              {
                attributes: u,
              },
              T,
            );
          return C.context.with(
            C.trace.setSpan(T, m),
            function () {
              try {
                const A = d.call(this, ...p);
                return typeof A?.then == "function"
                  ? A.then(
                      (g) => (m.end(), g),
                      (g) => (
                        m.setStatus({
                          code: C.SpanStatusCode.ERROR,
                          message: g.message,
                        }),
                        m.recordException(g),
                        m.end(),
                        Promise.reject(g)
                      ),
                    )
                  : (m.end(), A);
              } catch (A) {
                throw (
                  m.setStatus({
                    code: C.SpanStatusCode.ERROR,
                    message: A.message,
                  }),
                  m.recordException(A),
                  m.end(),
                  A
                );
              }
            },
            this,
          );
        };
      }
    }
  }
}
var Zn;
(function (e) {
  const t = "fastify.name";
  e.FASTIFY_NAME = t;
  const n = "fastify.type";
  e.FASTIFY_TYPE = n;
  const r = "hook.name";
  e.HOOK_NAME = r;
  const o = "plugin.name";
  e.PLUGIN_NAME = o;
})(Zn || (Zn = {}));
var vu;
(function (e) {
  const t = "middleware";
  e.MIDDLEWARE = t;
  const n = "request_handler";
  e.REQUEST_HANDLER = n;
})(vu || (vu = {}));
var Lu;
(function (e) {
  const t = "middleware";
  e.MIDDLEWARE = t;
  const n = "request handler";
  e.REQUEST_HANDLER = n;
})(Lu || (Lu = {}));
const Du = Symbol("opentelemetry.instrumentation.fastify.request_active_span");
function VR(e, t, n, r = {}) {
  const o = t.startSpan(n, {
      attributes: r,
    }),
    s = e[Du] || [];
  return (
    s.push(o),
    Object.defineProperty(e, Du, {
      enumerable: !1,
      configurable: !0,
      value: s,
    }),
    o
  );
}
function xd(e, t) {
  const n = e[Du] || [];
  n.length &&
    (n.forEach((r) => {
      (t &&
        (r.setStatus({
          code: C.SpanStatusCode.ERROR,
          message: t.message,
        }),
        r.recordException(t)),
        r.end());
    }),
    delete e[Du]);
}
function Kj(e, t, n) {
  let r, o;
  try {
    ((o = e()),
      xR(o) &&
        o.then(
          (s) => t(void 0, s),
          (s) => t(s),
        ));
  } catch (s) {
    r = s;
  } finally {
    if (!xR(o) && (t(r, o), r)) throw r;
    return o;
  }
}
function xR(e) {
  return (
    (typeof e == "object" &&
      e &&
      typeof Object.getOwnPropertyDescriptor(e, "then")?.value == "function") ||
    !1
  );
}
const zj = "0.1.0",
  Zj = "@sentry/instrumentation-fastify-v3",
  $R = "anonymous",
  Xj = new Set([
    "onTimeout",
    "onRequest",
    "preParsing",
    "preValidation",
    "preSerialization",
    "preHandler",
    "onSend",
    "onResponse",
    "onError",
  ]);
class Qj extends Ot {
  constructor(t = {}) {
    super(Zj, zj, t);
  }
  init() {
    return [
      new ft("fastify", [">=3.0.0 <4"], (t) => this._patchConstructor(t)),
    ];
  }
  _hookOnRequest() {
    const t = this;
    return function (r, o, s) {
      if (!t.isEnabled()) return s();
      t._wrap(o, "send", t._patchSend());
      const i = r,
        a = rl(C.context.active()),
        c = i.routeOptions ? i.routeOptions.url : r.routerPath;
      c && a?.type === Zr.HTTP && (a.route = c);
      const l = r.method || "GET";
      (je().setTransactionName(`${l} ${c}`), s());
    };
  }
  _wrapHandler(t, n, r, o) {
    const s = this;
    return (
      this._diag.debug("Patching fastify route.handler function"),
      function (...i) {
        if (!s.isEnabled()) return r.apply(this, i);
        const a = r.name || t || $R,
          c = `${Lu.MIDDLEWARE} - ${a}`,
          l = i[1],
          f = VR(l, s.tracer, c, {
            [Zn.FASTIFY_TYPE]: vu.MIDDLEWARE,
            [Zn.PLUGIN_NAME]: t,
            [Zn.HOOK_NAME]: n,
          }),
          d = o && i[i.length - 1];
        return (
          d &&
            (i[i.length - 1] = function (...u) {
              (xd(l), d.apply(this, u));
            }),
          C.context.with(C.trace.setSpan(C.context.active(), f), () =>
            Kj(
              () => r.apply(this, i),
              (u) => {
                (u instanceof Error &&
                  (f.setStatus({
                    code: C.SpanStatusCode.ERROR,
                    message: u.message,
                  }),
                  f.recordException(u)),
                  o || xd(l));
              },
            ),
          )
        );
      }
    );
  }
  _wrapAddHook() {
    const t = this;
    return (
      this._diag.debug("Patching fastify server.addHook function"),
      function (n) {
        return function (...o) {
          const s = o[0],
            i = o[1],
            a = this.pluginName;
          if (!Xj.has(s)) return n.apply(this, o);
          const c =
            typeof o[o.length - 1] == "function" &&
            i.constructor.name !== "AsyncFunction";
          return n.apply(this, [s, t._wrapHandler(a, s, i, c)]);
        };
      }
    );
  }
  _patchConstructor(t) {
    const n = this;
    function r(...o) {
      const s = t.fastify.apply(this, o);
      return (
        s.addHook("onRequest", n._hookOnRequest()),
        s.addHook("preHandler", n._hookPreHandler()),
        Jj(),
        n._wrap(s, "addHook", n._wrapAddHook()),
        s
      );
    }
    return (
      t.errorCodes !== void 0 && (r.errorCodes = t.errorCodes),
      (r.fastify = r),
      (r.default = r),
      r
    );
  }
  _patchSend() {
    const t = this;
    return (
      this._diag.debug("Patching fastify reply.send function"),
      function (r) {
        return function (...s) {
          const i = s[0];
          return t.isEnabled()
            ? er(
                () => r.apply(this, s),
                (a) => {
                  (!a && i instanceof Error && (a = i), xd(this, a));
                },
              )
            : r.apply(this, s);
        };
      }
    );
  }
  _hookPreHandler() {
    const t = this;
    return (
      this._diag.debug("Patching fastify preHandler function"),
      function (r, o, s) {
        if (!t.isEnabled()) return s();
        const i = r,
          a = i.routeOptions?.handler || i.context?.handler,
          c = a?.name.startsWith("bound ") ? a.name.substring(6) : a?.name,
          l = `${Lu.REQUEST_HANDLER} - ${c || this.pluginName || $R}`,
          f = {
            [Zn.PLUGIN_NAME]: this.pluginName,
            [Zn.FASTIFY_TYPE]: vu.REQUEST_HANDLER,
            [Q.SEMATTRS_HTTP_ROUTE]: i.routeOptions
              ? i.routeOptions.url
              : r.routerPath,
          };
        c && (f[Zn.FASTIFY_NAME] = c);
        const d = VR(o, t.tracer, l, f);
        WM(d);
        const { requestHook: u } = t.getConfig();
        return (
          u &&
            er(
              () =>
                u(d, {
                  request: r,
                }),
              (_) => {
                _ && t._diag.error("request hook failed", _);
              },
              !0,
            ),
          C.context.with(C.trace.setSpan(C.context.active(), d), () => {
            s();
          })
        );
      }
    );
  }
}
function Jj() {
  const e = he();
  e &&
    e.on("spanStart", (t) => {
      WM(t);
    });
}
function WM(e) {
  const t = Re(e).data,
    n = t["fastify.type"];
  if (t[Ee] || !n) return;
  e.setAttributes({
    [Ge]: "auto.http.otel.fastify",
    [Ee]: `${n}.fastify`,
  });
  const r = t["fastify.name"] || t["plugin.name"] || t["hook.name"];
  if (typeof r == "string") {
    const o = r.replace(/^fastify -> /, "").replace(/^@fastify\/otel -> /, "");
    e.updateName(o);
  }
}
const Ml = "Fastify",
  eq = Ne(`${Ml}.v3`, () => new Qj());
function tq() {
  const e = he();
  if (e) return e.getIntegrationByName(Ml);
}
function BR(e, t, n, r) {
  const o = tq()?.getShouldHandleError() || KM;
  if (
    (r === "diagnostics-channel" && (this.diagnosticsChannelExists = !0),
    this.diagnosticsChannelExists && r === "onError-hook")
  ) {
    ro &&
      $.warn(
        "Fastify error handler was already registered via diagnostics channel.",
        "You can safely remove `setupFastifyErrorHandler` call and set `shouldHandleError` on the integration options.",
      );
    return;
  }
  o(e, t, n) &&
    xe(e, {
      mechanism: {
        handled: !1,
        type: "auto.function.fastify",
      },
    });
}
const nq = Ne(`${Ml}.v5`, () => {
    const e = new Wj(),
      t = e.plugin();
    return (
      ou.subscribe("fastify.initialization", (n) => {
        const r = n.fastify;
        r?.register(t).after((o) => {
          o
            ? ro && $.error("Failed to setup Fastify instrumentation", o)
            : (sq(), r && iq(r));
        });
      }),
      ou.subscribe("tracing:fastify.request.handler:error", (n) => {
        const { error: r, request: o, reply: s } = n;
        BR.call(BR, r, o, s, "diagnostics-channel");
      }),
      e
    );
  }),
  rq = ({ shouldHandleError: e }) => {
    let t;
    return {
      name: Ml,
      setupOnce() {
        ((t = e || KM), eq(), nq());
      },
      getShouldHandleError() {
        return t;
      },
      setShouldHandleError(n) {
        t = n;
      },
    };
  },
  oq = (e = {}) => rq(e);
function KM(e, t, n) {
  const r = n.statusCode;
  return r >= 500 || r <= 299;
}
function zM(e) {
  const t = Re(e),
    n = t.description,
    r = t.data,
    o = r["fastify.type"],
    s = o === "hook",
    i = o === n?.startsWith("handler -"),
    a = n === "request" || o === "request-handler";
  if (r[Ee] || (!i && !a && !s)) return;
  const c = s ? "hook" : i ? "middleware" : a ? "request-handler" : "<unknown>";
  e.setAttributes({
    [Ge]: "auto.http.otel.fastify",
    [Ee]: `${c}.fastify`,
  });
  const l = r["fastify.name"] || r["plugin.name"] || r["hook.name"];
  if (typeof l == "string") {
    const f = l.replace(/^fastify -> /, "").replace(/^@fastify\/otel -> /, "");
    e.updateName(f);
  }
}
function sq() {
  const e = he();
  e &&
    e.on("spanStart", (t) => {
      zM(t);
    });
}
function iq(e) {
  e.addHook("onRequest", async (t, n) => {
    if (t.opentelemetry) {
      const { span: s } = t.opentelemetry();
      s && zM(s);
    }
    const r = t.routeOptions?.url,
      o = t.method || "GET";
    je().setTransactionName(`${o} ${r}`);
  });
}
var $d = {},
  fa = {},
  Bd = {},
  HR;
function ZM() {
  return (
    HR ||
      ((HR = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.SpanNames = e.TokenKind = e.AllowedOperationTypes = void 0),
          (function (t) {
            ((t.QUERY = "query"),
              (t.MUTATION = "mutation"),
              (t.SUBSCRIPTION = "subscription"));
          })(e.AllowedOperationTypes || (e.AllowedOperationTypes = {})),
          (function (t) {
            ((t.SOF = "<SOF>"),
              (t.EOF = "<EOF>"),
              (t.BANG = "!"),
              (t.DOLLAR = "$"),
              (t.AMP = "&"),
              (t.PAREN_L = "("),
              (t.PAREN_R = ")"),
              (t.SPREAD = "..."),
              (t.COLON = ":"),
              (t.EQUALS = "="),
              (t.AT = "@"),
              (t.BRACKET_L = "["),
              (t.BRACKET_R = "]"),
              (t.BRACE_L = "{"),
              (t.PIPE = "|"),
              (t.BRACE_R = "}"),
              (t.NAME = "Name"),
              (t.INT = "Int"),
              (t.FLOAT = "Float"),
              (t.STRING = "String"),
              (t.BLOCK_STRING = "BlockString"),
              (t.COMMENT = "Comment"));
          })(e.TokenKind || (e.TokenKind = {})),
          (function (t) {
            ((t.EXECUTE = "graphql.execute"),
              (t.PARSE = "graphql.parse"),
              (t.RESOLVE = "graphql.resolve"),
              (t.VALIDATE = "graphql.validate"),
              (t.SCHEMA_VALIDATE = "graphql.validateSchema"),
              (t.SCHEMA_PARSE = "graphql.parseSchema"));
          })(e.SpanNames || (e.SpanNames = {})));
      })(Bd)),
    Bd
  );
}
var Hd = {},
  FR;
function XM() {
  return (
    FR ||
      ((FR = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.AttributeNames = void 0),
          (function (t) {
            ((t.SOURCE = "graphql.source"),
              (t.FIELD_NAME = "graphql.field.name"),
              (t.FIELD_PATH = "graphql.field.path"),
              (t.FIELD_TYPE = "graphql.field.type"),
              (t.OPERATION_TYPE = "graphql.operation.type"),
              (t.OPERATION_NAME = "graphql.operation.name"),
              (t.VARIABLES = "graphql.variables."),
              (t.ERROR_VALIDATION_NAME = "graphql.validation.error"));
          })(e.AttributeNames || (e.AttributeNames = {})));
      })(Hd)),
    Hd
  );
}
var Or = {},
  YR;
function QE() {
  return (
    YR ||
      ((YR = 1),
      Object.defineProperty(Or, "__esModule", {
        value: !0,
      }),
      (Or.OTEL_GRAPHQL_DATA_SYMBOL = Or.OTEL_PATCHED_SYMBOL = void 0),
      (Or.OTEL_PATCHED_SYMBOL = Symbol.for("opentelemetry.patched")),
      (Or.OTEL_GRAPHQL_DATA_SYMBOL = Symbol.for("opentelemetry.graphql_data"))),
    Or
  );
}
var _a = {},
  jR;
function aq() {
  return (
    jR ||
      ((jR = 1),
      Object.defineProperty(_a, "__esModule", {
        value: !0,
      }),
      (_a.OPERATION_NOT_SUPPORTED = void 0),
      QE(),
      (_a.OPERATION_NOT_SUPPORTED = "Operation$operationName$not supported")),
    _a
  );
}
var Fd = {},
  qR;
function cq() {
  return (
    qR ||
      ((qR = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.wrapFieldResolver =
            e.wrapFields =
            e.getSourceFromLocation =
            e.getOperation =
            e.endSpan =
            e.addSpanSource =
            e.addInputVariableAttributes =
            e.isPromise =
              void 0));
        const t = Pe(),
          n = ZM(),
          r = XM(),
          o = QE(),
          s = Object.values(n.AllowedOperationTypes),
          i = (U) => typeof U?.then == "function";
        e.isPromise = i;
        const a = (U) => typeof U == "object" && U !== null;
        function c(U, k, Y) {
          Array.isArray(Y)
            ? Y.forEach((oe, ae) => {
                c(U, `${k}.${ae}`, oe);
              })
            : Y instanceof Object
              ? Object.entries(Y).forEach(([oe, ae]) => {
                  c(U, `${k}.${oe}`, ae);
                })
              : U.setAttribute(`${r.AttributeNames.VARIABLES}${String(k)}`, Y);
        }
        function l(U, k) {
          Object.entries(k).forEach(([Y, oe]) => {
            c(U, Y, oe);
          });
        }
        e.addInputVariableAttributes = l;
        function f(U, k, Y, oe, ae) {
          const ne = b(k, Y, oe, ae);
          U.setAttribute(r.AttributeNames.SOURCE, ne);
        }
        e.addSpanSource = f;
        function d(U, k, Y, oe, ae) {
          let ne = h(Y, ae);
          if (ne)
            return {
              field: ne,
              spanAdded: !1,
            };
          const M = k().flatResolveSpans ? m(Y) : T(Y, ae);
          return (
            (ne = {
              span: u(U, k, Y, oe, ae, M),
            }),
            E(Y, ae, ne),
            {
              field: ne,
              spanAdded: !0,
            }
          );
        }
        function u(U, k, Y, oe, ae, ne) {
          const P = {
              [r.AttributeNames.FIELD_NAME]: oe.fieldName,
              [r.AttributeNames.FIELD_PATH]: ae.join("."),
              [r.AttributeNames.FIELD_TYPE]: oe.returnType.toString(),
            },
            M = U.startSpan(
              `${n.SpanNames.RESOLVE} ${P[r.AttributeNames.FIELD_PATH]}`,
              {
                attributes: P,
              },
              ne ? t.trace.setSpan(t.context.active(), ne) : void 0,
            ),
            G = Y[o.OTEL_GRAPHQL_DATA_SYMBOL].source,
            V = oe.fieldNodes.find((K) => K.kind === "Field");
          return (
            V && f(M, G.loc, k().allowValues, V.loc?.start, V.loc?.end),
            M
          );
        }
        function _(U, k) {
          (k && U.recordException(k), U.end());
        }
        e.endSpan = _;
        function p(U, k) {
          if (!(!U || !Array.isArray(U.definitions)))
            return k
              ? U.definitions
                  .filter((Y) => s.indexOf(Y?.operation) !== -1)
                  .find((Y) => k === Y?.name?.value)
              : U.definitions.find((Y) => s.indexOf(Y?.operation) !== -1);
        }
        e.getOperation = p;
        function E(U, k, Y) {
          return (U[o.OTEL_GRAPHQL_DATA_SYMBOL].fields[k.join(".")] = Y);
        }
        function h(U, k) {
          return U[o.OTEL_GRAPHQL_DATA_SYMBOL].fields[k.join(".")];
        }
        function T(U, k) {
          for (let Y = k.length - 1; Y > 0; Y--) {
            const oe = h(U, k.slice(0, Y));
            if (oe) return oe.span;
          }
          return m(U);
        }
        function m(U) {
          return U[o.OTEL_GRAPHQL_DATA_SYMBOL].span;
        }
        function A(U, k) {
          const Y = [];
          let oe = k;
          for (; oe; ) {
            let ae = oe.key;
            (U && typeof ae == "number" && (ae = "*"),
              Y.push(String(ae)),
              (oe = oe.prev));
          }
          return Y.reverse();
        }
        function g(U) {
          return O(
            `
`,
            U,
          );
        }
        function N(U) {
          return O(" ", U);
        }
        function O(U, k) {
          let Y = "";
          for (let oe = 0; oe < k; oe++) Y += U;
          return Y;
        }
        const I = [
          n.TokenKind.FLOAT,
          n.TokenKind.STRING,
          n.TokenKind.INT,
          n.TokenKind.BLOCK_STRING,
        ];
        function b(U, k = !1, Y, oe) {
          let ae = "";
          if (U?.startToken) {
            const ne = typeof Y == "number" ? Y : U.start,
              P = typeof oe == "number" ? oe : U.end;
            let M = U.startToken.next,
              G = 1;
            for (; M; ) {
              if (M.start < ne) {
                ((M = M.next), (G = M?.line));
                continue;
              }
              if (M.end > P) {
                ((M = M.next), (G = M?.line));
                continue;
              }
              let V = M.value || M.kind,
                K = "";
              (!k && I.indexOf(M.kind) >= 0 && (V = "*"),
                M.kind === n.TokenKind.STRING && (V = `"${V}"`),
                M.kind === n.TokenKind.EOF && (V = ""),
                M.line > G
                  ? ((ae += g(M.line - G)), (G = M.line), (K = N(M.column - 1)))
                  : M.line === M.prev?.line &&
                    (K = N(M.start - (M.prev?.end || 0))),
                (ae += K + V),
                M && (M = M.next));
            }
          }
          return ae;
        }
        e.getSourceFromLocation = b;
        function w(U, k, Y) {
          if (!U || U[o.OTEL_PATCHED_SYMBOL]) return;
          const oe = U.getFields();
          ((U[o.OTEL_PATCHED_SYMBOL] = !0),
            Object.keys(oe).forEach((ae) => {
              const ne = oe[ae];
              if (
                ne &&
                (ne.resolve && (ne.resolve = F(k, Y, ne.resolve)), ne.type)
              ) {
                const P = L(ne.type);
                for (const M of P) w(M, k, Y);
              }
            }));
        }
        e.wrapFields = w;
        function L(U) {
          return "ofType" in U
            ? L(U.ofType)
            : j(U)
              ? U.getTypes()
              : H(U)
                ? [U]
                : [];
        }
        function j(U) {
          return "getTypes" in U && typeof U.getTypes == "function";
        }
        function H(U) {
          return "getFields" in U && typeof U.getFields == "function";
        }
        const x = (U, k, Y) => {
            Y &&
              (U.recordException(k),
              U.setStatus({
                code: t.SpanStatusCode.ERROR,
                message: k.message,
              }),
              U.end());
          },
          B = (U, k) => {
            k && U.end();
          };
        function F(U, k, Y, oe = !1) {
          if (ae[o.OTEL_PATCHED_SYMBOL] || typeof Y != "function") return Y;
          function ae(ne, P, M, G) {
            if (!Y) return;
            const V = k();
            if (
              V.ignoreTrivialResolveSpans &&
              oe &&
              (a(ne) || typeof ne == "function") &&
              typeof ne[G.fieldName] != "function"
            )
              return Y.call(this, ne, P, M, G);
            if (!M[o.OTEL_GRAPHQL_DATA_SYMBOL])
              return Y.call(this, ne, P, M, G);
            const K = A(V.mergeItems, G && G.path),
              X = K.filter((z) => typeof z == "string").length;
            let v,
              D = !1;
            if (V.depth >= 0 && V.depth < X) v = T(M, K);
            else {
              const { field: z, spanAdded: q } = d(U, k, M, G, K);
              ((v = z.span), (D = q));
            }
            return t.context.with(
              t.trace.setSpan(t.context.active(), v),
              () => {
                try {
                  const z = Y.call(this, ne, P, M, G);
                  return (0, e.isPromise)(z)
                    ? z.then(
                        (q) => (B(v, D), q),
                        (q) => {
                          throw (x(v, q, D), q);
                        },
                      )
                    : (B(v, D), z);
                } catch (z) {
                  throw (x(v, z, D), z);
                }
              },
            );
          }
          return ((ae[o.OTEL_PATCHED_SYMBOL] = !0), ae);
        }
        e.wrapFieldResolver = F;
      })(Fd)),
    Fd
  );
}
var Cr = {},
  WR;
function uq() {
  return (
    WR ||
      ((WR = 1),
      Object.defineProperty(Cr, "__esModule", {
        value: !0,
      }),
      (Cr.PACKAGE_NAME = Cr.PACKAGE_VERSION = void 0),
      (Cr.PACKAGE_VERSION = "0.56.0"),
      (Cr.PACKAGE_NAME = "@opentelemetry/instrumentation-graphql")),
    Cr
  );
}
var KR;
function lq() {
  if (KR) return fa;
  ((KR = 1),
    Object.defineProperty(fa, "__esModule", {
      value: !0,
    }),
    (fa.GraphQLInstrumentation = void 0));
  const e = Pe(),
    t = Le,
    n = ZM(),
    r = XM(),
    o = QE(),
    s = aq(),
    i = cq(),
    a = uq(),
    c = {
      mergeItems: !1,
      depth: -1,
      allowValues: !1,
      ignoreResolveSpans: !1,
    },
    l = [">=14.0.0 <17"];
  class f extends t.InstrumentationBase {
    constructor(u = {}) {
      super(a.PACKAGE_NAME, a.PACKAGE_VERSION, {
        ...c,
        ...u,
      });
    }
    setConfig(u = {}) {
      super.setConfig({
        ...c,
        ...u,
      });
    }
    init() {
      const u = new t.InstrumentationNodeModuleDefinition("graphql", l);
      return (
        u.files.push(this._addPatchingExecute()),
        u.files.push(this._addPatchingParser()),
        u.files.push(this._addPatchingValidate()),
        u
      );
    }
    _addPatchingExecute() {
      return new t.InstrumentationNodeModuleFile(
        "graphql/execution/execute.js",
        l,
        (u) => (
          (0, t.isWrapped)(u.execute) && this._unwrap(u, "execute"),
          this._wrap(u, "execute", this._patchExecute(u.defaultFieldResolver)),
          u
        ),
        (u) => {
          u && this._unwrap(u, "execute");
        },
      );
    }
    _addPatchingParser() {
      return new t.InstrumentationNodeModuleFile(
        "graphql/language/parser.js",
        l,
        (u) => (
          (0, t.isWrapped)(u.parse) && this._unwrap(u, "parse"),
          this._wrap(u, "parse", this._patchParse()),
          u
        ),
        (u) => {
          u && this._unwrap(u, "parse");
        },
      );
    }
    _addPatchingValidate() {
      return new t.InstrumentationNodeModuleFile(
        "graphql/validation/validate.js",
        l,
        (u) => (
          (0, t.isWrapped)(u.validate) && this._unwrap(u, "validate"),
          this._wrap(u, "validate", this._patchValidate()),
          u
        ),
        (u) => {
          u && this._unwrap(u, "validate");
        },
      );
    }
    _patchExecute(u) {
      const _ = this;
      return function (E) {
        return function () {
          let T;
          if (arguments.length >= 2) {
            const g = arguments;
            T = _._wrapExecuteArgs(
              g[0],
              g[1],
              g[2],
              g[3],
              g[4],
              g[5],
              g[6],
              g[7],
              u,
            );
          } else {
            const g = arguments[0];
            T = _._wrapExecuteArgs(
              g.schema,
              g.document,
              g.rootValue,
              g.contextValue,
              g.variableValues,
              g.operationName,
              g.fieldResolver,
              g.typeResolver,
              u,
            );
          }
          const m = (0, i.getOperation)(T.document, T.operationName),
            A = _._createExecuteSpan(m, T);
          return (
            (T.contextValue[o.OTEL_GRAPHQL_DATA_SYMBOL] = {
              source: T.document
                ? T.document || T.document[o.OTEL_GRAPHQL_DATA_SYMBOL]
                : void 0,
              span: A,
              fields: {},
            }),
            e.context.with(e.trace.setSpan(e.context.active(), A), () =>
              (0, t.safeExecuteInTheMiddle)(
                () => E.apply(this, [T]),
                (g, N) => {
                  _._handleExecutionResult(A, g, N);
                },
              ),
            )
          );
        };
      };
    }
    _handleExecutionResult(u, _, p) {
      const E = this.getConfig();
      if (p === void 0 || _) {
        (0, i.endSpan)(u, _);
        return;
      }
      if ((0, i.isPromise)(p))
        p.then(
          (h) => {
            if (typeof E.responseHook != "function") {
              (0, i.endSpan)(u);
              return;
            }
            this._executeResponseHook(u, h);
          },
          (h) => {
            (0, i.endSpan)(u, h);
          },
        );
      else {
        if (typeof E.responseHook != "function") {
          (0, i.endSpan)(u);
          return;
        }
        this._executeResponseHook(u, p);
      }
    }
    _executeResponseHook(u, _) {
      const { responseHook: p } = this.getConfig();
      p &&
        (0, t.safeExecuteInTheMiddle)(
          () => {
            p(u, _);
          },
          (E) => {
            (E && this._diag.error("Error running response hook", E),
              (0, i.endSpan)(u, void 0));
          },
          !0,
        );
    }
    _patchParse() {
      const u = this;
      return function (p) {
        return function (h, T) {
          return u._parse(this, p, h, T);
        };
      };
    }
    _patchValidate() {
      const u = this;
      return function (p) {
        return function (h, T, m, A, g) {
          return u._validate(this, p, h, T, m, g, A);
        };
      };
    }
    _parse(u, _, p, E) {
      const h = this.getConfig(),
        T = this.tracer.startSpan(n.SpanNames.PARSE);
      return e.context.with(e.trace.setSpan(e.context.active(), T), () =>
        (0, t.safeExecuteInTheMiddle)(
          () => _.call(u, p, E),
          (m, A) => {
            (A &&
              ((0, i.getOperation)(A)
                ? A.loc && (0, i.addSpanSource)(T, A.loc, h.allowValues)
                : T.updateName(n.SpanNames.SCHEMA_PARSE)),
              (0, i.endSpan)(T, m));
          },
        ),
      );
    }
    _validate(u, _, p, E, h, T, m) {
      const A = this.tracer.startSpan(n.SpanNames.VALIDATE, {});
      return e.context.with(e.trace.setSpan(e.context.active(), A), () =>
        (0, t.safeExecuteInTheMiddle)(
          () => _.call(u, p, E, h, m, T),
          (g, N) => {
            (E.loc || A.updateName(n.SpanNames.SCHEMA_VALIDATE),
              N &&
                N.length &&
                A.recordException({
                  name: r.AttributeNames.ERROR_VALIDATION_NAME,
                  message: JSON.stringify(N),
                }),
              (0, i.endSpan)(A, g));
          },
        ),
      );
    }
    _createExecuteSpan(u, _) {
      const p = this.getConfig(),
        E = this.tracer.startSpan(n.SpanNames.EXECUTE, {});
      if (u) {
        const { operation: h, name: T } = u;
        E.setAttribute(r.AttributeNames.OPERATION_TYPE, h);
        const m = T?.value;
        m
          ? (E.setAttribute(r.AttributeNames.OPERATION_NAME, m),
            E.updateName(`${h} ${m}`))
          : E.updateName(h);
      } else {
        let h = " ";
        (_.operationName && (h = ` "${_.operationName}" `),
          (h = s.OPERATION_NOT_SUPPORTED.replace("$operationName$", h)),
          E.setAttribute(r.AttributeNames.OPERATION_NAME, h));
      }
      return (
        _.document?.loc &&
          (0, i.addSpanSource)(E, _.document.loc, p.allowValues),
        _.variableValues &&
          p.allowValues &&
          (0, i.addInputVariableAttributes)(E, _.variableValues),
        E
      );
    }
    _wrapExecuteArgs(u, _, p, E, h, T, m, A, g) {
      if (
        (E || (E = {}),
        E[o.OTEL_GRAPHQL_DATA_SYMBOL] || this.getConfig().ignoreResolveSpans)
      )
        return {
          schema: u,
          document: _,
          rootValue: p,
          contextValue: E,
          variableValues: h,
          operationName: T,
          fieldResolver: m,
          typeResolver: A,
        };
      const N = m == null,
        O = m ?? g;
      return (
        (m = (0, i.wrapFieldResolver)(
          this.tracer,
          () => this.getConfig(),
          O,
          N,
        )),
        u &&
          ((0, i.wrapFields)(u.getQueryType(), this.tracer, () =>
            this.getConfig(),
          ),
          (0, i.wrapFields)(u.getMutationType(), this.tracer, () =>
            this.getConfig(),
          )),
        {
          schema: u,
          document: _,
          rootValue: p,
          contextValue: E,
          variableValues: h,
          operationName: T,
          fieldResolver: m,
          typeResolver: A,
        }
      );
    }
  }
  return ((fa.GraphQLInstrumentation = f), fa);
}
var zR;
function dq() {
  return (
    zR ||
      ((zR = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.GraphQLInstrumentation = void 0));
        var t = lq();
        Object.defineProperty(e, "GraphQLInstrumentation", {
          enumerable: !0,
          get: function () {
            return t.GraphQLInstrumentation;
          },
        });
      })($d)),
    $d
  );
}
var fq = dq();
const QM = "Graphql",
  _q = Ne(QM, fq.GraphQLInstrumentation, (e) => {
    const t = JM(e);
    return {
      ...t,
      responseHook(n, r) {
        (yt(n, "auto.graphql.otel.graphql"),
          r.errors?.length &&
            !Re(n).status &&
            n.setStatus({
              code: C.SpanStatusCode.ERROR,
            }));
        const s = Re(n).data,
          i = s["graphql.operation.type"],
          a = s["graphql.operation.name"];
        if (t.useOperationNameForRootSpan && i) {
          const c = Yt(n),
            f = Re(c).data[Ha] || [],
            d = a ? `${i} ${a}` : `${i}`;
          (Array.isArray(f)
            ? (f.push(d), c.setAttribute(Ha, f))
            : typeof f == "string"
              ? c.setAttribute(Ha, [f, d])
              : c.setAttribute(Ha, d),
            Re(c).data["original-description"] ||
              c.setAttribute("original-description", Re(c).description),
            c.updateName(`${Re(c).data["original-description"]} (${hq(f)})`));
        }
      },
    };
  }),
  pq = (e = {}) => ({
    name: QM,
    setupOnce() {
      _q(JM(e));
    },
  }),
  Eq = pq;
function JM(e) {
  return {
    ignoreResolveSpans: !0,
    ignoreTrivialResolveSpans: !0,
    useOperationNameForRootSpan: !0,
    ...e,
  };
}
function hq(e) {
  if (Array.isArray(e)) {
    const t = e.slice().sort();
    return t.length <= 5
      ? t.join(", ")
      : `${t.slice(0, 5).join(", ")}, +${t.length - 5}`;
  }
  return `${e}`;
}
var Yd = {},
  pa = {},
  Ea = {},
  ZR;
function Tq() {
  return (
    ZR ||
      ((ZR = 1),
      Object.defineProperty(Ea, "__esModule", {
        value: !0,
      }),
      (Ea.EVENT_LISTENERS_SET = void 0),
      (Ea.EVENT_LISTENERS_SET = Symbol(
        "opentelemetry.instrumentation.kafkajs.eventListenersSet",
      ))),
    Ea
  );
}
var ha = {},
  XR;
function Sq() {
  return (
    XR ||
      ((XR = 1),
      Object.defineProperty(ha, "__esModule", {
        value: !0,
      }),
      (ha.bufferTextMapGetter = void 0),
      (ha.bufferTextMapGetter = {
        get(e, t) {
          if (!e) return;
          const n = Object.keys(e);
          for (const r of n)
            if (r === t || r.toLowerCase() === t) return e[r]?.toString();
        },
        keys(e) {
          return e ? Object.keys(e) : [];
        },
      })),
    ha
  );
}
var Se = {},
  QR;
function mq() {
  return (
    QR ||
      ((QR = 1),
      Object.defineProperty(Se, "__esModule", {
        value: !0,
      }),
      (Se.METRIC_MESSAGING_PROCESS_DURATION =
        Se.METRIC_MESSAGING_CLIENT_SENT_MESSAGES =
        Se.METRIC_MESSAGING_CLIENT_OPERATION_DURATION =
        Se.METRIC_MESSAGING_CLIENT_CONSUMED_MESSAGES =
        Se.MESSAGING_SYSTEM_VALUE_KAFKA =
        Se.MESSAGING_OPERATION_TYPE_VALUE_SEND =
        Se.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE =
        Se.MESSAGING_OPERATION_TYPE_VALUE_PROCESS =
        Se.ATTR_MESSAGING_SYSTEM =
        Se.ATTR_MESSAGING_OPERATION_TYPE =
        Se.ATTR_MESSAGING_OPERATION_NAME =
        Se.ATTR_MESSAGING_KAFKA_OFFSET =
        Se.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE =
        Se.ATTR_MESSAGING_KAFKA_MESSAGE_KEY =
        Se.ATTR_MESSAGING_DESTINATION_PARTITION_ID =
        Se.ATTR_MESSAGING_DESTINATION_NAME =
        Se.ATTR_MESSAGING_BATCH_MESSAGE_COUNT =
          void 0),
      (Se.ATTR_MESSAGING_BATCH_MESSAGE_COUNT = "messaging.batch.message_count"),
      (Se.ATTR_MESSAGING_DESTINATION_NAME = "messaging.destination.name"),
      (Se.ATTR_MESSAGING_DESTINATION_PARTITION_ID =
        "messaging.destination.partition.id"),
      (Se.ATTR_MESSAGING_KAFKA_MESSAGE_KEY = "messaging.kafka.message.key"),
      (Se.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE =
        "messaging.kafka.message.tombstone"),
      (Se.ATTR_MESSAGING_KAFKA_OFFSET = "messaging.kafka.offset"),
      (Se.ATTR_MESSAGING_OPERATION_NAME = "messaging.operation.name"),
      (Se.ATTR_MESSAGING_OPERATION_TYPE = "messaging.operation.type"),
      (Se.ATTR_MESSAGING_SYSTEM = "messaging.system"),
      (Se.MESSAGING_OPERATION_TYPE_VALUE_PROCESS = "process"),
      (Se.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE = "receive"),
      (Se.MESSAGING_OPERATION_TYPE_VALUE_SEND = "send"),
      (Se.MESSAGING_SYSTEM_VALUE_KAFKA = "kafka"),
      (Se.METRIC_MESSAGING_CLIENT_CONSUMED_MESSAGES =
        "messaging.client.consumed.messages"),
      (Se.METRIC_MESSAGING_CLIENT_OPERATION_DURATION =
        "messaging.client.operation.duration"),
      (Se.METRIC_MESSAGING_CLIENT_SENT_MESSAGES =
        "messaging.client.sent.messages"),
      (Se.METRIC_MESSAGING_PROCESS_DURATION = "messaging.process.duration")),
    Se
  );
}
var br = {},
  JR;
function Aq() {
  return (
    JR ||
      ((JR = 1),
      Object.defineProperty(br, "__esModule", {
        value: !0,
      }),
      (br.PACKAGE_NAME = br.PACKAGE_VERSION = void 0),
      (br.PACKAGE_VERSION = "0.18.0"),
      (br.PACKAGE_NAME = "@opentelemetry/instrumentation-kafkajs")),
    br
  );
}
var eN;
function gq() {
  if (eN) return pa;
  ((eN = 1),
    Object.defineProperty(pa, "__esModule", {
      value: !0,
    }),
    (pa.KafkaJsInstrumentation = void 0));
  const e = Pe(),
    t = Le,
    n = pt(),
    r = Tq(),
    o = Sq(),
    s = mq(),
    i = Aq();
  function a(d, u, _) {
    return (p) => {
      d.add(u, {
        ..._,
        ...(p
          ? {
              [n.ATTR_ERROR_TYPE]: p,
            }
          : {}),
      });
    };
  }
  function c(d, u, _) {
    return (p) => {
      d.record((Date.now() - u) / 1e3, {
        ..._,
        ...(p
          ? {
              [n.ATTR_ERROR_TYPE]: p,
            }
          : {}),
      });
    };
  }
  const l = [
    0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 2.5, 5, 7.5, 10,
  ];
  class f extends t.InstrumentationBase {
    constructor(u = {}) {
      super(i.PACKAGE_NAME, i.PACKAGE_VERSION, u);
    }
    _updateMetricInstruments() {
      ((this._clientDuration = this.meter.createHistogram(
        s.METRIC_MESSAGING_CLIENT_OPERATION_DURATION,
        {
          advice: {
            explicitBucketBoundaries: l,
          },
        },
      )),
        (this._sentMessages = this.meter.createCounter(
          s.METRIC_MESSAGING_CLIENT_SENT_MESSAGES,
        )),
        (this._consumedMessages = this.meter.createCounter(
          s.METRIC_MESSAGING_CLIENT_CONSUMED_MESSAGES,
        )),
        (this._processDuration = this.meter.createHistogram(
          s.METRIC_MESSAGING_PROCESS_DURATION,
          {
            advice: {
              explicitBucketBoundaries: l,
            },
          },
        )));
    }
    init() {
      const u = (p) => {
        ((0, t.isWrapped)(p?.Kafka?.prototype.producer) &&
          this._unwrap(p.Kafka.prototype, "producer"),
          (0, t.isWrapped)(p?.Kafka?.prototype.consumer) &&
            this._unwrap(p.Kafka.prototype, "consumer"));
      };
      return new t.InstrumentationNodeModuleDefinition(
        "kafkajs",
        [">=0.3.0 <3"],
        (p) => (
          u(p),
          this._wrap(p?.Kafka?.prototype, "producer", this._getProducerPatch()),
          this._wrap(p?.Kafka?.prototype, "consumer", this._getConsumerPatch()),
          p
        ),
        u,
      );
    }
    _getConsumerPatch() {
      const u = this;
      return (_) =>
        function (...E) {
          const h = _.apply(this, E);
          return (
            (0, t.isWrapped)(h.run) && u._unwrap(h, "run"),
            u._wrap(h, "run", u._getConsumerRunPatch()),
            u._setKafkaEventListeners(h),
            h
          );
        };
    }
    _setKafkaEventListeners(u) {
      u[r.EVENT_LISTENERS_SET] ||
        (u.events?.REQUEST &&
          u.on(u.events.REQUEST, this._recordClientDurationMetric.bind(this)),
        (u[r.EVENT_LISTENERS_SET] = !0));
    }
    _recordClientDurationMetric(u) {
      const [_, p] = u.payload.broker.split(":");
      this._clientDuration.record(u.payload.duration / 1e3, {
        [s.ATTR_MESSAGING_SYSTEM]: s.MESSAGING_SYSTEM_VALUE_KAFKA,
        [s.ATTR_MESSAGING_OPERATION_NAME]: `${u.payload.apiName}`,
        [n.ATTR_SERVER_ADDRESS]: _,
        [n.ATTR_SERVER_PORT]: Number.parseInt(p, 10),
      });
    }
    _getProducerPatch() {
      const u = this;
      return (_) =>
        function (...E) {
          const h = _.apply(this, E);
          return (
            (0, t.isWrapped)(h.sendBatch) && u._unwrap(h, "sendBatch"),
            u._wrap(h, "sendBatch", u._getSendBatchPatch()),
            (0, t.isWrapped)(h.send) && u._unwrap(h, "send"),
            u._wrap(h, "send", u._getSendPatch()),
            (0, t.isWrapped)(h.transaction) && u._unwrap(h, "transaction"),
            u._wrap(h, "transaction", u._getProducerTransactionPatch()),
            u._setKafkaEventListeners(h),
            h
          );
        };
    }
    _getConsumerRunPatch() {
      const u = this;
      return (_) =>
        function (...E) {
          const h = E[0];
          return (
            h?.eachMessage &&
              ((0, t.isWrapped)(h.eachMessage) && u._unwrap(h, "eachMessage"),
              u._wrap(h, "eachMessage", u._getConsumerEachMessagePatch())),
            h?.eachBatch &&
              ((0, t.isWrapped)(h.eachBatch) && u._unwrap(h, "eachBatch"),
              u._wrap(h, "eachBatch", u._getConsumerEachBatchPatch())),
            _.call(this, h)
          );
        };
    }
    _getConsumerEachMessagePatch() {
      const u = this;
      return (_) =>
        function (...E) {
          const h = E[0],
            T = e.propagation.extract(
              e.ROOT_CONTEXT,
              h.message.headers,
              o.bufferTextMapGetter,
            ),
            m = u._startConsumerSpan({
              topic: h.topic,
              message: h.message,
              operationType: s.MESSAGING_OPERATION_TYPE_VALUE_PROCESS,
              ctx: T,
              attributes: {
                [s.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(
                  h.partition,
                ),
              },
            }),
            A = [
              c(u._processDuration, Date.now(), {
                [s.ATTR_MESSAGING_SYSTEM]: s.MESSAGING_SYSTEM_VALUE_KAFKA,
                [s.ATTR_MESSAGING_OPERATION_NAME]: "process",
                [s.ATTR_MESSAGING_DESTINATION_NAME]: h.topic,
                [s.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(
                  h.partition,
                ),
              }),
              a(u._consumedMessages, 1, {
                [s.ATTR_MESSAGING_SYSTEM]: s.MESSAGING_SYSTEM_VALUE_KAFKA,
                [s.ATTR_MESSAGING_OPERATION_NAME]: "process",
                [s.ATTR_MESSAGING_DESTINATION_NAME]: h.topic,
                [s.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(
                  h.partition,
                ),
              }),
            ],
            g = e.context.with(e.trace.setSpan(T, m), () => _.apply(this, E));
          return u._endSpansOnPromise([m], A, g);
        };
    }
    _getConsumerEachBatchPatch() {
      return (u) => {
        const _ = this;
        return function (...E) {
          const h = E[0],
            T = _._startConsumerSpan({
              topic: h.batch.topic,
              message: void 0,
              operationType: s.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE,
              ctx: e.ROOT_CONTEXT,
              attributes: {
                [s.ATTR_MESSAGING_BATCH_MESSAGE_COUNT]: h.batch.messages.length,
                [s.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(
                  h.batch.partition,
                ),
              },
            });
          return e.context.with(e.trace.setSpan(e.context.active(), T), () => {
            const m = Date.now(),
              A = [],
              g = [
                a(_._consumedMessages, h.batch.messages.length, {
                  [s.ATTR_MESSAGING_SYSTEM]: s.MESSAGING_SYSTEM_VALUE_KAFKA,
                  [s.ATTR_MESSAGING_OPERATION_NAME]: "process",
                  [s.ATTR_MESSAGING_DESTINATION_NAME]: h.batch.topic,
                  [s.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(
                    h.batch.partition,
                  ),
                }),
              ];
            h.batch.messages.forEach((O) => {
              const I = e.propagation.extract(
                  e.ROOT_CONTEXT,
                  O.headers,
                  o.bufferTextMapGetter,
                ),
                b = e.trace.getSpan(I)?.spanContext();
              let w;
              (b &&
                (w = {
                  context: b,
                }),
                A.push(
                  _._startConsumerSpan({
                    topic: h.batch.topic,
                    message: O,
                    operationType: s.MESSAGING_OPERATION_TYPE_VALUE_PROCESS,
                    link: w,
                    attributes: {
                      [s.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(
                        h.batch.partition,
                      ),
                    },
                  }),
                ),
                g.push(
                  c(_._processDuration, m, {
                    [s.ATTR_MESSAGING_SYSTEM]: s.MESSAGING_SYSTEM_VALUE_KAFKA,
                    [s.ATTR_MESSAGING_OPERATION_NAME]: "process",
                    [s.ATTR_MESSAGING_DESTINATION_NAME]: h.batch.topic,
                    [s.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(
                      h.batch.partition,
                    ),
                  }),
                ));
            });
            const N = u.apply(this, E);
            return (A.unshift(T), _._endSpansOnPromise(A, g, N));
          });
        };
      };
    }
    _getProducerTransactionPatch() {
      const u = this;
      return (_) =>
        function (...E) {
          const h = u.tracer.startSpan("transaction"),
            T = _.apply(this, E);
          return (
            T.then((m) => {
              const A = m.send;
              m.send = function (...b) {
                return e.context.with(
                  e.trace.setSpan(e.context.active(), h),
                  () =>
                    u
                      ._getSendPatch()(A)
                      .apply(this, b)
                      .catch((L) => {
                        throw (
                          h.setStatus({
                            code: e.SpanStatusCode.ERROR,
                            message: L?.message,
                          }),
                          h.recordException(L),
                          L
                        );
                      }),
                );
              };
              const g = m.sendBatch;
              m.sendBatch = function (...b) {
                return e.context.with(
                  e.trace.setSpan(e.context.active(), h),
                  () =>
                    u
                      ._getSendBatchPatch()(g)
                      .apply(this, b)
                      .catch((L) => {
                        throw (
                          h.setStatus({
                            code: e.SpanStatusCode.ERROR,
                            message: L?.message,
                          }),
                          h.recordException(L),
                          L
                        );
                      }),
                );
              };
              const N = m.commit;
              m.commit = function (...b) {
                const w = N.apply(this, b).then(() => {
                  h.setStatus({
                    code: e.SpanStatusCode.OK,
                  });
                });
                return u._endSpansOnPromise([h], [], w);
              };
              const O = m.abort;
              m.abort = function (...b) {
                const w = O.apply(this, b);
                return u._endSpansOnPromise([h], [], w);
              };
            }).catch((m) => {
              (h.setStatus({
                code: e.SpanStatusCode.ERROR,
                message: m?.message,
              }),
                h.recordException(m),
                h.end());
            }),
            T
          );
        };
    }
    _getSendBatchPatch() {
      const u = this;
      return (_) =>
        function (...E) {
          const T = E[0].topicMessages || [],
            m = [],
            A = [];
          T.forEach((N) => {
            N.messages.forEach((O) => {
              (m.push(u._startProducerSpan(N.topic, O)),
                A.push(
                  a(u._sentMessages, 1, {
                    [s.ATTR_MESSAGING_SYSTEM]: s.MESSAGING_SYSTEM_VALUE_KAFKA,
                    [s.ATTR_MESSAGING_OPERATION_NAME]: "send",
                    [s.ATTR_MESSAGING_DESTINATION_NAME]: N.topic,
                    ...(O.partition !== void 0
                      ? {
                          [s.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(
                            O.partition,
                          ),
                        }
                      : {}),
                  }),
                ));
            });
          });
          const g = _.apply(this, E);
          return u._endSpansOnPromise(m, A, g);
        };
    }
    _getSendPatch() {
      const u = this;
      return (_) =>
        function (...E) {
          const h = E[0],
            T = h.messages.map((g) => u._startProducerSpan(h.topic, g)),
            m = h.messages.map((g) =>
              a(u._sentMessages, 1, {
                [s.ATTR_MESSAGING_SYSTEM]: s.MESSAGING_SYSTEM_VALUE_KAFKA,
                [s.ATTR_MESSAGING_OPERATION_NAME]: "send",
                [s.ATTR_MESSAGING_DESTINATION_NAME]: h.topic,
                ...(g.partition !== void 0
                  ? {
                      [s.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(
                        g.partition,
                      ),
                    }
                  : {}),
              }),
            ),
            A = _.apply(this, E);
          return u._endSpansOnPromise(T, m, A);
        };
    }
    _endSpansOnPromise(u, _, p) {
      return Promise.resolve(p)
        .then((E) => (_.forEach((h) => h()), E))
        .catch((E) => {
          let h,
            T = n.ERROR_TYPE_VALUE_OTHER;
          throw (
            typeof E == "string" || E === void 0
              ? (h = E)
              : typeof E == "object" &&
                Object.prototype.hasOwnProperty.call(E, "message") &&
                ((h = E.message), (T = E.constructor.name)),
            _.forEach((m) => m(T)),
            u.forEach((m) => {
              (m.setAttribute(n.ATTR_ERROR_TYPE, T),
                m.setStatus({
                  code: e.SpanStatusCode.ERROR,
                  message: h,
                }));
            }),
            E
          );
        })
        .finally(() => {
          u.forEach((E) => E.end());
        });
    }
    _startConsumerSpan({
      topic: u,
      message: _,
      operationType: p,
      ctx: E,
      link: h,
      attributes: T,
    }) {
      const m = p === s.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE ? "poll" : p,
        A = this.tracer.startSpan(
          `${m} ${u}`,
          {
            kind:
              p === s.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE
                ? e.SpanKind.CLIENT
                : e.SpanKind.CONSUMER,
            attributes: {
              ...T,
              [s.ATTR_MESSAGING_SYSTEM]: s.MESSAGING_SYSTEM_VALUE_KAFKA,
              [s.ATTR_MESSAGING_DESTINATION_NAME]: u,
              [s.ATTR_MESSAGING_OPERATION_TYPE]: p,
              [s.ATTR_MESSAGING_OPERATION_NAME]: m,
              [s.ATTR_MESSAGING_KAFKA_MESSAGE_KEY]: _?.key
                ? String(_.key)
                : void 0,
              [s.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE]:
                _?.key && _.value === null ? !0 : void 0,
              [s.ATTR_MESSAGING_KAFKA_OFFSET]: _?.offset,
            },
            links: h ? [h] : [],
          },
          E,
        ),
        { consumerHook: g } = this.getConfig();
      return (
        g &&
          _ &&
          (0, t.safeExecuteInTheMiddle)(
            () =>
              g(A, {
                topic: u,
                message: _,
              }),
            (N) => {
              N && this._diag.error("consumerHook error", N);
            },
            !0,
          ),
        A
      );
    }
    _startProducerSpan(u, _) {
      const p = this.tracer.startSpan(`send ${u}`, {
        kind: e.SpanKind.PRODUCER,
        attributes: {
          [s.ATTR_MESSAGING_SYSTEM]: s.MESSAGING_SYSTEM_VALUE_KAFKA,
          [s.ATTR_MESSAGING_DESTINATION_NAME]: u,
          [s.ATTR_MESSAGING_KAFKA_MESSAGE_KEY]: _.key ? String(_.key) : void 0,
          [s.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE]:
            _.key && _.value === null ? !0 : void 0,
          [s.ATTR_MESSAGING_DESTINATION_PARTITION_ID]:
            _.partition !== void 0 ? String(_.partition) : void 0,
          [s.ATTR_MESSAGING_OPERATION_NAME]: "send",
          [s.ATTR_MESSAGING_OPERATION_TYPE]:
            s.MESSAGING_OPERATION_TYPE_VALUE_SEND,
        },
      });
      ((_.headers = _.headers ?? {}),
        e.propagation.inject(
          e.trace.setSpan(e.context.active(), p),
          _.headers,
        ));
      const { producerHook: E } = this.getConfig();
      return (
        E &&
          (0, t.safeExecuteInTheMiddle)(
            () =>
              E(p, {
                topic: u,
                message: _,
              }),
            (h) => {
              h && this._diag.error("producerHook error", h);
            },
            !0,
          ),
        p
      );
    }
  }
  return ((pa.KafkaJsInstrumentation = f), pa);
}
var tN;
function Rq() {
  return (
    tN ||
      ((tN = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.KafkaJsInstrumentation = void 0));
        var t = gq();
        Object.defineProperty(e, "KafkaJsInstrumentation", {
          enumerable: !0,
          get: function () {
            return t.KafkaJsInstrumentation;
          },
        });
      })(Yd)),
    Yd
  );
}
var Nq = Rq();
const ev = "Kafka",
  yq = Ne(
    ev,
    () =>
      new Nq.KafkaJsInstrumentation({
        consumerHook(e) {
          yt(e, "auto.kafkajs.otel.consumer");
        },
        producerHook(e) {
          yt(e, "auto.kafkajs.otel.producer");
        },
      }),
  ),
  Oq = () => ({
    name: ev,
    setupOnce() {
      yq();
    },
  }),
  Cq = Oq;
var jd = {},
  Ta = {},
  Ir = {},
  nN;
function bq() {
  return (
    nN ||
      ((nN = 1),
      Object.defineProperty(Ir, "__esModule", {
        value: !0,
      }),
      (Ir.PACKAGE_NAME = Ir.PACKAGE_VERSION = void 0),
      (Ir.PACKAGE_VERSION = "0.53.0"),
      (Ir.PACKAGE_NAME = "@opentelemetry/instrumentation-lru-memoizer")),
    Ir
  );
}
var rN;
function Iq() {
  if (rN) return Ta;
  ((rN = 1),
    Object.defineProperty(Ta, "__esModule", {
      value: !0,
    }),
    (Ta.LruMemoizerInstrumentation = void 0));
  const e = Pe(),
    t = Le,
    n = bq();
  class r extends t.InstrumentationBase {
    constructor(s = {}) {
      super(n.PACKAGE_NAME, n.PACKAGE_VERSION, s);
    }
    init() {
      return [
        new t.InstrumentationNodeModuleDefinition(
          "lru-memoizer",
          [">=1.3 <3"],
          (s) => {
            const i = function () {
              const a = s.apply(this, arguments);
              return function () {
                const c = [...arguments],
                  l = c.pop(),
                  f =
                    typeof l == "function"
                      ? e.context.bind(e.context.active(), l)
                      : l;
                return (c.push(f), a.apply(this, c));
              };
            };
            return ((i.sync = s.sync), i);
          },
          void 0,
        ),
      ];
    }
  }
  return ((Ta.LruMemoizerInstrumentation = r), Ta);
}
var oN;
function Pq() {
  return (
    oN ||
      ((oN = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.LruMemoizerInstrumentation = void 0));
        var t = Iq();
        Object.defineProperty(e, "LruMemoizerInstrumentation", {
          enumerable: !0,
          get: function () {
            return t.LruMemoizerInstrumentation;
          },
        });
      })(jd)),
    jd
  );
}
var Mq = Pq();
const tv = "LruMemoizer",
  vq = Ne(tv, () => new Mq.LruMemoizerInstrumentation()),
  Lq = () => ({
    name: tv,
    setupOnce() {
      vq();
    },
  }),
  Dq = Lq;
var qd = {},
  Sa = {},
  Be = {},
  sN;
function wq() {
  return (
    sN ||
      ((sN = 1),
      Object.defineProperty(Be, "__esModule", {
        value: !0,
      }),
      (Be.METRIC_DB_CLIENT_CONNECTIONS_USAGE =
        Be.DB_SYSTEM_VALUE_MONGODB =
        Be.ATTR_NET_PEER_PORT =
        Be.ATTR_NET_PEER_NAME =
        Be.ATTR_DB_SYSTEM =
        Be.ATTR_DB_STATEMENT =
        Be.ATTR_DB_OPERATION =
        Be.ATTR_DB_NAME =
        Be.ATTR_DB_MONGODB_COLLECTION =
        Be.ATTR_DB_CONNECTION_STRING =
          void 0),
      (Be.ATTR_DB_CONNECTION_STRING = "db.connection_string"),
      (Be.ATTR_DB_MONGODB_COLLECTION = "db.mongodb.collection"),
      (Be.ATTR_DB_NAME = "db.name"),
      (Be.ATTR_DB_OPERATION = "db.operation"),
      (Be.ATTR_DB_STATEMENT = "db.statement"),
      (Be.ATTR_DB_SYSTEM = "db.system"),
      (Be.ATTR_NET_PEER_NAME = "net.peer.name"),
      (Be.ATTR_NET_PEER_PORT = "net.peer.port"),
      (Be.DB_SYSTEM_VALUE_MONGODB = "mongodb"),
      (Be.METRIC_DB_CLIENT_CONNECTIONS_USAGE = "db.client.connections.usage")),
    Be
  );
}
var Wd = {},
  iN;
function Uq() {
  return (
    iN ||
      ((iN = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.MongodbCommandType = void 0),
          (function (t) {
            ((t.CREATE_INDEXES = "createIndexes"),
              (t.FIND_AND_MODIFY = "findAndModify"),
              (t.IS_MASTER = "isMaster"),
              (t.COUNT = "count"),
              (t.AGGREGATE = "aggregate"),
              (t.UNKNOWN = "unknown"));
          })(e.MongodbCommandType || (e.MongodbCommandType = {})));
      })(Wd)),
    Wd
  );
}
var Pr = {},
  aN;
function kq() {
  return (
    aN ||
      ((aN = 1),
      Object.defineProperty(Pr, "__esModule", {
        value: !0,
      }),
      (Pr.PACKAGE_NAME = Pr.PACKAGE_VERSION = void 0),
      (Pr.PACKAGE_VERSION = "0.61.0"),
      (Pr.PACKAGE_NAME = "@opentelemetry/instrumentation-mongodb")),
    Pr
  );
}
var cN;
function Gq() {
  if (cN) return Sa;
  ((cN = 1),
    Object.defineProperty(Sa, "__esModule", {
      value: !0,
    }),
    (Sa.MongoDBInstrumentation = void 0));
  const e = Pe(),
    t = Le,
    n = wq(),
    r = Uq(),
    o = kq(),
    s = {
      requireParentSpan: !0,
    };
  class i extends t.InstrumentationBase {
    constructor(c = {}) {
      super(o.PACKAGE_NAME, o.PACKAGE_VERSION, {
        ...s,
        ...c,
      });
    }
    setConfig(c = {}) {
      super.setConfig({
        ...s,
        ...c,
      });
    }
    _updateMetricInstruments() {
      this._connectionsUsage = this.meter.createUpDownCounter(
        n.METRIC_DB_CLIENT_CONNECTIONS_USAGE,
        {
          description:
            "The number of connections that are currently in state described by the state attribute.",
          unit: "{connection}",
        },
      );
    }
    init() {
      const { v3PatchConnection: c, v3UnpatchConnection: l } =
          this._getV3ConnectionPatches(),
        { v4PatchConnect: f, v4UnpatchConnect: d } =
          this._getV4ConnectPatches(),
        {
          v4PatchConnectionCallback: u,
          v4PatchConnectionPromise: _,
          v4UnpatchConnection: p,
        } = this._getV4ConnectionPatches(),
        { v4PatchConnectionPool: E, v4UnpatchConnectionPool: h } =
          this._getV4ConnectionPoolPatches(),
        { v4PatchSessions: T, v4UnpatchSessions: m } =
          this._getV4SessionsPatches();
      return [
        new t.InstrumentationNodeModuleDefinition(
          "mongodb",
          [">=3.3.0 <4"],
          void 0,
          void 0,
          [
            new t.InstrumentationNodeModuleFile(
              "mongodb/lib/core/wireprotocol/index.js",
              [">=3.3.0 <4"],
              c,
              l,
            ),
          ],
        ),
        new t.InstrumentationNodeModuleDefinition(
          "mongodb",
          [">=4.0.0 <7"],
          void 0,
          void 0,
          [
            new t.InstrumentationNodeModuleFile(
              "mongodb/lib/cmap/connection.js",
              [">=4.0.0 <6.4"],
              u,
              p,
            ),
            new t.InstrumentationNodeModuleFile(
              "mongodb/lib/cmap/connection.js",
              [">=6.4.0 <7"],
              _,
              p,
            ),
            new t.InstrumentationNodeModuleFile(
              "mongodb/lib/cmap/connection_pool.js",
              [">=4.0.0 <6.4"],
              E,
              h,
            ),
            new t.InstrumentationNodeModuleFile(
              "mongodb/lib/cmap/connect.js",
              [">=4.0.0 <7"],
              f,
              d,
            ),
            new t.InstrumentationNodeModuleFile(
              "mongodb/lib/sessions.js",
              [">=4.0.0 <7"],
              T,
              m,
            ),
          ],
        ),
      ];
    }
    _getV3ConnectionPatches() {
      return {
        v3PatchConnection: (c) => (
          (0, t.isWrapped)(c.insert) && this._unwrap(c, "insert"),
          this._wrap(c, "insert", this._getV3PatchOperation("insert")),
          (0, t.isWrapped)(c.remove) && this._unwrap(c, "remove"),
          this._wrap(c, "remove", this._getV3PatchOperation("remove")),
          (0, t.isWrapped)(c.update) && this._unwrap(c, "update"),
          this._wrap(c, "update", this._getV3PatchOperation("update")),
          (0, t.isWrapped)(c.command) && this._unwrap(c, "command"),
          this._wrap(c, "command", this._getV3PatchCommand()),
          (0, t.isWrapped)(c.query) && this._unwrap(c, "query"),
          this._wrap(c, "query", this._getV3PatchFind()),
          (0, t.isWrapped)(c.getMore) && this._unwrap(c, "getMore"),
          this._wrap(c, "getMore", this._getV3PatchCursor()),
          c
        ),
        v3UnpatchConnection: (c) => {
          c !== void 0 &&
            (this._unwrap(c, "insert"),
            this._unwrap(c, "remove"),
            this._unwrap(c, "update"),
            this._unwrap(c, "command"),
            this._unwrap(c, "query"),
            this._unwrap(c, "getMore"));
        },
      };
    }
    _getV4SessionsPatches() {
      return {
        v4PatchSessions: (c) => (
          (0, t.isWrapped)(c.acquire) && this._unwrap(c, "acquire"),
          this._wrap(
            c.ServerSessionPool.prototype,
            "acquire",
            this._getV4AcquireCommand(),
          ),
          (0, t.isWrapped)(c.release) && this._unwrap(c, "release"),
          this._wrap(
            c.ServerSessionPool.prototype,
            "release",
            this._getV4ReleaseCommand(),
          ),
          c
        ),
        v4UnpatchSessions: (c) => {
          c !== void 0 &&
            ((0, t.isWrapped)(c.acquire) && this._unwrap(c, "acquire"),
            (0, t.isWrapped)(c.release) && this._unwrap(c, "release"));
        },
      };
    }
    _getV4AcquireCommand() {
      const c = this;
      return (l) =>
        function () {
          const d = this.sessions.length,
            u = l.call(this),
            _ = this.sessions.length;
          return (
            d === _
              ? c._connectionsUsage.add(1, {
                  state: "used",
                  "pool.name": c._poolName,
                })
              : d - 1 === _ &&
                (c._connectionsUsage.add(-1, {
                  state: "idle",
                  "pool.name": c._poolName,
                }),
                c._connectionsUsage.add(1, {
                  state: "used",
                  "pool.name": c._poolName,
                })),
            u
          );
        };
    }
    _getV4ReleaseCommand() {
      const c = this;
      return (l) =>
        function (d) {
          const u = l.call(this, d);
          return (
            c._connectionsUsage.add(-1, {
              state: "used",
              "pool.name": c._poolName,
            }),
            c._connectionsUsage.add(1, {
              state: "idle",
              "pool.name": c._poolName,
            }),
            u
          );
        };
    }
    _getV4ConnectionPoolPatches() {
      return {
        v4PatchConnectionPool: (c) => {
          const l = c.ConnectionPool.prototype;
          return (
            (0, t.isWrapped)(l.checkOut) && this._unwrap(l, "checkOut"),
            this._wrap(l, "checkOut", this._getV4ConnectionPoolCheckOut()),
            c
          );
        },
        v4UnpatchConnectionPool: (c) => {
          c !== void 0 && this._unwrap(c.ConnectionPool.prototype, "checkOut");
        },
      };
    }
    _getV4ConnectPatches() {
      return {
        v4PatchConnect: (c) => (
          (0, t.isWrapped)(c.connect) && this._unwrap(c, "connect"),
          this._wrap(c, "connect", this._getV4ConnectCommand()),
          c
        ),
        v4UnpatchConnect: (c) => {
          c !== void 0 && this._unwrap(c, "connect");
        },
      };
    }
    _getV4ConnectionPoolCheckOut() {
      return (c) =>
        function (f) {
          const d = e.context.bind(e.context.active(), f);
          return c.call(this, d);
        };
    }
    _getV4ConnectCommand() {
      const c = this;
      return (l) =>
        function (d, u) {
          if (l.length === 1) {
            const p = l.call(this, d);
            return (
              p &&
                typeof p.then == "function" &&
                p.then(
                  () => c.setPoolName(d),
                  () => {},
                ),
              p
            );
          }
          const _ = function (p, E) {
            if (p || !E) {
              u(p, E);
              return;
            }
            (c.setPoolName(d), u(p, E));
          };
          return l.call(this, d, _);
        };
    }
    _getV4ConnectionPatches() {
      return {
        v4PatchConnectionCallback: (c) => (
          (0, t.isWrapped)(c.Connection.prototype.command) &&
            this._unwrap(c.Connection.prototype, "command"),
          this._wrap(
            c.Connection.prototype,
            "command",
            this._getV4PatchCommandCallback(),
          ),
          c
        ),
        v4PatchConnectionPromise: (c) => (
          (0, t.isWrapped)(c.Connection.prototype.command) &&
            this._unwrap(c.Connection.prototype, "command"),
          this._wrap(
            c.Connection.prototype,
            "command",
            this._getV4PatchCommandPromise(),
          ),
          c
        ),
        v4UnpatchConnection: (c) => {
          c !== void 0 && this._unwrap(c.Connection.prototype, "command");
        },
      };
    }
    _getV3PatchOperation(c) {
      const l = this;
      return (f) =>
        function (u, _, p, E, h) {
          const T = e.trace.getSpan(e.context.active()),
            m = l._checkSkipInstrumentation(T),
            A = typeof E == "function" ? E : h;
          if (m || typeof A != "function" || typeof p != "object")
            return typeof E == "function"
              ? f.call(this, u, _, p, E)
              : f.call(this, u, _, p, E, h);
          const g = l.tracer.startSpan(`mongodb.${c}`, {
            kind: e.SpanKind.CLIENT,
          });
          l._populateV3Attributes(g, _, u, p[0], c);
          const N = l._patchEnd(g, A);
          return typeof E == "function"
            ? f.call(this, u, _, p, N)
            : f.call(this, u, _, p, E, N);
        };
    }
    _getV3PatchCommand() {
      const c = this;
      return (l) =>
        function (d, u, _, p, E) {
          const h = e.trace.getSpan(e.context.active()),
            T = c._checkSkipInstrumentation(h),
            m = typeof p == "function" ? p : E;
          if (T || typeof m != "function" || typeof _ != "object")
            return typeof p == "function"
              ? l.call(this, d, u, _, p)
              : l.call(this, d, u, _, p, E);
          const A = i._getCommandType(_),
            g = A === r.MongodbCommandType.UNKNOWN ? "command" : A,
            N = c.tracer.startSpan(`mongodb.${g}`, {
              kind: e.SpanKind.CLIENT,
            }),
            O = A === r.MongodbCommandType.UNKNOWN ? void 0 : A;
          c._populateV3Attributes(N, u, d, _, O);
          const I = c._patchEnd(N, m);
          return typeof p == "function"
            ? l.call(this, d, u, _, I)
            : l.call(this, d, u, _, p, I);
        };
    }
    _getV4PatchCommandCallback() {
      const c = this;
      return (l) =>
        function (d, u, _, p) {
          const E = e.trace.getSpan(e.context.active()),
            h = c._checkSkipInstrumentation(E),
            T = p,
            m = Object.keys(u)[0];
          if (typeof u != "object" || u.ismaster || u.hello)
            return l.call(this, d, u, _, p);
          let A;
          h ||
            ((A = c.tracer.startSpan(`mongodb.${m}`, {
              kind: e.SpanKind.CLIENT,
            })),
            c._populateV4Attributes(A, this, d, u, m));
          const g = c._patchEnd(A, T, this.id, m);
          return l.call(this, d, u, _, g);
        };
    }
    _getV4PatchCommandPromise() {
      const c = this;
      return (l) =>
        function (...d) {
          const [u, _] = d,
            p = e.trace.getSpan(e.context.active()),
            E = c._checkSkipInstrumentation(p),
            h = Object.keys(_)[0],
            T = () => {};
          if (typeof _ != "object" || _.ismaster || _.hello)
            return l.apply(this, d);
          let m;
          E ||
            ((m = c.tracer.startSpan(`mongodb.${h}`, {
              kind: e.SpanKind.CLIENT,
            })),
            c._populateV4Attributes(m, this, u, _, h));
          const A = c._patchEnd(m, T, this.id, h),
            g = l.apply(this, d);
          return (
            g.then(
              (N) => A(null, N),
              (N) => A(N),
            ),
            g
          );
        };
    }
    _getV3PatchFind() {
      const c = this;
      return (l) =>
        function (d, u, _, p, E, h) {
          const T = e.trace.getSpan(e.context.active()),
            m = c._checkSkipInstrumentation(T),
            A = typeof E == "function" ? E : h;
          if (m || typeof A != "function" || typeof _ != "object")
            return typeof E == "function"
              ? l.call(this, d, u, _, p, E)
              : l.call(this, d, u, _, p, E, h);
          const g = c.tracer.startSpan("mongodb.find", {
            kind: e.SpanKind.CLIENT,
          });
          c._populateV3Attributes(g, u, d, _, "find");
          const N = c._patchEnd(g, A);
          return typeof E == "function"
            ? l.call(this, d, u, _, p, N)
            : l.call(this, d, u, _, p, E, N);
        };
    }
    _getV3PatchCursor() {
      const c = this;
      return (l) =>
        function (d, u, _, p, E, h) {
          const T = e.trace.getSpan(e.context.active()),
            m = c._checkSkipInstrumentation(T),
            A = typeof E == "function" ? E : h;
          if (m || typeof A != "function")
            return typeof E == "function"
              ? l.call(this, d, u, _, p, E)
              : l.call(this, d, u, _, p, E, h);
          const g = c.tracer.startSpan("mongodb.getMore", {
            kind: e.SpanKind.CLIENT,
          });
          c._populateV3Attributes(g, u, d, _.cmd, "getMore");
          const N = c._patchEnd(g, A);
          return typeof E == "function"
            ? l.call(this, d, u, _, p, N)
            : l.call(this, d, u, _, p, E, N);
        };
    }
    static _getCommandType(c) {
      return c.createIndexes !== void 0
        ? r.MongodbCommandType.CREATE_INDEXES
        : c.findandmodify !== void 0
          ? r.MongodbCommandType.FIND_AND_MODIFY
          : c.ismaster !== void 0
            ? r.MongodbCommandType.IS_MASTER
            : c.count !== void 0
              ? r.MongodbCommandType.COUNT
              : c.aggregate !== void 0
                ? r.MongodbCommandType.AGGREGATE
                : r.MongodbCommandType.UNKNOWN;
    }
    _populateV4Attributes(c, l, f, d, u) {
      let _, p;
      if (l) {
        const h = typeof l.address == "string" ? l.address.split(":") : "";
        h.length === 2 && ((_ = h[0]), (p = h[1]));
      }
      let E;
      (d?.documents && d.documents[0]
        ? (E = d.documents[0])
        : d?.cursors
          ? (E = d.cursors)
          : (E = d),
        this._addAllSpanAttributes(c, f.db, f.collection, _, p, E, u));
    }
    _populateV3Attributes(c, l, f, d, u) {
      let _, p;
      if (
        f &&
        f.s &&
        ((_ = f.s.options?.host ?? f.s.host),
        (p = (f.s.options?.port ?? f.s.port)?.toString()),
        _ == null || p == null)
      ) {
        const m = f.description?.address;
        if (m) {
          const A = m.split(":");
          ((_ = A[0]), (p = A[1]));
        }
      }
      const [E, h] = l.toString().split("."),
        T = d?.query ?? d?.q ?? d;
      this._addAllSpanAttributes(c, E, h, _, p, T, u);
    }
    _addAllSpanAttributes(c, l, f, d, u, _, p) {
      if (
        (c.setAttributes({
          [n.ATTR_DB_SYSTEM]: n.DB_SYSTEM_VALUE_MONGODB,
          [n.ATTR_DB_NAME]: l,
          [n.ATTR_DB_MONGODB_COLLECTION]: f,
          [n.ATTR_DB_OPERATION]: p,
          [n.ATTR_DB_CONNECTION_STRING]: `mongodb://${d}:${u}/${l}`,
        }),
        d && u)
      ) {
        c.setAttribute(n.ATTR_NET_PEER_NAME, d);
        const T = parseInt(u, 10);
        isNaN(T) || c.setAttribute(n.ATTR_NET_PEER_PORT, T);
      }
      if (!_) return;
      const { dbStatementSerializer: E } = this.getConfig(),
        h =
          typeof E == "function"
            ? E
            : this._defaultDbStatementSerializer.bind(this);
      (0, t.safeExecuteInTheMiddle)(
        () => {
          const T = h(_);
          c.setAttribute(n.ATTR_DB_STATEMENT, T);
        },
        (T) => {
          T && this._diag.error("Error running dbStatementSerializer hook", T);
        },
        !0,
      );
    }
    _getDefaultDbStatementReplacer() {
      const c = new WeakSet();
      return (l, f) =>
        typeof f != "object" || !f
          ? "?"
          : c.has(f)
            ? "[Circular]"
            : (c.add(f), f);
    }
    _defaultDbStatementSerializer(c) {
      const { enhancedDatabaseReporting: l } = this.getConfig();
      return l
        ? JSON.stringify(c)
        : JSON.stringify(c, this._getDefaultDbStatementReplacer());
    }
    _handleExecutionResult(c, l) {
      const { responseHook: f } = this.getConfig();
      typeof f == "function" &&
        (0, t.safeExecuteInTheMiddle)(
          () => {
            f(c, {
              data: l,
            });
          },
          (d) => {
            d && this._diag.error("Error running response hook", d);
          },
          !0,
        );
    }
    _patchEnd(c, l, f, d) {
      const u = e.context.active(),
        _ = this;
      return function (...E) {
        const h = E[0];
        if (c) {
          if (h instanceof Error)
            c?.setStatus({
              code: e.SpanStatusCode.ERROR,
              message: h.message,
            });
          else {
            const T = E[1];
            _._handleExecutionResult(c, T);
          }
          c.end();
        }
        return e.context.with(
          u,
          () => (
            d === "endSessions" &&
              _._connectionsUsage.add(-1, {
                state: "idle",
                "pool.name": _._poolName,
              }),
            l.apply(this, E)
          ),
        );
      };
    }
    setPoolName(c) {
      const l = c.hostAddress?.host,
        f = c.hostAddress?.port,
        d = c.dbName,
        u = `mongodb://${l}:${f}/${d}`;
      this._poolName = u;
    }
    _checkSkipInstrumentation(c) {
      return this.getConfig().requireParentSpan === !0 && c === void 0;
    }
  }
  return ((Sa.MongoDBInstrumentation = i), Sa);
}
var Kd = {},
  uN;
function Vq() {
  return (
    uN ||
      ((uN = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.MongodbCommandType = void 0),
          (function (t) {
            ((t.CREATE_INDEXES = "createIndexes"),
              (t.FIND_AND_MODIFY = "findAndModify"),
              (t.IS_MASTER = "isMaster"),
              (t.COUNT = "count"),
              (t.UNKNOWN = "unknown"));
          })(e.MongodbCommandType || (e.MongodbCommandType = {})));
      })(Kd)),
    Kd
  );
}
var lN;
function xq() {
  return (
    lN ||
      ((lN = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.MongodbCommandType = e.MongoDBInstrumentation = void 0));
        var t = Gq();
        Object.defineProperty(e, "MongoDBInstrumentation", {
          enumerable: !0,
          get: function () {
            return t.MongoDBInstrumentation;
          },
        });
        var n = Vq();
        Object.defineProperty(e, "MongodbCommandType", {
          enumerable: !0,
          get: function () {
            return n.MongodbCommandType;
          },
        });
      })(qd)),
    qd
  );
}
var $q = xq();
const nv = "Mongo",
  Bq = Ne(
    nv,
    () =>
      new $q.MongoDBInstrumentation({
        dbStatementSerializer: Hq,
        responseHook(e) {
          yt(e, "auto.db.otel.mongo");
        },
      }),
  );
function Hq(e) {
  const t = Dp(e);
  return JSON.stringify(t);
}
function Dp(e) {
  if (Array.isArray(e)) return e.map((t) => Dp(t));
  if (Fq(e)) {
    const t = {};
    return Object.entries(e)
      .map(([n, r]) => [n, Dp(r)])
      .reduce((n, r) => (jq(r) && (n[r[0]] = r[1]), n), t);
  }
  return "?";
}
function Fq(e) {
  return typeof e == "object" && e !== null && !Yq(e);
}
function Yq(e) {
  let t = !1;
  return (typeof Buffer < "u" && (t = Buffer.isBuffer(e)), t);
}
function jq(e) {
  return Array.isArray(e);
}
const qq = () => ({
    name: nv,
    setupOnce() {
      Bq();
    },
  }),
  Wq = qq;
var zd = {},
  Zd = {},
  bn = {},
  Qe = {},
  dN;
function rv() {
  return (
    dN ||
      ((dN = 1),
      Object.defineProperty(Qe, "__esModule", {
        value: !0,
      }),
      (Qe.ATTR_NET_PEER_PORT =
        Qe.ATTR_NET_PEER_NAME =
        Qe.ATTR_DB_USER =
        Qe.ATTR_DB_SYSTEM =
        Qe.ATTR_DB_STATEMENT =
        Qe.ATTR_DB_OPERATION =
        Qe.ATTR_DB_NAME =
        Qe.ATTR_DB_MONGODB_COLLECTION =
          void 0),
      (Qe.ATTR_DB_MONGODB_COLLECTION = "db.mongodb.collection"),
      (Qe.ATTR_DB_NAME = "db.name"),
      (Qe.ATTR_DB_OPERATION = "db.operation"),
      (Qe.ATTR_DB_STATEMENT = "db.statement"),
      (Qe.ATTR_DB_SYSTEM = "db.system"),
      (Qe.ATTR_DB_USER = "db.user"),
      (Qe.ATTR_NET_PEER_NAME = "net.peer.name"),
      (Qe.ATTR_NET_PEER_PORT = "net.peer.port")),
    Qe
  );
}
var fN;
function Kq() {
  if (fN) return bn;
  ((fN = 1),
    Object.defineProperty(bn, "__esModule", {
      value: !0,
    }),
    (bn.handleCallbackResponse =
      bn.handlePromiseResponse =
      bn.getAttributesFromCollection =
        void 0));
  const e = Pe(),
    t = Le,
    n = rv();
  function r(c) {
    return {
      [n.ATTR_DB_MONGODB_COLLECTION]: c.name,
      [n.ATTR_DB_NAME]: c.conn.name,
      [n.ATTR_DB_USER]: c.conn.user,
      [n.ATTR_NET_PEER_NAME]: c.conn.host,
      [n.ATTR_NET_PEER_PORT]: c.conn.port,
    };
  }
  bn.getAttributesFromCollection = r;
  function o(c, l = {}) {
    (c.recordException(l),
      c.setStatus({
        code: e.SpanStatusCode.ERROR,
        message: `${l.message} ${
          l.code
            ? `
Mongoose Error Code: ${l.code}`
            : ""
        }`,
      }));
  }
  function s(c, l, f, d = void 0) {
    f &&
      (0, t.safeExecuteInTheMiddle)(
        () =>
          f(c, {
            moduleVersion: d,
            response: l,
          }),
        (u) => {
          u && e.diag.error("mongoose instrumentation: responseHook error", u);
        },
        !0,
      );
  }
  function i(c, l, f, d = void 0) {
    return c instanceof Promise
      ? c
          .then((u) => (s(l, u, f, d), u))
          .catch((u) => {
            throw (o(l, u), u);
          })
          .finally(() => l.end())
      : (s(l, c, f, d), l.end(), c);
  }
  bn.handlePromiseResponse = i;
  function a(c, l, f, d, u, _, p = void 0) {
    let E = 0;
    return (
      u.length === 2 ? (E = 1) : u.length === 3 && (E = 2),
      (u[E] = (h, T) => (h ? o(d, h) : s(d, T, _, p), d.end(), c(h, T))),
      l.apply(f, u)
    );
  }
  return ((bn.handleCallbackResponse = a), bn);
}
var Mr = {},
  _N;
function zq() {
  return (
    _N ||
      ((_N = 1),
      Object.defineProperty(Mr, "__esModule", {
        value: !0,
      }),
      (Mr.PACKAGE_NAME = Mr.PACKAGE_VERSION = void 0),
      (Mr.PACKAGE_VERSION = "0.55.0"),
      (Mr.PACKAGE_NAME = "@opentelemetry/instrumentation-mongoose")),
    Mr
  );
}
var pN;
function Zq() {
  return (
    pN ||
      ((pN = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.MongooseInstrumentation = e._STORED_PARENT_SPAN = void 0));
        const t = Pe(),
          n = un,
          r = Kq(),
          o = Le,
          s = zq(),
          i = rv(),
          a = [
            "deleteOne",
            "deleteMany",
            "find",
            "findOne",
            "estimatedDocumentCount",
            "countDocuments",
            "distinct",
            "where",
            "$where",
            "findOneAndUpdate",
            "findOneAndDelete",
            "findOneAndReplace",
          ],
          c = ["remove", "count", "findOneAndRemove", ...a],
          l = ["count", "findOneAndRemove", ...a],
          f = [...a];
        function d(p) {
          return p
            ? p.startsWith("6.") || p.startsWith("5.")
              ? c
              : p.startsWith("7.")
                ? l
                : f
            : a;
        }
        function u(p) {
          return (p && (p.startsWith("5.") || p.startsWith("6."))) || !1;
        }
        e._STORED_PARENT_SPAN = Symbol("stored-parent-span");
        class _ extends o.InstrumentationBase {
          constructor(E = {}) {
            super(s.PACKAGE_NAME, s.PACKAGE_VERSION, E);
          }
          init() {
            return new o.InstrumentationNodeModuleDefinition(
              "mongoose",
              [">=5.9.7 <9"],
              this.patch.bind(this),
              this.unpatch.bind(this),
            );
          }
          patch(E, h) {
            const T = E[Symbol.toStringTag] === "Module" ? E.default : E;
            return (
              this._wrap(
                T.Model.prototype,
                "save",
                this.patchOnModelMethods("save", h),
              ),
              (T.Model.prototype.$save = T.Model.prototype.save),
              u(h) &&
                this._wrap(
                  T.Model.prototype,
                  "remove",
                  this.patchOnModelMethods("remove", h),
                ),
              this._wrap(T.Query.prototype, "exec", this.patchQueryExec(h)),
              this._wrap(
                T.Aggregate.prototype,
                "exec",
                this.patchAggregateExec(h),
              ),
              d(h).forEach((A) => {
                this._wrap(
                  T.Query.prototype,
                  A,
                  this.patchAndCaptureSpanContext(A),
                );
              }),
              this._wrap(T.Model, "aggregate", this.patchModelAggregate()),
              this._wrap(
                T.Model,
                "insertMany",
                this.patchModelStatic("insertMany", h),
              ),
              this._wrap(
                T.Model,
                "bulkWrite",
                this.patchModelStatic("bulkWrite", h),
              ),
              T
            );
          }
          unpatch(E, h) {
            const T = E[Symbol.toStringTag] === "Module" ? E.default : E,
              m = d(h);
            (this._unwrap(T.Model.prototype, "save"),
              (T.Model.prototype.$save = T.Model.prototype.save),
              u(h) && this._unwrap(T.Model.prototype, "remove"),
              this._unwrap(T.Query.prototype, "exec"),
              this._unwrap(T.Aggregate.prototype, "exec"),
              m.forEach((A) => {
                this._unwrap(T.Query.prototype, A);
              }),
              this._unwrap(T.Model, "aggregate"),
              this._unwrap(T.Model, "insertMany"),
              this._unwrap(T.Model, "bulkWrite"));
          }
          patchAggregateExec(E) {
            const h = this;
            return (T) =>
              function (A) {
                if (
                  h.getConfig().requireParentSpan &&
                  t.trace.getSpan(t.context.active()) === void 0
                )
                  return T.apply(this, arguments);
                const g = this[e._STORED_PARENT_SPAN],
                  N = {},
                  { dbStatementSerializer: O } = h.getConfig();
                O &&
                  (N[i.ATTR_DB_STATEMENT] = O("aggregate", {
                    options: this.options,
                    aggregatePipeline: this._pipeline,
                  }));
                const I = h._startSpan(
                  this._model.collection,
                  this._model?.modelName,
                  "aggregate",
                  N,
                  g,
                );
                return h._handleResponse(I, T, this, arguments, A, E);
              };
          }
          patchQueryExec(E) {
            const h = this;
            return (T) =>
              function (A) {
                if (
                  h.getConfig().requireParentSpan &&
                  t.trace.getSpan(t.context.active()) === void 0
                )
                  return T.apply(this, arguments);
                const g = this[e._STORED_PARENT_SPAN],
                  N = {},
                  { dbStatementSerializer: O } = h.getConfig();
                O &&
                  (N[i.ATTR_DB_STATEMENT] = O(this.op, {
                    condition: this._conditions,
                    updates: this._update,
                    options: this.options,
                    fields: this._fields,
                  }));
                const I = h._startSpan(
                  this.mongooseCollection,
                  this.model.modelName,
                  this.op,
                  N,
                  g,
                );
                return h._handleResponse(I, T, this, arguments, A, E);
              };
          }
          patchOnModelMethods(E, h) {
            const T = this;
            return (m) =>
              function (g, N) {
                if (
                  T.getConfig().requireParentSpan &&
                  t.trace.getSpan(t.context.active()) === void 0
                )
                  return m.apply(this, arguments);
                const O = {
                  document: this,
                };
                g && !(g instanceof Function) && (O.options = g);
                const I = {},
                  { dbStatementSerializer: b } = T.getConfig();
                b && (I[i.ATTR_DB_STATEMENT] = b(E, O));
                const w = T._startSpan(
                  this.constructor.collection,
                  this.constructor.modelName,
                  E,
                  I,
                );
                return (
                  g instanceof Function && ((N = g), (g = void 0)),
                  T._handleResponse(w, m, this, arguments, N, h)
                );
              };
          }
          patchModelStatic(E, h) {
            const T = this;
            return (m) =>
              function (g, N, O) {
                if (
                  T.getConfig().requireParentSpan &&
                  t.trace.getSpan(t.context.active()) === void 0
                )
                  return m.apply(this, arguments);
                typeof N == "function" && ((O = N), (N = void 0));
                const I = {};
                switch (E) {
                  case "insertMany":
                    I.documents = g;
                    break;
                  case "bulkWrite":
                    I.operations = g;
                    break;
                  default:
                    I.document = g;
                    break;
                }
                N !== void 0 && (I.options = N);
                const b = {},
                  { dbStatementSerializer: w } = T.getConfig();
                w && (b[i.ATTR_DB_STATEMENT] = w(E, I));
                const L = T._startSpan(this.collection, this.modelName, E, b);
                return T._handleResponse(L, m, this, arguments, O, h);
              };
          }
          patchModelAggregate() {
            const E = this;
            return (h) =>
              function () {
                const m = t.trace.getSpan(t.context.active()),
                  A = E._callOriginalFunction(() => h.apply(this, arguments));
                return (A && (A[e._STORED_PARENT_SPAN] = m), A);
              };
          }
          patchAndCaptureSpanContext(E) {
            const h = this;
            return (T) =>
              function () {
                return (
                  (this[e._STORED_PARENT_SPAN] = t.trace.getSpan(
                    t.context.active(),
                  )),
                  h._callOriginalFunction(() => T.apply(this, arguments))
                );
              };
          }
          _startSpan(E, h, T, m, A) {
            return this.tracer.startSpan(
              `mongoose.${h}.${T}`,
              {
                kind: t.SpanKind.CLIENT,
                attributes: {
                  ...m,
                  ...(0, r.getAttributesFromCollection)(E),
                  [i.ATTR_DB_OPERATION]: T,
                  [i.ATTR_DB_SYSTEM]: "mongoose",
                },
              },
              A ? t.trace.setSpan(t.context.active(), A) : void 0,
            );
          }
          _handleResponse(E, h, T, m, A, g = void 0) {
            const N = this;
            if (A instanceof Function)
              return N._callOriginalFunction(() =>
                (0, r.handleCallbackResponse)(
                  A,
                  h,
                  T,
                  E,
                  m,
                  N.getConfig().responseHook,
                  g,
                ),
              );
            {
              const O = N._callOriginalFunction(() => h.apply(T, m));
              return (0, r.handlePromiseResponse)(
                O,
                E,
                N.getConfig().responseHook,
                g,
              );
            }
          }
          _callOriginalFunction(E) {
            return this.getConfig().suppressInternalInstrumentation
              ? t.context.with((0, n.suppressTracing)(t.context.active()), E)
              : E();
          }
        }
        e.MongooseInstrumentation = _;
      })(Zd)),
    Zd
  );
}
var EN;
function Xq() {
  return (
    EN ||
      ((EN = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.MongooseInstrumentation = void 0));
        var t = Zq();
        Object.defineProperty(e, "MongooseInstrumentation", {
          enumerable: !0,
          get: function () {
            return t.MongooseInstrumentation;
          },
        });
      })(zd)),
    zd
  );
}
var Qq = Xq();
const ov = "Mongoose",
  Jq = Ne(
    ov,
    () =>
      new Qq.MongooseInstrumentation({
        responseHook(e) {
          yt(e, "auto.db.otel.mongoose");
        },
      }),
  ),
  eW = () => ({
    name: ov,
    setupOnce() {
      Jq();
    },
  }),
  tW = eW;
var Xd = {},
  ma = {},
  We = {},
  hN;
function sv() {
  return (
    hN ||
      ((hN = 1),
      Object.defineProperty(We, "__esModule", {
        value: !0,
      }),
      (We.METRIC_DB_CLIENT_CONNECTIONS_USAGE =
        We.DB_SYSTEM_VALUE_MYSQL =
        We.ATTR_NET_PEER_PORT =
        We.ATTR_NET_PEER_NAME =
        We.ATTR_DB_USER =
        We.ATTR_DB_SYSTEM =
        We.ATTR_DB_STATEMENT =
        We.ATTR_DB_NAME =
        We.ATTR_DB_CONNECTION_STRING =
          void 0),
      (We.ATTR_DB_CONNECTION_STRING = "db.connection_string"),
      (We.ATTR_DB_NAME = "db.name"),
      (We.ATTR_DB_STATEMENT = "db.statement"),
      (We.ATTR_DB_SYSTEM = "db.system"),
      (We.ATTR_DB_USER = "db.user"),
      (We.ATTR_NET_PEER_NAME = "net.peer.name"),
      (We.ATTR_NET_PEER_PORT = "net.peer.port"),
      (We.DB_SYSTEM_VALUE_MYSQL = "mysql"),
      (We.METRIC_DB_CLIENT_CONNECTIONS_USAGE = "db.client.connections.usage")),
    We
  );
}
var Qd = {},
  TN;
function nW() {
  return (
    TN ||
      ((TN = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.AttributeNames = void 0),
          (function (t) {
            t.MYSQL_VALUES = "db.mysql.values";
          })(e.AttributeNames || (e.AttributeNames = {})));
      })(Qd)),
    Qd
  );
}
var Tt = {},
  SN;
function rW() {
  if (SN) return Tt;
  ((SN = 1),
    Object.defineProperty(Tt, "__esModule", {
      value: !0,
    }),
    (Tt.getPoolName =
      Tt.arrayStringifyHelper =
      Tt.getSpanName =
      Tt.getDbValues =
      Tt.getDbStatement =
      Tt.getConnectionAttributes =
        void 0));
  const e = sv();
  function t(l) {
    const { host: f, port: d, database: u, user: _ } = n(l),
      p = parseInt(d, 10);
    return isNaN(p)
      ? {
          [e.ATTR_NET_PEER_NAME]: f,
          [e.ATTR_DB_CONNECTION_STRING]: r(f, d, u),
          [e.ATTR_DB_NAME]: u,
          [e.ATTR_DB_USER]: _,
        }
      : {
          [e.ATTR_NET_PEER_NAME]: f,
          [e.ATTR_NET_PEER_PORT]: p,
          [e.ATTR_DB_CONNECTION_STRING]: r(f, d, u),
          [e.ATTR_DB_NAME]: u,
          [e.ATTR_DB_USER]: _,
        };
  }
  Tt.getConnectionAttributes = t;
  function n(l) {
    const {
      host: f,
      port: d,
      database: u,
      user: _,
    } = (l && l.connectionConfig) || l || {};
    return {
      host: f,
      port: d,
      database: u,
      user: _,
    };
  }
  function r(l, f, d) {
    let u = `jdbc:mysql://${l || "localhost"}`;
    return (
      typeof f == "number" && (u += `:${f}`),
      typeof d == "string" && (u += `/${d}`),
      u
    );
  }
  function o(l) {
    return typeof l == "string" ? l : l.sql;
  }
  Tt.getDbStatement = o;
  function s(l, f) {
    return a(typeof l == "string" ? f : f || l.values);
  }
  Tt.getDbValues = s;
  function i(l) {
    const f = typeof l == "object" ? l.sql : l,
      d = f?.indexOf(" ");
    return typeof d == "number" && d !== -1 ? f?.substring(0, d) : f;
  }
  Tt.getSpanName = i;
  function a(l) {
    return l ? `[${l.toString()}]` : "";
  }
  Tt.arrayStringifyHelper = a;
  function c(l) {
    const f = l.config.connectionConfig;
    let d = "";
    return (
      (d += f.host ? `host: '${f.host}', ` : ""),
      (d += f.port ? `port: ${f.port}, ` : ""),
      (d += f.database ? `database: '${f.database}', ` : ""),
      (d += f.user ? `user: '${f.user}'` : ""),
      f.user || (d = d.substring(0, d.length - 2)),
      d.trim()
    );
  }
  return ((Tt.getPoolName = c), Tt);
}
var vr = {},
  mN;
function oW() {
  return (
    mN ||
      ((mN = 1),
      Object.defineProperty(vr, "__esModule", {
        value: !0,
      }),
      (vr.PACKAGE_NAME = vr.PACKAGE_VERSION = void 0),
      (vr.PACKAGE_VERSION = "0.54.0"),
      (vr.PACKAGE_NAME = "@opentelemetry/instrumentation-mysql")),
    vr
  );
}
var AN;
function sW() {
  if (AN) return ma;
  ((AN = 1),
    Object.defineProperty(ma, "__esModule", {
      value: !0,
    }),
    (ma.MySQLInstrumentation = void 0));
  const e = Pe(),
    t = Le,
    n = sv(),
    r = nW(),
    o = rW(),
    s = oW();
  class i extends t.InstrumentationBase {
    static COMMON_ATTRIBUTES = {
      [n.ATTR_DB_SYSTEM]: n.DB_SYSTEM_VALUE_MYSQL,
    };
    constructor(c = {}) {
      super(s.PACKAGE_NAME, s.PACKAGE_VERSION, c);
    }
    _updateMetricInstruments() {
      this._connectionsUsage = this.meter.createUpDownCounter(
        n.METRIC_DB_CLIENT_CONNECTIONS_USAGE,
        {
          description:
            "The number of connections that are currently in state described by the state attribute.",
          unit: "{connection}",
        },
      );
    }
    init() {
      return [
        new t.InstrumentationNodeModuleDefinition(
          "mysql",
          [">=2.0.0 <3"],
          (c) => (
            (0, t.isWrapped)(c.createConnection) &&
              this._unwrap(c, "createConnection"),
            this._wrap(c, "createConnection", this._patchCreateConnection()),
            (0, t.isWrapped)(c.createPool) && this._unwrap(c, "createPool"),
            this._wrap(c, "createPool", this._patchCreatePool()),
            (0, t.isWrapped)(c.createPoolCluster) &&
              this._unwrap(c, "createPoolCluster"),
            this._wrap(c, "createPoolCluster", this._patchCreatePoolCluster()),
            c
          ),
          (c) => {
            c !== void 0 &&
              (this._unwrap(c, "createConnection"),
              this._unwrap(c, "createPool"),
              this._unwrap(c, "createPoolCluster"));
          },
        ),
      ];
    }
    _patchCreateConnection() {
      return (c) => {
        const l = this;
        return function (d) {
          const u = c(...arguments);
          return (l._wrap(u, "query", l._patchQuery(u)), u);
        };
      };
    }
    _patchCreatePool() {
      return (c) => {
        const l = this;
        return function (d) {
          const u = c(...arguments);
          return (
            l._wrap(u, "query", l._patchQuery(u)),
            l._wrap(u, "getConnection", l._patchGetConnection(u)),
            l._wrap(u, "end", l._patchPoolEnd(u)),
            l._setPoolcallbacks(u, l, ""),
            u
          );
        };
      };
    }
    _patchPoolEnd(c) {
      return (l) => {
        const f = this;
        return function (u) {
          const _ = c._allConnections.length,
            p = c._freeConnections.length,
            E = _ - p,
            h = (0, o.getPoolName)(c);
          (f._connectionsUsage.add(-E, {
            state: "used",
            name: h,
          }),
            f._connectionsUsage.add(-p, {
              state: "idle",
              name: h,
            }),
            l.apply(c, arguments));
        };
      };
    }
    _patchCreatePoolCluster() {
      return (c) => {
        const l = this;
        return function (d) {
          const u = c(...arguments);
          return (
            l._wrap(u, "getConnection", l._patchGetConnection(u)),
            l._wrap(u, "add", l._patchAdd(u)),
            u
          );
        };
      };
    }
    _patchAdd(c) {
      return (l) => {
        const f = this;
        return function (u, _) {
          if (!f._enabled) return (f._unwrap(c, "add"), l.apply(c, arguments));
          l.apply(c, arguments);
          const p = c._nodes;
          if (p) {
            const E =
                typeof u == "object" ? "CLUSTER::" + c._lastId : String(u),
              h = p[E].pool;
            f._setPoolcallbacks(h, f, u);
          }
        };
      };
    }
    _patchGetConnection(c) {
      return (l) => {
        const f = this;
        return function (u, _, p) {
          if (!f._enabled)
            return (f._unwrap(c, "getConnection"), l.apply(c, arguments));
          if (arguments.length === 1 && typeof u == "function") {
            const E = f._getConnectionCallbackPatchFn(u);
            return l.call(c, E);
          }
          if (arguments.length === 2 && typeof _ == "function") {
            const E = f._getConnectionCallbackPatchFn(_);
            return l.call(c, u, E);
          }
          if (arguments.length === 3 && typeof p == "function") {
            const E = f._getConnectionCallbackPatchFn(p);
            return l.call(c, u, _, E);
          }
          return l.apply(c, arguments);
        };
      };
    }
    _getConnectionCallbackPatchFn(c) {
      const l = this,
        f = e.context.active();
      return function (d, u) {
        (u &&
          ((0, t.isWrapped)(u.query) || l._wrap(u, "query", l._patchQuery(u))),
          typeof c == "function" && e.context.with(f, c, this, d, u));
      };
    }
    _patchQuery(c) {
      return (l) => {
        const f = this;
        return function (d, u, _) {
          if (!f._enabled)
            return (f._unwrap(c, "query"), l.apply(c, arguments));
          const p = f.tracer.startSpan((0, o.getSpanName)(d), {
            kind: e.SpanKind.CLIENT,
            attributes: {
              ...i.COMMON_ATTRIBUTES,
              ...(0, o.getConnectionAttributes)(c.config),
            },
          });
          if (
            (p.setAttribute(n.ATTR_DB_STATEMENT, (0, o.getDbStatement)(d)),
            f.getConfig().enhancedDatabaseReporting)
          ) {
            let T;
            (Array.isArray(u) ? (T = u) : arguments[2] && (T = [u]),
              p.setAttribute(
                r.AttributeNames.MYSQL_VALUES,
                (0, o.getDbValues)(d, T),
              ));
          }
          const E = Array.from(arguments).findIndex(
              (T) => typeof T == "function",
            ),
            h = e.context.active();
          if (E === -1) {
            const T = e.context.with(
              e.trace.setSpan(e.context.active(), p),
              () => l.apply(c, arguments),
            );
            return (
              e.context.bind(h, T),
              T.on("error", (m) =>
                p.setStatus({
                  code: e.SpanStatusCode.ERROR,
                  message: m.message,
                }),
              ).on("end", () => {
                p.end();
              })
            );
          } else
            return (
              f._wrap(arguments, E, f._patchCallbackQuery(p, h)),
              e.context.with(e.trace.setSpan(e.context.active(), p), () =>
                l.apply(c, arguments),
              )
            );
        };
      };
    }
    _patchCallbackQuery(c, l) {
      return (f) =>
        function (d, u, _) {
          return (
            d &&
              c.setStatus({
                code: e.SpanStatusCode.ERROR,
                message: d.message,
              }),
            c.end(),
            e.context.with(l, () => f(...arguments))
          );
        };
    }
    _setPoolcallbacks(c, l, f) {
      const d = f || (0, o.getPoolName)(c);
      (c.on("connection", (u) => {
        l._connectionsUsage.add(1, {
          state: "idle",
          name: d,
        });
      }),
        c.on("acquire", (u) => {
          (l._connectionsUsage.add(-1, {
            state: "idle",
            name: d,
          }),
            l._connectionsUsage.add(1, {
              state: "used",
              name: d,
            }));
        }),
        c.on("release", (u) => {
          (l._connectionsUsage.add(-1, {
            state: "used",
            name: d,
          }),
            l._connectionsUsage.add(1, {
              state: "idle",
              name: d,
            }));
        }));
    }
  }
  return ((ma.MySQLInstrumentation = i), ma);
}
var gN;
function iW() {
  return (
    gN ||
      ((gN = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.MySQLInstrumentation = void 0));
        var t = sW();
        Object.defineProperty(e, "MySQLInstrumentation", {
          enumerable: !0,
          get: function () {
            return t.MySQLInstrumentation;
          },
        });
      })(Xd)),
    Xd
  );
}
var aW = iW();
const iv = "Mysql",
  cW = Ne(iv, () => new aW.MySQLInstrumentation({})),
  uW = () => ({
    name: iv,
    setupOnce() {
      cW();
    },
  }),
  lW = uW;
var Jd = {},
  Aa = {},
  Je = {},
  RN;
function av() {
  return (
    RN ||
      ((RN = 1),
      Object.defineProperty(Je, "__esModule", {
        value: !0,
      }),
      (Je.DB_SYSTEM_VALUE_MYSQL =
        Je.ATTR_NET_PEER_PORT =
        Je.ATTR_NET_PEER_NAME =
        Je.ATTR_DB_USER =
        Je.ATTR_DB_SYSTEM =
        Je.ATTR_DB_STATEMENT =
        Je.ATTR_DB_NAME =
        Je.ATTR_DB_CONNECTION_STRING =
          void 0),
      (Je.ATTR_DB_CONNECTION_STRING = "db.connection_string"),
      (Je.ATTR_DB_NAME = "db.name"),
      (Je.ATTR_DB_STATEMENT = "db.statement"),
      (Je.ATTR_DB_SYSTEM = "db.system"),
      (Je.ATTR_DB_USER = "db.user"),
      (Je.ATTR_NET_PEER_NAME = "net.peer.name"),
      (Je.ATTR_NET_PEER_PORT = "net.peer.port"),
      (Je.DB_SYSTEM_VALUE_MYSQL = "mysql")),
    Je
  );
}
var ga = {},
  NN;
function cv() {
  if (NN) return ga;
  ((NN = 1),
    Object.defineProperty(ga, "__esModule", {
      value: !0,
    }),
    (ga.addSqlCommenterComment = void 0));
  const e = Pe(),
    t = un;
  function n(s) {
    const i = s.indexOf("--");
    if (i >= 0) return !0;
    if (s.indexOf("/*") < 0) return !1;
    const c = s.indexOf("*/");
    return i < c;
  }
  function r(s) {
    return encodeURIComponent(s).replace(
      /[!'()*]/g,
      (i) => `%${i.charCodeAt(0).toString(16).toUpperCase()}`,
    );
  }
  function o(s, i) {
    if (typeof i != "string" || i.length === 0 || n(i)) return i;
    const a = new t.W3CTraceContextPropagator(),
      c = {};
    a.inject(e.trace.setSpan(e.ROOT_CONTEXT, s), c, e.defaultTextMapSetter);
    const l = Object.keys(c).sort();
    if (l.length === 0) return i;
    const f = l
      .map((d) => {
        const u = r(c[d]);
        return `${d}='${u}'`;
      })
      .join(",");
    return `${i} /*${f}*/`;
  }
  return ((ga.addSqlCommenterComment = o), ga);
}
var vt = {},
  yN;
function dW() {
  if (yN) return vt;
  ((yN = 1),
    Object.defineProperty(vt, "__esModule", {
      value: !0,
    }),
    (vt.getConnectionPrototypeToInstrument =
      vt.once =
      vt.getSpanName =
      vt.getQueryText =
      vt.getConnectionAttributes =
        void 0));
  const e = av(),
    t = Le,
    n = pt();
  function r(u, _, p) {
    const { host: E, port: h, database: T, user: m } = o(u),
      A = {};
    (_ & t.SemconvStability.OLD &&
      ((A[e.ATTR_DB_CONNECTION_STRING] = s(E, h, T)),
      (A[e.ATTR_DB_NAME] = T),
      (A[e.ATTR_DB_USER] = m)),
      _ & t.SemconvStability.STABLE && (A[n.ATTR_DB_NAMESPACE] = T));
    const g = parseInt(h, 10);
    return (
      p & t.SemconvStability.OLD &&
        ((A[e.ATTR_NET_PEER_NAME] = E),
        isNaN(g) || (A[e.ATTR_NET_PEER_PORT] = g)),
      p & t.SemconvStability.STABLE &&
        ((A[n.ATTR_SERVER_ADDRESS] = E),
        isNaN(g) || (A[n.ATTR_SERVER_PORT] = g)),
      A
    );
  }
  vt.getConnectionAttributes = r;
  function o(u) {
    const {
      host: _,
      port: p,
      database: E,
      user: h,
    } = (u && u.connectionConfig) || u || {};
    return {
      host: _,
      port: p,
      database: E,
      user: h,
    };
  }
  function s(u, _, p) {
    let E = `jdbc:mysql://${u || "localhost"}`;
    return (
      typeof _ == "number" && (E += `:${_}`),
      typeof p == "string" && (E += `/${p}`),
      E
    );
  }
  function i(u, _, p, E = !1, h = a) {
    const [T, m] =
      typeof u == "string" ? [u, p] : [u.sql, c(u) ? p || u.values : p];
    try {
      return E ? h(T) : _ && m ? _(T, m) : T;
    } catch {
      return "Could not determine the query due to an error in masking or formatting";
    }
  }
  vt.getQueryText = i;
  function a(u) {
    return u
      .replace(/\b\d+\b/g, "?")
      .replace(/(["'])(?:(?=(\\?))\2.)*?\1/g, "?");
  }
  function c(u) {
    return "values" in u;
  }
  function l(u) {
    const _ = typeof u == "object" ? u.sql : u,
      p = _?.indexOf(" ");
    return typeof p == "number" && p !== -1 ? _?.substring(0, p) : _;
  }
  vt.getSpanName = l;
  const f = (u) => {
    let _ = !1;
    return (...p) => {
      if (!_) return ((_ = !0), u(...p));
    };
  };
  vt.once = f;
  function d(u) {
    const _ = u.prototype,
      p = Object.getPrototypeOf(_);
    return typeof p?.query == "function" && typeof p?.execute == "function"
      ? p
      : _;
  }
  return ((vt.getConnectionPrototypeToInstrument = d), vt);
}
var Lr = {},
  ON;
function fW() {
  return (
    ON ||
      ((ON = 1),
      Object.defineProperty(Lr, "__esModule", {
        value: !0,
      }),
      (Lr.PACKAGE_NAME = Lr.PACKAGE_VERSION = void 0),
      (Lr.PACKAGE_VERSION = "0.55.0"),
      (Lr.PACKAGE_NAME = "@opentelemetry/instrumentation-mysql2")),
    Lr
  );
}
var CN;
function _W() {
  if (CN) return Aa;
  ((CN = 1),
    Object.defineProperty(Aa, "__esModule", {
      value: !0,
    }),
    (Aa.MySQL2Instrumentation = void 0));
  const e = Pe(),
    t = Le,
    n = av(),
    r = cv(),
    o = dW(),
    s = fW(),
    i = pt(),
    a = [">=1.4.2 <4"];
  class c extends t.InstrumentationBase {
    _netSemconvStability;
    _dbSemconvStability;
    constructor(f = {}) {
      (super(s.PACKAGE_NAME, s.PACKAGE_VERSION, f),
        this._setSemconvStabilityFromEnv());
    }
    _setSemconvStabilityFromEnv() {
      ((this._netSemconvStability = (0, t.semconvStabilityFromStr)(
        "http",
        process.env.OTEL_SEMCONV_STABILITY_OPT_IN,
      )),
        (this._dbSemconvStability = (0, t.semconvStabilityFromStr)(
          "database",
          process.env.OTEL_SEMCONV_STABILITY_OPT_IN,
        )));
    }
    init() {
      let f;
      function d(p) {
        !f && p.format && (f = p.format);
      }
      const u = (p) => {
          ((0, t.isWrapped)(p.query) && this._unwrap(p, "query"),
            this._wrap(p, "query", this._patchQuery(f, !1)),
            (0, t.isWrapped)(p.execute) && this._unwrap(p, "execute"),
            this._wrap(p, "execute", this._patchQuery(f, !0)));
        },
        _ = (p) => {
          (this._unwrap(p, "query"), this._unwrap(p, "execute"));
        };
      return [
        new t.InstrumentationNodeModuleDefinition(
          "mysql2",
          a,
          (p) => (d(p), p),
          () => {},
          [
            new t.InstrumentationNodeModuleFile(
              "mysql2/promise.js",
              a,
              (p) => (d(p), p),
              () => {},
            ),
            new t.InstrumentationNodeModuleFile(
              "mysql2/lib/connection.js",
              a,
              (p) => {
                const E = (0, o.getConnectionPrototypeToInstrument)(p);
                return (u(E), p);
              },
              (p) => {
                if (p === void 0) return;
                const E = (0, o.getConnectionPrototypeToInstrument)(p);
                _(E);
              },
            ),
          ],
        ),
      ];
    }
    _patchQuery(f, d) {
      return (u) => {
        const _ = this;
        return function (p, E, h) {
          let T;
          Array.isArray(E) ? (T = E) : arguments[2] && (T = [E]);
          const {
              maskStatement: m,
              maskStatementHook: A,
              responseHook: g,
            } = _.getConfig(),
            N = (0, o.getConnectionAttributes)(
              this.config,
              _._dbSemconvStability,
              _._netSemconvStability,
            ),
            O = (0, o.getQueryText)(p, f, T, m, A);
          (_._dbSemconvStability & t.SemconvStability.OLD &&
            ((N[n.ATTR_DB_SYSTEM] = n.DB_SYSTEM_VALUE_MYSQL),
            (N[n.ATTR_DB_STATEMENT] = O)),
            _._dbSemconvStability & t.SemconvStability.STABLE &&
              ((N[i.ATTR_DB_SYSTEM_NAME] = i.DB_SYSTEM_NAME_VALUE_MYSQL),
              (N[i.ATTR_DB_QUERY_TEXT] = O)));
          const I = _.tracer.startSpan((0, o.getSpanName)(p), {
            kind: e.SpanKind.CLIENT,
            attributes: N,
          });
          !d &&
            _.getConfig().addSqlCommenterCommentToQueries &&
            (arguments[0] = p =
              typeof p == "string"
                ? (0, r.addSqlCommenterComment)(I, p)
                : Object.assign(p, {
                    sql: (0, r.addSqlCommenterComment)(I, p.sql),
                  }));
          const b = (0, o.once)((w, L) => {
            (w
              ? I.setStatus({
                  code: e.SpanStatusCode.ERROR,
                  message: w.message,
                })
              : typeof g == "function" &&
                (0, t.safeExecuteInTheMiddle)(
                  () => {
                    g(I, {
                      queryResults: L,
                    });
                  },
                  (j) => {
                    j && _._diag.warn("Failed executing responseHook", j);
                  },
                  !0,
                ),
              I.end());
          });
          if (arguments.length === 1) {
            typeof p.onResult == "function" &&
              _._wrap(p, "onResult", _._patchCallbackQuery(b));
            const w = u.apply(this, arguments);
            return (
              w
                .once("error", (L) => {
                  b(L);
                })
                .once("result", (L) => {
                  b(void 0, L);
                }),
              w
            );
          }
          return (
            typeof arguments[1] == "function"
              ? _._wrap(arguments, 1, _._patchCallbackQuery(b))
              : typeof arguments[2] == "function" &&
                _._wrap(arguments, 2, _._patchCallbackQuery(b)),
            u.apply(this, arguments)
          );
        };
      };
    }
    _patchCallbackQuery(f) {
      return (d) =>
        function (u, _, p) {
          return (f(u, _), d(...arguments));
        };
    }
  }
  return ((Aa.MySQL2Instrumentation = c), Aa);
}
var bN;
function pW() {
  return (
    bN ||
      ((bN = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.MySQL2Instrumentation = void 0));
        var t = _W();
        Object.defineProperty(e, "MySQL2Instrumentation", {
          enumerable: !0,
          get: function () {
            return t.MySQL2Instrumentation;
          },
        });
      })(Jd)),
    Jd
  );
}
var EW = pW();
const uv = "Mysql2",
  hW = Ne(
    uv,
    () =>
      new EW.MySQL2Instrumentation({
        responseHook(e) {
          yt(e, "auto.db.otel.mysql2");
        },
      }),
  ),
  TW = () => ({
    name: uv,
    setupOnce() {
      hW();
    },
  }),
  SW = TW;
var ef = {},
  Ra = {},
  St = {},
  IN;
function mW() {
  return (
    IN ||
      ((IN = 1),
      Object.defineProperty(St, "__esModule", {
        value: !0,
      }),
      (St.DB_SYSTEM_VALUE_REDIS =
        St.ATTR_NET_PEER_PORT =
        St.ATTR_NET_PEER_NAME =
        St.ATTR_DB_SYSTEM =
        St.ATTR_DB_STATEMENT =
        St.ATTR_DB_CONNECTION_STRING =
          void 0),
      (St.ATTR_DB_CONNECTION_STRING = "db.connection_string"),
      (St.ATTR_DB_STATEMENT = "db.statement"),
      (St.ATTR_DB_SYSTEM = "db.system"),
      (St.ATTR_NET_PEER_NAME = "net.peer.name"),
      (St.ATTR_NET_PEER_PORT = "net.peer.port"),
      (St.DB_SYSTEM_VALUE_REDIS = "redis")),
    St
  );
}
var Na = {},
  PN;
function AW() {
  if (PN) return Na;
  ((PN = 1),
    Object.defineProperty(Na, "__esModule", {
      value: !0,
    }),
    (Na.endSpan = void 0));
  const e = Pe(),
    t = (n, r) => {
      (r &&
        (n.recordException(r),
        n.setStatus({
          code: e.SpanStatusCode.ERROR,
          message: r.message,
        })),
        n.end());
    };
  return ((Na.endSpan = t), Na);
}
var ya = {},
  MN;
function JE() {
  if (MN) return ya;
  ((MN = 1),
    Object.defineProperty(ya, "__esModule", {
      value: !0,
    }),
    (ya.defaultDbStatementSerializer = void 0));
  const e = [
      {
        regex: /^ECHO/i,
        args: 0,
      },
      {
        regex: /^(LPUSH|MSET|PFA|PUBLISH|RPUSH|SADD|SET|SPUBLISH|XADD|ZADD)/i,
        args: 1,
      },
      {
        regex: /^(HSET|HMSET|LSET|LINSERT)/i,
        args: 2,
      },
      {
        regex:
          /^(ACL|BIT|B[LRZ]|CLIENT|CLUSTER|CONFIG|COMMAND|DECR|DEL|EVAL|EX|FUNCTION|GEO|GET|HINCR|HMGET|HSCAN|INCR|L[TRLM]|MEMORY|P[EFISTU]|RPOP|S[CDIMORSU]|XACK|X[CDGILPRT]|Z[CDILMPRS])/i,
        args: -1,
      },
    ],
    t = (n, r) => {
      if (Array.isArray(r) && r.length) {
        const o = e.find(({ regex: i }) => i.test(n))?.args ?? 0,
          s = o >= 0 ? r.slice(0, o) : r;
        return (
          r.length > s.length && s.push(`[${r.length - o} other arguments]`),
          `${n} ${s.join(" ")}`
        );
      }
      return n;
    };
  return ((ya.defaultDbStatementSerializer = t), ya);
}
var Dr = {},
  vN;
function gW() {
  return (
    vN ||
      ((vN = 1),
      Object.defineProperty(Dr, "__esModule", {
        value: !0,
      }),
      (Dr.PACKAGE_NAME = Dr.PACKAGE_VERSION = void 0),
      (Dr.PACKAGE_VERSION = "0.56.0"),
      (Dr.PACKAGE_NAME = "@opentelemetry/instrumentation-ioredis")),
    Dr
  );
}
var LN;
function RW() {
  if (LN) return Ra;
  ((LN = 1),
    Object.defineProperty(Ra, "__esModule", {
      value: !0,
    }),
    (Ra.IORedisInstrumentation = void 0));
  const e = Pe(),
    t = Le,
    n = mW(),
    r = Le,
    o = AW(),
    s = JE(),
    i = gW(),
    a = {
      requireParentSpan: !0,
    };
  class c extends t.InstrumentationBase {
    constructor(f = {}) {
      super(i.PACKAGE_NAME, i.PACKAGE_VERSION, {
        ...a,
        ...f,
      });
    }
    setConfig(f = {}) {
      super.setConfig({
        ...a,
        ...f,
      });
    }
    init() {
      return [
        new t.InstrumentationNodeModuleDefinition(
          "ioredis",
          [">=2.0.0 <6"],
          (f, d) => {
            const u = f[Symbol.toStringTag] === "Module" ? f.default : f;
            return (
              (0, t.isWrapped)(u.prototype.sendCommand) &&
                this._unwrap(u.prototype, "sendCommand"),
              this._wrap(u.prototype, "sendCommand", this._patchSendCommand(d)),
              (0, t.isWrapped)(u.prototype.connect) &&
                this._unwrap(u.prototype, "connect"),
              this._wrap(u.prototype, "connect", this._patchConnection()),
              f
            );
          },
          (f) => {
            if (f === void 0) return;
            const d = f[Symbol.toStringTag] === "Module" ? f.default : f;
            (this._unwrap(d.prototype, "sendCommand"),
              this._unwrap(d.prototype, "connect"));
          },
        ),
      ];
    }
    _patchSendCommand(f) {
      return (d) => this._traceSendCommand(d, f);
    }
    _patchConnection() {
      return (f) => this._traceConnection(f);
    }
    _traceSendCommand(f, d) {
      const u = this;
      return function (_) {
        if (arguments.length < 1 || typeof _ != "object")
          return f.apply(this, arguments);
        const p = u.getConfig(),
          E = p.dbStatementSerializer || s.defaultDbStatementSerializer,
          h = e.trace.getSpan(e.context.active()) === void 0;
        if (p.requireParentSpan === !0 && h) return f.apply(this, arguments);
        const T = u.tracer.startSpan(_.name, {
            kind: e.SpanKind.CLIENT,
            attributes: {
              [n.ATTR_DB_SYSTEM]: n.DB_SYSTEM_VALUE_REDIS,
              [n.ATTR_DB_STATEMENT]: E(_.name, _.args),
            },
          }),
          { requestHook: m } = p;
        m &&
          (0, r.safeExecuteInTheMiddle)(
            () =>
              m(T, {
                moduleVersion: d,
                cmdName: _.name,
                cmdArgs: _.args,
              }),
            (N) => {
              N &&
                e.diag.error("ioredis instrumentation: request hook failed", N);
            },
            !0,
          );
        const { host: A, port: g } = this.options;
        T.setAttributes({
          [n.ATTR_NET_PEER_NAME]: A,
          [n.ATTR_NET_PEER_PORT]: g,
          [n.ATTR_DB_CONNECTION_STRING]: `redis://${A}:${g}`,
        });
        try {
          const N = f.apply(this, arguments),
            O = _.resolve;
          _.resolve = function (b) {
            ((0, r.safeExecuteInTheMiddle)(
              () => p.responseHook?.(T, _.name, _.args, b),
              (w) => {
                w &&
                  e.diag.error(
                    "ioredis instrumentation: response hook failed",
                    w,
                  );
              },
              !0,
            ),
              (0, o.endSpan)(T, null),
              O(b));
          };
          const I = _.reject;
          return (
            (_.reject = function (b) {
              ((0, o.endSpan)(T, b), I(b));
            }),
            N
          );
        } catch (N) {
          throw ((0, o.endSpan)(T, N), N);
        }
      };
    }
    _traceConnection(f) {
      const d = this;
      return function () {
        const u = e.trace.getSpan(e.context.active()) === void 0;
        if (d.getConfig().requireParentSpan === !0 && u)
          return f.apply(this, arguments);
        const _ = d.tracer.startSpan("connect", {
            kind: e.SpanKind.CLIENT,
            attributes: {
              [n.ATTR_DB_SYSTEM]: n.DB_SYSTEM_VALUE_REDIS,
              [n.ATTR_DB_STATEMENT]: "connect",
            },
          }),
          { host: p, port: E } = this.options;
        _.setAttributes({
          [n.ATTR_NET_PEER_NAME]: p,
          [n.ATTR_NET_PEER_PORT]: E,
          [n.ATTR_DB_CONNECTION_STRING]: `redis://${p}:${E}`,
        });
        try {
          const h = f.apply(this, arguments);
          return ((0, o.endSpan)(_, null), h);
        } catch (h) {
          throw ((0, o.endSpan)(_, h), h);
        }
      };
    }
  }
  return ((Ra.IORedisInstrumentation = c), Ra);
}
var DN;
function NW() {
  return (
    DN ||
      ((DN = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.IORedisInstrumentation = void 0));
        var t = RW();
        Object.defineProperty(e, "IORedisInstrumentation", {
          enumerable: !0,
          get: function () {
            return t.IORedisInstrumentation;
          },
        });
      })(ef)),
    ef
  );
}
var yW = NW(),
  tf = {},
  Oa = {},
  wr = {},
  wN;
function eh() {
  return (
    wN ||
      ((wN = 1),
      Object.defineProperty(wr, "__esModule", {
        value: !0,
      }),
      (wr.PACKAGE_NAME = wr.PACKAGE_VERSION = void 0),
      (wr.PACKAGE_VERSION = "0.57.0"),
      (wr.PACKAGE_NAME = "@opentelemetry/instrumentation-redis")),
    wr
  );
}
var Ca = {},
  In = {},
  UN;
function OW() {
  if (UN) return In;
  ((UN = 1),
    Object.defineProperty(In, "__esModule", {
      value: !0,
    }),
    (In.getTracedCreateStreamTrace =
      In.getTracedCreateClient =
      In.endSpan =
        void 0));
  const e = Pe(),
    t = (o, s) => {
      (s &&
        o.setStatus({
          code: e.SpanStatusCode.ERROR,
          message: s.message,
        }),
        o.end());
    };
  In.endSpan = t;
  const n = (o) =>
    function () {
      const i = o.apply(this, arguments);
      return e.context.bind(e.context.active(), i);
    };
  In.getTracedCreateClient = n;
  const r = (o) =>
    function () {
      return (
        Object.prototype.hasOwnProperty.call(this, "stream") ||
          Object.defineProperty(this, "stream", {
            get() {
              return this._patched_redis_stream;
            },
            set(i) {
              (e.context.bind(e.context.active(), i),
                (this._patched_redis_stream = i));
            },
          }),
        o.apply(this, arguments)
      );
    };
  return ((In.getTracedCreateStreamTrace = r), In);
}
var st = {},
  kN;
function th() {
  return (
    kN ||
      ((kN = 1),
      Object.defineProperty(st, "__esModule", {
        value: !0,
      }),
      (st.DB_SYSTEM_VALUE_REDIS =
        st.DB_SYSTEM_NAME_VALUE_REDIS =
        st.ATTR_NET_PEER_PORT =
        st.ATTR_NET_PEER_NAME =
        st.ATTR_DB_SYSTEM =
        st.ATTR_DB_STATEMENT =
        st.ATTR_DB_CONNECTION_STRING =
          void 0),
      (st.ATTR_DB_CONNECTION_STRING = "db.connection_string"),
      (st.ATTR_DB_STATEMENT = "db.statement"),
      (st.ATTR_DB_SYSTEM = "db.system"),
      (st.ATTR_NET_PEER_NAME = "net.peer.name"),
      (st.ATTR_NET_PEER_PORT = "net.peer.port"),
      (st.DB_SYSTEM_NAME_VALUE_REDIS = "redis"),
      (st.DB_SYSTEM_VALUE_REDIS = "redis")),
    st
  );
}
var GN;
function CW() {
  if (GN) return Ca;
  ((GN = 1),
    Object.defineProperty(Ca, "__esModule", {
      value: !0,
    }),
    (Ca.RedisInstrumentationV2_V3 = void 0));
  const e = Le,
    t = OW(),
    n = eh(),
    r = Pe(),
    o = pt(),
    s = th(),
    i = JE();
  class a extends e.InstrumentationBase {
    static COMPONENT = "redis";
    _semconvStability;
    constructor(l = {}) {
      (super(n.PACKAGE_NAME, n.PACKAGE_VERSION, l),
        (this._semconvStability = l.semconvStability
          ? l.semconvStability
          : (0, e.semconvStabilityFromStr)(
              "database",
              process.env.OTEL_SEMCONV_STABILITY_OPT_IN,
            )));
    }
    setConfig(l = {}) {
      (super.setConfig(l),
        (this._semconvStability = l.semconvStability
          ? l.semconvStability
          : (0, e.semconvStabilityFromStr)(
              "database",
              process.env.OTEL_SEMCONV_STABILITY_OPT_IN,
            )));
    }
    init() {
      return [
        new e.InstrumentationNodeModuleDefinition(
          "redis",
          [">=2.6.0 <4"],
          (l) => (
            (0, e.isWrapped)(l.RedisClient.prototype.internal_send_command) &&
              this._unwrap(l.RedisClient.prototype, "internal_send_command"),
            this._wrap(
              l.RedisClient.prototype,
              "internal_send_command",
              this._getPatchInternalSendCommand(),
            ),
            (0, e.isWrapped)(l.RedisClient.prototype.create_stream) &&
              this._unwrap(l.RedisClient.prototype, "create_stream"),
            this._wrap(
              l.RedisClient.prototype,
              "create_stream",
              this._getPatchCreateStream(),
            ),
            (0, e.isWrapped)(l.createClient) && this._unwrap(l, "createClient"),
            this._wrap(l, "createClient", this._getPatchCreateClient()),
            l
          ),
          (l) => {
            l !== void 0 &&
              (this._unwrap(l.RedisClient.prototype, "internal_send_command"),
              this._unwrap(l.RedisClient.prototype, "create_stream"),
              this._unwrap(l, "createClient"));
          },
        ),
      ];
    }
    _getPatchInternalSendCommand() {
      const l = this;
      return function (d) {
        return function (_) {
          if (arguments.length !== 1 || typeof _ != "object")
            return d.apply(this, arguments);
          const p = l.getConfig(),
            E = r.trace.getSpan(r.context.active()) === void 0;
          if (p.requireParentSpan === !0 && E) return d.apply(this, arguments);
          const h = p?.dbStatementSerializer || i.defaultDbStatementSerializer,
            T = {};
          (l._semconvStability & e.SemconvStability.OLD &&
            Object.assign(T, {
              [s.ATTR_DB_SYSTEM]: s.DB_SYSTEM_VALUE_REDIS,
              [s.ATTR_DB_STATEMENT]: h(_.command, _.args),
            }),
            l._semconvStability & e.SemconvStability.STABLE &&
              Object.assign(T, {
                [o.ATTR_DB_SYSTEM_NAME]: s.DB_SYSTEM_NAME_VALUE_REDIS,
                [o.ATTR_DB_OPERATION_NAME]: _.command,
                [o.ATTR_DB_QUERY_TEXT]: h(_.command, _.args),
              }));
          const m = l.tracer.startSpan(`${a.COMPONENT}-${_.command}`, {
            kind: r.SpanKind.CLIENT,
            attributes: T,
          });
          if (this.connection_options) {
            const g = {};
            (l._semconvStability & e.SemconvStability.OLD &&
              Object.assign(g, {
                [s.ATTR_NET_PEER_NAME]: this.connection_options.host,
                [s.ATTR_NET_PEER_PORT]: this.connection_options.port,
              }),
              l._semconvStability & e.SemconvStability.STABLE &&
                Object.assign(g, {
                  [o.ATTR_SERVER_ADDRESS]: this.connection_options.host,
                  [o.ATTR_SERVER_PORT]: this.connection_options.port,
                }),
              m.setAttributes(g));
          }
          this.address &&
            l._semconvStability & e.SemconvStability.OLD &&
            m.setAttribute(
              s.ATTR_DB_CONNECTION_STRING,
              `redis://${this.address}`,
            );
          const A = arguments[0].callback;
          if (A) {
            const g = r.context.active();
            arguments[0].callback = function (O, I) {
              if (p?.responseHook) {
                const b = p.responseHook;
                (0, e.safeExecuteInTheMiddle)(
                  () => {
                    b(m, _.command, _.args, I);
                  },
                  (w) => {
                    w && l._diag.error("Error executing responseHook", w);
                  },
                  !0,
                );
              }
              return (
                (0, t.endSpan)(m, O),
                r.context.with(g, A, this, ...arguments)
              );
            };
          }
          try {
            return d.apply(this, arguments);
          } catch (g) {
            throw ((0, t.endSpan)(m, g), g);
          }
        };
      };
    }
    _getPatchCreateClient() {
      return function (f) {
        return (0, t.getTracedCreateClient)(f);
      };
    }
    _getPatchCreateStream() {
      return function (f) {
        return (0, t.getTracedCreateStreamTrace)(f);
      };
    }
  }
  return ((Ca.RedisInstrumentationV2_V3 = a), Ca);
}
var ba = {},
  Ia = {},
  VN;
function bW() {
  if (VN) return Ia;
  ((VN = 1),
    Object.defineProperty(Ia, "__esModule", {
      value: !0,
    }),
    (Ia.getClientAttributes = void 0));
  const e = pt(),
    t = th(),
    n = Le;
  function r(s, i, a) {
    const c = {};
    return (
      a & n.SemconvStability.OLD &&
        Object.assign(c, {
          [t.ATTR_DB_SYSTEM]: t.DB_SYSTEM_VALUE_REDIS,
          [t.ATTR_NET_PEER_NAME]: i?.socket?.host,
          [t.ATTR_NET_PEER_PORT]: i?.socket?.port,
          [t.ATTR_DB_CONNECTION_STRING]: o(s, i?.url),
        }),
      a & n.SemconvStability.STABLE &&
        Object.assign(c, {
          [e.ATTR_DB_SYSTEM_NAME]: t.DB_SYSTEM_NAME_VALUE_REDIS,
          [e.ATTR_SERVER_ADDRESS]: i?.socket?.host,
          [e.ATTR_SERVER_PORT]: i?.socket?.port,
        }),
      c
    );
  }
  Ia.getClientAttributes = r;
  function o(s, i) {
    if (!(typeof i != "string" || !i))
      try {
        const a = new URL(i);
        return (
          a.searchParams.delete("user_pwd"),
          (a.username = ""),
          (a.password = ""),
          a.href
        );
      } catch (a) {
        s.error("failed to sanitize redis connection url", a);
      }
  }
  return Ia;
}
var xN;
function IW() {
  if (xN) return ba;
  ((xN = 1),
    Object.defineProperty(ba, "__esModule", {
      value: !0,
    }),
    (ba.RedisInstrumentationV4_V5 = void 0));
  const e = Pe(),
    t = Le,
    n = bW(),
    r = JE(),
    o = eh(),
    s = pt(),
    i = th(),
    a = Symbol("opentelemetry.instrumentation.redis.open_spans"),
    c = Symbol("opentelemetry.instrumentation.redis.multi_command_options");
  class l extends t.InstrumentationBase {
    static COMPONENT = "redis";
    _semconvStability;
    constructor(d = {}) {
      (super(o.PACKAGE_NAME, o.PACKAGE_VERSION, d),
        (this._semconvStability = d.semconvStability
          ? d.semconvStability
          : (0, t.semconvStabilityFromStr)(
              "database",
              process.env.OTEL_SEMCONV_STABILITY_OPT_IN,
            )));
    }
    setConfig(d = {}) {
      (super.setConfig(d),
        (this._semconvStability = d.semconvStability
          ? d.semconvStability
          : (0, t.semconvStabilityFromStr)(
              "database",
              process.env.OTEL_SEMCONV_STABILITY_OPT_IN,
            )));
    }
    init() {
      return [
        this._getInstrumentationNodeModuleDefinition("@redis/client"),
        this._getInstrumentationNodeModuleDefinition("@node-redis/client"),
      ];
    }
    _getInstrumentationNodeModuleDefinition(d) {
      const u = new t.InstrumentationNodeModuleFile(
          `${d}/dist/lib/commander.js`,
          ["^1.0.0"],
          (E, h) => {
            const T = E.transformCommandArguments;
            if (!T)
              return (
                this._diag.error(
                  "internal instrumentation error, missing transformCommandArguments function",
                ),
                E
              );
            const m = h?.startsWith("1.0.")
              ? "extendWithCommands"
              : "attachCommands";
            return (
              (0, t.isWrapped)(E?.[m]) && this._unwrap(E, m),
              this._wrap(E, m, this._getPatchExtendWithCommands(T)),
              E
            );
          },
          (E) => {
            ((0, t.isWrapped)(E?.extendWithCommands) &&
              this._unwrap(E, "extendWithCommands"),
              (0, t.isWrapped)(E?.attachCommands) &&
                this._unwrap(E, "attachCommands"));
          },
        ),
        _ = new t.InstrumentationNodeModuleFile(
          `${d}/dist/lib/client/multi-command.js`,
          ["^1.0.0", "^5.0.0"],
          (E) => {
            const h = E?.default?.prototype;
            return (
              (0, t.isWrapped)(h?.exec) && this._unwrap(h, "exec"),
              this._wrap(h, "exec", this._getPatchMultiCommandsExec()),
              (0, t.isWrapped)(h?.addCommand) && this._unwrap(h, "addCommand"),
              this._wrap(
                h,
                "addCommand",
                this._getPatchMultiCommandsAddCommand(),
              ),
              E
            );
          },
          (E) => {
            const h = E?.default?.prototype;
            ((0, t.isWrapped)(h?.exec) && this._unwrap(h, "exec"),
              (0, t.isWrapped)(h?.addCommand) && this._unwrap(h, "addCommand"));
          },
        ),
        p = new t.InstrumentationNodeModuleFile(
          `${d}/dist/lib/client/index.js`,
          ["^1.0.0", "^5.0.0"],
          (E) => {
            const h = E?.default?.prototype;
            return (
              h?.multi &&
                ((0, t.isWrapped)(h?.multi) && this._unwrap(h, "multi"),
                this._wrap(h, "multi", this._getPatchRedisClientMulti())),
              h?.MULTI &&
                ((0, t.isWrapped)(h?.MULTI) && this._unwrap(h, "MULTI"),
                this._wrap(h, "MULTI", this._getPatchRedisClientMulti())),
              (0, t.isWrapped)(h?.sendCommand) &&
                this._unwrap(h, "sendCommand"),
              this._wrap(
                h,
                "sendCommand",
                this._getPatchRedisClientSendCommand(),
              ),
              this._wrap(h, "connect", this._getPatchedClientConnect()),
              E
            );
          },
          (E) => {
            const h = E?.default?.prototype;
            ((0, t.isWrapped)(h?.multi) && this._unwrap(h, "multi"),
              (0, t.isWrapped)(h?.MULTI) && this._unwrap(h, "MULTI"),
              (0, t.isWrapped)(h?.sendCommand) &&
                this._unwrap(h, "sendCommand"));
          },
        );
      return new t.InstrumentationNodeModuleDefinition(
        d,
        ["^1.0.0", "^5.0.0"],
        (E) => E,
        () => {},
        [u, _, p],
      );
    }
    _getPatchExtendWithCommands(d) {
      const u = this;
      return function (p) {
        return function (h) {
          if (h?.BaseClass?.name !== "RedisClient")
            return p.apply(this, arguments);
          const T = h.executor;
          return (
            (h.executor = function (m, A) {
              const g = d(m, A).args;
              return u._traceClientCommand(T, this, arguments, g);
            }),
            p.apply(this, arguments)
          );
        };
      };
    }
    _getPatchMultiCommandsExec() {
      const d = this;
      return function (_) {
        return function () {
          const E = _.apply(this, arguments);
          return typeof E?.then != "function"
            ? (d._diag.error(
                "got non promise result when patching RedisClientMultiCommand.exec",
              ),
              E)
            : E.then((h) => {
                const T = this[a];
                return (d._endSpansWithRedisReplies(T, h), h);
              }).catch((h) => {
                const T = this[a];
                if (!T)
                  d._diag.error(
                    "cannot find open spans to end for redis multi command",
                  );
                else {
                  const m =
                    h.constructor.name === "MultiErrorReply"
                      ? h.replies
                      : new Array(T.length).fill(h);
                  d._endSpansWithRedisReplies(T, m);
                }
                return Promise.reject(h);
              });
        };
      };
    }
    _getPatchMultiCommandsAddCommand() {
      const d = this;
      return function (_) {
        return function (E) {
          return d._traceClientCommand(_, this, arguments, E);
        };
      };
    }
    _getPatchRedisClientMulti() {
      return function (u) {
        return function () {
          const p = u.apply(this, arguments);
          return ((p[c] = this.options), p);
        };
      };
    }
    _getPatchRedisClientSendCommand() {
      const d = this;
      return function (_) {
        return function (E) {
          return d._traceClientCommand(_, this, arguments, E);
        };
      };
    }
    _getPatchedClientConnect() {
      const d = this;
      return function (_) {
        return function () {
          const E = this.options,
            h = (0, n.getClientAttributes)(d._diag, E, d._semconvStability),
            T = d.tracer.startSpan(`${l.COMPONENT}-connect`, {
              kind: e.SpanKind.CLIENT,
              attributes: h,
            });
          return e.context
            .with(e.trace.setSpan(e.context.active(), T), () => _.apply(this))
            .then((A) => (T.end(), A))
            .catch(
              (A) => (
                T.recordException(A),
                T.setStatus({
                  code: e.SpanStatusCode.ERROR,
                  message: A.message,
                }),
                T.end(),
                Promise.reject(A)
              ),
            );
        };
      };
    }
    _traceClientCommand(d, u, _, p) {
      if (
        e.trace.getSpan(e.context.active()) === void 0 &&
        this.getConfig().requireParentSpan
      )
        return d.apply(u, _);
      const h = u.options || u[c],
        T = p[0],
        m = p.slice(1),
        A =
          this.getConfig().dbStatementSerializer ||
          r.defaultDbStatementSerializer,
        g = (0, n.getClientAttributes)(this._diag, h, this._semconvStability);
      this._semconvStability & t.SemconvStability.STABLE &&
        (g[s.ATTR_DB_OPERATION_NAME] = T);
      try {
        const I = A(T, m);
        I != null &&
          (this._semconvStability & t.SemconvStability.OLD &&
            (g[i.ATTR_DB_STATEMENT] = I),
          this._semconvStability & t.SemconvStability.STABLE &&
            (g[s.ATTR_DB_QUERY_TEXT] = I));
      } catch (I) {
        this._diag.error("dbStatementSerializer throw an exception", I, {
          commandName: T,
        });
      }
      const N = this.tracer.startSpan(`${l.COMPONENT}-${T}`, {
          kind: e.SpanKind.CLIENT,
          attributes: g,
        }),
        O = e.context.with(e.trace.setSpan(e.context.active(), N), () =>
          d.apply(u, _),
        );
      if (typeof O?.then == "function")
        O.then(
          (I) => {
            this._endSpanWithResponse(N, T, m, I, void 0);
          },
          (I) => {
            this._endSpanWithResponse(N, T, m, null, I);
          },
        );
      else {
        const I = O;
        ((I[a] = I[a] || []),
          I[a].push({
            span: N,
            commandName: T,
            commandArgs: m,
          }));
      }
      return O;
    }
    _endSpansWithRedisReplies(d, u) {
      if (!d)
        return this._diag.error(
          "cannot find open spans to end for redis multi command",
        );
      if (u.length !== d.length)
        return this._diag.error(
          "number of multi command spans does not match response from redis",
        );
      for (let _ = 0; _ < d.length; _++) {
        const { span: p, commandName: E, commandArgs: h } = d[_],
          T = u[_],
          [m, A] = T instanceof Error ? [null, T] : [T, void 0];
        this._endSpanWithResponse(p, E, h, m, A);
      }
    }
    _endSpanWithResponse(d, u, _, p, E) {
      const { responseHook: h } = this.getConfig();
      if (!E && h)
        try {
          h(d, u, _, p);
        } catch (T) {
          this._diag.error("responseHook throw an exception", T);
        }
      (E &&
        (d.recordException(E),
        d.setStatus({
          code: e.SpanStatusCode.ERROR,
          message: E?.message,
        })),
        d.end());
    }
  }
  return ((ba.RedisInstrumentationV4_V5 = l), ba);
}
var $N;
function PW() {
  if ($N) return Oa;
  (($N = 1),
    Object.defineProperty(Oa, "__esModule", {
      value: !0,
    }),
    (Oa.RedisInstrumentation = void 0));
  const e = Le,
    t = eh(),
    n = CW(),
    r = IW(),
    o = {
      requireParentSpan: !1,
    };
  class s extends e.InstrumentationBase {
    instrumentationV2_V3;
    instrumentationV4_V5;
    initialized = !1;
    constructor(a = {}) {
      const c = {
        ...o,
        ...a,
      };
      (super(t.PACKAGE_NAME, t.PACKAGE_VERSION, c),
        (this.instrumentationV2_V3 = new n.RedisInstrumentationV2_V3(
          this.getConfig(),
        )),
        (this.instrumentationV4_V5 = new r.RedisInstrumentationV4_V5(
          this.getConfig(),
        )),
        (this.initialized = !0));
    }
    setConfig(a = {}) {
      const c = {
        ...o,
        ...a,
      };
      (super.setConfig(c),
        this.initialized &&
          (this.instrumentationV2_V3.setConfig(c),
          this.instrumentationV4_V5.setConfig(c)));
    }
    init() {}
    getModuleDefinitions() {
      return [
        ...this.instrumentationV2_V3.getModuleDefinitions(),
        ...this.instrumentationV4_V5.getModuleDefinitions(),
      ];
    }
    setTracerProvider(a) {
      (super.setTracerProvider(a),
        this.initialized &&
          (this.instrumentationV2_V3.setTracerProvider(a),
          this.instrumentationV4_V5.setTracerProvider(a)));
    }
    enable() {
      (super.enable(),
        this.initialized &&
          (this.instrumentationV2_V3.enable(),
          this.instrumentationV4_V5.enable()));
    }
    disable() {
      (super.disable(),
        this.initialized &&
          (this.instrumentationV2_V3.disable(),
          this.instrumentationV4_V5.disable()));
    }
  }
  return ((Oa.RedisInstrumentation = s), Oa);
}
var BN;
function MW() {
  return (
    BN ||
      ((BN = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.RedisInstrumentation = void 0));
        var t = PW();
        Object.defineProperty(e, "RedisInstrumentation", {
          enumerable: !0,
          get: function () {
            return t.RedisInstrumentation;
          },
        });
      })(tf)),
    tf
  );
}
var vW = MW();
const LW = ["get", "set", "setex"],
  lv = ["get", "mget"],
  DW = ["set", "setex"];
function wu(e, t) {
  return e.includes(t.toLowerCase());
}
function dv(e) {
  return wu(lv, e) ? "cache.get" : wu(DW, e) ? "cache.put" : void 0;
}
function wW(e, t) {
  return t.some((n) => e.startsWith(n));
}
function UW(e, t) {
  try {
    if (t.length === 0) return;
    const n = (o) =>
        typeof o == "string" || typeof o == "number" || Buffer.isBuffer(o)
          ? [o.toString()]
          : Array.isArray(o)
            ? HN(o.map((s) => n(s)))
            : ["<unknown>"],
      r = t[0];
    return wu(LW, e) && r != null ? n(r) : HN(t.map((o) => n(o)));
  } catch {
    return;
  }
}
function kW(e, t, n) {
  if (!dv(e)) return !1;
  for (const r of t) if (wW(r, n)) return !0;
  return !1;
}
function GW(e) {
  const t = (n) => {
    try {
      return Buffer.isBuffer(n)
        ? n.byteLength
        : typeof n == "string"
          ? n.length
          : typeof n == "number"
            ? n.toString().length
            : n == null
              ? 0
              : JSON.stringify(n).length;
    } catch {
      return;
    }
  };
  return Array.isArray(e)
    ? e.reduce((n, r) => {
        const o = t(r);
        return typeof o == "number" ? (n !== void 0 ? n + o : o) : n;
      }, 0)
    : t(e);
}
function HN(e) {
  const t = [],
    n = (r) => {
      r.forEach((o) => {
        Array.isArray(o) ? n(o) : t.push(o);
      });
    };
  return (n(e), t);
}
const vl = "Redis";
let Ya = {};
const fv = (e, t, n, r) => {
    e.setAttribute(Ge, "auto.db.otel.redis");
    const o = UW(t, n),
      s = dv(t);
    if (!o || !s || !Ya.cachePrefixes || !kW(t, o, Ya.cachePrefixes)) return;
    const i = Re(e).data["net.peer.name"],
      a = Re(e).data["net.peer.port"];
    a &&
      i &&
      e.setAttributes({
        "network.peer.address": i,
        "network.peer.port": a,
      });
    const c = GW(r);
    (c && e.setAttribute(Vk, c),
      wu(lv, t) && c !== void 0 && e.setAttribute(kk, c > 0),
      e.setAttributes({
        [Ee]: s,
        [Gk]: o,
      }));
    const l = o.join(", ");
    e.updateName(Ya.maxCacheKeyLength ? hu(l, Ya.maxCacheKeyLength) : l);
  },
  VW = Ne(
    `${vl}.IORedis`,
    () =>
      new yW.IORedisInstrumentation({
        responseHook: fv,
      }),
  ),
  xW = Ne(
    `${vl}.Redis`,
    () =>
      new vW.RedisInstrumentation({
        responseHook: fv,
      }),
  ),
  $W = Object.assign(
    () => {
      (VW(), xW());
    },
    {
      id: vl,
    },
  ),
  BW = (e = {}) => ({
    name: vl,
    setupOnce() {
      ((Ya = e), $W());
    },
  }),
  HW = BW;
var nf = {},
  Pa = {},
  Ma = {},
  FN;
function FW() {
  return (
    FN ||
      ((FN = 1),
      Object.defineProperty(Ma, "__esModule", {
        value: !0,
      }),
      (Ma.EVENT_LISTENERS_SET = void 0),
      (Ma.EVENT_LISTENERS_SET = Symbol(
        "opentelemetry.instrumentation.pg.eventListenersSet",
      ))),
    Ma
  );
}
var me = {},
  rf = {},
  YN;
function _v() {
  return (
    YN ||
      ((YN = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.AttributeNames = void 0),
          (function (t) {
            ((t.PG_VALUES = "db.postgresql.values"),
              (t.PG_PLAN = "db.postgresql.plan"),
              (t.IDLE_TIMEOUT_MILLIS = "db.postgresql.idle.timeout.millis"),
              (t.MAX_CLIENT = "db.postgresql.max.client"));
          })(e.AttributeNames || (e.AttributeNames = {})));
      })(rf)),
    rf
  );
}
var Me = {},
  jN;
function pv() {
  return (
    jN ||
      ((jN = 1),
      Object.defineProperty(Me, "__esModule", {
        value: !0,
      }),
      (Me.METRIC_DB_CLIENT_CONNECTION_PENDING_REQUESTS =
        Me.METRIC_DB_CLIENT_CONNECTION_COUNT =
        Me.DB_SYSTEM_VALUE_POSTGRESQL =
        Me.DB_CLIENT_CONNECTION_STATE_VALUE_USED =
        Me.DB_CLIENT_CONNECTION_STATE_VALUE_IDLE =
        Me.ATTR_NET_PEER_PORT =
        Me.ATTR_NET_PEER_NAME =
        Me.ATTR_DB_USER =
        Me.ATTR_DB_SYSTEM =
        Me.ATTR_DB_STATEMENT =
        Me.ATTR_DB_NAME =
        Me.ATTR_DB_CONNECTION_STRING =
        Me.ATTR_DB_CLIENT_CONNECTION_STATE =
        Me.ATTR_DB_CLIENT_CONNECTION_POOL_NAME =
          void 0),
      (Me.ATTR_DB_CLIENT_CONNECTION_POOL_NAME =
        "db.client.connection.pool.name"),
      (Me.ATTR_DB_CLIENT_CONNECTION_STATE = "db.client.connection.state"),
      (Me.ATTR_DB_CONNECTION_STRING = "db.connection_string"),
      (Me.ATTR_DB_NAME = "db.name"),
      (Me.ATTR_DB_STATEMENT = "db.statement"),
      (Me.ATTR_DB_SYSTEM = "db.system"),
      (Me.ATTR_DB_USER = "db.user"),
      (Me.ATTR_NET_PEER_NAME = "net.peer.name"),
      (Me.ATTR_NET_PEER_PORT = "net.peer.port"),
      (Me.DB_CLIENT_CONNECTION_STATE_VALUE_IDLE = "idle"),
      (Me.DB_CLIENT_CONNECTION_STATE_VALUE_USED = "used"),
      (Me.DB_SYSTEM_VALUE_POSTGRESQL = "postgresql"),
      (Me.METRIC_DB_CLIENT_CONNECTION_COUNT = "db.client.connection.count"),
      (Me.METRIC_DB_CLIENT_CONNECTION_PENDING_REQUESTS =
        "db.client.connection.pending_requests")),
    Me
  );
}
var of = {},
  qN;
function Ev() {
  return (
    qN ||
      ((qN = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.SpanNames = void 0),
          (function (t) {
            ((t.QUERY_PREFIX = "pg.query"),
              (t.CONNECT = "pg.connect"),
              (t.POOL_CONNECT = "pg-pool.connect"));
          })(e.SpanNames || (e.SpanNames = {})));
      })(of)),
    of
  );
}
var WN;
function YW() {
  if (WN) return me;
  ((WN = 1),
    Object.defineProperty(me, "__esModule", {
      value: !0,
    }),
    (me.sanitizedErrorMessage =
      me.isObjectWithTextString =
      me.getErrorMessage =
      me.patchClientConnectCallback =
      me.patchCallbackPGPool =
      me.updateCounter =
      me.getPoolName =
      me.patchCallback =
      me.handleExecutionResult =
      me.handleConfigQuery =
      me.shouldSkipInstrumentation =
      me.getSemanticAttributesFromPoolConnection =
      me.getSemanticAttributesFromConnection =
      me.getConnectionString =
      me.parseAndMaskConnectionString =
      me.parseNormalizedOperationName =
      me.getQuerySpanName =
        void 0));
  const e = Pe(),
    t = _v(),
    n = pt(),
    r = pv(),
    o = Le,
    s = Ev();
  function i(b, w) {
    if (!w) return s.SpanNames.QUERY_PREFIX;
    const L = typeof w.name == "string" && w.name ? w.name : a(w.text);
    return `${s.SpanNames.QUERY_PREFIX}:${L}${b ? ` ${b}` : ""}`;
  }
  me.getQuerySpanName = i;
  function a(b) {
    const w = b.indexOf(" ");
    let L = w === -1 ? b : b.slice(0, w);
    return ((L = L.toUpperCase()), L.endsWith(";") ? L.slice(0, -1) : L);
  }
  me.parseNormalizedOperationName = a;
  function c(b) {
    try {
      const w = new URL(b);
      return ((w.username = ""), (w.password = ""), w.toString());
    } catch {
      return "postgresql://localhost:5432/";
    }
  }
  me.parseAndMaskConnectionString = c;
  function l(b) {
    if ("connectionString" in b && b.connectionString)
      return c(b.connectionString);
    const w = b.host || "localhost",
      L = b.port || 5432,
      j = b.database || "";
    return `postgresql://${w}:${L}/${j}`;
  }
  me.getConnectionString = l;
  function f(b) {
    if (Number.isInteger(b)) return b;
  }
  function d(b, w) {
    let L = {};
    return (
      w & o.SemconvStability.OLD &&
        (L = {
          ...L,
          [r.ATTR_DB_SYSTEM]: r.DB_SYSTEM_VALUE_POSTGRESQL,
          [r.ATTR_DB_NAME]: b.database,
          [r.ATTR_DB_CONNECTION_STRING]: l(b),
          [r.ATTR_DB_USER]: b.user,
          [r.ATTR_NET_PEER_NAME]: b.host,
          [r.ATTR_NET_PEER_PORT]: f(b.port),
        }),
      w & o.SemconvStability.STABLE &&
        (L = {
          ...L,
          [n.ATTR_DB_SYSTEM_NAME]: n.DB_SYSTEM_NAME_VALUE_POSTGRESQL,
          [n.ATTR_DB_NAMESPACE]: b.namespace,
          [n.ATTR_SERVER_ADDRESS]: b.host,
          [n.ATTR_SERVER_PORT]: f(b.port),
        }),
      L
    );
  }
  me.getSemanticAttributesFromConnection = d;
  function u(b, w) {
    let L;
    try {
      L = b.connectionString ? new URL(b.connectionString) : void 0;
    } catch {
      L = void 0;
    }
    let j = {
      [t.AttributeNames.IDLE_TIMEOUT_MILLIS]: b.idleTimeoutMillis,
      [t.AttributeNames.MAX_CLIENT]: b.maxClient,
    };
    return (
      w & o.SemconvStability.OLD &&
        (j = {
          ...j,
          [r.ATTR_DB_SYSTEM]: r.DB_SYSTEM_VALUE_POSTGRESQL,
          [r.ATTR_DB_NAME]: L?.pathname.slice(1) ?? b.database,
          [r.ATTR_DB_CONNECTION_STRING]: l(b),
          [r.ATTR_NET_PEER_NAME]: L?.hostname ?? b.host,
          [r.ATTR_NET_PEER_PORT]: Number(L?.port) || f(b.port),
          [r.ATTR_DB_USER]: L?.username ?? b.user,
        }),
      w & o.SemconvStability.STABLE &&
        (j = {
          ...j,
          [n.ATTR_DB_SYSTEM_NAME]: n.DB_SYSTEM_NAME_VALUE_POSTGRESQL,
          [n.ATTR_DB_NAMESPACE]: b.namespace,
          [n.ATTR_SERVER_ADDRESS]: L?.hostname ?? b.host,
          [n.ATTR_SERVER_PORT]: Number(L?.port) || f(b.port),
        }),
      j
    );
  }
  me.getSemanticAttributesFromPoolConnection = u;
  function _(b) {
    return (
      b.requireParentSpan === !0 &&
      e.trace.getSpan(e.context.active()) === void 0
    );
  }
  me.shouldSkipInstrumentation = _;
  function p(b, w, L, j) {
    const { connectionParameters: H } = this,
      x = H.database,
      B = i(x, j),
      F = b.startSpan(B, {
        kind: e.SpanKind.CLIENT,
        attributes: d(H, L),
      });
    if (!j) return F;
    if (
      (j.text &&
        (L & o.SemconvStability.OLD &&
          F.setAttribute(r.ATTR_DB_STATEMENT, j.text),
        L & o.SemconvStability.STABLE &&
          F.setAttribute(n.ATTR_DB_QUERY_TEXT, j.text)),
      w.enhancedDatabaseReporting && Array.isArray(j.values))
    )
      try {
        const U = j.values.map((k) =>
          k == null
            ? "null"
            : k instanceof Buffer
              ? k.toString()
              : typeof k == "object"
                ? typeof k.toPostgres == "function"
                  ? k.toPostgres()
                  : JSON.stringify(k)
                : k.toString(),
        );
        F.setAttribute(t.AttributeNames.PG_VALUES, U);
      } catch (U) {
        e.diag.error("failed to stringify ", j.values, U);
      }
    return (
      typeof j.name == "string" &&
        F.setAttribute(t.AttributeNames.PG_PLAN, j.name),
      F
    );
  }
  me.handleConfigQuery = p;
  function E(b, w, L) {
    typeof b.responseHook == "function" &&
      (0, o.safeExecuteInTheMiddle)(
        () => {
          b.responseHook(w, {
            data: L,
          });
        },
        (j) => {
          j && e.diag.error("Error running response hook", j);
        },
        !0,
      );
  }
  me.handleExecutionResult = E;
  function h(b, w, L, j, H) {
    return function (B, F) {
      (B
        ? (Object.prototype.hasOwnProperty.call(B, "code") &&
            (j[n.ATTR_ERROR_TYPE] = B.code),
          B instanceof Error && w.recordException(I(B)),
          w.setStatus({
            code: e.SpanStatusCode.ERROR,
            message: B.message,
          }))
        : E(b, w, F),
        H(),
        w.end(),
        L.call(this, B, F));
    };
  }
  me.patchCallback = h;
  function T(b) {
    let w = "";
    return (
      (w += (b?.host ? `${b.host}` : "unknown_host") + ":"),
      (w += (b?.port ? `${b.port}` : "unknown_port") + "/"),
      (w += b?.database ? `${b.database}` : "unknown_database"),
      w.trim()
    );
  }
  me.getPoolName = T;
  function m(b, w, L, j, H) {
    const x = w.totalCount,
      B = w.waitingCount,
      F = w.idleCount,
      U = x - F;
    return (
      L.add(U - H.used, {
        [r.ATTR_DB_CLIENT_CONNECTION_STATE]:
          r.DB_CLIENT_CONNECTION_STATE_VALUE_USED,
        [r.ATTR_DB_CLIENT_CONNECTION_POOL_NAME]: b,
      }),
      L.add(F - H.idle, {
        [r.ATTR_DB_CLIENT_CONNECTION_STATE]:
          r.DB_CLIENT_CONNECTION_STATE_VALUE_IDLE,
        [r.ATTR_DB_CLIENT_CONNECTION_POOL_NAME]: b,
      }),
      j.add(B - H.pending, {
        [r.ATTR_DB_CLIENT_CONNECTION_POOL_NAME]: b,
      }),
      {
        used: U,
        idle: F,
        pending: B,
      }
    );
  }
  me.updateCounter = m;
  function A(b, w) {
    return function (j, H, x) {
      (j &&
        (j instanceof Error && b.recordException(I(j)),
        b.setStatus({
          code: e.SpanStatusCode.ERROR,
          message: j.message,
        })),
        b.end(),
        w.call(this, j, H, x));
    };
  }
  me.patchCallbackPGPool = A;
  function g(b, w) {
    return function (j) {
      (j &&
        (j instanceof Error && b.recordException(I(j)),
        b.setStatus({
          code: e.SpanStatusCode.ERROR,
          message: j.message,
        })),
        b.end(),
        w.apply(this, arguments));
    };
  }
  me.patchClientConnectCallback = g;
  function N(b) {
    return typeof b == "object" && b !== null && "message" in b
      ? String(b.message)
      : void 0;
  }
  me.getErrorMessage = N;
  function O(b) {
    return typeof b == "object" && typeof b?.text == "string";
  }
  me.isObjectWithTextString = O;
  function I(b) {
    const w = b?.name ?? "PostgreSQLError",
      L = b?.code ?? "UNKNOWN";
    return `PostgreSQL error of type '${w}' occurred (code: ${L})`;
  }
  return ((me.sanitizedErrorMessage = I), me);
}
var Ur = {},
  KN;
function jW() {
  return (
    KN ||
      ((KN = 1),
      Object.defineProperty(Ur, "__esModule", {
        value: !0,
      }),
      (Ur.PACKAGE_NAME = Ur.PACKAGE_VERSION = void 0),
      (Ur.PACKAGE_VERSION = "0.61.0"),
      (Ur.PACKAGE_NAME = "@opentelemetry/instrumentation-pg")),
    Ur
  );
}
var zN;
function qW() {
  if (zN) return Pa;
  ((zN = 1),
    Object.defineProperty(Pa, "__esModule", {
      value: !0,
    }),
    (Pa.PgInstrumentation = void 0));
  const e = Le,
    t = Pe(),
    n = FW(),
    r = YW(),
    o = cv(),
    s = jW(),
    i = Ev(),
    a = un,
    c = pt(),
    l = pv();
  function f(_) {
    return _[Symbol.toStringTag] === "Module" ? _.default : _;
  }
  class d extends e.InstrumentationBase {
    _connectionsCounter = {
      used: 0,
      idle: 0,
      pending: 0,
    };
    _semconvStability;
    constructor(p = {}) {
      (super(s.PACKAGE_NAME, s.PACKAGE_VERSION, p),
        (this._semconvStability = (0, e.semconvStabilityFromStr)(
          "database",
          process.env.OTEL_SEMCONV_STABILITY_OPT_IN,
        )));
    }
    _updateMetricInstruments() {
      ((this._operationDuration = this.meter.createHistogram(
        c.METRIC_DB_CLIENT_OPERATION_DURATION,
        {
          description: "Duration of database client operations.",
          unit: "s",
          valueType: t.ValueType.DOUBLE,
          advice: {
            explicitBucketBoundaries: [
              0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 5, 10,
            ],
          },
        },
      )),
        (this._connectionsCounter = {
          idle: 0,
          pending: 0,
          used: 0,
        }),
        (this._connectionsCount = this.meter.createUpDownCounter(
          l.METRIC_DB_CLIENT_CONNECTION_COUNT,
          {
            description:
              "The number of connections that are currently in state described by the state attribute.",
            unit: "{connection}",
          },
        )),
        (this._connectionPendingRequests = this.meter.createUpDownCounter(
          l.METRIC_DB_CLIENT_CONNECTION_PENDING_REQUESTS,
          {
            description:
              "The number of current pending requests for an open connection.",
            unit: "{connection}",
          },
        )));
    }
    init() {
      const p = [">=8.0.3 <9"],
        E = [">=2.0.0 <4"],
        h = new e.InstrumentationNodeModuleFile(
          "pg/lib/native/client.js",
          p,
          this._patchPgClient.bind(this),
          this._unpatchPgClient.bind(this),
        ),
        T = new e.InstrumentationNodeModuleFile(
          "pg/lib/client.js",
          p,
          this._patchPgClient.bind(this),
          this._unpatchPgClient.bind(this),
        ),
        m = new e.InstrumentationNodeModuleDefinition(
          "pg",
          p,
          (g) => {
            const N = f(g);
            return (this._patchPgClient(N.Client), g);
          },
          (g) => {
            const N = f(g);
            return (this._unpatchPgClient(N.Client), g);
          },
          [T, h],
        ),
        A = new e.InstrumentationNodeModuleDefinition(
          "pg-pool",
          E,
          (g) => {
            const N = f(g);
            return (
              (0, e.isWrapped)(N.prototype.connect) &&
                this._unwrap(N.prototype, "connect"),
              this._wrap(N.prototype, "connect", this._getPoolConnectPatch()),
              N
            );
          },
          (g) => {
            const N = f(g);
            (0, e.isWrapped)(N.prototype.connect) &&
              this._unwrap(N.prototype, "connect");
          },
        );
      return [m, A];
    }
    _patchPgClient(p) {
      if (!p) return;
      const E = f(p);
      return (
        (0, e.isWrapped)(E.prototype.query) &&
          this._unwrap(E.prototype, "query"),
        (0, e.isWrapped)(E.prototype.connect) &&
          this._unwrap(E.prototype, "connect"),
        this._wrap(E.prototype, "query", this._getClientQueryPatch()),
        this._wrap(E.prototype, "connect", this._getClientConnectPatch()),
        p
      );
    }
    _unpatchPgClient(p) {
      const E = f(p);
      return (
        (0, e.isWrapped)(E.prototype.query) &&
          this._unwrap(E.prototype, "query"),
        (0, e.isWrapped)(E.prototype.connect) &&
          this._unwrap(E.prototype, "connect"),
        p
      );
    }
    _getClientConnectPatch() {
      const p = this;
      return (E) =>
        function (T) {
          if (r.shouldSkipInstrumentation(p.getConfig()))
            return E.call(this, T);
          const m = p.tracer.startSpan(i.SpanNames.CONNECT, {
            kind: t.SpanKind.CLIENT,
            attributes: r.getSemanticAttributesFromConnection(
              this,
              p._semconvStability,
            ),
          });
          if (T) {
            const g = t.trace.getSpan(t.context.active());
            ((T = r.patchClientConnectCallback(m, T)),
              g && (T = t.context.bind(t.context.active(), T)));
          }
          const A = t.context.with(t.trace.setSpan(t.context.active(), m), () =>
            E.call(this, T),
          );
          return u(m, A);
        };
    }
    recordOperationDuration(p, E) {
      const h = {},
        T = [
          c.ATTR_DB_NAMESPACE,
          c.ATTR_ERROR_TYPE,
          c.ATTR_SERVER_PORT,
          c.ATTR_SERVER_ADDRESS,
          c.ATTR_DB_OPERATION_NAME,
        ];
      (this._semconvStability & e.SemconvStability.OLD &&
        T.push(l.ATTR_DB_SYSTEM),
        this._semconvStability & e.SemconvStability.STABLE &&
          T.push(c.ATTR_DB_SYSTEM_NAME),
        T.forEach((A) => {
          A in p && (h[A] = p[A]);
        }));
      const m =
        (0, a.hrTimeToMilliseconds)((0, a.hrTimeDuration)(E, (0, a.hrTime)())) /
        1e3;
      this._operationDuration.record(m, h);
    }
    _getClientQueryPatch() {
      const p = this;
      return (E) => (
        this._diag.debug("Patching pg.Client.prototype.query"),
        function (...T) {
          if (r.shouldSkipInstrumentation(p.getConfig()))
            return E.apply(this, T);
          const m = (0, a.hrTime)(),
            A = T[0],
            g = typeof A == "string",
            N = r.isObjectWithTextString(A),
            O = g
              ? {
                  text: A,
                  values: Array.isArray(T[1]) ? T[1] : void 0,
                }
              : N
                ? A
                : void 0,
            I = {
              [l.ATTR_DB_SYSTEM]: l.DB_SYSTEM_VALUE_POSTGRESQL,
              [c.ATTR_DB_NAMESPACE]: this.database,
              [c.ATTR_SERVER_PORT]: this.connectionParameters.port,
              [c.ATTR_SERVER_ADDRESS]: this.connectionParameters.host,
            };
          O?.text &&
            (I[c.ATTR_DB_OPERATION_NAME] = r.parseNormalizedOperationName(
              O?.text,
            ));
          const b = () => {
              p.recordOperationDuration(I, m);
            },
            w = p.getConfig(),
            L = r.handleConfigQuery.call(
              this,
              p.tracer,
              w,
              p._semconvStability,
              O,
            );
          if (
            (w.addSqlCommenterCommentToQueries &&
              (g
                ? (T[0] = (0, o.addSqlCommenterComment)(L, A))
                : N &&
                  !("name" in A) &&
                  (T[0] = {
                    ...A,
                    text: (0, o.addSqlCommenterComment)(L, A.text),
                  })),
            T.length > 0)
          ) {
            const x = t.trace.getSpan(t.context.active());
            if (typeof T[T.length - 1] == "function")
              ((T[T.length - 1] = r.patchCallback(w, L, T[T.length - 1], I, b)),
                x &&
                  (T[T.length - 1] = t.context.bind(
                    t.context.active(),
                    T[T.length - 1],
                  )));
            else if (typeof O?.callback == "function") {
              let B = r.patchCallback(p.getConfig(), L, O.callback, I, b);
              (x && (B = t.context.bind(t.context.active(), B)),
                (T[0].callback = B));
            }
          }
          const { requestHook: j } = w;
          typeof j == "function" &&
            O &&
            (0, e.safeExecuteInTheMiddle)(
              () => {
                const {
                  database: x,
                  host: B,
                  port: F,
                  user: U,
                } = this.connectionParameters;
                j(L, {
                  connection: {
                    database: x,
                    host: B,
                    port: F,
                    user: U,
                  },
                  query: {
                    text: O.text,
                    values: O.values,
                    name: O.name,
                  },
                });
              },
              (x) => {
                x && p._diag.error("Error running query hook", x);
              },
              !0,
            );
          let H;
          try {
            H = E.apply(this, T);
          } catch (x) {
            throw (
              x instanceof Error &&
                L.recordException(r.sanitizedErrorMessage(x)),
              L.setStatus({
                code: t.SpanStatusCode.ERROR,
                message: r.getErrorMessage(x),
              }),
              L.end(),
              x
            );
          }
          return H instanceof Promise
            ? H.then(
                (x) =>
                  new Promise((B) => {
                    (r.handleExecutionResult(p.getConfig(), L, x),
                      b(),
                      L.end(),
                      B(x));
                  }),
              ).catch(
                (x) =>
                  new Promise((B, F) => {
                    (x instanceof Error &&
                      L.recordException(r.sanitizedErrorMessage(x)),
                      L.setStatus({
                        code: t.SpanStatusCode.ERROR,
                        message: x.message,
                      }),
                      b(),
                      L.end(),
                      F(x));
                  }),
              )
            : H;
        }
      );
    }
    _setPoolConnectEventListeners(p) {
      if (p[n.EVENT_LISTENERS_SET]) return;
      const E = r.getPoolName(p.options);
      (p.on("connect", () => {
        this._connectionsCounter = r.updateCounter(
          E,
          p,
          this._connectionsCount,
          this._connectionPendingRequests,
          this._connectionsCounter,
        );
      }),
        p.on("acquire", () => {
          this._connectionsCounter = r.updateCounter(
            E,
            p,
            this._connectionsCount,
            this._connectionPendingRequests,
            this._connectionsCounter,
          );
        }),
        p.on("remove", () => {
          this._connectionsCounter = r.updateCounter(
            E,
            p,
            this._connectionsCount,
            this._connectionPendingRequests,
            this._connectionsCounter,
          );
        }),
        p.on("release", () => {
          this._connectionsCounter = r.updateCounter(
            E,
            p,
            this._connectionsCount,
            this._connectionPendingRequests,
            this._connectionsCounter,
          );
        }),
        (p[n.EVENT_LISTENERS_SET] = !0));
    }
    _getPoolConnectPatch() {
      const p = this;
      return (E) =>
        function (T) {
          if (r.shouldSkipInstrumentation(p.getConfig()))
            return E.call(this, T);
          const m = p.tracer.startSpan(i.SpanNames.POOL_CONNECT, {
            kind: t.SpanKind.CLIENT,
            attributes: r.getSemanticAttributesFromPoolConnection(
              this.options,
              p._semconvStability,
            ),
          });
          if ((p._setPoolConnectEventListeners(this), T)) {
            const g = t.trace.getSpan(t.context.active());
            ((T = r.patchCallbackPGPool(m, T)),
              g && (T = t.context.bind(t.context.active(), T)));
          }
          const A = t.context.with(t.trace.setSpan(t.context.active(), m), () =>
            E.call(this, T),
          );
          return u(m, A);
        };
    }
  }
  Pa.PgInstrumentation = d;
  function u(_, p) {
    if (!(p instanceof Promise)) return p;
    const E = p;
    return t.context.bind(
      t.context.active(),
      E.then((h) => (_.end(), h)).catch(
        (h) => (
          h instanceof Error && _.recordException(r.sanitizedErrorMessage(h)),
          _.setStatus({
            code: t.SpanStatusCode.ERROR,
            message: r.getErrorMessage(h),
          }),
          _.end(),
          Promise.reject(h)
        ),
      ),
    );
  }
  return Pa;
}
var ZN;
function WW() {
  return (
    ZN ||
      ((ZN = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.AttributeNames = e.PgInstrumentation = void 0));
        var t = qW();
        Object.defineProperty(e, "PgInstrumentation", {
          enumerable: !0,
          get: function () {
            return t.PgInstrumentation;
          },
        });
        var n = _v();
        Object.defineProperty(e, "AttributeNames", {
          enumerable: !0,
          get: function () {
            return n.AttributeNames;
          },
        });
      })(nf)),
    nf
  );
}
var KW = WW();
const hv = "Postgres",
  zW = Ne(
    hv,
    () =>
      new KW.PgInstrumentation({
        requireParentSpan: !0,
        requestHook(e) {
          yt(e, "auto.db.otel.postgres");
        },
      }),
  ),
  ZW = () => ({
    name: hv,
    setupOnce() {
      zW();
    },
  }),
  XW = ZW,
  nh = "PostgresJs",
  XN = [">=3.0.0 <4"],
  QW = Ne(
    nh,
    (e) =>
      new JW({
        requireParentSpan: e?.requireParentSpan ?? !0,
        requestHook: e?.requestHook,
      }),
  );
class JW extends Ot {
  constructor(t) {
    super("sentry-postgres-js", Ze, t);
  }
  init() {
    const t = new ft("postgres", XN);
    return (
      ["src", "cf/src", "cjs/src"].forEach((n) => {
        (t.files.push(
          new Bn(
            `postgres/${n}/connection.js`,
            ["*"],
            this._patchConnection.bind(this),
            this._unwrap.bind(this),
          ),
        ),
          t.files.push(
            new Bn(
              `postgres/${n}/query.js`,
              XN,
              this._patchQuery.bind(this),
              this._unwrap.bind(this),
            ),
          ));
      }),
      [t]
    );
  }
  _shouldCreateSpans() {
    const t = this.getConfig();
    return (
      C.trace.getSpan(C.context.active()) !== void 0 || !t.requireParentSpan
    );
  }
  _patchReject(t, n) {
    return new Proxy(t, {
      apply: (r, o, s) => {
        n.setStatus({
          code: Ae,
          message: s?.[0]?.message || "internal_error",
        });
        const i = Reflect.apply(r, o, s);
        return (
          n.setAttribute(
            Q.ATTR_DB_RESPONSE_STATUS_CODE,
            s?.[0]?.code || "Unknown error",
          ),
          n.setAttribute(Q.ATTR_ERROR_TYPE, s?.[0]?.name || "Unknown error"),
          n.end(),
          i
        );
      },
    });
  }
  _patchResolve(t, n) {
    return new Proxy(t, {
      apply: (r, o, s) => {
        const i = Reflect.apply(r, o, s),
          a = s?.[0]?.command;
        return (a && n.setAttribute(Q.ATTR_DB_OPERATION_NAME, a), n.end(), i);
      },
    });
  }
  _patchQuery(t) {
    return (
      (t.Query.prototype.handle = new Proxy(t.Query.prototype.handle, {
        apply: async (n, r, o) => {
          if (!this._shouldCreateSpans()) return Reflect.apply(n, r, o);
          const s = this._sanitizeSqlQuery(r.strings?.[0]);
          return Gn(
            {
              name: s || "postgresjs.query",
              op: "db",
            },
            (i) => {
              const c = Ke().getScopeData().contexts.postgresjsConnection;
              yt(i, "auto.db.otel.postgres");
              const { requestHook: l } = this.getConfig();
              l &&
                er(
                  () => l(i, s, c),
                  (_) => {
                    _ &&
                      $.error(`Error in requestHook for ${nh} integration:`, _);
                  },
                );
              const f = c?.ATTR_DB_NAMESPACE || "<unknown database>",
                d = c?.ATTR_SERVER_ADDRESS || "<unknown host>",
                u = c?.ATTR_SERVER_PORT || "<unknown port>";
              (i.setAttribute(Q.ATTR_DB_SYSTEM_NAME, "postgres"),
                i.setAttribute(Q.ATTR_DB_NAMESPACE, f),
                i.setAttribute(Q.ATTR_SERVER_ADDRESS, d),
                i.setAttribute(Q.ATTR_SERVER_PORT, u),
                i.setAttribute(Q.ATTR_DB_QUERY_TEXT, s),
                (r.resolve = this._patchResolve(r.resolve, i)),
                (r.reject = this._patchReject(r.reject, i)));
              try {
                return Reflect.apply(n, r, o);
              } catch (_) {
                throw (
                  i.setStatus({
                    code: Ae,
                  }),
                  i.end(),
                  _
                );
              }
            },
          );
        },
      })),
      t
    );
  }
  _patchConnection(t) {
    return new Proxy(t, {
      apply: (n, r, o) => {
        const s = o[0]?.database || "<unknown database>",
          i = o[0]?.host?.[0] || "<unknown host>",
          a = o[0]?.port?.[0] || "<unknown port>";
        return (
          Ke().setContext("postgresjsConnection", {
            ATTR_DB_NAMESPACE: s,
            ATTR_SERVER_ADDRESS: i,
            ATTR_SERVER_PORT: a,
          }),
          Reflect.apply(n, r, o)
        );
      },
    });
  }
  _sanitizeSqlQuery(t) {
    return t
      ? t
          .replace(/\s+/g, " ")
          .trim()
          .substring(0, 1024)
          .replace(/--.*?(\r?\n|$)/g, "")
          .replace(/\/\*[\s\S]*?\*\//g, "")
          .replace(/;\s*$/, "")
          .replace(/\b\d+\b/g, "?")
          .replace(/\s+/g, " ")
          .replace(/\bIN\b\s*\(\s*\?(?:\s*,\s*\?)*\s*\)/g, "IN (?)")
      : "Unknown SQL Query";
  }
}
const eK = () => ({
    name: nh,
    setupOnce() {
      QW();
    },
  }),
  tK = eK;
var nK = process.env.PRISMA_SHOW_ALL_TRACES === "true",
  rK = "00-10-10-00";
function oK(e) {
  switch (e) {
    case "client":
      return C.SpanKind.CLIENT;
    case "internal":
    default:
      return C.SpanKind.INTERNAL;
  }
}
var sK = class {
  tracerProvider;
  ignoreSpanTypes;
  constructor({ tracerProvider: e, ignoreSpanTypes: t }) {
    ((this.tracerProvider = e), (this.ignoreSpanTypes = t));
  }
  isEnabled() {
    return !0;
  }
  getTraceParent(e) {
    const t = C.trace.getSpanContext(e ?? C.context.active());
    return t ? `00-${t.traceId}-${t.spanId}-0${t.traceFlags}` : rK;
  }
  dispatchEngineSpans(e) {
    const t = this.tracerProvider.getTracer("prisma"),
      n = new Map(),
      r = e.filter((o) => o.parentId === null);
    for (const o of r) Tv(t, o, e, n, this.ignoreSpanTypes);
  }
  getActiveContext() {
    return C.context.active();
  }
  runInChildSpan(e, t) {
    if (
      (typeof e == "string" &&
        (e = {
          name: e,
        }),
      e.internal && !nK)
    )
      return t();
    const n = this.tracerProvider.getTracer("prisma"),
      r = e.context ?? this.getActiveContext(),
      o = `prisma:client:${e.name}`;
    if (Sv(o, this.ignoreSpanTypes)) return t();
    if (e.active === !1) {
      const s = n.startSpan(o, e, r);
      return QN(s, t(s, r));
    }
    return n.startActiveSpan(o, e, (s) => QN(s, t(s, r)));
  }
};
function Tv(e, t, n, r, o) {
  if (Sv(t.name, o)) return;
  const s = {
    attributes: t.attributes,
    kind: oK(t.kind),
    startTime: t.startTime,
  };
  e.startActiveSpan(t.name, s, (i) => {
    (r.set(t.id, i.spanContext().spanId),
      t.links &&
        i.addLinks(
          t.links.flatMap((c) => {
            const l = r.get(c);
            return l
              ? {
                  context: {
                    spanId: l,
                    traceId: i.spanContext().traceId,
                    traceFlags: i.spanContext().traceFlags,
                  },
                }
              : [];
          }),
        ));
    const a = n.filter((c) => c.parentId === t.id);
    for (const c of a) Tv(e, c, n, r, o);
    i.end(t.endTime);
  });
}
function QN(e, t) {
  return iK(t)
    ? t.then(
        (n) => (e.end(), n),
        (n) => {
          throw (e.end(), n);
        },
      )
    : (e.end(), t);
}
function iK(e) {
  return e != null && typeof e.then == "function";
}
function Sv(e, t) {
  return t.some((n) => (typeof n == "string" ? n === e : n.test(e)));
}
var mv = {
    name: "@prisma/instrumentation",
    version: "6.19.0",
  },
  wp = mv.version,
  aK = wp.split(".")[0],
  JN = "PRISMA_INSTRUMENTATION",
  sf = `V${aK}_PRISMA_INSTRUMENTATION`,
  cK = mv.name,
  uK = "@prisma/client",
  lK = class extends Ot {
    tracerProvider;
    constructor(e = {}) {
      super(cK, wp, e);
    }
    setTracerProvider(e) {
      this.tracerProvider = e;
    }
    init() {
      return [new ft(uK, [wp])];
    }
    enable() {
      const e = this._config,
        t = {
          helper: new sK({
            tracerProvider: this.tracerProvider ?? C.trace.getTracerProvider(),
            ignoreSpanTypes: e.ignoreSpanTypes ?? [],
          }),
        };
      ((global[JN] = t), (global[sf] = t));
    }
    disable() {
      (delete global[JN], delete global[sf]);
    }
    isEnabled() {
      return !!global[sf];
    }
  };
const Av = "Prisma";
function dK(e) {
  return !!e && typeof e == "object" && "dispatchEngineSpans" in e;
}
function gv() {
  const e = globalThis.PRISMA_INSTRUMENTATION;
  return e && typeof e == "object" && "helper" in e ? e.helper : void 0;
}
class fK extends lK {
  constructor() {
    super();
  }
  enable() {
    super.enable();
    const t = gv();
    dK(t) &&
      (t.createEngineSpan = (n) => {
        const r = C.trace.getTracer("prismaV5Compatibility"),
          o = r._idGenerator;
        if (!o) {
          on(() => {
            console.warn(
              "[Sentry] Could not find _idGenerator on tracer, skipping Prisma v5 compatibility - some Prisma spans may be missing!",
            );
          });
          return;
        }
        try {
          n.spans.forEach((s) => {
            const i = _K(s.kind),
              a = s.parent_span_id,
              c = s.span_id,
              l = s.trace_id,
              f = s.links?.map((u) => ({
                context: {
                  traceId: u.trace_id,
                  spanId: u.span_id,
                  traceFlags: C.TraceFlags.SAMPLED,
                },
              })),
              d = C.trace.setSpanContext(C.context.active(), {
                traceId: l,
                spanId: a,
                traceFlags: C.TraceFlags.SAMPLED,
              });
            C.context.with(d, () => {
              const u = {
                generateTraceId: () => l,
                generateSpanId: () => c,
              };
              ((r._idGenerator = u),
                r
                  .startSpan(s.name, {
                    kind: i,
                    links: f,
                    startTime: s.start_time,
                    attributes: s.attributes,
                  })
                  .end(s.end_time),
                (r._idGenerator = o));
            });
          });
        } finally {
          r._idGenerator = o;
        }
      });
  }
}
function _K(e) {
  switch (e) {
    case "client":
      return C.SpanKind.CLIENT;
    case "internal":
    default:
      return C.SpanKind.INTERNAL;
  }
}
const pK = Ne(Av, (e) => new fK()),
  EK = (e) => ({
    name: Av,
    setupOnce() {
      pK();
    },
    setup(t) {
      gv() &&
        t.on("spanStart", (n) => {
          const r = Re(n);
          (r.description?.startsWith("prisma:") &&
            n.setAttribute(Ge, "auto.db.otel.prisma"),
            r.description === "prisma:engine:db_query" &&
              r.data["db.query.text"] &&
              n.updateName(r.data["db.query.text"]),
            r.description === "prisma:engine:db_query" &&
              !r.data["db.system"] &&
              n.setAttribute("db.system", "prisma"));
        });
    },
  });
var af = {},
  va = {},
  kr = {},
  ey;
function hK() {
  return (
    ey ||
      ((ey = 1),
      Object.defineProperty(kr, "__esModule", {
        value: !0,
      }),
      (kr.PACKAGE_NAME = kr.PACKAGE_VERSION = void 0),
      (kr.PACKAGE_VERSION = "0.55.0"),
      (kr.PACKAGE_NAME = "@opentelemetry/instrumentation-hapi")),
    kr
  );
}
var tn = {},
  ty;
function Rv() {
  return (
    ty ||
      ((ty = 1),
      Object.defineProperty(tn, "__esModule", {
        value: !0,
      }),
      (tn.HapiLifecycleMethodNames =
        tn.HapiLayerType =
        tn.handlerPatched =
        tn.HapiComponentName =
          void 0),
      (tn.HapiComponentName = "@hapi/hapi"),
      (tn.handlerPatched = Symbol("hapi-handler-patched")),
      (tn.HapiLayerType = {
        ROUTER: "router",
        PLUGIN: "plugin",
        EXT: "server.ext",
      }),
      (tn.HapiLifecycleMethodNames = new Set([
        "onPreAuth",
        "onCredentials",
        "onPostAuth",
        "onPreHandler",
        "onPostHandler",
        "onPreResponse",
        "onRequest",
      ]))),
    tn
  );
}
var cf = {},
  La = {},
  ny;
function TK() {
  return (
    ny ||
      ((ny = 1),
      Object.defineProperty(La, "__esModule", {
        value: !0,
      }),
      (La.ATTR_HTTP_METHOD = void 0),
      (La.ATTR_HTTP_METHOD = "http.method")),
    La
  );
}
var uf = {},
  ry;
function Nv() {
  return (
    ry ||
      ((ry = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.AttributeNames = void 0),
          (function (t) {
            ((t.HAPI_TYPE = "hapi.type"),
              (t.PLUGIN_NAME = "hapi.plugin.name"),
              (t.EXT_TYPE = "server.ext.type"));
          })(e.AttributeNames || (e.AttributeNames = {})));
      })(uf)),
    uf
  );
}
var oy;
function SK() {
  return (
    oy ||
      ((oy = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.getPluginFromInput =
            e.getExtMetadata =
            e.getRouteMetadata =
            e.isPatchableExtMethod =
            e.isDirectExtInput =
            e.isLifecycleExtEventObj =
            e.isLifecycleExtType =
            e.getPluginName =
              void 0));
        const t = pt(),
          n = TK(),
          r = Rv(),
          o = Nv(),
          s = Le;
        function i(p) {
          return p.name ? p.name : p.pkg.name;
        }
        e.getPluginName = i;
        const a = (p) =>
          typeof p == "string" && r.HapiLifecycleMethodNames.has(p);
        e.isLifecycleExtType = a;
        const c = (p) => {
          const E = p?.type;
          return E !== void 0 && (0, e.isLifecycleExtType)(E);
        };
        e.isLifecycleExtEventObj = c;
        const l = (p) =>
          Array.isArray(p) &&
          p.length <= 3 &&
          (0, e.isLifecycleExtType)(p[0]) &&
          typeof p[1] == "function";
        e.isDirectExtInput = l;
        const f = (p) => !Array.isArray(p);
        e.isPatchableExtMethod = f;
        const d = (p, E, h) => {
          const T = {
            [t.ATTR_HTTP_ROUTE]: p.path,
          };
          (E & s.SemconvStability.OLD && (T[n.ATTR_HTTP_METHOD] = p.method),
            E & s.SemconvStability.STABLE &&
              (T[t.ATTR_HTTP_REQUEST_METHOD] = p.method));
          let m;
          return (
            h
              ? ((T[o.AttributeNames.HAPI_TYPE] = r.HapiLayerType.PLUGIN),
                (T[o.AttributeNames.PLUGIN_NAME] = h),
                (m = `${h}: route - ${p.path}`))
              : ((T[o.AttributeNames.HAPI_TYPE] = r.HapiLayerType.ROUTER),
                (m = `route - ${p.path}`)),
            {
              attributes: T,
              name: m,
            }
          );
        };
        e.getRouteMetadata = d;
        const u = (p, E) =>
          E
            ? {
                attributes: {
                  [o.AttributeNames.EXT_TYPE]: p,
                  [o.AttributeNames.HAPI_TYPE]: r.HapiLayerType.EXT,
                  [o.AttributeNames.PLUGIN_NAME]: E,
                },
                name: `${E}: ext - ${p}`,
              }
            : {
                attributes: {
                  [o.AttributeNames.EXT_TYPE]: p,
                  [o.AttributeNames.HAPI_TYPE]: r.HapiLayerType.EXT,
                },
                name: `ext - ${p}`,
              };
        e.getExtMetadata = u;
        const _ = (p) =>
          "plugin" in p
            ? "plugin" in p.plugin
              ? p.plugin.plugin
              : p.plugin
            : p;
        e.getPluginFromInput = _;
      })(cf)),
    cf
  );
}
var sy;
function mK() {
  if (sy) return va;
  ((sy = 1),
    Object.defineProperty(va, "__esModule", {
      value: !0,
    }),
    (va.HapiInstrumentation = void 0));
  const e = Pe(),
    t = un,
    n = Le,
    r = hK(),
    o = Rv(),
    s = SK();
  class i extends n.InstrumentationBase {
    _semconvStability;
    constructor(c = {}) {
      (super(r.PACKAGE_NAME, r.PACKAGE_VERSION, c),
        (this._semconvStability = (0, n.semconvStabilityFromStr)(
          "http",
          process.env.OTEL_SEMCONV_STABILITY_OPT_IN,
        )));
    }
    init() {
      return new n.InstrumentationNodeModuleDefinition(
        o.HapiComponentName,
        [">=17.0.0 <22"],
        (c) => {
          const l = c[Symbol.toStringTag] === "Module" ? c.default : c;
          return (
            (0, n.isWrapped)(l.server) ||
              this._wrap(l, "server", this._getServerPatch.bind(this)),
            (0, n.isWrapped)(l.Server) ||
              this._wrap(l, "Server", this._getServerPatch.bind(this)),
            l
          );
        },
        (c) => {
          const l = c[Symbol.toStringTag] === "Module" ? c.default : c;
          this._massUnwrap([l], ["server", "Server"]);
        },
      );
    }
    _getServerPatch(c) {
      const l = this,
        f = this;
      return function (u) {
        const _ = c.apply(this, [u]);
        return (
          f._wrap(_, "route", (p) => l._getServerRoutePatch.bind(l)(p)),
          f._wrap(_, "ext", (p) => l._getServerExtPatch.bind(l)(p)),
          f._wrap(_, "register", l._getServerRegisterPatch.bind(l)),
          _
        );
      };
    }
    _getServerRegisterPatch(c) {
      const l = this;
      return function (d, u) {
        if (Array.isArray(d))
          for (const _ of d) {
            const p = (0, s.getPluginFromInput)(_);
            l._wrapRegisterHandler(p);
          }
        else {
          const _ = (0, s.getPluginFromInput)(d);
          l._wrapRegisterHandler(_);
        }
        return c.apply(this, [d, u]);
      };
    }
    _getServerExtPatch(c, l) {
      const f = this;
      return function (...u) {
        if (Array.isArray(u[0])) {
          const _ = u[0];
          for (let p = 0; p < _.length; p++) {
            const E = _[p];
            if ((0, s.isLifecycleExtType)(E.type)) {
              const h = E,
                T = f._wrapExtMethods(h.method, E.type, l);
              ((h.method = T), (_[p] = h));
            }
          }
          return c.apply(this, u);
        } else if ((0, s.isDirectExtInput)(u)) {
          const _ = u,
            p = _[1],
            E = f._wrapExtMethods(p, _[0], l);
          return c.apply(this, [_[0], E, _[2]]);
        } else if ((0, s.isLifecycleExtEventObj)(u[0])) {
          const _ = u[0],
            p = f._wrapExtMethods(_.method, _.type, l);
          return ((_.method = p), c.call(this, _));
        }
        return c.apply(this, u);
      };
    }
    _getServerRoutePatch(c, l) {
      const f = this;
      return function (d) {
        if (Array.isArray(d))
          for (let u = 0; u < d.length; u++) {
            const _ = f._wrapRouteHandler.call(f, d[u], l);
            d[u] = _;
          }
        else d = f._wrapRouteHandler.call(f, d, l);
        return c.apply(this, [d]);
      };
    }
    _wrapRegisterHandler(c) {
      const l = this,
        f = (0, s.getPluginName)(c),
        d = c.register,
        u = this,
        _ = function (p, E) {
          return (
            u._wrap(p, "route", (h) => l._getServerRoutePatch.bind(l)(h, f)),
            u._wrap(p, "ext", (h) => l._getServerExtPatch.bind(l)(h, f)),
            d.call(this, p, E)
          );
        };
      c.register = _;
    }
    _wrapExtMethods(c, l, f) {
      const d = this;
      if (c instanceof Array) {
        for (let u = 0; u < c.length; u++) c[u] = d._wrapExtMethods(c[u], l);
        return c;
      } else if ((0, s.isPatchableExtMethod)(c))
        return c[o.handlerPatched] === !0
          ? c
          : ((c[o.handlerPatched] = !0),
            async function (..._) {
              if (e.trace.getSpan(e.context.active()) === void 0)
                return await c.apply(this, _);
              const p = (0, s.getExtMetadata)(l, f),
                E = d.tracer.startSpan(p.name, {
                  attributes: p.attributes,
                });
              try {
                return await e.context.with(
                  e.trace.setSpan(e.context.active(), E),
                  c,
                  void 0,
                  ..._,
                );
              } catch (h) {
                throw (
                  E.recordException(h),
                  E.setStatus({
                    code: e.SpanStatusCode.ERROR,
                    message: h.message,
                  }),
                  h
                );
              } finally {
                E.end();
              }
            });
      return c;
    }
    _wrapRouteHandler(c, l) {
      const f = this;
      if (c[o.handlerPatched] === !0) return c;
      c[o.handlerPatched] = !0;
      const d = (u) =>
        async function (..._) {
          if (e.trace.getSpan(e.context.active()) === void 0)
            return await u.call(this, ..._);
          const p = (0, t.getRPCMetadata)(e.context.active());
          p?.type === t.RPCType.HTTP && (p.route = c.path);
          const E = (0, s.getRouteMetadata)(c, f._semconvStability, l),
            h = f.tracer.startSpan(E.name, {
              attributes: E.attributes,
            });
          try {
            return await e.context.with(
              e.trace.setSpan(e.context.active(), h),
              () => u.call(this, ..._),
            );
          } catch (T) {
            throw (
              h.recordException(T),
              h.setStatus({
                code: e.SpanStatusCode.ERROR,
                message: T.message,
              }),
              T
            );
          } finally {
            h.end();
          }
        };
      if (typeof c.handler == "function") c.handler = d(c.handler);
      else if (typeof c.options == "function") {
        const u = c.options;
        c.options = function (_) {
          const p = u(_);
          return (
            typeof p.handler == "function" && (p.handler = d(p.handler)),
            p
          );
        };
      } else
        typeof c.options?.handler == "function" &&
          (c.options.handler = d(c.options.handler));
      return c;
    }
  }
  return ((va.HapiInstrumentation = i), va);
}
var iy;
function AK() {
  return (
    iy ||
      ((iy = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.AttributeNames = e.HapiInstrumentation = void 0));
        var t = mK();
        Object.defineProperty(e, "HapiInstrumentation", {
          enumerable: !0,
          get: function () {
            return t.HapiInstrumentation;
          },
        });
        var n = Nv();
        Object.defineProperty(e, "AttributeNames", {
          enumerable: !0,
          get: function () {
            return n.AttributeNames;
          },
        });
      })(af)),
    af
  );
}
var gK = AK();
const yv = "Hapi",
  RK = Ne(yv, () => new gK.HapiInstrumentation()),
  NK = () => ({
    name: yv,
    setupOnce() {
      RK();
    },
  }),
  yK = NK,
  yo = {
    HONO_TYPE: "hono.type",
    HONO_NAME: "hono.name",
  },
  $c = {
    MIDDLEWARE: "middleware",
    REQUEST_HANDLER: "request_handler",
  },
  OK = "@sentry/instrumentation-hono",
  CK = "0.0.1";
class bK extends Ot {
  constructor(t = {}) {
    super(OK, CK, t);
  }
  init() {
    return [new ft("hono", [">=4.0.0 <5"], (t) => this._patch(t))];
  }
  _patch(t) {
    const n = this;
    class r extends t.Hono {
      constructor(...s) {
        (super(...s),
          n._wrap(this, "get", n._patchHandler()),
          n._wrap(this, "post", n._patchHandler()),
          n._wrap(this, "put", n._patchHandler()),
          n._wrap(this, "delete", n._patchHandler()),
          n._wrap(this, "options", n._patchHandler()),
          n._wrap(this, "patch", n._patchHandler()),
          n._wrap(this, "all", n._patchHandler()),
          n._wrap(this, "on", n._patchOnHandler()),
          n._wrap(this, "use", n._patchMiddlewareHandler()));
      }
    }
    try {
      t.Hono = r;
    } catch {
      return {
        ...t,
        Hono: r,
      };
    }
    return t;
  }
  _patchHandler() {
    const t = this;
    return function (n) {
      return function (...o) {
        if (typeof o[0] == "string") {
          const s = o[0];
          if (o.length === 1) return n.apply(this, [s]);
          const i = o.slice(1);
          return n.apply(this, [s, ...i.map((a) => t._wrapHandler(a))]);
        }
        return n.apply(
          this,
          o.map((s) => t._wrapHandler(s)),
        );
      };
    };
  }
  _patchOnHandler() {
    const t = this;
    return function (n) {
      return function (...o) {
        const s = o.slice(2);
        return n.apply(this, [
          ...o.slice(0, 2),
          ...s.map((i) => t._wrapHandler(i)),
        ]);
      };
    };
  }
  _patchMiddlewareHandler() {
    const t = this;
    return function (n) {
      return function (...o) {
        if (typeof o[0] == "string") {
          const s = o[0];
          if (o.length === 1) return n.apply(this, [s]);
          const i = o.slice(1);
          return n.apply(this, [s, ...i.map((a) => t._wrapHandler(a))]);
        }
        return n.apply(
          this,
          o.map((s) => t._wrapHandler(s)),
        );
      };
    };
  }
  _wrapHandler(t) {
    const n = this;
    return function (r, o) {
      if (!n.isEnabled()) return t.apply(this, [r, o]);
      const s = r.req.path,
        i = n.tracer.startSpan(s);
      return C.context.with(C.trace.setSpan(C.context.active(), i), () =>
        n._safeExecute(
          () => {
            const a = t.apply(this, [r, o]);
            if (tr(a))
              return a.then((c) => {
                const l = n._determineHandlerType(c);
                return (
                  i.setAttributes({
                    [yo.HONO_TYPE]: l,
                    [yo.HONO_NAME]:
                      l === $c.REQUEST_HANDLER ? s : t.name || "anonymous",
                  }),
                  n.getConfig().responseHook?.(i),
                  c
                );
              });
            {
              const c = n._determineHandlerType(a);
              return (
                i.setAttributes({
                  [yo.HONO_TYPE]: c,
                  [yo.HONO_NAME]:
                    c === $c.REQUEST_HANDLER ? s : t.name || "anonymous",
                }),
                n.getConfig().responseHook?.(i),
                a
              );
            }
          },
          () => i.end(),
          (a) => {
            (n._handleError(i, a), i.end());
          },
        ),
      );
    };
  }
  _safeExecute(t, n, r) {
    try {
      const o = t();
      return (
        tr(o)
          ? o.then(
              () => n(),
              (s) => r(s),
            )
          : n(),
        o
      );
    } catch (o) {
      throw (r(o), o);
    }
  }
  _determineHandlerType(t) {
    return t === void 0 ? $c.MIDDLEWARE : $c.REQUEST_HANDLER;
  }
  _handleError(t, n) {
    n instanceof Error &&
      (t.setStatus({
        code: C.SpanStatusCode.ERROR,
        message: n.message,
      }),
      t.recordException(n));
  }
}
const Ov = "Hono";
function IK(e) {
  const t = Re(e).data,
    n = t[yo.HONO_TYPE];
  if (t[Ee] || !n) return;
  e.setAttributes({
    [Ge]: "auto.http.otel.hono",
    [Ee]: `${n}.hono`,
  });
  const r = t[yo.HONO_NAME];
  if ((typeof r == "string" && e.updateName(r), je() === Xo())) {
    ro &&
      $.warn(
        "Isolation scope is default isolation scope - skipping setting transactionName",
      );
    return;
  }
  const o = t[Q.ATTR_HTTP_ROUTE],
    s = t[Q.ATTR_HTTP_REQUEST_METHOD];
  typeof o == "string" &&
    typeof s == "string" &&
    je().setTransactionName(`${s} ${o}`);
}
const PK = Ne(
    Ov,
    () =>
      new bK({
        responseHook: (e) => {
          IK(e);
        },
      }),
  ),
  MK = () => ({
    name: Ov,
    setupOnce() {
      PK();
    },
  }),
  vK = MK;
var lf = {},
  Da = {},
  df = {},
  ay;
function rh() {
  return (
    ay ||
      ((ay = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.KoaLayerType = void 0),
          (function (t) {
            ((t.ROUTER = "router"), (t.MIDDLEWARE = "middleware"));
          })(e.KoaLayerType || (e.KoaLayerType = {})));
      })(df)),
    df
  );
}
var Gr = {},
  cy;
function LK() {
  return (
    cy ||
      ((cy = 1),
      Object.defineProperty(Gr, "__esModule", {
        value: !0,
      }),
      (Gr.PACKAGE_NAME = Gr.PACKAGE_VERSION = void 0),
      (Gr.PACKAGE_VERSION = "0.57.0"),
      (Gr.PACKAGE_NAME = "@opentelemetry/instrumentation-koa")),
    Gr
  );
}
var Vr = {},
  ff = {},
  uy;
function Cv() {
  return (
    uy ||
      ((uy = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.AttributeNames = void 0),
          (function (t) {
            ((t.KOA_TYPE = "koa.type"), (t.KOA_NAME = "koa.name"));
          })(e.AttributeNames || (e.AttributeNames = {})));
      })(ff)),
    ff
  );
}
var ly;
function DK() {
  if (ly) return Vr;
  ((ly = 1),
    Object.defineProperty(Vr, "__esModule", {
      value: !0,
    }),
    (Vr.isLayerIgnored = Vr.getMiddlewareMetadata = void 0));
  const e = rh(),
    t = Cv(),
    n = pt(),
    r = (s, i, a, c) =>
      a
        ? {
            attributes: {
              [t.AttributeNames.KOA_NAME]: c?.toString(),
              [t.AttributeNames.KOA_TYPE]: e.KoaLayerType.ROUTER,
              [n.ATTR_HTTP_ROUTE]: c?.toString(),
            },
            name: s._matchedRouteName || `router - ${c}`,
          }
        : {
            attributes: {
              [t.AttributeNames.KOA_NAME]: i.name ?? "middleware",
              [t.AttributeNames.KOA_TYPE]: e.KoaLayerType.MIDDLEWARE,
            },
            name: `middleware - ${i.name}`,
          };
  Vr.getMiddlewareMetadata = r;
  const o = (s, i) =>
    !!(Array.isArray(i?.ignoreLayersType) && i?.ignoreLayersType?.includes(s));
  return ((Vr.isLayerIgnored = o), Vr);
}
var wa = {},
  dy;
function wK() {
  return (
    dy ||
      ((dy = 1),
      Object.defineProperty(wa, "__esModule", {
        value: !0,
      }),
      (wa.kLayerPatched = void 0),
      (wa.kLayerPatched = Symbol("koa-layer-patched"))),
    wa
  );
}
var fy;
function UK() {
  if (fy) return Da;
  ((fy = 1),
    Object.defineProperty(Da, "__esModule", {
      value: !0,
    }),
    (Da.KoaInstrumentation = void 0));
  const e = Pe(),
    t = Le,
    n = rh(),
    r = LK(),
    o = DK(),
    s = un,
    i = wK();
  class a extends t.InstrumentationBase {
    constructor(l = {}) {
      super(r.PACKAGE_NAME, r.PACKAGE_VERSION, l);
    }
    init() {
      return new t.InstrumentationNodeModuleDefinition(
        "koa",
        [">=2.0.0 <4"],
        (l) => {
          const f = l[Symbol.toStringTag] === "Module" ? l.default : l;
          return f == null
            ? f
            : ((0, t.isWrapped)(f.prototype.use) &&
                this._unwrap(f.prototype, "use"),
              this._wrap(f.prototype, "use", this._getKoaUsePatch.bind(this)),
              l);
        },
        (l) => {
          const f = l[Symbol.toStringTag] === "Module" ? l.default : l;
          (0, t.isWrapped)(f.prototype.use) && this._unwrap(f.prototype, "use");
        },
      );
    }
    _getKoaUsePatch(l) {
      const f = this;
      return function (u) {
        let _;
        return (
          u.router
            ? (_ = f._patchRouterDispatch(u))
            : (_ = f._patchLayer(u, !1)),
          l.apply(this, [_])
        );
      };
    }
    _patchRouterDispatch(l) {
      e.diag.debug("Patching @koa/router dispatch");
      const d = l.router?.stack ?? [];
      for (const u of d) {
        const _ = u.path,
          p = u.stack;
        for (let E = 0; E < p.length; E++) {
          const h = p[E];
          p[E] = this._patchLayer(h, !0, _);
        }
      }
      return l;
    }
    _patchLayer(l, f, d) {
      const u = f ? n.KoaLayerType.ROUTER : n.KoaLayerType.MIDDLEWARE;
      return l[i.kLayerPatched] === !0 ||
        (0, o.isLayerIgnored)(u, this.getConfig())
        ? l
        : l.constructor.name === "GeneratorFunction" ||
            l.constructor.name === "AsyncGeneratorFunction"
          ? (e.diag.debug("ignoring generator-based Koa middleware layer"), l)
          : ((l[i.kLayerPatched] = !0),
            e.diag.debug("patching Koa middleware layer"),
            async (_, p) => {
              if (e.trace.getSpan(e.context.active()) === void 0)
                return l(_, p);
              const h = (0, o.getMiddlewareMetadata)(_, l, f, d),
                T = this.tracer.startSpan(h.name, {
                  attributes: h.attributes,
                }),
                m = (0, s.getRPCMetadata)(e.context.active());
              m?.type === s.RPCType.HTTP &&
                _._matchedRoute &&
                (m.route = _._matchedRoute.toString());
              const { requestHook: A } = this.getConfig();
              A &&
                (0, t.safeExecuteInTheMiddle)(
                  () =>
                    A(T, {
                      context: _,
                      middlewareLayer: l,
                      layerType: u,
                    }),
                  (N) => {
                    N &&
                      e.diag.error(
                        "koa instrumentation: request hook failed",
                        N,
                      );
                  },
                  !0,
                );
              const g = e.trace.setSpan(e.context.active(), T);
              return e.context.with(g, async () => {
                try {
                  return await l(_, p);
                } catch (N) {
                  throw (T.recordException(N), N);
                } finally {
                  T.end();
                }
              });
            });
    }
  }
  return ((Da.KoaInstrumentation = a), Da);
}
var _y;
function kK() {
  return (
    _y ||
      ((_y = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.KoaLayerType = e.AttributeNames = e.KoaInstrumentation = void 0));
        var t = UK();
        Object.defineProperty(e, "KoaInstrumentation", {
          enumerable: !0,
          get: function () {
            return t.KoaInstrumentation;
          },
        });
        var n = Cv();
        Object.defineProperty(e, "AttributeNames", {
          enumerable: !0,
          get: function () {
            return n.AttributeNames;
          },
        });
        var r = rh();
        Object.defineProperty(e, "KoaLayerType", {
          enumerable: !0,
          get: function () {
            return r.KoaLayerType;
          },
        });
      })(lf)),
    lf
  );
}
var GK = kK();
const bv = "Koa",
  VK = Ne(bv, GK.KoaInstrumentation, (e = {}) => ({
    ignoreLayersType: e.ignoreLayersType,
    requestHook(t, n) {
      yt(t, "auto.http.otel.koa");
      const r = Re(t).data,
        o = r["koa.type"];
      o && t.setAttribute(Ee, `${o}.koa`);
      const s = r["koa.name"];
      if (
        (typeof s == "string" && t.updateName(s || "< unknown >"),
        je() === Xo())
      ) {
        ro &&
          $.warn(
            "Isolation scope is default isolation scope - skipping setting transactionName",
          );
        return;
      }
      const i = r[Q.ATTR_HTTP_ROUTE],
        a = n.context?.request?.method?.toUpperCase() || "GET";
      i && je().setTransactionName(`${a} ${i}`);
    },
  })),
  xK = (e = {}) => ({
    name: bv,
    setupOnce() {
      VK(e);
    },
  }),
  $K = xK;
var _f = {},
  pf = {},
  Ef = {},
  py;
function Iv() {
  return (
    py ||
      ((py = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.ConnectNames = e.ConnectTypes = e.AttributeNames = void 0),
          (function (t) {
            ((t.CONNECT_TYPE = "connect.type"),
              (t.CONNECT_NAME = "connect.name"));
          })(e.AttributeNames || (e.AttributeNames = {})),
          (function (t) {
            ((t.MIDDLEWARE = "middleware"),
              (t.REQUEST_HANDLER = "request_handler"));
          })(e.ConnectTypes || (e.ConnectTypes = {})),
          (function (t) {
            ((t.MIDDLEWARE = "middleware"),
              (t.REQUEST_HANDLER = "request handler"));
          })(e.ConnectNames || (e.ConnectNames = {})));
      })(Ef)),
    Ef
  );
}
var xr = {},
  Ey;
function BK() {
  return (
    Ey ||
      ((Ey = 1),
      Object.defineProperty(xr, "__esModule", {
        value: !0,
      }),
      (xr.PACKAGE_NAME = xr.PACKAGE_VERSION = void 0),
      (xr.PACKAGE_VERSION = "0.52.0"),
      (xr.PACKAGE_NAME = "@opentelemetry/instrumentation-connect")),
    xr
  );
}
var Pn = {},
  Ua = {},
  hy;
function HK() {
  return (
    hy ||
      ((hy = 1),
      Object.defineProperty(Ua, "__esModule", {
        value: !0,
      }),
      (Ua._LAYERS_STORE_PROPERTY = void 0),
      (Ua._LAYERS_STORE_PROPERTY = Symbol(
        "opentelemetry.instrumentation-connect.request-route-stack",
      ))),
    Ua
  );
}
var Ty;
function FK() {
  if (Ty) return Pn;
  ((Ty = 1),
    Object.defineProperty(Pn, "__esModule", {
      value: !0,
    }),
    (Pn.generateRoute =
      Pn.replaceCurrentStackRoute =
      Pn.addNewStackLayer =
        void 0));
  const e = Pe(),
    t = HK(),
    n = (s) => {
      (Array.isArray(s[t._LAYERS_STORE_PROPERTY]) === !1 &&
        Object.defineProperty(s, t._LAYERS_STORE_PROPERTY, {
          enumerable: !1,
          value: [],
        }),
        s[t._LAYERS_STORE_PROPERTY].push("/"));
      const i = s[t._LAYERS_STORE_PROPERTY].length;
      return () => {
        i === s[t._LAYERS_STORE_PROPERTY].length
          ? s[t._LAYERS_STORE_PROPERTY].pop()
          : e.diag.warn("Connect: Trying to pop the stack multiple time");
      };
    };
  Pn.addNewStackLayer = n;
  const r = (s, i) => {
    i && s[t._LAYERS_STORE_PROPERTY].splice(-1, 1, i);
  };
  Pn.replaceCurrentStackRoute = r;
  const o = (s) =>
    s[t._LAYERS_STORE_PROPERTY].reduce((i, a) => i.replace(/\/+$/, "") + a);
  return ((Pn.generateRoute = o), Pn);
}
var Sy;
function YK() {
  return (
    Sy ||
      ((Sy = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.ConnectInstrumentation = e.ANONYMOUS_NAME = void 0));
        const t = Pe(),
          n = un,
          r = Iv(),
          o = BK(),
          s = Le,
          i = pt(),
          a = FK();
        e.ANONYMOUS_NAME = "anonymous";
        class c extends s.InstrumentationBase {
          constructor(f = {}) {
            super(o.PACKAGE_NAME, o.PACKAGE_VERSION, f);
          }
          init() {
            return [
              new s.InstrumentationNodeModuleDefinition(
                "connect",
                [">=3.0.0 <4"],
                (f) => this._patchConstructor(f),
              ),
            ];
          }
          _patchApp(f) {
            ((0, s.isWrapped)(f.use) ||
              this._wrap(f, "use", this._patchUse.bind(this)),
              (0, s.isWrapped)(f.handle) ||
                this._wrap(f, "handle", this._patchHandle.bind(this)));
          }
          _patchConstructor(f) {
            const d = this;
            return function (...u) {
              const _ = f.apply(this, u);
              return (d._patchApp(_), _);
            };
          }
          _patchNext(f, d) {
            return function (_) {
              const p = f.apply(this, [_]);
              return (d(), p);
            };
          }
          _startSpan(f, d) {
            let u, _, p;
            f
              ? ((u = r.ConnectTypes.REQUEST_HANDLER),
                (p = r.ConnectNames.REQUEST_HANDLER),
                (_ = f))
              : ((u = r.ConnectTypes.MIDDLEWARE),
                (p = r.ConnectNames.MIDDLEWARE),
                (_ = d.name || e.ANONYMOUS_NAME));
            const E = `${p} - ${_}`,
              h = {
                attributes: {
                  [i.ATTR_HTTP_ROUTE]: f.length > 0 ? f : "/",
                  [r.AttributeNames.CONNECT_TYPE]: u,
                  [r.AttributeNames.CONNECT_NAME]: _,
                },
              };
            return this.tracer.startSpan(E, h);
          }
          _patchMiddleware(f, d) {
            const u = this,
              _ = d.length === 4;
            function p() {
              if (!u.isEnabled()) return d.apply(this, arguments);
              const [E, h, T] = _ ? [1, 2, 3] : [0, 1, 2],
                m = arguments[E],
                A = arguments[h],
                g = arguments[T];
              (0, a.replaceCurrentStackRoute)(m, f);
              const N = (0, n.getRPCMetadata)(t.context.active());
              f &&
                N?.type === n.RPCType.HTTP &&
                (N.route = (0, a.generateRoute)(m));
              let O = "";
              f
                ? (O = `request handler - ${f}`)
                : (O = `middleware - ${d.name || e.ANONYMOUS_NAME}`);
              const I = u._startSpan(f, d);
              u._diag.debug("start span", O);
              let b = !1;
              function w() {
                (b
                  ? u._diag.debug(`span ${I.name} - already finished`)
                  : ((b = !0),
                    u._diag.debug(`finishing span ${I.name}`),
                    I.end()),
                  A.removeListener("close", w));
              }
              return (
                A.addListener("close", w),
                (arguments[T] = u._patchNext(g, w)),
                d.apply(this, arguments)
              );
            }
            return (
              Object.defineProperty(p, "length", {
                value: d.length,
                writable: !1,
                configurable: !0,
              }),
              p
            );
          }
          _patchUse(f) {
            const d = this;
            return function (...u) {
              const _ = u[u.length - 1],
                p = u[u.length - 2] || "";
              return (
                (u[u.length - 1] = d._patchMiddleware(p, _)),
                f.apply(this, u)
              );
            };
          }
          _patchHandle(f) {
            const d = this;
            return function () {
              const [u, _] = [0, 2],
                p = arguments[u],
                E = arguments[_],
                h = (0, a.addNewStackLayer)(p);
              return (
                typeof E == "function" && (arguments[_] = d._patchOut(E, h)),
                f.apply(this, arguments)
              );
            };
          }
          _patchOut(f, d) {
            return function (..._) {
              return (d(), Reflect.apply(f, this, _));
            };
          }
        }
        e.ConnectInstrumentation = c;
      })(pf)),
    pf
  );
}
var my;
function jK() {
  return (
    my ||
      ((my = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.ConnectTypes =
            e.ConnectNames =
            e.AttributeNames =
            e.ANONYMOUS_NAME =
            e.ConnectInstrumentation =
              void 0));
        var t = YK();
        (Object.defineProperty(e, "ConnectInstrumentation", {
          enumerable: !0,
          get: function () {
            return t.ConnectInstrumentation;
          },
        }),
          Object.defineProperty(e, "ANONYMOUS_NAME", {
            enumerable: !0,
            get: function () {
              return t.ANONYMOUS_NAME;
            },
          }));
        var n = Iv();
        (Object.defineProperty(e, "AttributeNames", {
          enumerable: !0,
          get: function () {
            return n.AttributeNames;
          },
        }),
          Object.defineProperty(e, "ConnectNames", {
            enumerable: !0,
            get: function () {
              return n.ConnectNames;
            },
          }),
          Object.defineProperty(e, "ConnectTypes", {
            enumerable: !0,
            get: function () {
              return n.ConnectTypes;
            },
          }));
      })(_f)),
    _f
  );
}
var qK = jK();
const Pv = "Connect",
  WK = Ne(Pv, () => new qK.ConnectInstrumentation()),
  KK = () => ({
    name: Pv,
    setupOnce() {
      WK();
    },
  }),
  zK = KK;
var hf = {},
  Tf = {},
  et = {},
  Ay;
function ZK() {
  return (
    Ay ||
      ((Ay = 1),
      Object.defineProperty(et, "__esModule", {
        value: !0,
      }),
      (et.DB_SYSTEM_VALUE_MSSQL =
        et.ATTR_NET_PEER_PORT =
        et.ATTR_NET_PEER_NAME =
        et.ATTR_DB_USER =
        et.ATTR_DB_SYSTEM =
        et.ATTR_DB_STATEMENT =
        et.ATTR_DB_SQL_TABLE =
        et.ATTR_DB_NAME =
          void 0),
      (et.ATTR_DB_NAME = "db.name"),
      (et.ATTR_DB_SQL_TABLE = "db.sql.table"),
      (et.ATTR_DB_STATEMENT = "db.statement"),
      (et.ATTR_DB_SYSTEM = "db.system"),
      (et.ATTR_DB_USER = "db.user"),
      (et.ATTR_NET_PEER_NAME = "net.peer.name"),
      (et.ATTR_NET_PEER_PORT = "net.peer.port"),
      (et.DB_SYSTEM_VALUE_MSSQL = "mssql")),
    et
  );
}
var $r = {},
  gy;
function XK() {
  if (gy) return $r;
  ((gy = 1),
    Object.defineProperty($r, "__esModule", {
      value: !0,
    }),
    ($r.once = $r.getSpanName = void 0));
  function e(n, r, o, s) {
    return n === "execBulkLoad" && s && r
      ? `${n} ${s} ${r}`
      : n === "callProcedure"
        ? r
          ? `${n} ${o} ${r}`
          : `${n} ${o}`
        : r
          ? `${n} ${r}`
          : `${n}`;
  }
  $r.getSpanName = e;
  const t = (n) => {
    let r = !1;
    return (...o) => {
      if (!r) return ((r = !0), n(...o));
    };
  };
  return (($r.once = t), $r);
}
var Br = {},
  Ry;
function QK() {
  return (
    Ry ||
      ((Ry = 1),
      Object.defineProperty(Br, "__esModule", {
        value: !0,
      }),
      (Br.PACKAGE_NAME = Br.PACKAGE_VERSION = void 0),
      (Br.PACKAGE_VERSION = "0.27.0"),
      (Br.PACKAGE_NAME = "@opentelemetry/instrumentation-tedious")),
    Br
  );
}
var Ny;
function JK() {
  return (
    Ny ||
      ((Ny = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.TediousInstrumentation = e.INJECTED_CTX = void 0));
        const t = Pe(),
          n = events,
          r = Le,
          o = ZK(),
          s = XK(),
          i = QK(),
          a = Symbol("opentelemetry.instrumentation-tedious.current-database");
        e.INJECTED_CTX = Symbol(
          "opentelemetry.instrumentation-tedious.context-info-injected",
        );
        const c = [
          "callProcedure",
          "execSql",
          "execSqlBatch",
          "execBulkLoad",
          "prepare",
          "execute",
        ];
        function l(d) {
          Object.defineProperty(this, a, {
            value: d,
            writable: !0,
          });
        }
        class f extends r.InstrumentationBase {
          static COMPONENT = "tedious";
          constructor(u = {}) {
            super(i.PACKAGE_NAME, i.PACKAGE_VERSION, u);
          }
          init() {
            return [
              new r.InstrumentationNodeModuleDefinition(
                f.COMPONENT,
                [">=1.11.0 <20"],
                (u) => {
                  const _ = u.Connection.prototype;
                  for (const p of c)
                    ((0, r.isWrapped)(_[p]) && this._unwrap(_, p),
                      this._wrap(_, p, this._patchQuery(p, u)));
                  return (
                    (0, r.isWrapped)(_.connect) && this._unwrap(_, "connect"),
                    this._wrap(_, "connect", this._patchConnect),
                    u
                  );
                },
                (u) => {
                  if (u === void 0) return;
                  const _ = u.Connection.prototype;
                  for (const p of c) this._unwrap(_, p);
                  this._unwrap(_, "connect");
                },
              ),
            ];
          }
          _patchConnect(u) {
            return function () {
              return (
                l.call(this, this.config?.options?.database),
                this.removeListener("databaseChange", l),
                this.on("databaseChange", l),
                this.once("end", () => {
                  this.removeListener("databaseChange", l);
                }),
                u.apply(this, arguments)
              );
            };
          }
          _buildTraceparent(u) {
            const _ = u.spanContext();
            return `00-${_.traceId}-${_.spanId}-0${Number(_.traceFlags || t.TraceFlags.NONE).toString(16)}`;
          }
          _injectContextInfo(u, _, p) {
            return new Promise((E) => {
              try {
                const h = "set context_info @opentelemetry_traceparent",
                  T = new _.Request(h, (A) => {
                    E();
                  });
                Object.defineProperty(T, e.INJECTED_CTX, {
                  value: !0,
                });
                const m = Buffer.from(p, "utf8");
                (T.addParameter(
                  "opentelemetry_traceparent",
                  _.TYPES.VarBinary,
                  m,
                  {
                    length: m.length,
                  },
                ),
                  u.execSql(T));
              } catch {
                E();
              }
            });
          }
          _shouldInjectFor(u) {
            return (
              u === "execSql" ||
              u === "execSqlBatch" ||
              u === "callProcedure" ||
              u === "execute"
            );
          }
          _patchQuery(u, _) {
            return (p) => {
              const E = this;
              function h(T) {
                if (T?.[e.INJECTED_CTX]) return p.apply(this, arguments);
                if (!(T instanceof n.EventEmitter))
                  return (
                    E._diag.warn(
                      `Unexpected invocation of patched ${u} method. Span not recorded`,
                    ),
                    p.apply(this, arguments)
                  );
                let m = 0,
                  A = 0;
                const g = () => A++,
                  N = () => m++,
                  O = this[a],
                  I = ((B) =>
                    B.sqlTextOrProcedure === "sp_prepare" &&
                    B.parametersByName?.stmt?.value
                      ? B.parametersByName.stmt.value
                      : B.sqlTextOrProcedure)(T),
                  b = E.tracer.startSpan((0, s.getSpanName)(u, O, I, T.table), {
                    kind: t.SpanKind.CLIENT,
                    attributes: {
                      [o.ATTR_DB_SYSTEM]: o.DB_SYSTEM_VALUE_MSSQL,
                      [o.ATTR_DB_NAME]: O,
                      [o.ATTR_NET_PEER_PORT]: this.config?.options?.port,
                      [o.ATTR_NET_PEER_NAME]: this.config?.server,
                      [o.ATTR_DB_USER]:
                        this.config?.userName ??
                        this.config?.authentication?.options?.userName,
                      [o.ATTR_DB_STATEMENT]: I,
                      [o.ATTR_DB_SQL_TABLE]: T.table,
                    },
                  }),
                  w = (0, s.once)((B) => {
                    (T.removeListener("done", g),
                      T.removeListener("doneInProc", g),
                      T.removeListener("doneProc", N),
                      T.removeListener("error", w),
                      this.removeListener("end", w),
                      b.setAttribute("tedious.procedure_count", m),
                      b.setAttribute("tedious.statement_count", A),
                      B &&
                        b.setStatus({
                          code: t.SpanStatusCode.ERROR,
                          message: B.message,
                        }),
                      b.end());
                  });
                (T.on("done", g),
                  T.on("doneInProc", g),
                  T.on("doneProc", N),
                  T.once("error", w),
                  this.on("end", w),
                  typeof T.callback == "function"
                    ? E._wrap(T, "callback", E._patchCallbackQuery(w))
                    : E._diag.error(
                        "Expected request.callback to be a function",
                      ));
                const L = () =>
                  t.context.with(
                    t.trace.setSpan(t.context.active(), b),
                    p,
                    this,
                    ...arguments,
                  );
                if (
                  !(
                    E.getConfig().enableTraceContextPropagation &&
                    E._shouldInjectFor(u)
                  )
                )
                  return L();
                const x = E._buildTraceparent(b);
                E._injectContextInfo(this, _, x).finally(L);
              }
              return (
                Object.defineProperty(h, "length", {
                  value: p.length,
                  writable: !1,
                }),
                h
              );
            };
          }
          _patchCallbackQuery(u) {
            return (_) =>
              function (p, E, h) {
                return (u(p), _.apply(this, arguments));
              };
          }
        }
        e.TediousInstrumentation = f;
      })(Tf)),
    Tf
  );
}
var yy;
function e2() {
  return (
    yy ||
      ((yy = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.TediousInstrumentation = void 0));
        var t = JK();
        Object.defineProperty(e, "TediousInstrumentation", {
          enumerable: !0,
          get: function () {
            return t.TediousInstrumentation;
          },
        });
      })(hf)),
    hf
  );
}
var t2 = e2();
const n2 = new Set([
    "callProcedure",
    "execSql",
    "execSqlBatch",
    "execBulkLoad",
    "prepare",
    "execute",
  ]),
  Mv = "Tedious",
  r2 = Ne(Mv, () => new t2.TediousInstrumentation({})),
  o2 = () => {
    let e;
    return {
      name: Mv,
      setupOnce() {
        const t = r2();
        e = WP(t);
      },
      setup(t) {
        e?.(() =>
          t.on("spanStart", (n) => {
            const { description: r, data: o } = Re(n);
            if (!r || o["db.system"] !== "mssql") return;
            const s = r.split(" ")[0] || "";
            n2.has(s) && n.setAttribute(Ge, "auto.db.otel.tedious");
          }),
        );
      },
    };
  },
  s2 = o2;
var Sf = {},
  ka = {},
  Hr = {},
  Oy;
function i2() {
  return (
    Oy ||
      ((Oy = 1),
      Object.defineProperty(Hr, "__esModule", {
        value: !0,
      }),
      (Hr.PACKAGE_NAME = Hr.PACKAGE_VERSION = void 0),
      (Hr.PACKAGE_VERSION = "0.52.0"),
      (Hr.PACKAGE_NAME = "@opentelemetry/instrumentation-generic-pool")),
    Hr
  );
}
var Cy;
function a2() {
  if (Cy) return ka;
  ((Cy = 1),
    Object.defineProperty(ka, "__esModule", {
      value: !0,
    }),
    (ka.GenericPoolInstrumentation = void 0));
  const e = Pe(),
    t = Le,
    n = i2(),
    r = "generic-pool";
  class o extends t.InstrumentationBase {
    _isDisabled = !1;
    constructor(i = {}) {
      super(n.PACKAGE_NAME, n.PACKAGE_VERSION, i);
    }
    init() {
      return [
        new t.InstrumentationNodeModuleDefinition(
          r,
          [">=3.0.0 <4"],
          (i) => {
            const a = i.Pool;
            return (
              (0, t.isWrapped)(a.prototype.acquire) &&
                this._unwrap(a.prototype, "acquire"),
              this._wrap(
                a.prototype,
                "acquire",
                this._acquirePatcher.bind(this),
              ),
              i
            );
          },
          (i) => {
            const a = i.Pool;
            return (this._unwrap(a.prototype, "acquire"), i);
          },
        ),
        new t.InstrumentationNodeModuleDefinition(
          r,
          [">=2.4.0 <3"],
          (i) => {
            const a = i.Pool;
            return (
              (0, t.isWrapped)(a.prototype.acquire) &&
                this._unwrap(a.prototype, "acquire"),
              this._wrap(
                a.prototype,
                "acquire",
                this._acquireWithCallbacksPatcher.bind(this),
              ),
              i
            );
          },
          (i) => {
            const a = i.Pool;
            return (this._unwrap(a.prototype, "acquire"), i);
          },
        ),
        new t.InstrumentationNodeModuleDefinition(
          r,
          [">=2.0.0 <2.4"],
          (i) => (
            (this._isDisabled = !1),
            (0, t.isWrapped)(i.Pool) && this._unwrap(i, "Pool"),
            this._wrap(i, "Pool", this._poolWrapper.bind(this)),
            i
          ),
          (i) => ((this._isDisabled = !0), i),
        ),
      ];
    }
    _acquirePatcher(i) {
      const a = this;
      return function (...l) {
        const f = e.context.active(),
          d = a.tracer.startSpan("generic-pool.acquire", {}, f);
        return e.context.with(e.trace.setSpan(f, d), () =>
          i.call(this, ...l).then(
            (u) => (d.end(), u),
            (u) => {
              throw (d.recordException(u), d.end(), u);
            },
          ),
        );
      };
    }
    _poolWrapper(i) {
      const a = this;
      return function () {
        const l = i.apply(this, arguments);
        return (
          a._wrap(l, "acquire", a._acquireWithCallbacksPatcher.bind(a)),
          l
        );
      };
    }
    _acquireWithCallbacksPatcher(i) {
      const a = this;
      return function (l, f) {
        if (a._isDisabled) return i.call(this, l, f);
        const d = e.context.active(),
          u = a.tracer.startSpan("generic-pool.acquire", {}, d);
        return e.context.with(e.trace.setSpan(d, u), () => {
          i.call(
            this,
            (_, p) => {
              if ((u.end(), l)) return l(_, p);
            },
            f,
          );
        });
      };
    }
  }
  return ((ka.GenericPoolInstrumentation = o), ka);
}
var by;
function c2() {
  return (
    by ||
      ((by = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.GenericPoolInstrumentation = void 0));
        var t = a2();
        Object.defineProperty(e, "GenericPoolInstrumentation", {
          enumerable: !0,
          get: function () {
            return t.GenericPoolInstrumentation;
          },
        });
      })(Sf)),
    Sf
  );
}
var u2 = c2();
const vv = "GenericPool",
  l2 = Ne(vv, () => new u2.GenericPoolInstrumentation({})),
  d2 = () => {
    let e;
    return {
      name: vv,
      setupOnce() {
        const t = l2();
        e = WP(t);
      },
      setup(t) {
        e?.(() =>
          t.on("spanStart", (n) => {
            const o = Re(n).description;
            (o === "generic-pool.aquire" || o === "generic-pool.acquire") &&
              n.setAttribute(Ge, "auto.db.otel.generic_pool");
          }),
        );
      },
    };
  },
  f2 = d2;
var mf = {},
  Ga = {},
  nn = {},
  Iy;
function Lv() {
  return (
    Iy ||
      ((Iy = 1),
      Object.defineProperty(nn, "__esModule", {
        value: !0,
      }),
      (nn.ATTR_NET_PEER_PORT =
        nn.ATTR_NET_PEER_NAME =
        nn.ATTR_MESSAGING_SYSTEM =
        nn.ATTR_MESSAGING_OPERATION =
          void 0),
      (nn.ATTR_MESSAGING_OPERATION = "messaging.operation"),
      (nn.ATTR_MESSAGING_SYSTEM = "messaging.system"),
      (nn.ATTR_NET_PEER_NAME = "net.peer.name"),
      (nn.ATTR_NET_PEER_PORT = "net.peer.port")),
    nn
  );
}
var He = {},
  Py;
function Dv() {
  return (
    Py ||
      ((Py = 1),
      Object.defineProperty(He, "__esModule", {
        value: !0,
      }),
      (He.ATTR_MESSAGING_CONVERSATION_ID =
        He.OLD_ATTR_MESSAGING_MESSAGE_ID =
        He.MESSAGING_DESTINATION_KIND_VALUE_TOPIC =
        He.ATTR_MESSAGING_URL =
        He.ATTR_MESSAGING_PROTOCOL_VERSION =
        He.ATTR_MESSAGING_PROTOCOL =
        He.MESSAGING_OPERATION_VALUE_PROCESS =
        He.ATTR_MESSAGING_RABBITMQ_ROUTING_KEY =
        He.ATTR_MESSAGING_DESTINATION_KIND =
        He.ATTR_MESSAGING_DESTINATION =
          void 0),
      (He.ATTR_MESSAGING_DESTINATION = "messaging.destination"),
      (He.ATTR_MESSAGING_DESTINATION_KIND = "messaging.destination_kind"),
      (He.ATTR_MESSAGING_RABBITMQ_ROUTING_KEY =
        "messaging.rabbitmq.routing_key"),
      (He.MESSAGING_OPERATION_VALUE_PROCESS = "process"),
      (He.ATTR_MESSAGING_PROTOCOL = "messaging.protocol"),
      (He.ATTR_MESSAGING_PROTOCOL_VERSION = "messaging.protocol_version"),
      (He.ATTR_MESSAGING_URL = "messaging.url"),
      (He.MESSAGING_DESTINATION_KIND_VALUE_TOPIC = "topic"),
      (He.OLD_ATTR_MESSAGING_MESSAGE_ID = "messaging.message_id"),
      (He.ATTR_MESSAGING_CONVERSATION_ID = "messaging.conversation_id")),
    He
  );
}
var Af = {},
  My;
function wv() {
  return (
    My ||
      ((My = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.DEFAULT_CONFIG = e.EndOperation = void 0),
          (function (t) {
            ((t.AutoAck = "auto ack"),
              (t.Ack = "ack"),
              (t.AckAll = "ackAll"),
              (t.Reject = "reject"),
              (t.Nack = "nack"),
              (t.NackAll = "nackAll"),
              (t.ChannelClosed = "channel closed"),
              (t.ChannelError = "channel error"),
              (t.InstrumentationTimeout = "instrumentation timeout"));
          })(e.EndOperation || (e.EndOperation = {})),
          (e.DEFAULT_CONFIG = {
            consumeTimeoutMs: 1e3 * 60,
            useLinksForConsume: !1,
          }));
      })(Af)),
    Af
  );
}
var Fe = {},
  vy;
function _2() {
  if (vy) return Fe;
  ((vy = 1),
    Object.defineProperty(Fe, "__esModule", {
      value: !0,
    }),
    (Fe.isConfirmChannelTracing =
      Fe.unmarkConfirmChannelTracing =
      Fe.markConfirmChannelTracing =
      Fe.getConnectionAttributesFromUrl =
      Fe.getConnectionAttributesFromServer =
      Fe.normalizeExchange =
      Fe.CONNECTION_ATTRIBUTES =
      Fe.CHANNEL_CONSUME_TIMEOUT_TIMER =
      Fe.CHANNEL_SPANS_NOT_ENDED =
      Fe.MESSAGE_STORED_SPAN =
        void 0));
  const e = Pe(),
    t = Lv(),
    n = Dv();
  ((Fe.MESSAGE_STORED_SPAN = Symbol(
    "opentelemetry.amqplib.message.stored-span",
  )),
    (Fe.CHANNEL_SPANS_NOT_ENDED = Symbol(
      "opentelemetry.amqplib.channel.spans-not-ended",
    )),
    (Fe.CHANNEL_CONSUME_TIMEOUT_TIMER = Symbol(
      "opentelemetry.amqplib.channel.consumer-timeout-timer",
    )),
    (Fe.CONNECTION_ATTRIBUTES = Symbol(
      "opentelemetry.amqplib.connection.attributes",
    )));
  const r = (0, e.createContextKey)(
      "opentelemetry.amqplib.channel.is-confirm-channel",
    ),
    o = (E) => (E !== "" ? E : "<default>");
  Fe.normalizeExchange = o;
  const s = (E) => E.replace(/:[^:@/]*@/, ":***@"),
    i = (E, h) => E || (h === "AMQP" ? 5672 : 5671),
    a = (E) => {
      const h = E || "amqp";
      return (h.endsWith(":") ? h.substring(0, h.length - 1) : h).toUpperCase();
    },
    c = (E) => E || "localhost",
    l = (E, h, T, m) =>
      T
        ? {
            [h]: T,
          }
        : (e.diag.error(
            `amqplib instrumentation: could not extract connection attribute ${m} from user supplied url`,
            {
              url: E,
            },
          ),
          {}),
    f = (E) => {
      const h = E.serverProperties.product?.toLowerCase?.();
      return h
        ? {
            [t.ATTR_MESSAGING_SYSTEM]: h,
          }
        : {};
    };
  Fe.getConnectionAttributesFromServer = f;
  const d = (E) => {
    const h = {
      [n.ATTR_MESSAGING_PROTOCOL_VERSION]: "0.9.1",
    };
    if (((E = E || "amqp://localhost"), typeof E == "object")) {
      const T = E,
        m = a(T?.protocol);
      Object.assign(h, {
        ...l(E, n.ATTR_MESSAGING_PROTOCOL, m, "protocol"),
      });
      const A = c(T?.hostname);
      Object.assign(h, {
        ...l(E, t.ATTR_NET_PEER_NAME, A, "hostname"),
      });
      const g = i(T.port, m);
      Object.assign(h, {
        ...l(E, t.ATTR_NET_PEER_PORT, g, "port"),
      });
    } else {
      const T = s(E);
      h[n.ATTR_MESSAGING_URL] = T;
      try {
        const m = new URL(T),
          A = a(m.protocol);
        Object.assign(h, {
          ...l(T, n.ATTR_MESSAGING_PROTOCOL, A, "protocol"),
        });
        const g = c(m.hostname);
        Object.assign(h, {
          ...l(T, t.ATTR_NET_PEER_NAME, g, "hostname"),
        });
        const N = i(m.port ? parseInt(m.port) : void 0, A);
        Object.assign(h, {
          ...l(T, t.ATTR_NET_PEER_PORT, N, "port"),
        });
      } catch (m) {
        e.diag.error(
          "amqplib instrumentation: error while extracting connection details from connection url",
          {
            censoredUrl: T,
            err: m,
          },
        );
      }
    }
    return h;
  };
  Fe.getConnectionAttributesFromUrl = d;
  const u = (E) => E.setValue(r, !0);
  Fe.markConfirmChannelTracing = u;
  const _ = (E) => E.deleteValue(r);
  Fe.unmarkConfirmChannelTracing = _;
  const p = (E) => E.getValue(r) === !0;
  return ((Fe.isConfirmChannelTracing = p), Fe);
}
var Fr = {},
  Ly;
function p2() {
  return (
    Ly ||
      ((Ly = 1),
      Object.defineProperty(Fr, "__esModule", {
        value: !0,
      }),
      (Fr.PACKAGE_NAME = Fr.PACKAGE_VERSION = void 0),
      (Fr.PACKAGE_VERSION = "0.55.0"),
      (Fr.PACKAGE_NAME = "@opentelemetry/instrumentation-amqplib")),
    Fr
  );
}
var Dy;
function E2() {
  if (Dy) return Ga;
  ((Dy = 1),
    Object.defineProperty(Ga, "__esModule", {
      value: !0,
    }),
    (Ga.AmqplibInstrumentation = void 0));
  const e = Pe(),
    t = un,
    n = Le,
    r = Lv(),
    o = Dv(),
    s = wv(),
    i = _2(),
    a = p2(),
    c = [">=0.5.5 <1"];
  class l extends n.InstrumentationBase {
    constructor(d = {}) {
      super(a.PACKAGE_NAME, a.PACKAGE_VERSION, {
        ...s.DEFAULT_CONFIG,
        ...d,
      });
    }
    setConfig(d = {}) {
      super.setConfig({
        ...s.DEFAULT_CONFIG,
        ...d,
      });
    }
    init() {
      const d = new n.InstrumentationNodeModuleFile(
          "amqplib/lib/channel_model.js",
          c,
          this.patchChannelModel.bind(this),
          this.unpatchChannelModel.bind(this),
        ),
        u = new n.InstrumentationNodeModuleFile(
          "amqplib/lib/callback_model.js",
          c,
          this.patchChannelModel.bind(this),
          this.unpatchChannelModel.bind(this),
        ),
        _ = new n.InstrumentationNodeModuleFile(
          "amqplib/lib/connect.js",
          c,
          this.patchConnect.bind(this),
          this.unpatchConnect.bind(this),
        );
      return new n.InstrumentationNodeModuleDefinition(
        "amqplib",
        c,
        void 0,
        void 0,
        [d, _, u],
      );
    }
    patchConnect(d) {
      return (
        (d = this.unpatchConnect(d)),
        (0, n.isWrapped)(d.connect) ||
          this._wrap(d, "connect", this.getConnectPatch.bind(this)),
        d
      );
    }
    unpatchConnect(d) {
      return ((0, n.isWrapped)(d.connect) && this._unwrap(d, "connect"), d);
    }
    patchChannelModel(d, u) {
      return (
        (0, n.isWrapped)(d.Channel.prototype.publish) ||
          this._wrap(
            d.Channel.prototype,
            "publish",
            this.getPublishPatch.bind(this, u),
          ),
        (0, n.isWrapped)(d.Channel.prototype.consume) ||
          this._wrap(
            d.Channel.prototype,
            "consume",
            this.getConsumePatch.bind(this, u),
          ),
        (0, n.isWrapped)(d.Channel.prototype.ack) ||
          this._wrap(
            d.Channel.prototype,
            "ack",
            this.getAckPatch.bind(this, !1, s.EndOperation.Ack),
          ),
        (0, n.isWrapped)(d.Channel.prototype.nack) ||
          this._wrap(
            d.Channel.prototype,
            "nack",
            this.getAckPatch.bind(this, !0, s.EndOperation.Nack),
          ),
        (0, n.isWrapped)(d.Channel.prototype.reject) ||
          this._wrap(
            d.Channel.prototype,
            "reject",
            this.getAckPatch.bind(this, !0, s.EndOperation.Reject),
          ),
        (0, n.isWrapped)(d.Channel.prototype.ackAll) ||
          this._wrap(
            d.Channel.prototype,
            "ackAll",
            this.getAckAllPatch.bind(this, !1, s.EndOperation.AckAll),
          ),
        (0, n.isWrapped)(d.Channel.prototype.nackAll) ||
          this._wrap(
            d.Channel.prototype,
            "nackAll",
            this.getAckAllPatch.bind(this, !0, s.EndOperation.NackAll),
          ),
        (0, n.isWrapped)(d.Channel.prototype.emit) ||
          this._wrap(
            d.Channel.prototype,
            "emit",
            this.getChannelEmitPatch.bind(this),
          ),
        (0, n.isWrapped)(d.ConfirmChannel.prototype.publish) ||
          this._wrap(
            d.ConfirmChannel.prototype,
            "publish",
            this.getConfirmedPublishPatch.bind(this, u),
          ),
        d
      );
    }
    unpatchChannelModel(d) {
      return (
        (0, n.isWrapped)(d.Channel.prototype.publish) &&
          this._unwrap(d.Channel.prototype, "publish"),
        (0, n.isWrapped)(d.Channel.prototype.consume) &&
          this._unwrap(d.Channel.prototype, "consume"),
        (0, n.isWrapped)(d.Channel.prototype.ack) &&
          this._unwrap(d.Channel.prototype, "ack"),
        (0, n.isWrapped)(d.Channel.prototype.nack) &&
          this._unwrap(d.Channel.prototype, "nack"),
        (0, n.isWrapped)(d.Channel.prototype.reject) &&
          this._unwrap(d.Channel.prototype, "reject"),
        (0, n.isWrapped)(d.Channel.prototype.ackAll) &&
          this._unwrap(d.Channel.prototype, "ackAll"),
        (0, n.isWrapped)(d.Channel.prototype.nackAll) &&
          this._unwrap(d.Channel.prototype, "nackAll"),
        (0, n.isWrapped)(d.Channel.prototype.emit) &&
          this._unwrap(d.Channel.prototype, "emit"),
        (0, n.isWrapped)(d.ConfirmChannel.prototype.publish) &&
          this._unwrap(d.ConfirmChannel.prototype, "publish"),
        d
      );
    }
    getConnectPatch(d) {
      return function (_, p, E) {
        return d.call(this, _, p, function (h, T) {
          if (h == null) {
            const m = (0, i.getConnectionAttributesFromUrl)(_),
              A = (0, i.getConnectionAttributesFromServer)(T);
            T[i.CONNECTION_ATTRIBUTES] = {
              ...m,
              ...A,
            };
          }
          E.apply(this, arguments);
        });
      };
    }
    getChannelEmitPatch(d) {
      const u = this;
      return function (p) {
        if (p === "close") {
          u.endAllSpansOnChannel(
            this,
            !0,
            s.EndOperation.ChannelClosed,
            void 0,
          );
          const E = this[i.CHANNEL_CONSUME_TIMEOUT_TIMER];
          (E && clearInterval(E),
            (this[i.CHANNEL_CONSUME_TIMEOUT_TIMER] = void 0));
        } else
          p === "error" &&
            u.endAllSpansOnChannel(
              this,
              !0,
              s.EndOperation.ChannelError,
              void 0,
            );
        return d.apply(this, arguments);
      };
    }
    getAckAllPatch(d, u, _) {
      const p = this;
      return function (h) {
        return (
          p.endAllSpansOnChannel(this, d, u, h),
          _.apply(this, arguments)
        );
      };
    }
    getAckPatch(d, u, _) {
      const p = this;
      return function (h, T, m) {
        const A = this,
          g = u === s.EndOperation.Reject ? T : m,
          N = A[i.CHANNEL_SPANS_NOT_ENDED] ?? [],
          O = N.findIndex((I) => I.msg === h);
        if (O < 0) p.endConsumerSpan(h, d, u, g);
        else if (u !== s.EndOperation.Reject && T) {
          for (let I = 0; I <= O; I++) p.endConsumerSpan(N[I].msg, d, u, g);
          N.splice(0, O + 1);
        } else (p.endConsumerSpan(h, d, u, g), N.splice(O, 1));
        return _.apply(this, arguments);
      };
    }
    getConsumePatch(d, u) {
      const _ = this;
      return function (E, h, T) {
        const m = this;
        if (
          !Object.prototype.hasOwnProperty.call(m, i.CHANNEL_SPANS_NOT_ENDED)
        ) {
          const { consumeTimeoutMs: g } = _.getConfig();
          if (g) {
            const N = setInterval(() => {
              _.checkConsumeTimeoutOnChannel(m);
            }, g);
            (N.unref(), (m[i.CHANNEL_CONSUME_TIMEOUT_TIMER] = N));
          }
          m[i.CHANNEL_SPANS_NOT_ENDED] = [];
        }
        const A = function (g) {
          if (!g) return h.call(this, g);
          const N = g.properties.headers ?? {};
          let O = e.propagation.extract(e.ROOT_CONTEXT, N);
          const I = g.fields?.exchange;
          let b;
          if (_._config.useLinksForConsume) {
            const H = O ? e.trace.getSpan(O)?.spanContext() : void 0;
            ((O = void 0),
              H &&
                (b = [
                  {
                    context: H,
                  },
                ]));
          }
          const w = _.tracer.startSpan(
              `${E} process`,
              {
                kind: e.SpanKind.CONSUMER,
                attributes: {
                  ...m?.connection?.[i.CONNECTION_ATTRIBUTES],
                  [o.ATTR_MESSAGING_DESTINATION]: I,
                  [o.ATTR_MESSAGING_DESTINATION_KIND]:
                    o.MESSAGING_DESTINATION_KIND_VALUE_TOPIC,
                  [o.ATTR_MESSAGING_RABBITMQ_ROUTING_KEY]: g.fields?.routingKey,
                  [r.ATTR_MESSAGING_OPERATION]:
                    o.MESSAGING_OPERATION_VALUE_PROCESS,
                  [o.OLD_ATTR_MESSAGING_MESSAGE_ID]: g?.properties.messageId,
                  [o.ATTR_MESSAGING_CONVERSATION_ID]:
                    g?.properties.correlationId,
                },
                links: b,
              },
              O,
            ),
            { consumeHook: L } = _.getConfig();
          (L &&
            (0, n.safeExecuteInTheMiddle)(
              () =>
                L(w, {
                  moduleVersion: d,
                  msg: g,
                }),
              (H) => {
                H &&
                  e.diag.error(
                    "amqplib instrumentation: consumerHook error",
                    H,
                  );
              },
              !0,
            ),
            T?.noAck ||
              (m[i.CHANNEL_SPANS_NOT_ENDED].push({
                msg: g,
                timeOfConsume: (0, t.hrTime)(),
              }),
              (g[i.MESSAGE_STORED_SPAN] = w)));
          const j = O || e.ROOT_CONTEXT;
          (e.context.with(e.trace.setSpan(j, w), () => {
            h.call(this, g);
          }),
            T?.noAck &&
              (_.callConsumeEndHook(w, g, !1, s.EndOperation.AutoAck),
              w.end()));
        };
        return ((arguments[1] = A), u.apply(this, arguments));
      };
    }
    getConfirmedPublishPatch(d, u) {
      const _ = this;
      return function (E, h, T, m, A) {
        const g = this,
          { span: N, modifiedOptions: O } = _.createPublishSpan(_, E, h, g, m),
          { publishHook: I } = _.getConfig();
        I &&
          (0, n.safeExecuteInTheMiddle)(
            () =>
              I(N, {
                moduleVersion: d,
                exchange: E,
                routingKey: h,
                content: T,
                options: O,
                isConfirmChannel: !0,
              }),
            (j) => {
              j &&
                e.diag.error("amqplib instrumentation: publishHook error", j);
            },
            !0,
          );
        const b = function (j, H) {
            try {
              A?.call(this, j, H);
            } finally {
              const { publishConfirmHook: x } = _.getConfig();
              (x &&
                (0, n.safeExecuteInTheMiddle)(
                  () =>
                    x(N, {
                      moduleVersion: d,
                      exchange: E,
                      routingKey: h,
                      content: T,
                      options: m,
                      isConfirmChannel: !0,
                      confirmError: j,
                    }),
                  (B) => {
                    B &&
                      e.diag.error(
                        "amqplib instrumentation: publishConfirmHook error",
                        B,
                      );
                  },
                  !0,
                ),
                j &&
                  N.setStatus({
                    code: e.SpanStatusCode.ERROR,
                    message: "message confirmation has been nack'ed",
                  }),
                N.end());
            }
          },
          w = (0, i.markConfirmChannelTracing)(e.context.active()),
          L = [...arguments];
        return (
          (L[3] = O),
          (L[4] = e.context.bind(
            (0, i.unmarkConfirmChannelTracing)(e.trace.setSpan(w, N)),
            b,
          )),
          e.context.with(w, u.bind(this, ...L))
        );
      };
    }
    getPublishPatch(d, u) {
      const _ = this;
      return function (E, h, T, m) {
        if ((0, i.isConfirmChannelTracing)(e.context.active()))
          return u.apply(this, arguments);
        {
          const A = this,
            { span: g, modifiedOptions: N } = _.createPublishSpan(
              _,
              E,
              h,
              A,
              m,
            ),
            { publishHook: O } = _.getConfig();
          O &&
            (0, n.safeExecuteInTheMiddle)(
              () =>
                O(g, {
                  moduleVersion: d,
                  exchange: E,
                  routingKey: h,
                  content: T,
                  options: N,
                  isConfirmChannel: !1,
                }),
              (w) => {
                w &&
                  e.diag.error("amqplib instrumentation: publishHook error", w);
              },
              !0,
            );
          const I = [...arguments];
          I[3] = N;
          const b = u.apply(this, I);
          return (g.end(), b);
        }
      };
    }
    createPublishSpan(d, u, _, p, E) {
      const h = (0, i.normalizeExchange)(u),
        T = d.tracer.startSpan(`publish ${h}`, {
          kind: e.SpanKind.PRODUCER,
          attributes: {
            ...p.connection[i.CONNECTION_ATTRIBUTES],
            [o.ATTR_MESSAGING_DESTINATION]: u,
            [o.ATTR_MESSAGING_DESTINATION_KIND]:
              o.MESSAGING_DESTINATION_KIND_VALUE_TOPIC,
            [o.ATTR_MESSAGING_RABBITMQ_ROUTING_KEY]: _,
            [o.OLD_ATTR_MESSAGING_MESSAGE_ID]: E?.messageId,
            [o.ATTR_MESSAGING_CONVERSATION_ID]: E?.correlationId,
          },
        }),
        m = E ?? {};
      return (
        (m.headers = m.headers ?? {}),
        e.propagation.inject(e.trace.setSpan(e.context.active(), T), m.headers),
        {
          span: T,
          modifiedOptions: m,
        }
      );
    }
    endConsumerSpan(d, u, _, p) {
      const E = d[i.MESSAGE_STORED_SPAN];
      E &&
        (u !== !1 &&
          E.setStatus({
            code: e.SpanStatusCode.ERROR,
            message:
              _ !== s.EndOperation.ChannelClosed &&
              _ !== s.EndOperation.ChannelError
                ? `${_} called on message${p === !0 ? " with requeue" : p === !1 ? " without requeue" : ""}`
                : _,
          }),
        this.callConsumeEndHook(E, d, u, _),
        E.end(),
        (d[i.MESSAGE_STORED_SPAN] = void 0));
    }
    endAllSpansOnChannel(d, u, _, p) {
      ((d[i.CHANNEL_SPANS_NOT_ENDED] ?? []).forEach((h) => {
        this.endConsumerSpan(h.msg, u, _, p);
      }),
        (d[i.CHANNEL_SPANS_NOT_ENDED] = []));
    }
    callConsumeEndHook(d, u, _, p) {
      const { consumeEndHook: E } = this.getConfig();
      E &&
        (0, n.safeExecuteInTheMiddle)(
          () =>
            E(d, {
              msg: u,
              rejected: _,
              endOperation: p,
            }),
          (h) => {
            h &&
              e.diag.error("amqplib instrumentation: consumerEndHook error", h);
          },
          !0,
        );
    }
    checkConsumeTimeoutOnChannel(d) {
      const u = (0, t.hrTime)(),
        _ = d[i.CHANNEL_SPANS_NOT_ENDED] ?? [];
      let p;
      const { consumeTimeoutMs: E } = this.getConfig();
      for (p = 0; p < _.length; p++) {
        const h = _[p],
          T = (0, t.hrTimeDuration)(h.timeOfConsume, u);
        if ((0, t.hrTimeToMilliseconds)(T) < E) break;
        this.endConsumerSpan(
          h.msg,
          null,
          s.EndOperation.InstrumentationTimeout,
          !0,
        );
      }
      _.splice(0, p);
    }
  }
  return ((Ga.AmqplibInstrumentation = l), Ga);
}
var wy;
function h2() {
  return (
    wy ||
      ((wy = 1),
      (function (e) {
        (Object.defineProperty(e, "__esModule", {
          value: !0,
        }),
          (e.EndOperation =
            e.DEFAULT_CONFIG =
            e.AmqplibInstrumentation =
              void 0));
        var t = E2();
        Object.defineProperty(e, "AmqplibInstrumentation", {
          enumerable: !0,
          get: function () {
            return t.AmqplibInstrumentation;
          },
        });
        var n = wv();
        (Object.defineProperty(e, "DEFAULT_CONFIG", {
          enumerable: !0,
          get: function () {
            return n.DEFAULT_CONFIG;
          },
        }),
          Object.defineProperty(e, "EndOperation", {
            enumerable: !0,
            get: function () {
              return n.EndOperation;
            },
          }));
      })(mf)),
    mf
  );
}
var T2 = h2();
const Uv = "Amqplib",
  S2 = {
    consumeEndHook: (e) => {
      yt(e, "auto.amqplib.otel.consumer");
    },
    publishHook: (e) => {
      yt(e, "auto.amqplib.otel.publisher");
    },
  },
  m2 = Ne(Uv, () => new T2.AmqplibInstrumentation(S2)),
  A2 = () => ({
    name: Uv,
    setupOnce() {
      m2();
    },
  }),
  g2 = A2,
  oh = "VercelAI",
  Uy = [
    "generateText",
    "streamText",
    "generateObject",
    "streamObject",
    "embed",
    "embedMany",
  ];
function R2(e) {
  if (typeof e != "object" || e === null) return !1;
  const t = e;
  return (
    "type" in t &&
    "error" in t &&
    "toolName" in t &&
    "toolCallId" in t &&
    t.type === "tool-error" &&
    t.error instanceof Error
  );
}
function N2(e) {
  if (typeof e != "object" || e === null || !("content" in e)) return;
  const t = e;
  if (Array.isArray(t.content)) {
    for (const n of t.content)
      if (R2(n)) {
        const r = Nx(n.toolCallId);
        if (r) {
          const o = r.spanContext();
          (Jr((s) => {
            (s.setContext("trace", {
              trace_id: o.traceId,
              span_id: o.spanId,
            }),
              s.setTag("vercel.ai.tool.name", n.toolName),
              s.setTag("vercel.ai.tool.callId", n.toolCallId),
              s.setLevel("error"),
              xe(n.error, {
                mechanism: {
                  type: "auto.vercelai.otel",
                  handled: !1,
                },
              }));
          }),
            yx(n.toolCallId));
        } else
          Jr((o) => {
            (o.setTag("vercel.ai.tool.name", n.toolName),
              o.setTag("vercel.ai.tool.callId", n.toolCallId),
              o.setLevel("error"),
              xe(n.error, {
                mechanism: {
                  type: "auto.vercelai.otel",
                  handled: !1,
                },
              }));
          });
      }
  }
}
function y2(e, t, n, r) {
  const o =
      e?.recordInputs !== void 0
        ? e.recordInputs
        : t.recordInputs !== void 0
          ? t.recordInputs
          : n === !0
            ? !0
            : r,
    s =
      e?.recordOutputs !== void 0
        ? e.recordOutputs
        : t.recordOutputs !== void 0
          ? t.recordOutputs
          : n === !0
            ? !0
            : r;
  return {
    recordInputs: o,
    recordOutputs: s,
  };
}
class Uu extends Ot {
  __init() {
    this._isPatched = !1;
  }
  __init2() {
    this._callbacks = [];
  }
  constructor(t = {}) {
    (super("@sentry/instrumentation-vercel-ai", Ze, t),
      Uu.prototype.__init.call(this),
      Uu.prototype.__init2.call(this));
  }
  init() {
    return new ft("ai", [">=3.0.0 <6"], this._patch.bind(this));
  }
  callWhenPatched(t) {
    this._isPatched ? t() : this._callbacks.push(t);
  }
  _patch(t) {
    ((this._isPatched = !0),
      this._callbacks.forEach((r) => r()),
      (this._callbacks = []));
    const n = (r) =>
      new Proxy(r, {
        apply: (o, s, i) => {
          const a = i[0].experimental_telemetry || {},
            c = a.isEnabled,
            l = he(),
            f = l?.getIntegrationByName(oh),
            d = f?.options,
            u = f ? !!l?.getOptions().sendDefaultPii : !1,
            { recordInputs: _, recordOutputs: p } = y2(d, a, c, u);
          return (
            (i[0].experimental_telemetry = {
              ...a,
              isEnabled: c !== void 0 ? c : !0,
              recordInputs: _,
              recordOutputs: p,
            }),
            to(
              () => Reflect.apply(o, s, i),
              (E) => {
                E && typeof E == "object" && sn(E, "_sentry_active_span", fl());
              },
              () => {},
              (E) => {
                N2(E);
              },
            )
          );
        },
      });
    if (Object.prototype.toString.call(t) === "[object Module]") {
      for (const r of Uy) t[r] = n(t[r]);
      return t;
    } else {
      const r = Uy.reduce((o, s) => ((o[s] = n(t[s])), o), {});
      return {
        ...t,
        ...r,
      };
    }
  }
}
const O2 = Ne(oh, () => new Uu({}));
function C2(e) {
  return !!e.getIntegrationByName("Modules")?.getModules?.()?.ai;
}
const b2 = (e = {}) => {
    let t;
    return {
      name: oh,
      options: e,
      setupOnce() {
        t = O2();
      },
      afterAllSetup(n) {
        (e.force ?? C2(n)) ? Dg(n) : t?.callWhenPatched(() => Dg(n));
      },
    };
  },
  I2 = b2,
  P2 = [">=4.0.0 <7"];
class M2 extends Ot {
  constructor(t = {}) {
    super("@sentry/instrumentation-openai", Ze, t);
  }
  init() {
    return new ft("openai", P2, this._patch.bind(this));
  }
  _patch(t) {
    let n = t;
    return (
      (n = this._patchClient(n, "OpenAI")),
      (n = this._patchClient(n, "AzureOpenAI")),
      n
    );
  }
  _patchClient(t, n) {
    const r = t[n];
    if (!r) return t;
    const o = this.getConfig(),
      s = function (...i) {
        if (IE(Nl)) return Reflect.construct(r, i);
        const a = Reflect.construct(r, i),
          l = !!he()?.getOptions().sendDefaultPii,
          f = o.recordInputs ?? l,
          d = o.recordOutputs ?? l;
        return e$(a, {
          recordInputs: f,
          recordOutputs: d,
        });
      };
    (Object.setPrototypeOf(s, r),
      Object.setPrototypeOf(s.prototype, r.prototype));
    for (const i of Object.getOwnPropertyNames(r))
      if (!["length", "name", "prototype"].includes(i)) {
        const a = Object.getOwnPropertyDescriptor(r, i);
        a && Object.defineProperty(s, i, a);
      }
    try {
      t[n] = s;
    } catch {
      Object.defineProperty(t, n, {
        value: s,
        writable: !0,
        configurable: !0,
        enumerable: !0,
      });
    }
    if (t.default === r)
      try {
        t.default = s;
      } catch {
        Object.defineProperty(t, "default", {
          value: s,
          writable: !0,
          configurable: !0,
          enumerable: !0,
        });
      }
    return t;
  }
}
const v2 = Ne(Nl, (e) => new M2(e)),
  L2 = (e = {}) => ({
    name: Nl,
    setupOnce() {
      v2(e);
    },
  }),
  D2 = L2,
  w2 = [">=0.19.2 <1.0.0"];
class U2 extends Ot {
  constructor(t = {}) {
    super("@sentry/instrumentation-anthropic-ai", Ze, t);
  }
  init() {
    return new ft("@anthropic-ai/sdk", w2, this._patch.bind(this));
  }
  _patch(t) {
    const n = t.Anthropic,
      r = this.getConfig(),
      o = function (...s) {
        if (IE(Ol)) return Reflect.construct(n, s);
        const i = Reflect.construct(n, s),
          c = !!he()?.getOptions().sendDefaultPii,
          l = r.recordInputs ?? c,
          f = r.recordOutputs ?? c;
        return m$(i, {
          recordInputs: l,
          recordOutputs: f,
        });
      };
    (Object.setPrototypeOf(o, n),
      Object.setPrototypeOf(o.prototype, n.prototype));
    for (const s of Object.getOwnPropertyNames(n))
      if (!["length", "name", "prototype"].includes(s)) {
        const i = Object.getOwnPropertyDescriptor(n, s);
        i && Object.defineProperty(o, s, i);
      }
    try {
      t.Anthropic = o;
    } catch {
      Object.defineProperty(t, "Anthropic", {
        value: o,
        writable: !0,
        configurable: !0,
        enumerable: !0,
      });
    }
    if (t.default === n)
      try {
        t.default = o;
      } catch {
        Object.defineProperty(t, "default", {
          value: o,
          writable: !0,
          configurable: !0,
          enumerable: !0,
        });
      }
    return t;
  }
}
const k2 = Ne(Ol, (e) => new U2(e)),
  G2 = (e = {}) => ({
    name: Ol,
    options: e,
    setupOnce() {
      k2(e);
    },
  }),
  V2 = G2,
  ky = [">=0.10.0 <2"];
class x2 extends Ot {
  constructor(t = {}) {
    super("@sentry/instrumentation-google-genai", Ze, t);
  }
  init() {
    return new ft(
      "@google/genai",
      ky,
      (n) => this._patch(n),
      (n) => n,
      [
        new Bn(
          "@google/genai/dist/node/index.cjs",
          ky,
          (n) => this._patch(n),
          (n) => n,
        ),
      ],
    );
  }
  _patch(t) {
    const n = t.GoogleGenAI,
      r = this.getConfig();
    if (typeof n != "function") return t;
    const o = function (...s) {
      if (IE(Cl)) return Reflect.construct(n, s);
      const i = Reflect.construct(n, s),
        c = !!he()?.getOptions().sendDefaultPii,
        l = r,
        f = l?.recordInputs ?? c,
        d = l?.recordOutputs ?? c;
      return L$(i, {
        recordInputs: f,
        recordOutputs: d,
      });
    };
    (Object.setPrototypeOf(o, n),
      Object.setPrototypeOf(o.prototype, n.prototype));
    for (const s of Object.getOwnPropertyNames(n))
      if (!["length", "name", "prototype"].includes(s)) {
        const i = Object.getOwnPropertyDescriptor(n, s);
        i && Object.defineProperty(o, s, i);
      }
    return (K$(t, "GoogleGenAI", o), t);
  }
}
const $2 = Ne(Cl, (e) => new x2(e)),
  B2 = (e = {}) => ({
    name: Cl,
    setupOnce() {
      $2(e);
    },
  }),
  H2 = B2,
  Bc = [">=0.1.0 <2.0.0"];
function F2(e, t) {
  return e
    ? Array.isArray(e)
      ? e.includes(t)
        ? e
        : [...e, t]
      : typeof e == "object"
        ? [e, t]
        : e
    : [t];
}
function Y2(e, t, n) {
  return new Proxy(e, {
    apply(r, o, s) {
      let a = s[1];
      (!a || typeof a != "object" || Array.isArray(a)) &&
        ((a = {}), (s[1] = a));
      const c = a.callbacks,
        l = F2(c, t);
      return ((a.callbacks = l), Reflect.apply(r, o, s));
    },
  });
}
class j2 extends Ot {
  constructor(t = {}) {
    super("@sentry/instrumentation-langchain", Ze, t);
  }
  init() {
    const t = [],
      n = [
        "@langchain/anthropic",
        "@langchain/openai",
        "@langchain/google-genai",
        "@langchain/mistralai",
        "@langchain/google-vertexai",
        "@langchain/groq",
      ];
    for (const r of n)
      t.push(
        new ft(r, Bc, this._patch.bind(this), (o) => o, [
          new Bn(`${r}/dist/index.cjs`, Bc, this._patch.bind(this), (o) => o),
        ]),
      );
    return (
      t.push(
        new ft("langchain", Bc, this._patch.bind(this), (r) => r, [
          new Bn(
            "langchain/dist/chat_models/universal.cjs",
            Bc,
            this._patch.bind(this),
            (r) => r,
          ),
        ]),
      ),
      t
    );
  }
  _patch(t) {
    xG([Nl, Ol, Cl]);
    const r = !!he()?.getOptions().sendDefaultPii,
      o = this.getConfig(),
      s = o?.recordInputs ?? r,
      i = o?.recordOutputs ?? r,
      a = $$({
        recordInputs: s,
        recordOutputs: i,
      });
    return (this._patchRunnableMethods(t, a), t);
  }
  _patchRunnableMethods(t, n) {
    const r = [
        "ChatAnthropic",
        "ChatOpenAI",
        "ChatGoogleGenerativeAI",
        "ChatMistralAI",
        "ChatVertexAI",
        "ChatGroq",
        "ConfigurableModel",
      ],
      o = t.universal_exports ?? t,
      s = Object.values(o).find(
        (c) => typeof c == "function" && r.includes(c.name),
      );
    if (!s) return;
    const i = s.prototype,
      a = ["invoke", "stream", "batch"];
    for (const c of a) {
      const l = i[c];
      typeof l == "function" && (i[c] = Y2(l, n));
    }
  }
}
const q2 = Ne(HP, (e) => new j2(e)),
  W2 = (e = {}) => ({
    name: HP,
    setupOnce() {
      q2(e);
    },
  }),
  K2 = W2,
  Gy = [">=0.0.0 <2.0.0"];
class z2 extends Ot {
  constructor(t = {}) {
    super("@sentry/instrumentation-langgraph", Ze, t);
  }
  init() {
    return new ft(
      "@langchain/langgraph",
      Gy,
      this._patch.bind(this),
      (n) => n,
      [
        new Bn(
          "@langchain/langgraph/dist/index.cjs",
          Gy,
          this._patch.bind(this),
          (n) => n,
        ),
      ],
    );
  }
  _patch(t) {
    const r = !!he()?.getOptions().sendDefaultPii,
      o = this.getConfig(),
      s = o.recordInputs ?? r,
      i = o.recordOutputs ?? r,
      a = {
        recordInputs: s,
        recordOutputs: i,
      };
    if (t.StateGraph && typeof t.StateGraph == "function") {
      const c = t.StateGraph;
      c.prototype.compile = q$(c.prototype.compile, a);
    }
    return t;
  }
}
const Z2 = Ne(YP, (e) => new z2(e)),
  X2 = (e = {}) => ({
    name: YP,
    setupOnce() {
      Z2(e);
    },
  }),
  Q2 = X2;
function J2(e, t, n, r, o) {
  let i = () => {};
  const a = o.firestoreSpanCreationHook;
  typeof a == "function" &&
    (i = (f) => {
      er(
        () => a(f),
        (d) => {
          d && C.diag.error(d?.message);
        },
        !0,
      );
    });
  const c = new ft("@firebase/firestore", t, (f) => Vy(f, n, r, e, i)),
    l = [
      "@firebase/firestore/dist/lite/index.node.cjs.js",
      "@firebase/firestore/dist/lite/index.node.mjs.js",
      "@firebase/firestore/dist/lite/index.rn.esm2017.js",
      "@firebase/firestore/dist/lite/index.cjs.js",
    ];
  for (const f of l)
    c.files.push(
      new Bn(
        f,
        t,
        (d) => Vy(d, n, r, e, i),
        (d) => kv(d, r),
      ),
    );
  return c;
}
function Vy(e, t, n, r, o) {
  return (
    kv(e, n),
    t(e, "addDoc", ez(r, o)),
    t(e, "getDocs", nz(r, o)),
    t(e, "setDoc", rz(r, o)),
    t(e, "deleteDoc", tz(r, o)),
    e
  );
}
function kv(e, t) {
  for (const n of ["addDoc", "getDocs", "setDoc", "deleteDoc"])
    il(e[n]) && t(e, n);
  return e;
}
function ez(e, t) {
  return function (r) {
    return function (o, s) {
      const i = Dl(e, "addDoc", o);
      return (t(i), Ll(i, () => r(o, s)));
    };
  };
}
function tz(e, t) {
  return function (r) {
    return function (o) {
      const s = Dl(e, "deleteDoc", o.parent || o);
      return (t(s), Ll(s, () => r(o)));
    };
  };
}
function nz(e, t) {
  return function (r) {
    return function (o) {
      const s = Dl(e, "getDocs", o);
      return (t(s), Ll(s, () => r(o)));
    };
  };
}
function rz(e, t) {
  return function (r) {
    return function (o, s, i) {
      const a = Dl(e, "setDoc", o.parent || o);
      return (t(a), Ll(a, () => (typeof i < "u" ? r(o, s, i) : r(o, s))));
    };
  };
}
function Ll(e, t) {
  return C.context.with(C.trace.setSpan(C.context.active(), e), () =>
    er(
      () => t(),
      (n) => {
        (n && e.recordException(n), e.end());
      },
      !0,
    ),
  );
}
function Dl(e, t, n) {
  const r = e.startSpan(`${t} ${n.path}`, {
    kind: C.SpanKind.CLIENT,
  });
  return (sz(r, n), r.setAttribute(Q.ATTR_DB_OPERATION_NAME, t), r);
}
function oz(e) {
  let t, n;
  if (typeof e.host == "string")
    if (e.host.startsWith("[")) {
      if (e.host.endsWith("]")) t = e.host.replace(/^\[|\]$/g, "");
      else if (e.host.includes("]:")) {
        const r = e.host.lastIndexOf(":");
        r !== -1 &&
          ((t = e.host.slice(1, r).replace(/^\[|\]$/g, "")),
          (n = e.host.slice(r + 1)));
      }
    } else if (Ao.isIPv6(e.host)) t = e.host;
    else {
      const r = e.host.lastIndexOf(":");
      r !== -1
        ? ((t = e.host.slice(0, r)), (n = e.host.slice(r + 1)))
        : (t = e.host);
    }
  return {
    address: t,
    port: n ? parseInt(n, 10) : void 0,
  };
}
function sz(e, t) {
  const n = t.firestore.app,
    r = n.options,
    s = (t.firestore.toJSON() || {}).settings || {},
    i = {
      [Q.ATTR_DB_COLLECTION_NAME]: t.path,
      [Q.ATTR_DB_NAMESPACE]: n.name,
      [Q.ATTR_DB_SYSTEM_NAME]: "firebase.firestore",
      "firebase.firestore.type": t.type,
      "firebase.firestore.options.projectId": r.projectId,
      "firebase.firestore.options.appId": r.appId,
      "firebase.firestore.options.messagingSenderId": r.messagingSenderId,
      "firebase.firestore.options.storageBucket": r.storageBucket,
    },
    { address: a, port: c } = oz(s);
  (a && (i[Q.ATTR_SERVER_ADDRESS] = a),
    c && (i[Q.ATTR_SERVER_PORT] = c),
    e.setAttributes(i));
}
function iz(e, t, n, r, o) {
  let s = () => {},
    i = () => {};
  const a = o.functions?.errorHook,
    c = o.functions?.requestHook,
    l = o.functions?.responseHook;
  (typeof l == "function" &&
    (i = (u, _) => {
      er(
        () => l(u, _),
        (p) => {
          p && C.diag.error(p?.message);
        },
        !0,
      );
    }),
    typeof c == "function" &&
      (s = (u) => {
        er(
          () => c(u),
          (_) => {
            _ && C.diag.error(_?.message);
          },
          !0,
        );
      }));
  const f = new ft("firebase-functions", t);
  return (
    [
      {
        name: "firebase-functions/lib/v2/providers/https.js",
        triggerType: "function",
      },
      {
        name: "firebase-functions/lib/v2/providers/firestore.js",
        triggerType: "firestore",
      },
      {
        name: "firebase-functions/lib/v2/providers/scheduler.js",
        triggerType: "scheduler",
      },
      {
        name: "firebase-functions/lib/v2/storage.js",
        triggerType: "storage",
      },
    ].forEach(({ name: u, triggerType: _ }) => {
      f.files.push(
        new Bn(
          u,
          t,
          (p) =>
            az(
              p,
              n,
              r,
              e,
              {
                requestHook: s,
                responseHook: i,
                errorHook: a,
              },
              _,
            ),
          (p) => Gv(p, r),
        ),
      );
    }),
    f
  );
}
function mt(e, t, n) {
  return function (o) {
    return function (...s) {
      const i = typeof s[0] == "function" ? s[0] : s[1],
        a = typeof s[0] == "function" ? void 0 : s[0];
      if (!i) return o.call(this, ...s);
      const c = async function (...l) {
        const f =
            process.env.FUNCTION_TARGET || process.env.K_SERVICE || "unknown",
          d = e.startSpan(`firebase.function.${n}`, {
            kind: C.SpanKind.SERVER,
          }),
          u = {
            "faas.name": f,
            "faas.trigger": n,
            "faas.provider": "firebase",
          };
        return (
          process.env.GCLOUD_PROJECT &&
            (u["cloud.project_id"] = process.env.GCLOUD_PROJECT),
          process.env.EVENTARC_CLOUD_EVENT_SOURCE &&
            (u["cloud.event_source"] = process.env.EVENTARC_CLOUD_EVENT_SOURCE),
          d.setAttributes(u),
          t?.requestHook?.(d),
          C.context.with(C.trace.setSpan(C.context.active(), d), async () => {
            let _, p;
            try {
              p = await i.apply(this, l);
            } catch (E) {
              _ = E;
            }
            if (
              (t?.responseHook?.(d, _), _ && d.recordException(_), d.end(), _)
            )
              throw (await t?.errorHook?.(d, _), _);
            return p;
          })
        );
      };
      return a ? o.call(this, a, c) : o.call(this, c);
    };
  };
}
function az(e, t, n, r, o, s) {
  switch ((Gv(e, n), s)) {
    case "function":
      (t(e, "onRequest", mt(r, o, "http.request")),
        t(e, "onCall", mt(r, o, "http.call")));
      break;
    case "firestore":
      (t(e, "onDocumentCreated", mt(r, o, "firestore.document.created")),
        t(e, "onDocumentUpdated", mt(r, o, "firestore.document.updated")),
        t(e, "onDocumentDeleted", mt(r, o, "firestore.document.deleted")),
        t(e, "onDocumentWritten", mt(r, o, "firestore.document.written")),
        t(
          e,
          "onDocumentCreatedWithAuthContext",
          mt(r, o, "firestore.document.created"),
        ),
        t(
          e,
          "onDocumentUpdatedWithAuthContext",
          mt(r, o, "firestore.document.updated"),
        ),
        t(
          e,
          "onDocumentDeletedWithAuthContext",
          mt(r, o, "firestore.document.deleted"),
        ),
        t(
          e,
          "onDocumentWrittenWithAuthContext",
          mt(r, o, "firestore.document.written"),
        ));
      break;
    case "scheduler":
      t(e, "onSchedule", mt(r, o, "scheduler.scheduled"));
      break;
    case "storage":
      (t(e, "onObjectFinalized", mt(r, o, "storage.object.finalized")),
        t(e, "onObjectArchived", mt(r, o, "storage.object.archived")),
        t(e, "onObjectDeleted", mt(r, o, "storage.object.deleted")),
        t(
          e,
          "onObjectMetadataUpdated",
          mt(r, o, "storage.object.metadataUpdated"),
        ));
      break;
  }
  return e;
}
function Gv(e, t) {
  const n = [
    "onSchedule",
    "onRequest",
    "onCall",
    "onObjectFinalized",
    "onObjectArchived",
    "onObjectDeleted",
    "onObjectMetadataUpdated",
    "onDocumentCreated",
    "onDocumentUpdated",
    "onDocumentDeleted",
    "onDocumentWritten",
    "onDocumentCreatedWithAuthContext",
    "onDocumentUpdatedWithAuthContext",
    "onDocumentDeletedWithAuthContext",
    "onDocumentWrittenWithAuthContext",
  ];
  for (const r of n) il(e[r]) && t(e, r);
  return e;
}
const xy = {},
  cz = [">=3.0.0 <5"],
  uz = [">=6.0.0 <7"];
class lz extends Ot {
  constructor(t = xy) {
    super("@sentry/instrumentation-firebase", Ze, t);
  }
  setConfig(t = {}) {
    super.setConfig({
      ...xy,
      ...t,
    });
  }
  init() {
    const t = [];
    return (
      t.push(J2(this.tracer, cz, this._wrap, this._unwrap, this.getConfig())),
      t.push(iz(this.tracer, uz, this._wrap, this._unwrap, this.getConfig())),
      t
    );
  }
}
const Vv = "Firebase",
  dz = {
    firestoreSpanCreationHook: (e) => {
      (yt(e, "auto.firebase.otel.firestore"), e.setAttribute(Ee, "db.query"));
    },
    functions: {
      requestHook: (e) => {
        (yt(e, "auto.firebase.otel.functions"),
          e.setAttribute(Ee, "http.request"));
      },
      errorHook: async (e, t) => {
        t &&
          (xe(t, {
            mechanism: {
              type: "auto.firebase.otel.functions",
              handled: !1,
            },
          }),
          await z1(2e3));
      },
    },
  },
  fz = Ne(Vv, () => new lz(dz)),
  _z = () => ({
    name: Vv,
    setupOnce() {
      fz();
    },
  }),
  pz = _z;
function Ez() {
  return [
    tj(),
    oq(),
    Eq(),
    vK(),
    Wq(),
    tW(),
    lW(),
    SW(),
    HW(),
    XW(),
    EK(),
    yK(),
    $K(),
    zK(),
    s2(),
    f2(),
    Cq(),
    g2(),
    Dq(),
    K2(),
    Q2(),
    I2(),
    D2(),
    V2(),
    H2(),
    tK(),
    pz(),
  ];
}
const gf = 1e6;
function hz(e, t = {}) {
  e.getOptions().debug && oY();
  const n = Tz(e, t);
  e.traceProvider = n;
}
function Tz(e, t = {}) {
  const n = new PB({
    sampler: new TH(e),
    resource: QP().merge(
      XP({
        [Q.ATTR_SERVICE_NAME]: "node",
        [Q.SEMRESATTRS_SERVICE_NAMESPACE]: "sentry",
        [Q.ATTR_SERVICE_VERSION]: Ze,
      }),
    ),
    forceFlushTimeoutMillis: 500,
    spanProcessors: [
      new hH({
        timeout: Sz(e.getOptions().maxSpanWaitDuration),
      }),
      ...(t.spanProcessors || []),
    ],
  });
  return (
    C.trace.setGlobalTracerProvider(n),
    C.propagation.setGlobalPropagator(new FB()),
    C.context.setGlobalContextManager(new rY()),
    n
  );
}
function Sz(e) {
  if (e != null) {
    if (e > gf)
      return (
        ro &&
          $.warn(
            `\`maxSpanWaitDuration\` is too high, using the maximum value of ${gf}`,
          ),
        gf
      );
    if (e <= 0 || Number.isNaN(e)) {
      ro &&
        $.warn(
          "`maxSpanWaitDuration` must be a positive number, using default value instead.",
        );
      return;
    }
    return e;
  }
}
function mz() {
  return xM()
    .filter((t) => t.name !== "Http" && t.name !== "NodeFetch")
    .concat(DY(), HY());
}
function Az(e) {
  return [...mz(), ...(zt(e) ? Ez() : [])];
}
function gz(e = {}) {
  return Rz(e, Az);
}
function Rz(e = {}, t) {
  PE(e, "node");
  const n = NY({
    ...e,
    defaultIntegrations: e.defaultIntegrations ?? t(e),
  });
  return (
    n &&
      !e.skipOpenTelemetrySetup &&
      (hz(n, {
        spanProcessors: e.openTelemetrySpanProcessors,
      }),
      OY()),
    n
  );
}
function W(e, t, n) {
  function r(a, c) {
    if (
      (a._zod ||
        Object.defineProperty(a, "_zod", {
          value: {
            def: c,
            constr: i,
            traits: new Set(),
          },
          enumerable: !1,
        }),
      a._zod.traits.has(e))
    )
      return;
    (a._zod.traits.add(e), t(a, c));
    const l = i.prototype,
      f = Object.keys(l);
    for (let d = 0; d < f.length; d++) {
      const u = f[d];
      u in a || (a[u] = l[u].bind(a));
    }
  }
  const o = n?.Parent ?? Object;
  class s extends o {}
  Object.defineProperty(s, "name", {
    value: e,
  });
  function i(a) {
    var c;
    const l = n?.Parent ? new s() : this;
    (r(l, a), (c = l._zod).deferred ?? (c.deferred = []));
    for (const f of l._zod.deferred) f();
    return l;
  }
  return (
    Object.defineProperty(i, "init", {
      value: r,
    }),
    Object.defineProperty(i, Symbol.hasInstance, {
      value: (a) =>
        n?.Parent && a instanceof n.Parent ? !0 : a?._zod?.traits?.has(e),
    }),
    Object.defineProperty(i, "name", {
      value: e,
    }),
    i
  );
}
class wo extends Error {
  constructor() {
    super(
      "Encountered Promise during synchronous parse. Use .parseAsync() instead.",
    );
  }
}
class xv extends Error {
  constructor(t) {
    (super(`Encountered unidirectional transform during encode: ${t}`),
      (this.name = "ZodEncodeError"));
  }
}
const $v = {};
function oo(e) {
  return $v;
}
function Nz(e) {
  const t = Object.values(e).filter((r) => typeof r == "number");
  return Object.entries(e)
    .filter(([r, o]) => t.indexOf(+r) === -1)
    .map(([r, o]) => o);
}
function Up(e, t) {
  return typeof t == "bigint" ? t.toString() : t;
}
function sh(e) {
  return {
    get value() {
      {
        const t = e();
        return (
          Object.defineProperty(this, "value", {
            value: t,
          }),
          t
        );
      }
    },
  };
}
function ih(e) {
  return e == null;
}
function ah(e) {
  const t = e.startsWith("^") ? 1 : 0,
    n = e.endsWith("$") ? e.length - 1 : e.length;
  return e.slice(t, n);
}
function yz(e, t) {
  const n = (e.toString().split(".")[1] || "").length,
    r = t.toString();
  let o = (r.split(".")[1] || "").length;
  if (o === 0 && /\d?e-\d?/.test(r)) {
    const c = r.match(/\d?e-(\d?)/);
    c?.[1] && (o = Number.parseInt(c[1]));
  }
  const s = n > o ? n : o,
    i = Number.parseInt(e.toFixed(s).replace(".", "")),
    a = Number.parseInt(t.toFixed(s).replace(".", ""));
  return (i % a) / 10 ** s;
}
const $y = Symbol("evaluating");
function ke(e, t, n) {
  let r;
  Object.defineProperty(e, t, {
    get() {
      if (r !== $y) return (r === void 0 && ((r = $y), (r = n())), r);
    },
    set(o) {
      Object.defineProperty(e, t, {
        value: o,
      });
    },
    configurable: !0,
  });
}
function fo(e, t, n) {
  Object.defineProperty(e, t, {
    value: n,
    writable: !0,
    enumerable: !0,
    configurable: !0,
  });
}
function _o(...e) {
  const t = {};
  for (const n of e) {
    const r = Object.getOwnPropertyDescriptors(n);
    Object.assign(t, r);
  }
  return Object.defineProperties({}, t);
}
function By(e) {
  return JSON.stringify(e);
}
function Oz(e) {
  return e
    .toLowerCase()
    .trim()
    .replace(/[^\w\s-]/g, "")
    .replace(/[\s_-]+/g, "-")
    .replace(/^-+|-+$/g, "");
}
const Bv =
  "captureStackTrace" in Error ? Error.captureStackTrace : (...e) => {};
function ku(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
const Cz = sh(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare"))
    return !1;
  try {
    const e = Function;
    return (new e(""), !0);
  } catch {
    return !1;
  }
});
function cc(e) {
  if (ku(e) === !1) return !1;
  const t = e.constructor;
  if (t === void 0 || typeof t != "function") return !0;
  const n = t.prototype;
  return !(
    ku(n) === !1 ||
    Object.prototype.hasOwnProperty.call(n, "isPrototypeOf") === !1
  );
}
function Hv(e) {
  return cc(e)
    ? {
        ...e,
      }
    : Array.isArray(e)
      ? [...e]
      : e;
}
const bz = new Set(["string", "number", "symbol"]);
function wl(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function or(e, t, n) {
  const r = new e._zod.constr(t ?? e._zod.def);
  return ((!t || n?.parent) && (r._zod.parent = e), r);
}
function fe(e) {
  const t = e;
  if (!t) return {};
  if (typeof t == "string")
    return {
      error: () => t,
    };
  if (t?.message !== void 0) {
    if (t?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    t.error = t.message;
  }
  return (
    delete t.message,
    typeof t.error == "string"
      ? {
          ...t,
          error: () => t.error,
        }
      : t
  );
}
function Iz(e) {
  return Object.keys(e).filter(
    (t) => e[t]._zod.optin === "optional" && e[t]._zod.optout === "optional",
  );
}
const Pz = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE],
};
function Mz(e, t) {
  const n = e._zod.def,
    r = _o(e._zod.def, {
      get shape() {
        const o = {};
        for (const s in t) {
          if (!(s in n.shape)) throw new Error(`Unrecognized key: "${s}"`);
          t[s] && (o[s] = n.shape[s]);
        }
        return (fo(this, "shape", o), o);
      },
      checks: [],
    });
  return or(e, r);
}
function vz(e, t) {
  const n = e._zod.def,
    r = _o(e._zod.def, {
      get shape() {
        const o = {
          ...e._zod.def.shape,
        };
        for (const s in t) {
          if (!(s in n.shape)) throw new Error(`Unrecognized key: "${s}"`);
          t[s] && delete o[s];
        }
        return (fo(this, "shape", o), o);
      },
      checks: [],
    });
  return or(e, r);
}
function Lz(e, t) {
  if (!cc(t))
    throw new Error("Invalid input to extend: expected a plain object");
  const n = e._zod.def.checks;
  if (n && n.length > 0)
    throw new Error(
      "Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.",
    );
  const o = _o(e._zod.def, {
    get shape() {
      const s = {
        ...e._zod.def.shape,
        ...t,
      };
      return (fo(this, "shape", s), s);
    },
    checks: [],
  });
  return or(e, o);
}
function Dz(e, t) {
  if (!cc(t))
    throw new Error("Invalid input to safeExtend: expected a plain object");
  const n = {
    ...e._zod.def,
    get shape() {
      const r = {
        ...e._zod.def.shape,
        ...t,
      };
      return (fo(this, "shape", r), r);
    },
    checks: e._zod.def.checks,
  };
  return or(e, n);
}
function wz(e, t) {
  const n = _o(e._zod.def, {
    get shape() {
      const r = {
        ...e._zod.def.shape,
        ...t._zod.def.shape,
      };
      return (fo(this, "shape", r), r);
    },
    get catchall() {
      return t._zod.def.catchall;
    },
    checks: [],
  });
  return or(e, n);
}
function Uz(e, t, n) {
  const r = _o(t._zod.def, {
    get shape() {
      const o = t._zod.def.shape,
        s = {
          ...o,
        };
      if (n)
        for (const i in n) {
          if (!(i in o)) throw new Error(`Unrecognized key: "${i}"`);
          n[i] &&
            (s[i] = e
              ? new e({
                  type: "optional",
                  innerType: o[i],
                })
              : o[i]);
        }
      else
        for (const i in o)
          s[i] = e
            ? new e({
                type: "optional",
                innerType: o[i],
              })
            : o[i];
      return (fo(this, "shape", s), s);
    },
    checks: [],
  });
  return or(t, r);
}
function kz(e, t, n) {
  const r = _o(t._zod.def, {
    get shape() {
      const o = t._zod.def.shape,
        s = {
          ...o,
        };
      if (n)
        for (const i in n) {
          if (!(i in s)) throw new Error(`Unrecognized key: "${i}"`);
          n[i] &&
            (s[i] = new e({
              type: "nonoptional",
              innerType: o[i],
            }));
        }
      else
        for (const i in o)
          s[i] = new e({
            type: "nonoptional",
            innerType: o[i],
          });
      return (fo(this, "shape", s), s);
    },
    checks: [],
  });
  return or(t, r);
}
function Oo(e, t = 0) {
  if (e.aborted === !0) return !0;
  for (let n = t; n < e.issues.length; n++)
    if (e.issues[n]?.continue !== !0) return !0;
  return !1;
}
function Fv(e, t) {
  return t.map((n) => {
    var r;
    return ((r = n).path ?? (r.path = []), n.path.unshift(e), n);
  });
}
function Hc(e) {
  return typeof e == "string" ? e : e?.message;
}
function so(e, t, n) {
  const r = {
    ...e,
    path: e.path ?? [],
  };
  if (!e.message) {
    const o =
      Hc(e.inst?._zod.def?.error?.(e)) ??
      Hc(t?.error?.(e)) ??
      Hc(n.customError?.(e)) ??
      Hc(n.localeError?.(e)) ??
      "Invalid input";
    r.message = o;
  }
  return (
    delete r.inst,
    delete r.continue,
    t?.reportInput || delete r.input,
    r
  );
}
function ch(e) {
  return Array.isArray(e)
    ? "array"
    : typeof e == "string"
      ? "string"
      : "unknown";
}
function uc(...e) {
  const [t, n, r] = e;
  return typeof t == "string"
    ? {
        message: t,
        code: "custom",
        input: n,
        inst: r,
      }
    : {
        ...t,
      };
}
const Yv = (e, t) => {
    ((e.name = "$ZodError"),
      Object.defineProperty(e, "_zod", {
        value: e._zod,
        enumerable: !1,
      }),
      Object.defineProperty(e, "issues", {
        value: t,
        enumerable: !1,
      }),
      (e.message = JSON.stringify(t, Up, 2)),
      Object.defineProperty(e, "toString", {
        value: () => e.message,
        enumerable: !1,
      }));
  },
  jv = W("$ZodError", Yv),
  qv = W("$ZodError", Yv, {
    Parent: Error,
  });
function Gz(e, t = (n) => n.message) {
  const n = {},
    r = [];
  for (const o of e.issues)
    o.path.length > 0
      ? ((n[o.path[0]] = n[o.path[0]] || []), n[o.path[0]].push(t(o)))
      : r.push(t(o));
  return {
    formErrors: r,
    fieldErrors: n,
  };
}
function Vz(e, t = (n) => n.message) {
  const n = {
      _errors: [],
    },
    r = (o) => {
      for (const s of o.issues)
        if (s.code === "invalid_union" && s.errors.length)
          s.errors.map((i) =>
            r({
              issues: i,
            }),
          );
        else if (s.code === "invalid_key")
          r({
            issues: s.issues,
          });
        else if (s.code === "invalid_element")
          r({
            issues: s.issues,
          });
        else if (s.path.length === 0) n._errors.push(t(s));
        else {
          let i = n,
            a = 0;
          for (; a < s.path.length; ) {
            const c = s.path[a];
            (a === s.path.length - 1
              ? ((i[c] = i[c] || {
                  _errors: [],
                }),
                i[c]._errors.push(t(s)))
              : (i[c] = i[c] || {
                  _errors: [],
                }),
              (i = i[c]),
              a++);
          }
        }
    };
  return (r(e), n);
}
const uh = (e) => (t, n, r, o) => {
    const s = r
        ? Object.assign(r, {
            async: !1,
          })
        : {
            async: !1,
          },
      i = t._zod.run(
        {
          value: n,
          issues: [],
        },
        s,
      );
    if (i instanceof Promise) throw new wo();
    if (i.issues.length) {
      const a = new (o?.Err ?? e)(i.issues.map((c) => so(c, s, oo())));
      throw (Bv(a, o?.callee), a);
    }
    return i.value;
  },
  lh = (e) => async (t, n, r, o) => {
    const s = r
      ? Object.assign(r, {
          async: !0,
        })
      : {
          async: !0,
        };
    let i = t._zod.run(
      {
        value: n,
        issues: [],
      },
      s,
    );
    if ((i instanceof Promise && (i = await i), i.issues.length)) {
      const a = new (o?.Err ?? e)(i.issues.map((c) => so(c, s, oo())));
      throw (Bv(a, o?.callee), a);
    }
    return i.value;
  },
  Ul = (e) => (t, n, r) => {
    const o = r
        ? {
            ...r,
            async: !1,
          }
        : {
            async: !1,
          },
      s = t._zod.run(
        {
          value: n,
          issues: [],
        },
        o,
      );
    if (s instanceof Promise) throw new wo();
    return s.issues.length
      ? {
          success: !1,
          error: new (e ?? jv)(s.issues.map((i) => so(i, o, oo()))),
        }
      : {
          success: !0,
          data: s.value,
        };
  },
  xz = Ul(qv),
  kl = (e) => async (t, n, r) => {
    const o = r
      ? Object.assign(r, {
          async: !0,
        })
      : {
          async: !0,
        };
    let s = t._zod.run(
      {
        value: n,
        issues: [],
      },
      o,
    );
    return (
      s instanceof Promise && (s = await s),
      s.issues.length
        ? {
            success: !1,
            error: new e(s.issues.map((i) => so(i, o, oo()))),
          }
        : {
            success: !0,
            data: s.value,
          }
    );
  },
  $z = kl(qv),
  Bz = (e) => (t, n, r) => {
    const o = r
      ? Object.assign(r, {
          direction: "backward",
        })
      : {
          direction: "backward",
        };
    return uh(e)(t, n, o);
  },
  Hz = (e) => (t, n, r) => uh(e)(t, n, r),
  Fz = (e) => async (t, n, r) => {
    const o = r
      ? Object.assign(r, {
          direction: "backward",
        })
      : {
          direction: "backward",
        };
    return lh(e)(t, n, o);
  },
  Yz = (e) => async (t, n, r) => lh(e)(t, n, r),
  jz = (e) => (t, n, r) => {
    const o = r
      ? Object.assign(r, {
          direction: "backward",
        })
      : {
          direction: "backward",
        };
    return Ul(e)(t, n, o);
  },
  qz = (e) => (t, n, r) => Ul(e)(t, n, r),
  Wz = (e) => async (t, n, r) => {
    const o = r
      ? Object.assign(r, {
          direction: "backward",
        })
      : {
          direction: "backward",
        };
    return kl(e)(t, n, o);
  },
  Kz = (e) => async (t, n, r) => kl(e)(t, n, r),
  zz = /^[cC][^\s-]{8,}$/,
  Zz = /^[0-9a-z]+$/,
  Xz = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/,
  Qz = /^[0-9a-vA-V]{20}$/,
  Jz = /^[A-Za-z0-9]{27}$/,
  e3 = /^[a-zA-Z0-9_-]{21}$/,
  t3 =
    /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/,
  n3 =
    /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/,
  Hy = (e) =>
    e
      ? new RegExp(
          `^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`,
        )
      : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/,
  r3 =
    /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/,
  o3 = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function s3() {
  return new RegExp(o3, "u");
}
const i3 =
    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  a3 =
    /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/,
  c3 =
    /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/,
  u3 =
    /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  l3 =
    /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/,
  Wv = /^[A-Za-z0-9_-]*$/,
  d3 = /^\+(?:[0-9]){6,14}[0-9]$/,
  Kv =
    "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))",
  f3 = new RegExp(`^${Kv}$`);
function zv(e) {
  const t = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof e.precision == "number"
    ? e.precision === -1
      ? `${t}`
      : e.precision === 0
        ? `${t}:[0-5]\\d`
        : `${t}:[0-5]\\d\\.\\d{${e.precision}}`
    : `${t}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function _3(e) {
  return new RegExp(`^${zv(e)}$`);
}
function p3(e) {
  const t = zv({
      precision: e.precision,
    }),
    n = ["Z"];
  (e.local && n.push(""),
    e.offset && n.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)"));
  const r = `${t}(?:${n.join("|")})`;
  return new RegExp(`^${Kv}T(?:${r})$`);
}
const E3 = (e) => {
    const t = e
      ? `[\\s\\S]{${e?.minimum ?? 0},${e?.maximum ?? ""}}`
      : "[\\s\\S]*";
    return new RegExp(`^${t}$`);
  },
  h3 = /^-?\d+$/,
  T3 = /^-?\d+(?:\.\d+)?/,
  S3 = /^[^A-Z]*$/,
  m3 = /^[^a-z]*$/,
  Pt = W("$ZodCheck", (e, t) => {
    var n;
    (e._zod ?? (e._zod = {}),
      (e._zod.def = t),
      (n = e._zod).onattach ?? (n.onattach = []));
  }),
  Zv = {
    number: "number",
    bigint: "bigint",
    object: "date",
  },
  Xv = W("$ZodCheckLessThan", (e, t) => {
    Pt.init(e, t);
    const n = Zv[typeof t.value];
    (e._zod.onattach.push((r) => {
      const o = r._zod.bag,
        s =
          (t.inclusive ? o.maximum : o.exclusiveMaximum) ??
          Number.POSITIVE_INFINITY;
      t.value < s &&
        (t.inclusive ? (o.maximum = t.value) : (o.exclusiveMaximum = t.value));
    }),
      (e._zod.check = (r) => {
        (t.inclusive ? r.value <= t.value : r.value < t.value) ||
          r.issues.push({
            origin: n,
            code: "too_big",
            maximum: t.value,
            input: r.value,
            inclusive: t.inclusive,
            inst: e,
            continue: !t.abort,
          });
      }));
  }),
  Qv = W("$ZodCheckGreaterThan", (e, t) => {
    Pt.init(e, t);
    const n = Zv[typeof t.value];
    (e._zod.onattach.push((r) => {
      const o = r._zod.bag,
        s =
          (t.inclusive ? o.minimum : o.exclusiveMinimum) ??
          Number.NEGATIVE_INFINITY;
      t.value > s &&
        (t.inclusive ? (o.minimum = t.value) : (o.exclusiveMinimum = t.value));
    }),
      (e._zod.check = (r) => {
        (t.inclusive ? r.value >= t.value : r.value > t.value) ||
          r.issues.push({
            origin: n,
            code: "too_small",
            minimum: t.value,
            input: r.value,
            inclusive: t.inclusive,
            inst: e,
            continue: !t.abort,
          });
      }));
  }),
  A3 = W("$ZodCheckMultipleOf", (e, t) => {
    (Pt.init(e, t),
      e._zod.onattach.push((n) => {
        var r;
        (r = n._zod.bag).multipleOf ?? (r.multipleOf = t.value);
      }),
      (e._zod.check = (n) => {
        if (typeof n.value != typeof t.value)
          throw new Error("Cannot mix number and bigint in multiple_of check.");
        (typeof n.value == "bigint"
          ? n.value % t.value === BigInt(0)
          : yz(n.value, t.value) === 0) ||
          n.issues.push({
            origin: typeof n.value,
            code: "not_multiple_of",
            divisor: t.value,
            input: n.value,
            inst: e,
            continue: !t.abort,
          });
      }));
  }),
  g3 = W("$ZodCheckNumberFormat", (e, t) => {
    (Pt.init(e, t), (t.format = t.format || "float64"));
    const n = t.format?.includes("int"),
      r = n ? "int" : "number",
      [o, s] = Pz[t.format];
    (e._zod.onattach.push((i) => {
      const a = i._zod.bag;
      ((a.format = t.format),
        (a.minimum = o),
        (a.maximum = s),
        n && (a.pattern = h3));
    }),
      (e._zod.check = (i) => {
        const a = i.value;
        if (n) {
          if (!Number.isInteger(a)) {
            i.issues.push({
              expected: r,
              format: t.format,
              code: "invalid_type",
              continue: !1,
              input: a,
              inst: e,
            });
            return;
          }
          if (!Number.isSafeInteger(a)) {
            a > 0
              ? i.issues.push({
                  input: a,
                  code: "too_big",
                  maximum: Number.MAX_SAFE_INTEGER,
                  note: "Integers must be within the safe integer range.",
                  inst: e,
                  origin: r,
                  continue: !t.abort,
                })
              : i.issues.push({
                  input: a,
                  code: "too_small",
                  minimum: Number.MIN_SAFE_INTEGER,
                  note: "Integers must be within the safe integer range.",
                  inst: e,
                  origin: r,
                  continue: !t.abort,
                });
            return;
          }
        }
        (a < o &&
          i.issues.push({
            origin: "number",
            input: a,
            code: "too_small",
            minimum: o,
            inclusive: !0,
            inst: e,
            continue: !t.abort,
          }),
          a > s &&
            i.issues.push({
              origin: "number",
              input: a,
              code: "too_big",
              maximum: s,
              inst: e,
            }));
      }));
  }),
  R3 = W("$ZodCheckMaxLength", (e, t) => {
    var n;
    (Pt.init(e, t),
      (n = e._zod.def).when ??
        (n.when = (r) => {
          const o = r.value;
          return !ih(o) && o.length !== void 0;
        }),
      e._zod.onattach.push((r) => {
        const o = r._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        t.maximum < o && (r._zod.bag.maximum = t.maximum);
      }),
      (e._zod.check = (r) => {
        const o = r.value;
        if (o.length <= t.maximum) return;
        const i = ch(o);
        r.issues.push({
          origin: i,
          code: "too_big",
          maximum: t.maximum,
          inclusive: !0,
          input: o,
          inst: e,
          continue: !t.abort,
        });
      }));
  }),
  N3 = W("$ZodCheckMinLength", (e, t) => {
    var n;
    (Pt.init(e, t),
      (n = e._zod.def).when ??
        (n.when = (r) => {
          const o = r.value;
          return !ih(o) && o.length !== void 0;
        }),
      e._zod.onattach.push((r) => {
        const o = r._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        t.minimum > o && (r._zod.bag.minimum = t.minimum);
      }),
      (e._zod.check = (r) => {
        const o = r.value;
        if (o.length >= t.minimum) return;
        const i = ch(o);
        r.issues.push({
          origin: i,
          code: "too_small",
          minimum: t.minimum,
          inclusive: !0,
          input: o,
          inst: e,
          continue: !t.abort,
        });
      }));
  }),
  y3 = W("$ZodCheckLengthEquals", (e, t) => {
    var n;
    (Pt.init(e, t),
      (n = e._zod.def).when ??
        (n.when = (r) => {
          const o = r.value;
          return !ih(o) && o.length !== void 0;
        }),
      e._zod.onattach.push((r) => {
        const o = r._zod.bag;
        ((o.minimum = t.length), (o.maximum = t.length), (o.length = t.length));
      }),
      (e._zod.check = (r) => {
        const o = r.value,
          s = o.length;
        if (s === t.length) return;
        const i = ch(o),
          a = s > t.length;
        r.issues.push({
          origin: i,
          ...(a
            ? {
                code: "too_big",
                maximum: t.length,
              }
            : {
                code: "too_small",
                minimum: t.length,
              }),
          inclusive: !0,
          exact: !0,
          input: r.value,
          inst: e,
          continue: !t.abort,
        });
      }));
  }),
  Gl = W("$ZodCheckStringFormat", (e, t) => {
    var n, r;
    (Pt.init(e, t),
      e._zod.onattach.push((o) => {
        const s = o._zod.bag;
        ((s.format = t.format),
          t.pattern &&
            (s.patterns ?? (s.patterns = new Set()),
            s.patterns.add(t.pattern)));
      }),
      t.pattern
        ? ((n = e._zod).check ??
          (n.check = (o) => {
            ((t.pattern.lastIndex = 0),
              !t.pattern.test(o.value) &&
                o.issues.push({
                  origin: "string",
                  code: "invalid_format",
                  format: t.format,
                  input: o.value,
                  ...(t.pattern
                    ? {
                        pattern: t.pattern.toString(),
                      }
                    : {}),
                  inst: e,
                  continue: !t.abort,
                }));
          }))
        : ((r = e._zod).check ?? (r.check = () => {})));
  }),
  O3 = W("$ZodCheckRegex", (e, t) => {
    (Gl.init(e, t),
      (e._zod.check = (n) => {
        ((t.pattern.lastIndex = 0),
          !t.pattern.test(n.value) &&
            n.issues.push({
              origin: "string",
              code: "invalid_format",
              format: "regex",
              input: n.value,
              pattern: t.pattern.toString(),
              inst: e,
              continue: !t.abort,
            }));
      }));
  }),
  C3 = W("$ZodCheckLowerCase", (e, t) => {
    (t.pattern ?? (t.pattern = S3), Gl.init(e, t));
  }),
  b3 = W("$ZodCheckUpperCase", (e, t) => {
    (t.pattern ?? (t.pattern = m3), Gl.init(e, t));
  }),
  I3 = W("$ZodCheckIncludes", (e, t) => {
    Pt.init(e, t);
    const n = wl(t.includes),
      r = new RegExp(
        typeof t.position == "number" ? `^.{${t.position}}${n}` : n,
      );
    ((t.pattern = r),
      e._zod.onattach.push((o) => {
        const s = o._zod.bag;
        (s.patterns ?? (s.patterns = new Set()), s.patterns.add(r));
      }),
      (e._zod.check = (o) => {
        o.value.includes(t.includes, t.position) ||
          o.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "includes",
            includes: t.includes,
            input: o.value,
            inst: e,
            continue: !t.abort,
          });
      }));
  }),
  P3 = W("$ZodCheckStartsWith", (e, t) => {
    Pt.init(e, t);
    const n = new RegExp(`^${wl(t.prefix)}.*`);
    (t.pattern ?? (t.pattern = n),
      e._zod.onattach.push((r) => {
        const o = r._zod.bag;
        (o.patterns ?? (o.patterns = new Set()), o.patterns.add(n));
      }),
      (e._zod.check = (r) => {
        r.value.startsWith(t.prefix) ||
          r.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "starts_with",
            prefix: t.prefix,
            input: r.value,
            inst: e,
            continue: !t.abort,
          });
      }));
  }),
  M3 = W("$ZodCheckEndsWith", (e, t) => {
    Pt.init(e, t);
    const n = new RegExp(`.*${wl(t.suffix)}$`);
    (t.pattern ?? (t.pattern = n),
      e._zod.onattach.push((r) => {
        const o = r._zod.bag;
        (o.patterns ?? (o.patterns = new Set()), o.patterns.add(n));
      }),
      (e._zod.check = (r) => {
        r.value.endsWith(t.suffix) ||
          r.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "ends_with",
            suffix: t.suffix,
            input: r.value,
            inst: e,
            continue: !t.abort,
          });
      }));
  }),
  v3 = W("$ZodCheckOverwrite", (e, t) => {
    (Pt.init(e, t),
      (e._zod.check = (n) => {
        n.value = t.tx(n.value);
      }));
  });
class L3 {
  constructor(t = []) {
    ((this.content = []), (this.indent = 0), this && (this.args = t));
  }
  indented(t) {
    ((this.indent += 1), t(this), (this.indent -= 1));
  }
  write(t) {
    if (typeof t == "function") {
      (t(this, {
        execution: "sync",
      }),
        t(this, {
          execution: "async",
        }));
      return;
    }
    const r = t
        .split(
          `
`,
        )
        .filter((i) => i),
      o = Math.min(...r.map((i) => i.length - i.trimStart().length)),
      s = r.map((i) => i.slice(o)).map((i) => " ".repeat(this.indent * 2) + i);
    for (const i of s) this.content.push(i);
  }
  compile() {
    const t = Function,
      n = this?.args,
      o = [...(this?.content ?? [""]).map((s) => `  ${s}`)];
    return new t(
      ...n,
      o.join(`
`),
    );
  }
}
const D3 = {
    major: 4,
    minor: 1,
    patch: 13,
  },
  Xe = W("$ZodType", (e, t) => {
    var n;
    (e ?? (e = {}),
      (e._zod.def = t),
      (e._zod.bag = e._zod.bag || {}),
      (e._zod.version = D3));
    const r = [...(e._zod.def.checks ?? [])];
    e._zod.traits.has("$ZodCheck") && r.unshift(e);
    for (const o of r) for (const s of o._zod.onattach) s(e);
    if (r.length === 0)
      ((n = e._zod).deferred ?? (n.deferred = []),
        e._zod.deferred?.push(() => {
          e._zod.run = e._zod.parse;
        }));
    else {
      const o = (i, a, c) => {
          let l = Oo(i),
            f;
          for (const d of a) {
            if (d._zod.def.when) {
              if (!d._zod.def.when(i)) continue;
            } else if (l) continue;
            const u = i.issues.length,
              _ = d._zod.check(i);
            if (_ instanceof Promise && c?.async === !1) throw new wo();
            if (f || _ instanceof Promise)
              f = (f ?? Promise.resolve()).then(async () => {
                (await _, i.issues.length !== u && (l || (l = Oo(i, u))));
              });
            else {
              if (i.issues.length === u) continue;
              l || (l = Oo(i, u));
            }
          }
          return f ? f.then(() => i) : i;
        },
        s = (i, a, c) => {
          if (Oo(i)) return ((i.aborted = !0), i);
          const l = o(a, r, c);
          if (l instanceof Promise) {
            if (c.async === !1) throw new wo();
            return l.then((f) => e._zod.parse(f, c));
          }
          return e._zod.parse(l, c);
        };
      e._zod.run = (i, a) => {
        if (a.skipChecks) return e._zod.parse(i, a);
        if (a.direction === "backward") {
          const l = e._zod.parse(
            {
              value: i.value,
              issues: [],
            },
            {
              ...a,
              skipChecks: !0,
            },
          );
          return l instanceof Promise ? l.then((f) => s(f, i, a)) : s(l, i, a);
        }
        const c = e._zod.parse(i, a);
        if (c instanceof Promise) {
          if (a.async === !1) throw new wo();
          return c.then((l) => o(l, r, a));
        }
        return o(c, r, a);
      };
    }
    e["~standard"] = {
      validate: (o) => {
        try {
          const s = xz(e, o);
          return s.success
            ? {
                value: s.data,
              }
            : {
                issues: s.error?.issues,
              };
        } catch {
          return $z(e, o).then((i) =>
            i.success
              ? {
                  value: i.data,
                }
              : {
                  issues: i.error?.issues,
                },
          );
        }
      },
      vendor: "zod",
      version: 1,
    };
  }),
  dh = W("$ZodString", (e, t) => {
    (Xe.init(e, t),
      (e._zod.pattern =
        [...(e?._zod.bag?.patterns ?? [])].pop() ?? E3(e._zod.bag)),
      (e._zod.parse = (n, r) => {
        if (t.coerce)
          try {
            n.value = String(n.value);
          } catch {}
        return (
          typeof n.value == "string" ||
            n.issues.push({
              expected: "string",
              code: "invalid_type",
              input: n.value,
              inst: e,
            }),
          n
        );
      }));
  }),
  $e = W("$ZodStringFormat", (e, t) => {
    (Gl.init(e, t), dh.init(e, t));
  }),
  w3 = W("$ZodGUID", (e, t) => {
    (t.pattern ?? (t.pattern = n3), $e.init(e, t));
  }),
  U3 = W("$ZodUUID", (e, t) => {
    if (t.version) {
      const r = {
        v1: 1,
        v2: 2,
        v3: 3,
        v4: 4,
        v5: 5,
        v6: 6,
        v7: 7,
        v8: 8,
      }[t.version];
      if (r === void 0) throw new Error(`Invalid UUID version: "${t.version}"`);
      t.pattern ?? (t.pattern = Hy(r));
    } else t.pattern ?? (t.pattern = Hy());
    $e.init(e, t);
  }),
  k3 = W("$ZodEmail", (e, t) => {
    (t.pattern ?? (t.pattern = r3), $e.init(e, t));
  }),
  G3 = W("$ZodURL", (e, t) => {
    ($e.init(e, t),
      (e._zod.check = (n) => {
        try {
          const r = n.value.trim(),
            o = new URL(r);
          (t.hostname &&
            ((t.hostname.lastIndex = 0),
            t.hostname.test(o.hostname) ||
              n.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid hostname",
                pattern: t.hostname.source,
                input: n.value,
                inst: e,
                continue: !t.abort,
              })),
            t.protocol &&
              ((t.protocol.lastIndex = 0),
              t.protocol.test(
                o.protocol.endsWith(":") ? o.protocol.slice(0, -1) : o.protocol,
              ) ||
                n.issues.push({
                  code: "invalid_format",
                  format: "url",
                  note: "Invalid protocol",
                  pattern: t.protocol.source,
                  input: n.value,
                  inst: e,
                  continue: !t.abort,
                })),
            t.normalize ? (n.value = o.href) : (n.value = r));
          return;
        } catch {
          n.issues.push({
            code: "invalid_format",
            format: "url",
            input: n.value,
            inst: e,
            continue: !t.abort,
          });
        }
      }));
  }),
  V3 = W("$ZodEmoji", (e, t) => {
    (t.pattern ?? (t.pattern = s3()), $e.init(e, t));
  }),
  x3 = W("$ZodNanoID", (e, t) => {
    (t.pattern ?? (t.pattern = e3), $e.init(e, t));
  }),
  $3 = W("$ZodCUID", (e, t) => {
    (t.pattern ?? (t.pattern = zz), $e.init(e, t));
  }),
  B3 = W("$ZodCUID2", (e, t) => {
    (t.pattern ?? (t.pattern = Zz), $e.init(e, t));
  }),
  H3 = W("$ZodULID", (e, t) => {
    (t.pattern ?? (t.pattern = Xz), $e.init(e, t));
  }),
  F3 = W("$ZodXID", (e, t) => {
    (t.pattern ?? (t.pattern = Qz), $e.init(e, t));
  }),
  Y3 = W("$ZodKSUID", (e, t) => {
    (t.pattern ?? (t.pattern = Jz), $e.init(e, t));
  }),
  j3 = W("$ZodISODateTime", (e, t) => {
    (t.pattern ?? (t.pattern = p3(t)), $e.init(e, t));
  }),
  q3 = W("$ZodISODate", (e, t) => {
    (t.pattern ?? (t.pattern = f3), $e.init(e, t));
  }),
  W3 = W("$ZodISOTime", (e, t) => {
    (t.pattern ?? (t.pattern = _3(t)), $e.init(e, t));
  }),
  K3 = W("$ZodISODuration", (e, t) => {
    (t.pattern ?? (t.pattern = t3), $e.init(e, t));
  }),
  z3 = W("$ZodIPv4", (e, t) => {
    (t.pattern ?? (t.pattern = i3),
      $e.init(e, t),
      (e._zod.bag.format = "ipv4"));
  }),
  Z3 = W("$ZodIPv6", (e, t) => {
    (t.pattern ?? (t.pattern = a3),
      $e.init(e, t),
      (e._zod.bag.format = "ipv6"),
      (e._zod.check = (n) => {
        try {
          new URL(`http://[${n.value}]`);
        } catch {
          n.issues.push({
            code: "invalid_format",
            format: "ipv6",
            input: n.value,
            inst: e,
            continue: !t.abort,
          });
        }
      }));
  }),
  X3 = W("$ZodCIDRv4", (e, t) => {
    (t.pattern ?? (t.pattern = c3), $e.init(e, t));
  }),
  Q3 = W("$ZodCIDRv6", (e, t) => {
    (t.pattern ?? (t.pattern = u3),
      $e.init(e, t),
      (e._zod.check = (n) => {
        const r = n.value.split("/");
        try {
          if (r.length !== 2) throw new Error();
          const [o, s] = r;
          if (!s) throw new Error();
          const i = Number(s);
          if (`${i}` !== s) throw new Error();
          if (i < 0 || i > 128) throw new Error();
          new URL(`http://[${o}]`);
        } catch {
          n.issues.push({
            code: "invalid_format",
            format: "cidrv6",
            input: n.value,
            inst: e,
            continue: !t.abort,
          });
        }
      }));
  });
function Jv(e) {
  if (e === "") return !0;
  if (e.length % 4 !== 0) return !1;
  try {
    return (atob(e), !0);
  } catch {
    return !1;
  }
}
const J3 = W("$ZodBase64", (e, t) => {
  (t.pattern ?? (t.pattern = l3),
    $e.init(e, t),
    (e._zod.bag.contentEncoding = "base64"),
    (e._zod.check = (n) => {
      Jv(n.value) ||
        n.issues.push({
          code: "invalid_format",
          format: "base64",
          input: n.value,
          inst: e,
          continue: !t.abort,
        });
    }));
});
function eZ(e) {
  if (!Wv.test(e)) return !1;
  const t = e.replace(/[-_]/g, (r) => (r === "-" ? "+" : "/")),
    n = t.padEnd(Math.ceil(t.length / 4) * 4, "=");
  return Jv(n);
}
const tZ = W("$ZodBase64URL", (e, t) => {
    (t.pattern ?? (t.pattern = Wv),
      $e.init(e, t),
      (e._zod.bag.contentEncoding = "base64url"),
      (e._zod.check = (n) => {
        eZ(n.value) ||
          n.issues.push({
            code: "invalid_format",
            format: "base64url",
            input: n.value,
            inst: e,
            continue: !t.abort,
          });
      }));
  }),
  nZ = W("$ZodE164", (e, t) => {
    (t.pattern ?? (t.pattern = d3), $e.init(e, t));
  });
function rZ(e, t = null) {
  try {
    const n = e.split(".");
    if (n.length !== 3) return !1;
    const [r] = n;
    if (!r) return !1;
    const o = JSON.parse(atob(r));
    return !(
      ("typ" in o && o?.typ !== "JWT") ||
      !o.alg ||
      (t && (!("alg" in o) || o.alg !== t))
    );
  } catch {
    return !1;
  }
}
const oZ = W("$ZodJWT", (e, t) => {
    ($e.init(e, t),
      (e._zod.check = (n) => {
        rZ(n.value, t.alg) ||
          n.issues.push({
            code: "invalid_format",
            format: "jwt",
            input: n.value,
            inst: e,
            continue: !t.abort,
          });
      }));
  }),
  eL = W("$ZodNumber", (e, t) => {
    (Xe.init(e, t),
      (e._zod.pattern = e._zod.bag.pattern ?? T3),
      (e._zod.parse = (n, r) => {
        if (t.coerce)
          try {
            n.value = Number(n.value);
          } catch {}
        const o = n.value;
        if (typeof o == "number" && !Number.isNaN(o) && Number.isFinite(o))
          return n;
        const s =
          typeof o == "number"
            ? Number.isNaN(o)
              ? "NaN"
              : Number.isFinite(o)
                ? void 0
                : "Infinity"
            : void 0;
        return (
          n.issues.push({
            expected: "number",
            code: "invalid_type",
            input: o,
            inst: e,
            ...(s
              ? {
                  received: s,
                }
              : {}),
          }),
          n
        );
      }));
  }),
  sZ = W("$ZodNumberFormat", (e, t) => {
    (g3.init(e, t), eL.init(e, t));
  }),
  iZ = W("$ZodUnknown", (e, t) => {
    (Xe.init(e, t), (e._zod.parse = (n) => n));
  }),
  aZ = W("$ZodNever", (e, t) => {
    (Xe.init(e, t),
      (e._zod.parse = (n, r) => (
        n.issues.push({
          expected: "never",
          code: "invalid_type",
          input: n.value,
          inst: e,
        }),
        n
      )));
  });
function Fy(e, t, n) {
  (e.issues.length && t.issues.push(...Fv(n, e.issues)),
    (t.value[n] = e.value));
}
const cZ = W("$ZodArray", (e, t) => {
  (Xe.init(e, t),
    (e._zod.parse = (n, r) => {
      const o = n.value;
      if (!Array.isArray(o))
        return (
          n.issues.push({
            expected: "array",
            code: "invalid_type",
            input: o,
            inst: e,
          }),
          n
        );
      n.value = Array(o.length);
      const s = [];
      for (let i = 0; i < o.length; i++) {
        const a = o[i],
          c = t.element._zod.run(
            {
              value: a,
              issues: [],
            },
            r,
          );
        c instanceof Promise ? s.push(c.then((l) => Fy(l, n, i))) : Fy(c, n, i);
      }
      return s.length ? Promise.all(s).then(() => n) : n;
    }));
});
function Gu(e, t, n, r) {
  (e.issues.length && t.issues.push(...Fv(n, e.issues)),
    e.value === void 0
      ? n in r && (t.value[n] = void 0)
      : (t.value[n] = e.value));
}
function tL(e) {
  const t = Object.keys(e.shape);
  for (const r of t)
    if (!e.shape?.[r]?._zod?.traits?.has("$ZodType"))
      throw new Error(`Invalid element at key "${r}": expected a Zod schema`);
  const n = Iz(e.shape);
  return {
    ...e,
    keys: t,
    keySet: new Set(t),
    numKeys: t.length,
    optionalKeys: new Set(n),
  };
}
function nL(e, t, n, r, o, s) {
  const i = [],
    a = o.keySet,
    c = o.catchall._zod,
    l = c.def.type;
  for (const f in t) {
    if (a.has(f)) continue;
    if (l === "never") {
      i.push(f);
      continue;
    }
    const d = c.run(
      {
        value: t[f],
        issues: [],
      },
      r,
    );
    d instanceof Promise
      ? e.push(d.then((u) => Gu(u, n, f, t)))
      : Gu(d, n, f, t);
  }
  return (
    i.length &&
      n.issues.push({
        code: "unrecognized_keys",
        keys: i,
        input: t,
        inst: s,
      }),
    e.length ? Promise.all(e).then(() => n) : n
  );
}
const uZ = W("$ZodObject", (e, t) => {
    if ((Xe.init(e, t), !Object.getOwnPropertyDescriptor(t, "shape")?.get)) {
      const a = t.shape;
      Object.defineProperty(t, "shape", {
        get: () => {
          const c = {
            ...a,
          };
          return (
            Object.defineProperty(t, "shape", {
              value: c,
            }),
            c
          );
        },
      });
    }
    const r = sh(() => tL(t));
    ke(e._zod, "propValues", () => {
      const a = t.shape,
        c = {};
      for (const l in a) {
        const f = a[l]._zod;
        if (f.values) {
          c[l] ?? (c[l] = new Set());
          for (const d of f.values) c[l].add(d);
        }
      }
      return c;
    });
    const o = ku,
      s = t.catchall;
    let i;
    e._zod.parse = (a, c) => {
      i ?? (i = r.value);
      const l = a.value;
      if (!o(l))
        return (
          a.issues.push({
            expected: "object",
            code: "invalid_type",
            input: l,
            inst: e,
          }),
          a
        );
      a.value = {};
      const f = [],
        d = i.shape;
      for (const u of i.keys) {
        const p = d[u]._zod.run(
          {
            value: l[u],
            issues: [],
          },
          c,
        );
        p instanceof Promise
          ? f.push(p.then((E) => Gu(E, a, u, l)))
          : Gu(p, a, u, l);
      }
      return s
        ? nL(f, l, a, c, r.value, e)
        : f.length
          ? Promise.all(f).then(() => a)
          : a;
    };
  }),
  lZ = W("$ZodObjectJIT", (e, t) => {
    uZ.init(e, t);
    const n = e._zod.parse,
      r = sh(() => tL(t)),
      o = (u) => {
        const _ = new L3(["shape", "payload", "ctx"]),
          p = r.value,
          E = (A) => {
            const g = By(A);
            return `shape[${g}]._zod.run({ value: input[${g}], issues: [] }, ctx)`;
          };
        _.write("const input = payload.value;");
        const h = Object.create(null);
        let T = 0;
        for (const A of p.keys) h[A] = `key_${T++}`;
        _.write("const newResult = {};");
        for (const A of p.keys) {
          const g = h[A],
            N = By(A);
          (_.write(`const ${g} = ${E(A)};`),
            _.write(`
        if (${g}.issues.length) {
          payload.issues = payload.issues.concat(${g}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${N}, ...iss.path] : [${N}]
          })));
        }
        
        
        if (${g}.value === undefined) {
          if (${N} in input) {
            newResult[${N}] = undefined;
          }
        } else {
          newResult[${N}] = ${g}.value;
        }
        
      `));
        }
        (_.write("payload.value = newResult;"), _.write("return payload;"));
        const m = _.compile();
        return (A, g) => m(u, A, g);
      };
    let s;
    const i = ku,
      a = !$v.jitless,
      l = a && Cz.value,
      f = t.catchall;
    let d;
    e._zod.parse = (u, _) => {
      d ?? (d = r.value);
      const p = u.value;
      return i(p)
        ? a && l && _?.async === !1 && _.jitless !== !0
          ? (s || (s = o(t.shape)),
            (u = s(u, _)),
            f ? nL([], p, u, _, d, e) : u)
          : n(u, _)
        : (u.issues.push({
            expected: "object",
            code: "invalid_type",
            input: p,
            inst: e,
          }),
          u);
    };
  });
function Yy(e, t, n, r) {
  for (const s of e) if (s.issues.length === 0) return ((t.value = s.value), t);
  const o = e.filter((s) => !Oo(s));
  return o.length === 1
    ? ((t.value = o[0].value), o[0])
    : (t.issues.push({
        code: "invalid_union",
        input: t.value,
        inst: n,
        errors: e.map((s) => s.issues.map((i) => so(i, r, oo()))),
      }),
      t);
}
const dZ = W("$ZodUnion", (e, t) => {
    (Xe.init(e, t),
      ke(e._zod, "optin", () =>
        t.options.some((o) => o._zod.optin === "optional")
          ? "optional"
          : void 0,
      ),
      ke(e._zod, "optout", () =>
        t.options.some((o) => o._zod.optout === "optional")
          ? "optional"
          : void 0,
      ),
      ke(e._zod, "values", () => {
        if (t.options.every((o) => o._zod.values))
          return new Set(t.options.flatMap((o) => Array.from(o._zod.values)));
      }),
      ke(e._zod, "pattern", () => {
        if (t.options.every((o) => o._zod.pattern)) {
          const o = t.options.map((s) => s._zod.pattern);
          return new RegExp(`^(${o.map((s) => ah(s.source)).join("|")})$`);
        }
      }));
    const n = t.options.length === 1,
      r = t.options[0]._zod.run;
    e._zod.parse = (o, s) => {
      if (n) return r(o, s);
      let i = !1;
      const a = [];
      for (const c of t.options) {
        const l = c._zod.run(
          {
            value: o.value,
            issues: [],
          },
          s,
        );
        if (l instanceof Promise) (a.push(l), (i = !0));
        else {
          if (l.issues.length === 0) return l;
          a.push(l);
        }
      }
      return i ? Promise.all(a).then((c) => Yy(c, o, e, s)) : Yy(a, o, e, s);
    };
  }),
  fZ = W("$ZodIntersection", (e, t) => {
    (Xe.init(e, t),
      (e._zod.parse = (n, r) => {
        const o = n.value,
          s = t.left._zod.run(
            {
              value: o,
              issues: [],
            },
            r,
          ),
          i = t.right._zod.run(
            {
              value: o,
              issues: [],
            },
            r,
          );
        return s instanceof Promise || i instanceof Promise
          ? Promise.all([s, i]).then(([c, l]) => jy(n, c, l))
          : jy(n, s, i);
      }));
  });
function kp(e, t) {
  if (e === t)
    return {
      valid: !0,
      data: e,
    };
  if (e instanceof Date && t instanceof Date && +e == +t)
    return {
      valid: !0,
      data: e,
    };
  if (cc(e) && cc(t)) {
    const n = Object.keys(t),
      r = Object.keys(e).filter((s) => n.indexOf(s) !== -1),
      o = {
        ...e,
        ...t,
      };
    for (const s of r) {
      const i = kp(e[s], t[s]);
      if (!i.valid)
        return {
          valid: !1,
          mergeErrorPath: [s, ...i.mergeErrorPath],
        };
      o[s] = i.data;
    }
    return {
      valid: !0,
      data: o,
    };
  }
  if (Array.isArray(e) && Array.isArray(t)) {
    if (e.length !== t.length)
      return {
        valid: !1,
        mergeErrorPath: [],
      };
    const n = [];
    for (let r = 0; r < e.length; r++) {
      const o = e[r],
        s = t[r],
        i = kp(o, s);
      if (!i.valid)
        return {
          valid: !1,
          mergeErrorPath: [r, ...i.mergeErrorPath],
        };
      n.push(i.data);
    }
    return {
      valid: !0,
      data: n,
    };
  }
  return {
    valid: !1,
    mergeErrorPath: [],
  };
}
function jy(e, t, n) {
  if (
    (t.issues.length && e.issues.push(...t.issues),
    n.issues.length && e.issues.push(...n.issues),
    Oo(e))
  )
    return e;
  const r = kp(t.value, n.value);
  if (!r.valid)
    throw new Error(
      `Unmergable intersection. Error path: ${JSON.stringify(r.mergeErrorPath)}`,
    );
  return ((e.value = r.data), e);
}
const _Z = W("$ZodEnum", (e, t) => {
    Xe.init(e, t);
    const n = Nz(t.entries),
      r = new Set(n);
    ((e._zod.values = r),
      (e._zod.pattern = new RegExp(
        `^(${n
          .filter((o) => bz.has(typeof o))
          .map((o) => (typeof o == "string" ? wl(o) : o.toString()))
          .join("|")})$`,
      )),
      (e._zod.parse = (o, s) => {
        const i = o.value;
        return (
          r.has(i) ||
            o.issues.push({
              code: "invalid_value",
              values: n,
              input: i,
              inst: e,
            }),
          o
        );
      }));
  }),
  pZ = W("$ZodTransform", (e, t) => {
    (Xe.init(e, t),
      (e._zod.parse = (n, r) => {
        if (r.direction === "backward") throw new xv(e.constructor.name);
        const o = t.transform(n.value, n);
        if (r.async)
          return (o instanceof Promise ? o : Promise.resolve(o)).then(
            (i) => ((n.value = i), n),
          );
        if (o instanceof Promise) throw new wo();
        return ((n.value = o), n);
      }));
  });
function qy(e, t) {
  return e.issues.length && t === void 0
    ? {
        issues: [],
        value: void 0,
      }
    : e;
}
const EZ = W("$ZodOptional", (e, t) => {
    (Xe.init(e, t),
      (e._zod.optin = "optional"),
      (e._zod.optout = "optional"),
      ke(e._zod, "values", () =>
        t.innerType._zod.values
          ? new Set([...t.innerType._zod.values, void 0])
          : void 0,
      ),
      ke(e._zod, "pattern", () => {
        const n = t.innerType._zod.pattern;
        return n ? new RegExp(`^(${ah(n.source)})?$`) : void 0;
      }),
      (e._zod.parse = (n, r) => {
        if (t.innerType._zod.optin === "optional") {
          const o = t.innerType._zod.run(n, r);
          return o instanceof Promise
            ? o.then((s) => qy(s, n.value))
            : qy(o, n.value);
        }
        return n.value === void 0 ? n : t.innerType._zod.run(n, r);
      }));
  }),
  hZ = W("$ZodNullable", (e, t) => {
    (Xe.init(e, t),
      ke(e._zod, "optin", () => t.innerType._zod.optin),
      ke(e._zod, "optout", () => t.innerType._zod.optout),
      ke(e._zod, "pattern", () => {
        const n = t.innerType._zod.pattern;
        return n ? new RegExp(`^(${ah(n.source)}|null)$`) : void 0;
      }),
      ke(e._zod, "values", () =>
        t.innerType._zod.values
          ? new Set([...t.innerType._zod.values, null])
          : void 0,
      ),
      (e._zod.parse = (n, r) =>
        n.value === null ? n : t.innerType._zod.run(n, r)));
  }),
  TZ = W("$ZodDefault", (e, t) => {
    (Xe.init(e, t),
      (e._zod.optin = "optional"),
      ke(e._zod, "values", () => t.innerType._zod.values),
      (e._zod.parse = (n, r) => {
        if (r.direction === "backward") return t.innerType._zod.run(n, r);
        if (n.value === void 0) return ((n.value = t.defaultValue), n);
        const o = t.innerType._zod.run(n, r);
        return o instanceof Promise ? o.then((s) => Wy(s, t)) : Wy(o, t);
      }));
  });
function Wy(e, t) {
  return (e.value === void 0 && (e.value = t.defaultValue), e);
}
const SZ = W("$ZodPrefault", (e, t) => {
    (Xe.init(e, t),
      (e._zod.optin = "optional"),
      ke(e._zod, "values", () => t.innerType._zod.values),
      (e._zod.parse = (n, r) => (
        r.direction === "backward" ||
          (n.value === void 0 && (n.value = t.defaultValue)),
        t.innerType._zod.run(n, r)
      )));
  }),
  mZ = W("$ZodNonOptional", (e, t) => {
    (Xe.init(e, t),
      ke(e._zod, "values", () => {
        const n = t.innerType._zod.values;
        return n ? new Set([...n].filter((r) => r !== void 0)) : void 0;
      }),
      (e._zod.parse = (n, r) => {
        const o = t.innerType._zod.run(n, r);
        return o instanceof Promise ? o.then((s) => Ky(s, e)) : Ky(o, e);
      }));
  });
function Ky(e, t) {
  return (
    !e.issues.length &&
      e.value === void 0 &&
      e.issues.push({
        code: "invalid_type",
        expected: "nonoptional",
        input: e.value,
        inst: t,
      }),
    e
  );
}
const AZ = W("$ZodCatch", (e, t) => {
    (Xe.init(e, t),
      ke(e._zod, "optin", () => t.innerType._zod.optin),
      ke(e._zod, "optout", () => t.innerType._zod.optout),
      ke(e._zod, "values", () => t.innerType._zod.values),
      (e._zod.parse = (n, r) => {
        if (r.direction === "backward") return t.innerType._zod.run(n, r);
        const o = t.innerType._zod.run(n, r);
        return o instanceof Promise
          ? o.then(
              (s) => (
                (n.value = s.value),
                s.issues.length &&
                  ((n.value = t.catchValue({
                    ...n,
                    error: {
                      issues: s.issues.map((i) => so(i, r, oo())),
                    },
                    input: n.value,
                  })),
                  (n.issues = [])),
                n
              ),
            )
          : ((n.value = o.value),
            o.issues.length &&
              ((n.value = t.catchValue({
                ...n,
                error: {
                  issues: o.issues.map((s) => so(s, r, oo())),
                },
                input: n.value,
              })),
              (n.issues = [])),
            n);
      }));
  }),
  gZ = W("$ZodPipe", (e, t) => {
    (Xe.init(e, t),
      ke(e._zod, "values", () => t.in._zod.values),
      ke(e._zod, "optin", () => t.in._zod.optin),
      ke(e._zod, "optout", () => t.out._zod.optout),
      ke(e._zod, "propValues", () => t.in._zod.propValues),
      (e._zod.parse = (n, r) => {
        if (r.direction === "backward") {
          const s = t.out._zod.run(n, r);
          return s instanceof Promise
            ? s.then((i) => Fc(i, t.in, r))
            : Fc(s, t.in, r);
        }
        const o = t.in._zod.run(n, r);
        return o instanceof Promise
          ? o.then((s) => Fc(s, t.out, r))
          : Fc(o, t.out, r);
      }));
  });
function Fc(e, t, n) {
  return e.issues.length
    ? ((e.aborted = !0), e)
    : t._zod.run(
        {
          value: e.value,
          issues: e.issues,
        },
        n,
      );
}
const RZ = W("$ZodReadonly", (e, t) => {
  (Xe.init(e, t),
    ke(e._zod, "propValues", () => t.innerType._zod.propValues),
    ke(e._zod, "values", () => t.innerType._zod.values),
    ke(e._zod, "optin", () => t.innerType?._zod?.optin),
    ke(e._zod, "optout", () => t.innerType?._zod?.optout),
    (e._zod.parse = (n, r) => {
      if (r.direction === "backward") return t.innerType._zod.run(n, r);
      const o = t.innerType._zod.run(n, r);
      return o instanceof Promise ? o.then(zy) : zy(o);
    }));
});
function zy(e) {
  return ((e.value = Object.freeze(e.value)), e);
}
const NZ = W("$ZodCustom", (e, t) => {
  (Pt.init(e, t),
    Xe.init(e, t),
    (e._zod.parse = (n, r) => n),
    (e._zod.check = (n) => {
      const r = n.value,
        o = t.fn(r);
      if (o instanceof Promise) return o.then((s) => Zy(s, n, r, e));
      Zy(o, n, r, e);
    }));
});
function Zy(e, t, n, r) {
  if (!e) {
    const o = {
      code: "custom",
      input: n,
      inst: r,
      path: [...(r._zod.def.path ?? [])],
      continue: !r._zod.def.abort,
    };
    (r._zod.def.params && (o.params = r._zod.def.params), t.issues.push(uc(o)));
  }
}
var Xy;
class yZ {
  constructor() {
    ((this._map = new WeakMap()), (this._idmap = new Map()));
  }
  add(t, ...n) {
    const r = n[0];
    if ((this._map.set(t, r), r && typeof r == "object" && "id" in r)) {
      if (this._idmap.has(r.id))
        throw new Error(`ID ${r.id} already exists in the registry`);
      this._idmap.set(r.id, t);
    }
    return this;
  }
  clear() {
    return ((this._map = new WeakMap()), (this._idmap = new Map()), this);
  }
  remove(t) {
    const n = this._map.get(t);
    return (
      n && typeof n == "object" && "id" in n && this._idmap.delete(n.id),
      this._map.delete(t),
      this
    );
  }
  get(t) {
    const n = t._zod.parent;
    if (n) {
      const r = {
        ...(this.get(n) ?? {}),
      };
      delete r.id;
      const o = {
        ...r,
        ...this._map.get(t),
      };
      return Object.keys(o).length ? o : void 0;
    }
    return this._map.get(t);
  }
  has(t) {
    return this._map.has(t);
  }
}
function OZ() {
  return new yZ();
}
(Xy = globalThis).__zod_globalRegistry ?? (Xy.__zod_globalRegistry = OZ());
const Yc = globalThis.__zod_globalRegistry;
function CZ(e, t) {
  return new e({
    type: "string",
    ...fe(t),
  });
}
function bZ(e, t) {
  return new e({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...fe(t),
  });
}
function Qy(e, t) {
  return new e({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...fe(t),
  });
}
function IZ(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...fe(t),
  });
}
function PZ(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...fe(t),
  });
}
function MZ(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...fe(t),
  });
}
function vZ(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...fe(t),
  });
}
function LZ(e, t) {
  return new e({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...fe(t),
  });
}
function DZ(e, t) {
  return new e({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...fe(t),
  });
}
function wZ(e, t) {
  return new e({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...fe(t),
  });
}
function UZ(e, t) {
  return new e({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...fe(t),
  });
}
function kZ(e, t) {
  return new e({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...fe(t),
  });
}
function GZ(e, t) {
  return new e({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...fe(t),
  });
}
function VZ(e, t) {
  return new e({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...fe(t),
  });
}
function xZ(e, t) {
  return new e({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...fe(t),
  });
}
function $Z(e, t) {
  return new e({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...fe(t),
  });
}
function BZ(e, t) {
  return new e({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...fe(t),
  });
}
function HZ(e, t) {
  return new e({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...fe(t),
  });
}
function FZ(e, t) {
  return new e({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...fe(t),
  });
}
function YZ(e, t) {
  return new e({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...fe(t),
  });
}
function jZ(e, t) {
  return new e({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...fe(t),
  });
}
function qZ(e, t) {
  return new e({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...fe(t),
  });
}
function WZ(e, t) {
  return new e({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...fe(t),
  });
}
function KZ(e, t) {
  return new e({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...fe(t),
  });
}
function zZ(e, t) {
  return new e({
    type: "string",
    format: "date",
    check: "string_format",
    ...fe(t),
  });
}
function ZZ(e, t) {
  return new e({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...fe(t),
  });
}
function XZ(e, t) {
  return new e({
    type: "string",
    format: "duration",
    check: "string_format",
    ...fe(t),
  });
}
function QZ(e, t) {
  return new e({
    type: "number",
    checks: [],
    ...fe(t),
  });
}
function JZ(e, t) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "safeint",
    ...fe(t),
  });
}
function e4(e) {
  return new e({
    type: "unknown",
  });
}
function t4(e, t) {
  return new e({
    type: "never",
    ...fe(t),
  });
}
function Jy(e, t) {
  return new Xv({
    check: "less_than",
    ...fe(t),
    value: e,
    inclusive: !1,
  });
}
function Rf(e, t) {
  return new Xv({
    check: "less_than",
    ...fe(t),
    value: e,
    inclusive: !0,
  });
}
function eO(e, t) {
  return new Qv({
    check: "greater_than",
    ...fe(t),
    value: e,
    inclusive: !1,
  });
}
function Nf(e, t) {
  return new Qv({
    check: "greater_than",
    ...fe(t),
    value: e,
    inclusive: !0,
  });
}
function tO(e, t) {
  return new A3({
    check: "multiple_of",
    ...fe(t),
    value: e,
  });
}
function rL(e, t) {
  return new R3({
    check: "max_length",
    ...fe(t),
    maximum: e,
  });
}
function Vu(e, t) {
  return new N3({
    check: "min_length",
    ...fe(t),
    minimum: e,
  });
}
function oL(e, t) {
  return new y3({
    check: "length_equals",
    ...fe(t),
    length: e,
  });
}
function n4(e, t) {
  return new O3({
    check: "string_format",
    format: "regex",
    ...fe(t),
    pattern: e,
  });
}
function r4(e) {
  return new C3({
    check: "string_format",
    format: "lowercase",
    ...fe(e),
  });
}
function o4(e) {
  return new b3({
    check: "string_format",
    format: "uppercase",
    ...fe(e),
  });
}
function s4(e, t) {
  return new I3({
    check: "string_format",
    format: "includes",
    ...fe(t),
    includes: e,
  });
}
function i4(e, t) {
  return new P3({
    check: "string_format",
    format: "starts_with",
    ...fe(t),
    prefix: e,
  });
}
function a4(e, t) {
  return new M3({
    check: "string_format",
    format: "ends_with",
    ...fe(t),
    suffix: e,
  });
}
function ns(e) {
  return new v3({
    check: "overwrite",
    tx: e,
  });
}
function c4(e) {
  return ns((t) => t.normalize(e));
}
function u4() {
  return ns((e) => e.trim());
}
function l4() {
  return ns((e) => e.toLowerCase());
}
function d4() {
  return ns((e) => e.toUpperCase());
}
function f4() {
  return ns((e) => Oz(e));
}
function _4(e, t, n) {
  return new e({
    type: "array",
    element: t,
    ...fe(n),
  });
}
function p4(e, t, n) {
  return new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...fe(n),
  });
}
function E4(e) {
  const t = h4(
    (n) => (
      (n.addIssue = (r) => {
        if (typeof r == "string") n.issues.push(uc(r, n.value, t._zod.def));
        else {
          const o = r;
          (o.fatal && (o.continue = !1),
            o.code ?? (o.code = "custom"),
            o.input ?? (o.input = n.value),
            o.inst ?? (o.inst = t),
            o.continue ?? (o.continue = !t._zod.def.abort),
            n.issues.push(uc(o)));
        }
      }),
      e(n.value, n)
    ),
  );
  return t;
}
function h4(e, t) {
  const n = new Pt({
    check: "custom",
    ...fe(t),
  });
  return ((n._zod.check = e), n);
}
const T4 = W("ZodISODateTime", (e, t) => {
  (j3.init(e, t), Ye.init(e, t));
});
function S4(e) {
  return KZ(T4, e);
}
const m4 = W("ZodISODate", (e, t) => {
  (q3.init(e, t), Ye.init(e, t));
});
function A4(e) {
  return zZ(m4, e);
}
const g4 = W("ZodISOTime", (e, t) => {
  (W3.init(e, t), Ye.init(e, t));
});
function R4(e) {
  return ZZ(g4, e);
}
const N4 = W("ZodISODuration", (e, t) => {
  (K3.init(e, t), Ye.init(e, t));
});
function y4(e) {
  return XZ(N4, e);
}
const O4 = (e, t) => {
    (jv.init(e, t),
      (e.name = "ZodError"),
      Object.defineProperties(e, {
        format: {
          value: (n) => Vz(e, n),
        },
        flatten: {
          value: (n) => Gz(e, n),
        },
        addIssue: {
          value: (n) => {
            (e.issues.push(n), (e.message = JSON.stringify(e.issues, Up, 2)));
          },
        },
        addIssues: {
          value: (n) => {
            (e.issues.push(...n),
              (e.message = JSON.stringify(e.issues, Up, 2)));
          },
        },
        isEmpty: {
          get() {
            return e.issues.length === 0;
          },
        },
      }));
  },
  Zt = W("ZodError", O4, {
    Parent: Error,
  }),
  C4 = uh(Zt),
  b4 = lh(Zt),
  I4 = Ul(Zt),
  P4 = kl(Zt),
  M4 = Bz(Zt),
  v4 = Hz(Zt),
  L4 = Fz(Zt),
  D4 = Yz(Zt),
  w4 = jz(Zt),
  U4 = qz(Zt),
  k4 = Wz(Zt),
  G4 = Kz(Zt),
  tt = W(
    "ZodType",
    (e, t) => (
      Xe.init(e, t),
      (e.def = t),
      (e.type = t.type),
      Object.defineProperty(e, "_def", {
        value: t,
      }),
      (e.check = (...n) =>
        e.clone(
          _o(t, {
            checks: [
              ...(t.checks ?? []),
              ...n.map((r) =>
                typeof r == "function"
                  ? {
                      _zod: {
                        check: r,
                        def: {
                          check: "custom",
                        },
                        onattach: [],
                      },
                    }
                  : r,
              ),
            ],
          }),
        )),
      (e.clone = (n, r) => or(e, n, r)),
      (e.brand = () => e),
      (e.register = (n, r) => (n.add(e, r), e)),
      (e.parse = (n, r) =>
        C4(e, n, r, {
          callee: e.parse,
        })),
      (e.safeParse = (n, r) => I4(e, n, r)),
      (e.parseAsync = async (n, r) =>
        b4(e, n, r, {
          callee: e.parseAsync,
        })),
      (e.safeParseAsync = async (n, r) => P4(e, n, r)),
      (e.spa = e.safeParseAsync),
      (e.encode = (n, r) => M4(e, n, r)),
      (e.decode = (n, r) => v4(e, n, r)),
      (e.encodeAsync = async (n, r) => L4(e, n, r)),
      (e.decodeAsync = async (n, r) => D4(e, n, r)),
      (e.safeEncode = (n, r) => w4(e, n, r)),
      (e.safeDecode = (n, r) => U4(e, n, r)),
      (e.safeEncodeAsync = async (n, r) => k4(e, n, r)),
      (e.safeDecodeAsync = async (n, r) => G4(e, n, r)),
      (e.refine = (n, r) => e.check(C9(n, r))),
      (e.superRefine = (n) => e.check(b9(n))),
      (e.overwrite = (n) => e.check(ns(n))),
      (e.optional = () => sO(e)),
      (e.nullable = () => iO(e)),
      (e.nullish = () => sO(iO(e))),
      (e.nonoptional = (n) => m9(e, n)),
      (e.array = () => Vl(e)),
      (e.or = (n) => u9([e, n])),
      (e.and = (n) => d9(e, n)),
      (e.transform = (n) => aO(e, _9(n))),
      (e.default = (n) => h9(e, n)),
      (e.prefault = (n) => S9(e, n)),
      (e.catch = (n) => g9(e, n)),
      (e.pipe = (n) => aO(e, n)),
      (e.readonly = () => y9(e)),
      (e.describe = (n) => {
        const r = e.clone();
        return (
          Yc.add(r, {
            description: n,
          }),
          r
        );
      }),
      Object.defineProperty(e, "description", {
        get() {
          return Yc.get(e)?.description;
        },
        configurable: !0,
      }),
      (e.meta = (...n) => {
        if (n.length === 0) return Yc.get(e);
        const r = e.clone();
        return (Yc.add(r, n[0]), r);
      }),
      (e.isOptional = () => e.safeParse(void 0).success),
      (e.isNullable = () => e.safeParse(null).success),
      e
    ),
  ),
  sL = W("_ZodString", (e, t) => {
    (dh.init(e, t), tt.init(e, t));
    const n = e._zod.bag;
    ((e.format = n.format ?? null),
      (e.minLength = n.minimum ?? null),
      (e.maxLength = n.maximum ?? null),
      (e.regex = (...r) => e.check(n4(...r))),
      (e.includes = (...r) => e.check(s4(...r))),
      (e.startsWith = (...r) => e.check(i4(...r))),
      (e.endsWith = (...r) => e.check(a4(...r))),
      (e.min = (...r) => e.check(Vu(...r))),
      (e.max = (...r) => e.check(rL(...r))),
      (e.length = (...r) => e.check(oL(...r))),
      (e.nonempty = (...r) => e.check(Vu(1, ...r))),
      (e.lowercase = (r) => e.check(r4(r))),
      (e.uppercase = (r) => e.check(o4(r))),
      (e.trim = () => e.check(u4())),
      (e.normalize = (...r) => e.check(c4(...r))),
      (e.toLowerCase = () => e.check(l4())),
      (e.toUpperCase = () => e.check(d4())),
      (e.slugify = () => e.check(f4())));
  }),
  V4 = W("ZodString", (e, t) => {
    (dh.init(e, t),
      sL.init(e, t),
      (e.email = (n) => e.check(bZ(x4, n))),
      (e.url = (n) => e.check(LZ($4, n))),
      (e.jwt = (n) => e.check(WZ(t9, n))),
      (e.emoji = (n) => e.check(DZ(B4, n))),
      (e.guid = (n) => e.check(Qy(nO, n))),
      (e.uuid = (n) => e.check(IZ(jc, n))),
      (e.uuidv4 = (n) => e.check(PZ(jc, n))),
      (e.uuidv6 = (n) => e.check(MZ(jc, n))),
      (e.uuidv7 = (n) => e.check(vZ(jc, n))),
      (e.nanoid = (n) => e.check(wZ(H4, n))),
      (e.guid = (n) => e.check(Qy(nO, n))),
      (e.cuid = (n) => e.check(UZ(F4, n))),
      (e.cuid2 = (n) => e.check(kZ(Y4, n))),
      (e.ulid = (n) => e.check(GZ(j4, n))),
      (e.base64 = (n) => e.check(YZ(Q4, n))),
      (e.base64url = (n) => e.check(jZ(J4, n))),
      (e.xid = (n) => e.check(VZ(q4, n))),
      (e.ksuid = (n) => e.check(xZ(W4, n))),
      (e.ipv4 = (n) => e.check($Z(K4, n))),
      (e.ipv6 = (n) => e.check(BZ(z4, n))),
      (e.cidrv4 = (n) => e.check(HZ(Z4, n))),
      (e.cidrv6 = (n) => e.check(FZ(X4, n))),
      (e.e164 = (n) => e.check(qZ(e9, n))),
      (e.datetime = (n) => e.check(S4(n))),
      (e.date = (n) => e.check(A4(n))),
      (e.time = (n) => e.check(R4(n))),
      (e.duration = (n) => e.check(y4(n))));
  });
function dt(e) {
  return CZ(V4, e);
}
const Ye = W("ZodStringFormat", (e, t) => {
    ($e.init(e, t), sL.init(e, t));
  }),
  x4 = W("ZodEmail", (e, t) => {
    (k3.init(e, t), Ye.init(e, t));
  }),
  nO = W("ZodGUID", (e, t) => {
    (w3.init(e, t), Ye.init(e, t));
  }),
  jc = W("ZodUUID", (e, t) => {
    (U3.init(e, t), Ye.init(e, t));
  }),
  $4 = W("ZodURL", (e, t) => {
    (G3.init(e, t), Ye.init(e, t));
  }),
  B4 = W("ZodEmoji", (e, t) => {
    (V3.init(e, t), Ye.init(e, t));
  }),
  H4 = W("ZodNanoID", (e, t) => {
    (x3.init(e, t), Ye.init(e, t));
  }),
  F4 = W("ZodCUID", (e, t) => {
    ($3.init(e, t), Ye.init(e, t));
  }),
  Y4 = W("ZodCUID2", (e, t) => {
    (B3.init(e, t), Ye.init(e, t));
  }),
  j4 = W("ZodULID", (e, t) => {
    (H3.init(e, t), Ye.init(e, t));
  }),
  q4 = W("ZodXID", (e, t) => {
    (F3.init(e, t), Ye.init(e, t));
  }),
  W4 = W("ZodKSUID", (e, t) => {
    (Y3.init(e, t), Ye.init(e, t));
  }),
  K4 = W("ZodIPv4", (e, t) => {
    (z3.init(e, t), Ye.init(e, t));
  }),
  z4 = W("ZodIPv6", (e, t) => {
    (Z3.init(e, t), Ye.init(e, t));
  }),
  Z4 = W("ZodCIDRv4", (e, t) => {
    (X3.init(e, t), Ye.init(e, t));
  }),
  X4 = W("ZodCIDRv6", (e, t) => {
    (Q3.init(e, t), Ye.init(e, t));
  }),
  Q4 = W("ZodBase64", (e, t) => {
    (J3.init(e, t), Ye.init(e, t));
  }),
  J4 = W("ZodBase64URL", (e, t) => {
    (tZ.init(e, t), Ye.init(e, t));
  }),
  e9 = W("ZodE164", (e, t) => {
    (nZ.init(e, t), Ye.init(e, t));
  }),
  t9 = W("ZodJWT", (e, t) => {
    (oZ.init(e, t), Ye.init(e, t));
  }),
  iL = W("ZodNumber", (e, t) => {
    (eL.init(e, t),
      tt.init(e, t),
      (e.gt = (r, o) => e.check(eO(r, o))),
      (e.gte = (r, o) => e.check(Nf(r, o))),
      (e.min = (r, o) => e.check(Nf(r, o))),
      (e.lt = (r, o) => e.check(Jy(r, o))),
      (e.lte = (r, o) => e.check(Rf(r, o))),
      (e.max = (r, o) => e.check(Rf(r, o))),
      (e.int = (r) => e.check(rO(r))),
      (e.safe = (r) => e.check(rO(r))),
      (e.positive = (r) => e.check(eO(0, r))),
      (e.nonnegative = (r) => e.check(Nf(0, r))),
      (e.negative = (r) => e.check(Jy(0, r))),
      (e.nonpositive = (r) => e.check(Rf(0, r))),
      (e.multipleOf = (r, o) => e.check(tO(r, o))),
      (e.step = (r, o) => e.check(tO(r, o))),
      (e.finite = () => e));
    const n = e._zod.bag;
    ((e.minValue =
      Math.max(
        n.minimum ?? Number.NEGATIVE_INFINITY,
        n.exclusiveMinimum ?? Number.NEGATIVE_INFINITY,
      ) ?? null),
      (e.maxValue =
        Math.min(
          n.maximum ?? Number.POSITIVE_INFINITY,
          n.exclusiveMaximum ?? Number.POSITIVE_INFINITY,
        ) ?? null),
      (e.isInt =
        (n.format ?? "").includes("int") ||
        Number.isSafeInteger(n.multipleOf ?? 0.5)),
      (e.isFinite = !0),
      (e.format = n.format ?? null));
  });
function za(e) {
  return QZ(iL, e);
}
const n9 = W("ZodNumberFormat", (e, t) => {
  (sZ.init(e, t), iL.init(e, t));
});
function rO(e) {
  return JZ(n9, e);
}
const r9 = W("ZodUnknown", (e, t) => {
  (iZ.init(e, t), tt.init(e, t));
});
function oO() {
  return e4(r9);
}
const o9 = W("ZodNever", (e, t) => {
  (aZ.init(e, t), tt.init(e, t));
});
function s9(e) {
  return t4(o9, e);
}
const i9 = W("ZodArray", (e, t) => {
  (cZ.init(e, t),
    tt.init(e, t),
    (e.element = t.element),
    (e.min = (n, r) => e.check(Vu(n, r))),
    (e.nonempty = (n) => e.check(Vu(1, n))),
    (e.max = (n, r) => e.check(rL(n, r))),
    (e.length = (n, r) => e.check(oL(n, r))),
    (e.unwrap = () => e.element));
});
function Vl(e, t) {
  return _4(i9, e, t);
}
const a9 = W("ZodObject", (e, t) => {
  (lZ.init(e, t),
    tt.init(e, t),
    ke(e, "shape", () => t.shape),
    (e.keyof = () => xu(Object.keys(e._zod.def.shape))),
    (e.catchall = (n) =>
      e.clone({
        ...e._zod.def,
        catchall: n,
      })),
    (e.passthrough = () =>
      e.clone({
        ...e._zod.def,
        catchall: oO(),
      })),
    (e.loose = () =>
      e.clone({
        ...e._zod.def,
        catchall: oO(),
      })),
    (e.strict = () =>
      e.clone({
        ...e._zod.def,
        catchall: s9(),
      })),
    (e.strip = () =>
      e.clone({
        ...e._zod.def,
        catchall: void 0,
      })),
    (e.extend = (n) => Lz(e, n)),
    (e.safeExtend = (n) => Dz(e, n)),
    (e.merge = (n) => wz(e, n)),
    (e.pick = (n) => Mz(e, n)),
    (e.omit = (n) => vz(e, n)),
    (e.partial = (...n) => Uz(aL, e, n[0])),
    (e.required = (...n) => kz(cL, e, n[0])));
});
function sr(e, t) {
  const n = {
    type: "object",
    shape: e ?? {},
    ...fe(t),
  };
  return new a9(n);
}
const c9 = W("ZodUnion", (e, t) => {
  (dZ.init(e, t), tt.init(e, t), (e.options = t.options));
});
function u9(e, t) {
  return new c9({
    type: "union",
    options: e,
    ...fe(t),
  });
}
const l9 = W("ZodIntersection", (e, t) => {
  (fZ.init(e, t), tt.init(e, t));
});
function d9(e, t) {
  return new l9({
    type: "intersection",
    left: e,
    right: t,
  });
}
const Gp = W("ZodEnum", (e, t) => {
  (_Z.init(e, t),
    tt.init(e, t),
    (e.enum = t.entries),
    (e.options = Object.values(t.entries)));
  const n = new Set(Object.keys(t.entries));
  ((e.extract = (r, o) => {
    const s = {};
    for (const i of r)
      if (n.has(i)) s[i] = t.entries[i];
      else throw new Error(`Key ${i} not found in enum`);
    return new Gp({
      ...t,
      checks: [],
      ...fe(o),
      entries: s,
    });
  }),
    (e.exclude = (r, o) => {
      const s = {
        ...t.entries,
      };
      for (const i of r)
        if (n.has(i)) delete s[i];
        else throw new Error(`Key ${i} not found in enum`);
      return new Gp({
        ...t,
        checks: [],
        ...fe(o),
        entries: s,
      });
    }));
});
function xu(e, t) {
  const n = Array.isArray(e) ? Object.fromEntries(e.map((r) => [r, r])) : e;
  return new Gp({
    type: "enum",
    entries: n,
    ...fe(t),
  });
}
const f9 = W("ZodTransform", (e, t) => {
  (pZ.init(e, t),
    tt.init(e, t),
    (e._zod.parse = (n, r) => {
      if (r.direction === "backward") throw new xv(e.constructor.name);
      n.addIssue = (s) => {
        if (typeof s == "string") n.issues.push(uc(s, n.value, t));
        else {
          const i = s;
          (i.fatal && (i.continue = !1),
            i.code ?? (i.code = "custom"),
            i.input ?? (i.input = n.value),
            i.inst ?? (i.inst = e),
            n.issues.push(uc(i)));
        }
      };
      const o = t.transform(n.value, n);
      return o instanceof Promise
        ? o.then((s) => ((n.value = s), n))
        : ((n.value = o), n);
    }));
});
function _9(e) {
  return new f9({
    type: "transform",
    transform: e,
  });
}
const aL = W("ZodOptional", (e, t) => {
  (EZ.init(e, t), tt.init(e, t), (e.unwrap = () => e._zod.def.innerType));
});
function sO(e) {
  return new aL({
    type: "optional",
    innerType: e,
  });
}
const p9 = W("ZodNullable", (e, t) => {
  (hZ.init(e, t), tt.init(e, t), (e.unwrap = () => e._zod.def.innerType));
});
function iO(e) {
  return new p9({
    type: "nullable",
    innerType: e,
  });
}
const E9 = W("ZodDefault", (e, t) => {
  (TZ.init(e, t),
    tt.init(e, t),
    (e.unwrap = () => e._zod.def.innerType),
    (e.removeDefault = e.unwrap));
});
function h9(e, t) {
  return new E9({
    type: "default",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : Hv(t);
    },
  });
}
const T9 = W("ZodPrefault", (e, t) => {
  (SZ.init(e, t), tt.init(e, t), (e.unwrap = () => e._zod.def.innerType));
});
function S9(e, t) {
  return new T9({
    type: "prefault",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : Hv(t);
    },
  });
}
const cL = W("ZodNonOptional", (e, t) => {
  (mZ.init(e, t), tt.init(e, t), (e.unwrap = () => e._zod.def.innerType));
});
function m9(e, t) {
  return new cL({
    type: "nonoptional",
    innerType: e,
    ...fe(t),
  });
}
const A9 = W("ZodCatch", (e, t) => {
  (AZ.init(e, t),
    tt.init(e, t),
    (e.unwrap = () => e._zod.def.innerType),
    (e.removeCatch = e.unwrap));
});
function g9(e, t) {
  return new A9({
    type: "catch",
    innerType: e,
    catchValue: typeof t == "function" ? t : () => t,
  });
}
const R9 = W("ZodPipe", (e, t) => {
  (gZ.init(e, t), tt.init(e, t), (e.in = t.in), (e.out = t.out));
});
function aO(e, t) {
  return new R9({
    type: "pipe",
    in: e,
    out: t,
  });
}
const N9 = W("ZodReadonly", (e, t) => {
  (RZ.init(e, t), tt.init(e, t), (e.unwrap = () => e._zod.def.innerType));
});
function y9(e) {
  return new N9({
    type: "readonly",
    innerType: e,
  });
}
const O9 = W("ZodCustom", (e, t) => {
  (NZ.init(e, t), tt.init(e, t));
});
function C9(e, t = {}) {
  return p4(O9, e, t);
}
function b9(e) {
  return E4(e);
}
const I9 = xu(["ACTIVE", "PAUSED", "DELETED"]);
sr({
  version: za().optional(),
  id: dt(),
  name: dt(),
  prompt: dt(),
  status: I9,
  rrule: dt().optional(),
  cwds: Vl(dt()),
  created_at: za(),
  updated_at: za(),
});
const P9 = {
    Dev: "dev",
    InternalAlpha: "internal-alpha",
    PublicBeta: "public-beta",
    Prod: "prod",
  },
  M9 = Object.values(P9);
M9.join(", ");
function Ue(e) {
  return e == null ? !1 : e.kind === "ssh" || e.kind === "brix";
}
const v9 = "codex.localEnvironmentConfigPath",
  L9 = "__none__",
  D9 = ["tool", "run", "debug", "test"],
  w9 = ["darwin", "linux", "win32"],
  U9 = sr({
    name: dt(),
    icon: xu(D9).nullable().catch(null),
    command: dt(),
    platform: xu(w9).optional(),
  }),
  yf = sr({
    script: dt(),
  }),
  k9 = sr({
    script: dt(),
    darwin: yf.optional(),
    linux: yf.optional(),
    win32: yf.optional(),
  }),
  G9 = sr({
    version: za().int().min(1).default(1),
    name: dt(),
    setup: k9,
    actions: Vl(U9).optional(),
  });
function ot(e) {
  switch (typeof e) {
    case "undefined":
      return "null";
    case "string":
      return `string(len=${e.length})`;
    case "number":
    case "boolean":
      return String(e);
    case "bigint":
      return e.toString();
    case "function":
    case "symbol":
      return typeof e;
  }
  if (e == null) return "null";
  switch (Object.prototype.toString.call(e)) {
    case "[object Date]":
      try {
        const n = e;
        return Number.isNaN(n.getTime()) ? "date(invalid)" : n.toISOString();
      } catch {
        return "date(invalid)";
      }
    case "[object Error]": {
      const n = e,
        r = n.code;
      return typeof r == "string" && r.length > 0
        ? `error(name=${n.name},code=${r})`
        : `error(name=${n.name})`;
    }
    case "[object Uint8Array]":
      return `bytes(len=${e.byteLength})`;
    case "[object Array]":
      return `array(len=${e.length})`;
  }
  try {
    return `object(keys=${Object.keys(e).length})`;
  } catch {
    return "object(keys=unknown)";
  }
}
function Oe(e) {
  return {
    type: "ok",
    value: e,
  };
}
function Va(e) {
  return {
    type: "error",
    error: {
      message: e instanceof Error ? e.message : String(e),
    },
  };
}
const V9 =
    "https://17de4aef18bcd467f0a250b004f16737@o33249.ingest.us.sentry.io/4510507758977024",
  x9 = "codex-desktop@";
function $9(e) {
  return `${x9}${e}`;
}
function B9(e) {
  switch (e) {
    case "dev":
    case "internal-alpha":
    case "public-beta":
      return !0;
    case "prod":
      return !1;
  }
}
function H9(e) {
  return B9(e) ? 1 : 0;
}
var Of, cO;
function F9() {
  return (cO || ((cO = 1), (Of = function () {})), Of);
}
var Cf, uO;
function po() {
  if (uO) return Cf;
  uO = 1;
  var e = F9()();
  return (
    (Cf = function (t) {
      return t !== e && t !== null;
    }),
    Cf
  );
}
var bf, lO;
function uL() {
  if (lO) return bf;
  lO = 1;
  var e = po(),
    t = Array.prototype.forEach,
    n = Object.create,
    r = function (o, s) {
      var i;
      for (i in o) s[i] = o[i];
    };
  return (
    (bf = function (o) {
      var s = n(null);
      return (
        t.call(arguments, function (i) {
          e(i) && r(Object(i), s);
        }),
        s
      );
    }),
    bf
  );
}
var If, dO;
function Y9() {
  return (
    dO ||
      ((dO = 1),
      (If = function () {
        var e = Math.sign;
        return typeof e != "function" ? !1 : e(10) === 1 && e(-20) === -1;
      })),
    If
  );
}
var Pf, fO;
function j9() {
  return (
    fO ||
      ((fO = 1),
      (Pf = function (e) {
        return ((e = Number(e)), isNaN(e) || e === 0 ? e : e > 0 ? 1 : -1);
      })),
    Pf
  );
}
var Mf, _O;
function q9() {
  return (_O || ((_O = 1), (Mf = Y9()() ? Math.sign : j9())), Mf);
}
var vf, pO;
function W9() {
  if (pO) return vf;
  pO = 1;
  var e = q9(),
    t = Math.abs,
    n = Math.floor;
  return (
    (vf = function (r) {
      return isNaN(r)
        ? 0
        : ((r = Number(r)), r === 0 || !isFinite(r) ? r : e(r) * n(t(r)));
    }),
    vf
  );
}
var Lf, EO;
function Eo() {
  if (EO) return Lf;
  EO = 1;
  var e = W9(),
    t = Math.max;
  return (
    (Lf = function (n) {
      return t(0, e(n));
    }),
    Lf
  );
}
var Df, hO;
function lL() {
  if (hO) return Df;
  hO = 1;
  var e = Eo();
  return (
    (Df = function (t, n, r) {
      var o;
      return isNaN(t)
        ? ((o = n), o >= 0 ? (r && o ? o - 1 : o) : 1)
        : t === !1
          ? !1
          : e(t);
    }),
    Df
  );
}
var wf, TO;
function ir() {
  return (
    TO ||
      ((TO = 1),
      (wf = function (e) {
        if (typeof e != "function")
          throw new TypeError(e + " is not a function");
        return e;
      })),
    wf
  );
}
var Uf, SO;
function rs() {
  if (SO) return Uf;
  SO = 1;
  var e = po();
  return (
    (Uf = function (t) {
      if (!e(t)) throw new TypeError("Cannot use null or undefined");
      return t;
    }),
    Uf
  );
}
var kf, mO;
function K9() {
  if (mO) return kf;
  mO = 1;
  var e = ir(),
    t = rs(),
    n = Function.prototype.bind,
    r = Function.prototype.call,
    o = Object.keys,
    s = Object.prototype.propertyIsEnumerable;
  return (
    (kf = function (i, a) {
      return function (c, l) {
        var f,
          d = arguments[2],
          u = arguments[3];
        return (
          (c = Object(t(c))),
          e(l),
          (f = o(c)),
          u && f.sort(typeof u == "function" ? n.call(u, c) : void 0),
          typeof i != "function" && (i = f[i]),
          r.call(i, f, function (_, p) {
            return s.call(c, _) ? r.call(l, d, c[_], _, c, p) : a;
          })
        );
      };
    }),
    kf
  );
}
var Gf, AO;
function xl() {
  return (AO || ((AO = 1), (Gf = K9()("forEach"))), Gf);
}
var gO = {},
  RO;
function ho() {
  return (RO || (RO = 1), gO);
}
var Vf = {
    exports: {},
  },
  xf,
  NO;
function z9() {
  return (
    NO ||
      ((NO = 1),
      (xf = function () {
        var e = Object.assign,
          t;
        return typeof e != "function"
          ? !1
          : ((t = {
              foo: "raz",
            }),
            e(
              t,
              {
                bar: "dwa",
              },
              {
                trzy: "trzy",
              },
            ),
            t.foo + t.bar + t.trzy === "razdwatrzy");
      })),
    xf
  );
}
var $f, yO;
function Z9() {
  return (
    yO ||
      ((yO = 1),
      ($f = function () {
        try {
          return (Object.keys("primitive"), !0);
        } catch {
          return !1;
        }
      })),
    $f
  );
}
var Bf, OO;
function X9() {
  if (OO) return Bf;
  OO = 1;
  var e = po(),
    t = Object.keys;
  return (
    (Bf = function (n) {
      return t(e(n) ? Object(n) : n);
    }),
    Bf
  );
}
var Hf, CO;
function Q9() {
  return (CO || ((CO = 1), (Hf = Z9()() ? Object.keys : X9())), Hf);
}
var Ff, bO;
function J9() {
  if (bO) return Ff;
  bO = 1;
  var e = Q9(),
    t = rs(),
    n = Math.max;
  return (
    (Ff = function (r, o) {
      var s,
        i,
        a = n(arguments.length, 2),
        c;
      for (
        r = Object(t(r)),
          c = function (l) {
            try {
              r[l] = o[l];
            } catch (f) {
              s || (s = f);
            }
          },
          i = 1;
        i < a;
        ++i
      )
        ((o = arguments[i]), e(o).forEach(c));
      if (s !== void 0) throw s;
      return r;
    }),
    Ff
  );
}
var Yf, IO;
function dL() {
  return (IO || ((IO = 1), (Yf = z9()() ? Object.assign : J9())), Yf);
}
var jf, PO;
function eX() {
  if (PO) return jf;
  PO = 1;
  var e = po(),
    t = {
      function: !0,
      object: !0,
    };
  return (
    (jf = function (n) {
      return (e(n) && t[typeof n]) || !1;
    }),
    jf
  );
}
var MO;
function tX() {
  return (
    MO ||
      ((MO = 1),
      (function (e) {
        var t = dL(),
          n = eX(),
          r = po(),
          o = Error.captureStackTrace;
        e.exports = function (s) {
          var i = new Error(s),
            a = arguments[1],
            c = arguments[2];
          return (
            r(c) || (n(a) && ((c = a), (a = null))),
            r(c) && t(i, c),
            r(a) && (i.code = a),
            o && o(i, e.exports),
            i
          );
        };
      })(Vf)),
    Vf.exports
  );
}
var qc = {
    exports: {},
  },
  qf,
  vO;
function fL() {
  if (vO) return qf;
  vO = 1;
  var e = rs(),
    t = Object.defineProperty,
    n = Object.getOwnPropertyDescriptor,
    r = Object.getOwnPropertyNames,
    o = Object.getOwnPropertySymbols;
  return (
    (qf = function (s, i) {
      var a,
        c = Object(e(i));
      if (
        ((s = Object(e(s))),
        r(c).forEach(function (l) {
          try {
            t(s, l, n(i, l));
          } catch (f) {
            a = f;
          }
        }),
        typeof o == "function" &&
          o(c).forEach(function (l) {
            try {
              t(s, l, n(i, l));
            } catch (f) {
              a = f;
            }
          }),
        a !== void 0)
      )
        throw a;
      return s;
    }),
    qf
  );
}
var LO;
function _L() {
  if (LO) return qc.exports;
  LO = 1;
  var e = Eo(),
    t = function (i, a) {
      return a;
    },
    n,
    r,
    o,
    s;
  try {
    Object.defineProperty(t, "length", {
      configurable: !0,
      writable: !1,
      enumerable: !1,
      value: 1,
    });
  } catch {}
  return (
    t.length === 1
      ? ((n = {
          configurable: !0,
          writable: !1,
          enumerable: !1,
        }),
        (r = Object.defineProperty),
        (qc.exports = function (i, a) {
          return (
            (a = e(a)),
            i.length === a ? i : ((n.value = a), r(i, "length", n))
          );
        }))
      : ((s = fL()),
        (o = (function () {
          var i = [];
          return function (a) {
            var c,
              l = 0;
            if (i[a]) return i[a];
            for (c = []; a--; ) c.push("a" + (++l).toString(36));
            return new Function(
              "fn",
              "return function (" +
                c.join(", ") +
                ") { return fn.apply(this, arguments); };",
            );
          };
        })()),
        (qc.exports = function (i, a) {
          var c;
          if (((a = e(a)), i.length === a)) return i;
          c = o(a)(i);
          try {
            s(c, i);
          } catch {}
          return c;
        })),
    qc.exports
  );
}
var Wf = {
    exports: {},
  },
  Kf,
  DO;
function pL() {
  if (DO) return Kf;
  DO = 1;
  var e = void 0;
  return (
    (Kf = function (t) {
      return t !== e && t !== null;
    }),
    Kf
  );
}
var zf, wO;
function nX() {
  if (wO) return zf;
  wO = 1;
  var e = pL(),
    t = {
      object: !0,
      function: !0,
      undefined: !0,
    };
  return (
    (zf = function (n) {
      return e(n) ? hasOwnProperty.call(t, typeof n) : !1;
    }),
    zf
  );
}
var Zf, UO;
function rX() {
  if (UO) return Zf;
  UO = 1;
  var e = nX();
  return (
    (Zf = function (t) {
      if (!e(t)) return !1;
      try {
        return t.constructor ? t.constructor.prototype === t : !1;
      } catch {
        return !1;
      }
    }),
    Zf
  );
}
var Xf, kO;
function oX() {
  if (kO) return Xf;
  kO = 1;
  var e = rX();
  return (
    (Xf = function (t) {
      if (typeof t != "function" || !hasOwnProperty.call(t, "length"))
        return !1;
      try {
        if (
          typeof t.length != "number" ||
          typeof t.call != "function" ||
          typeof t.apply != "function"
        )
          return !1;
      } catch {
        return !1;
      }
      return !e(t);
    }),
    Xf
  );
}
var Qf, GO;
function sX() {
  if (GO) return Qf;
  GO = 1;
  var e = oX(),
    t = /^\s*class[\s{/}]/,
    n = Function.prototype.toString;
  return (
    (Qf = function (r) {
      return !(!e(r) || t.test(n.call(r)));
    }),
    Qf
  );
}
var Jf, VO;
function iX() {
  if (VO) return Jf;
  VO = 1;
  var e = "razdwatrzy";
  return (
    (Jf = function () {
      return typeof e.contains != "function"
        ? !1
        : e.contains("dwa") === !0 && e.contains("foo") === !1;
    }),
    Jf
  );
}
var e_, xO;
function aX() {
  if (xO) return e_;
  xO = 1;
  var e = String.prototype.indexOf;
  return (
    (e_ = function (t) {
      return e.call(this, t, arguments[1]) > -1;
    }),
    e_
  );
}
var t_, $O;
function cX() {
  return (
    $O || (($O = 1), (t_ = iX()() ? String.prototype.contains : aX())),
    t_
  );
}
var BO;
function To() {
  if (BO) return Wf.exports;
  BO = 1;
  var e = pL(),
    t = sX(),
    n = dL(),
    r = uL(),
    o = cX(),
    s = (Wf.exports = function (i, a) {
      var c, l, f, d, u;
      return (
        arguments.length < 2 || typeof i != "string"
          ? ((d = a), (a = i), (i = null))
          : (d = arguments[2]),
        e(i)
          ? ((c = o.call(i, "c")), (l = o.call(i, "e")), (f = o.call(i, "w")))
          : ((c = f = !0), (l = !1)),
        (u = {
          value: a,
          configurable: c,
          enumerable: l,
          writable: f,
        }),
        d ? n(r(d), u) : u
      );
    });
  return (
    (s.gs = function (i, a, c) {
      var l, f, d, u;
      return (
        typeof i != "string"
          ? ((d = c), (c = a), (a = i), (i = null))
          : (d = arguments[3]),
        e(a)
          ? t(a)
            ? e(c)
              ? t(c) || ((d = c), (c = void 0))
              : (c = void 0)
            : ((d = a), (a = c = void 0))
          : (a = void 0),
        e(i)
          ? ((l = o.call(i, "c")), (f = o.call(i, "e")))
          : ((l = !0), (f = !1)),
        (u = {
          get: a,
          set: c,
          configurable: l,
          enumerable: f,
        }),
        d ? n(r(d), u) : u
      );
    }),
    Wf.exports
  );
}
var Wc = {
    exports: {},
  },
  HO;
function uX() {
  return (
    HO ||
      ((HO = 1),
      (function (e, t) {
        var n = To(),
          r = ir(),
          o = Function.prototype.apply,
          s = Function.prototype.call,
          i = Object.create,
          a = Object.defineProperty,
          c = Object.defineProperties,
          l = Object.prototype.hasOwnProperty,
          f = {
            configurable: !0,
            enumerable: !1,
            writable: !0,
          },
          d,
          u,
          _,
          p,
          E,
          h,
          T;
        ((d = function (m, A) {
          var g;
          return (
            r(A),
            l.call(this, "__ee__")
              ? (g = this.__ee__)
              : ((g = f.value = i(null)),
                a(this, "__ee__", f),
                (f.value = null)),
            g[m]
              ? typeof g[m] == "object"
                ? g[m].push(A)
                : (g[m] = [g[m], A])
              : (g[m] = A),
            this
          );
        }),
          (u = function (m, A) {
            var g, N;
            return (
              r(A),
              (N = this),
              d.call(
                this,
                m,
                (g = function () {
                  (_.call(N, m, g), o.call(A, this, arguments));
                }),
              ),
              (g.__eeOnceListener__ = A),
              this
            );
          }),
          (_ = function (m, A) {
            var g, N, O, I;
            if ((r(A), !l.call(this, "__ee__"))) return this;
            if (((g = this.__ee__), !g[m])) return this;
            if (((N = g[m]), typeof N == "object"))
              for (I = 0; (O = N[I]); ++I)
                (O === A || O.__eeOnceListener__ === A) &&
                  (N.length === 2 ? (g[m] = N[I ? 0 : 1]) : N.splice(I, 1));
            else (N === A || N.__eeOnceListener__ === A) && delete g[m];
            return this;
          }),
          (p = function (m) {
            var A, g, N, O, I;
            if (l.call(this, "__ee__") && ((O = this.__ee__[m]), !!O))
              if (typeof O == "object") {
                for (
                  g = arguments.length, I = new Array(g - 1), A = 1;
                  A < g;
                  ++A
                )
                  I[A - 1] = arguments[A];
                for (O = O.slice(), A = 0; (N = O[A]); ++A) o.call(N, this, I);
              } else
                switch (arguments.length) {
                  case 1:
                    s.call(O, this);
                    break;
                  case 2:
                    s.call(O, this, arguments[1]);
                    break;
                  case 3:
                    s.call(O, this, arguments[1], arguments[2]);
                    break;
                  default:
                    for (
                      g = arguments.length, I = new Array(g - 1), A = 1;
                      A < g;
                      ++A
                    )
                      I[A - 1] = arguments[A];
                    o.call(O, this, I);
                }
          }),
          (E = {
            on: d,
            once: u,
            off: _,
            emit: p,
          }),
          (h = {
            on: n(d),
            once: n(u),
            off: n(_),
            emit: n(p),
          }),
          (T = c({}, h)),
          (e.exports = t =
            function (m) {
              return m == null ? i(T) : c(Object(m), h);
            }),
          (t.methods = E));
      })(Wc, Wc.exports)),
    Wc.exports
  );
}
var n_, FO;
function lX() {
  return (
    FO ||
      ((FO = 1),
      (n_ = function () {
        var e = Array.from,
          t,
          n;
        return typeof e != "function"
          ? !1
          : ((t = ["raz", "dwa"]),
            (n = e(t)),
            !!(n && n !== t && n[1] === "dwa"));
      })),
    n_
  );
}
var r_, YO;
function dX() {
  return (
    YO ||
      ((YO = 1),
      (r_ = function () {
        return typeof globalThis != "object" || !globalThis
          ? !1
          : globalThis.Array === Array;
      })),
    r_
  );
}
var o_, jO;
function fX() {
  if (jO) return o_;
  jO = 1;
  var e = function () {
    if (typeof self == "object" && self) return self;
    if (typeof window == "object" && window) return window;
    throw new Error("Unable to resolve global `this`");
  };
  return (
    (o_ = (function () {
      if (this) return this;
      try {
        Object.defineProperty(Object.prototype, "__global__", {
          get: function () {
            return this;
          },
          configurable: !0,
        });
      } catch {
        return e();
      }
      try {
        return __global__ || e();
      } finally {
        delete Object.prototype.__global__;
      }
    })()),
    o_
  );
}
var s_, qO;
function $l() {
  return (qO || ((qO = 1), (s_ = dX()() ? globalThis : fX())), s_);
}
var i_, WO;
function _X() {
  if (WO) return i_;
  WO = 1;
  var e = $l(),
    t = {
      object: !0,
      symbol: !0,
    };
  return (
    (i_ = function () {
      var n = e.Symbol,
        r;
      if (typeof n != "function") return !1;
      r = n("test symbol");
      try {
        String(r);
      } catch {
        return !1;
      }
      return !(
        !t[typeof n.iterator] ||
        !t[typeof n.toPrimitive] ||
        !t[typeof n.toStringTag]
      );
    }),
    i_
  );
}
var a_, KO;
function pX() {
  return (
    KO ||
      ((KO = 1),
      (a_ = function (e) {
        return e
          ? typeof e == "symbol"
            ? !0
            : !e.constructor || e.constructor.name !== "Symbol"
              ? !1
              : e[e.constructor.toStringTag] === "Symbol"
          : !1;
      })),
    a_
  );
}
var c_, zO;
function EL() {
  if (zO) return c_;
  zO = 1;
  var e = pX();
  return (
    (c_ = function (t) {
      if (!e(t)) throw new TypeError(t + " is not a symbol");
      return t;
    }),
    c_
  );
}
var u_, ZO;
function EX() {
  if (ZO) return u_;
  ZO = 1;
  var e = To(),
    t = Object.create,
    n = Object.defineProperty,
    r = Object.prototype,
    o = t(null);
  return (
    (u_ = function (s) {
      for (var i = 0, a, c; o[s + (i || "")]; ) ++i;
      return (
        (s += i || ""),
        (o[s] = !0),
        (a = "@@" + s),
        n(
          r,
          a,
          e.gs(null, function (l) {
            c || ((c = !0), n(this, a, e(l)), (c = !1));
          }),
        ),
        a
      );
    }),
    u_
  );
}
var l_, XO;
function hX() {
  if (XO) return l_;
  XO = 1;
  var e = To(),
    t = $l().Symbol;
  return (
    (l_ = function (n) {
      return Object.defineProperties(n, {
        hasInstance: e("", (t && t.hasInstance) || n("hasInstance")),
        isConcatSpreadable: e(
          "",
          (t && t.isConcatSpreadable) || n("isConcatSpreadable"),
        ),
        iterator: e("", (t && t.iterator) || n("iterator")),
        match: e("", (t && t.match) || n("match")),
        replace: e("", (t && t.replace) || n("replace")),
        search: e("", (t && t.search) || n("search")),
        species: e("", (t && t.species) || n("species")),
        split: e("", (t && t.split) || n("split")),
        toPrimitive: e("", (t && t.toPrimitive) || n("toPrimitive")),
        toStringTag: e("", (t && t.toStringTag) || n("toStringTag")),
        unscopables: e("", (t && t.unscopables) || n("unscopables")),
      });
    }),
    l_
  );
}
var d_, QO;
function TX() {
  if (QO) return d_;
  QO = 1;
  var e = To(),
    t = EL(),
    n = Object.create(null);
  return (
    (d_ = function (r) {
      return Object.defineProperties(r, {
        for: e(function (o) {
          return n[o] ? n[o] : (n[o] = r(String(o)));
        }),
        keyFor: e(function (o) {
          var s;
          t(o);
          for (s in n) if (n[s] === o) return s;
        }),
      });
    }),
    d_
  );
}
var f_, JO;
function SX() {
  if (JO) return f_;
  JO = 1;
  var e = To(),
    t = EL(),
    n = $l().Symbol,
    r = EX(),
    o = hX(),
    s = TX(),
    i = Object.create,
    a = Object.defineProperties,
    c = Object.defineProperty,
    l,
    f,
    d;
  if (typeof n == "function")
    try {
      (String(n()), (d = !0));
    } catch {}
  else n = null;
  return (
    (f = function (_) {
      if (this instanceof f) throw new TypeError("Symbol is not a constructor");
      return l(_);
    }),
    (f_ = l =
      function u(_) {
        var p;
        if (this instanceof u)
          throw new TypeError("Symbol is not a constructor");
        return d
          ? n(_)
          : ((p = i(f.prototype)),
            (_ = _ === void 0 ? "" : String(_)),
            a(p, {
              __description__: e("", _),
              __name__: e("", r(_)),
            }));
      }),
    o(l),
    s(l),
    a(f.prototype, {
      constructor: e(l),
      toString: e("", function () {
        return this.__name__;
      }),
    }),
    a(l.prototype, {
      toString: e(function () {
        return "Symbol (" + t(this).__description__ + ")";
      }),
      valueOf: e(function () {
        return t(this);
      }),
    }),
    c(
      l.prototype,
      l.toPrimitive,
      e("", function () {
        var u = t(this);
        return typeof u == "symbol" ? u : u.toString();
      }),
    ),
    c(l.prototype, l.toStringTag, e("c", "Symbol")),
    c(f.prototype, l.toStringTag, e("c", l.prototype[l.toStringTag])),
    c(f.prototype, l.toPrimitive, e("c", l.prototype[l.toPrimitive])),
    f_
  );
}
var __, eC;
function mX() {
  return (eC || ((eC = 1), (__ = _X()() ? $l().Symbol : SX())), __);
}
var p_, tC;
function AX() {
  if (tC) return p_;
  tC = 1;
  var e = Object.prototype.toString,
    t = e.call(
      (function () {
        return arguments;
      })(),
    );
  return (
    (p_ = function (n) {
      return e.call(n) === t;
    }),
    p_
  );
}
var E_, nC;
function gX() {
  if (nC) return E_;
  nC = 1;
  var e = Object.prototype.toString,
    t = RegExp.prototype.test.bind(/^[object [A-Za-z0-9]*Function]$/);
  return (
    (E_ = function (n) {
      return typeof n == "function" && t(e.call(n));
    }),
    E_
  );
}
var h_, rC;
function RX() {
  if (rC) return h_;
  rC = 1;
  var e = Object.prototype.toString,
    t = e.call("");
  return (
    (h_ = function (n) {
      return (
        typeof n == "string" ||
        (n &&
          typeof n == "object" &&
          (n instanceof String || e.call(n) === t)) ||
        !1
      );
    }),
    h_
  );
}
var T_, oC;
function NX() {
  if (oC) return T_;
  oC = 1;
  var e = mX().iterator,
    t = AX(),
    n = gX(),
    r = Eo(),
    o = ir(),
    s = rs(),
    i = po(),
    a = RX(),
    c = Array.isArray,
    l = Function.prototype.call,
    f = {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: null,
    },
    d = Object.defineProperty;
  return (
    (T_ = function (u) {
      var _ = arguments[1],
        p = arguments[2],
        E,
        h,
        T,
        m,
        A,
        g,
        N,
        O,
        I,
        b;
      if (
        ((u = Object(s(u))), i(_) && o(_), !this || this === Array || !n(this))
      ) {
        if (!_) {
          if (t(u))
            return (
              (A = u.length),
              A !== 1
                ? Array.apply(null, u)
                : ((m = new Array(1)), (m[0] = u[0]), m)
            );
          if (c(u)) {
            for (m = new Array((A = u.length)), h = 0; h < A; ++h) m[h] = u[h];
            return m;
          }
        }
        m = [];
      } else E = this;
      if (!c(u)) {
        if ((I = u[e]) !== void 0) {
          for (
            N = o(I).call(u), E && (m = new E()), O = N.next(), h = 0;
            !O.done;
          )
            ((b = _ ? l.call(_, p, O.value, h) : O.value),
              E ? ((f.value = b), d(m, h, f)) : (m[h] = b),
              (O = N.next()),
              ++h);
          A = h;
        } else if (a(u)) {
          for (A = u.length, E && (m = new E()), h = 0, T = 0; h < A; ++h)
            ((b = u[h]),
              h + 1 < A &&
                ((g = b.charCodeAt(0)),
                g >= 55296 && g <= 56319 && (b += u[++h])),
              (b = _ ? l.call(_, p, b, T) : b),
              E ? ((f.value = b), d(m, T, f)) : (m[T] = b),
              ++T);
          A = T;
        }
      }
      if (A === void 0)
        for (A = r(u.length), E && (m = new E(A)), h = 0; h < A; ++h)
          ((b = _ ? l.call(_, p, u[h], h) : u[h]),
            E ? ((f.value = b), d(m, h, f)) : (m[h] = b));
      return (E && ((f.value = null), (m.length = A)), m);
    }),
    T_
  );
}
var S_, sC;
function fh() {
  return (sC || ((sC = 1), (S_ = lX()() ? Array.from : NX())), S_);
}
var m_, iC;
function yX() {
  if (iC) return m_;
  iC = 1;
  var e = fh(),
    t = Array.isArray;
  return (
    (m_ = function (n) {
      return t(n) ? n : e(n);
    }),
    m_
  );
}
var A_, aC;
function OX() {
  if (aC) return A_;
  aC = 1;
  var e = yX(),
    t = po(),
    n = ir(),
    r = Array.prototype.slice,
    o;
  return (
    (o = function (s) {
      return this.map(function (i, a) {
        return i ? i(s[a]) : s[a];
      }).concat(r.call(s, this.length));
    }),
    (A_ = function (s) {
      return (
        (s = e(s)),
        s.forEach(function (i) {
          t(i) && n(i);
        }),
        o.bind(s)
      );
    }),
    A_
  );
}
var g_, cC;
function CX() {
  if (cC) return g_;
  cC = 1;
  var e = ir();
  return (
    (g_ = function (t) {
      var n;
      return typeof t == "function"
        ? {
            set: t,
            get: t,
          }
        : ((n = {
            get: e(t.get),
          }),
          t.set !== void 0
            ? ((n.set = e(t.set)),
              t.delete && (n.delete = e(t.delete)),
              t.clear && (n.clear = e(t.clear)),
              n)
            : ((n.set = n.get), n));
    }),
    g_
  );
}
var R_, uC;
function bX() {
  if (uC) return R_;
  uC = 1;
  var e = tX(),
    t = _L(),
    n = To(),
    r = uX().methods,
    o = OX(),
    s = CX(),
    i = Function.prototype.apply,
    a = Function.prototype.call,
    c = Object.create,
    l = Object.defineProperties,
    f = r.on,
    d = r.emit;
  return (
    (R_ = function (u, _, p) {
      var E = c(null),
        h,
        T,
        m,
        A,
        g,
        N,
        O,
        I,
        b,
        w,
        L,
        j,
        H,
        x,
        B;
      return (
        _ !== !1 ? (T = _) : isNaN(u.length) ? (T = 1) : (T = u.length),
        p.normalizer &&
          ((w = s(p.normalizer)),
          (m = w.get),
          (A = w.set),
          (g = w.delete),
          (N = w.clear)),
        p.resolvers != null && (B = o(p.resolvers)),
        m
          ? (x = t(function (F) {
              var U,
                k,
                Y = arguments;
              if (
                (B && (Y = B(Y)),
                (U = m(Y)),
                U !== null && hasOwnProperty.call(E, U))
              )
                return (L && h.emit("get", U, Y, this), E[U]);
              if (
                (Y.length === 1
                  ? (k = a.call(u, this, Y[0]))
                  : (k = i.call(u, this, Y)),
                U === null)
              ) {
                if (((U = m(Y)), U !== null))
                  throw e("Circular invocation", "CIRCULAR_INVOCATION");
                U = A(Y);
              } else if (hasOwnProperty.call(E, U))
                throw e("Circular invocation", "CIRCULAR_INVOCATION");
              return ((E[U] = k), j && h.emit("set", U, null, k), k);
            }, T))
          : _ === 0
            ? (x = function () {
                var F;
                if (hasOwnProperty.call(E, "data"))
                  return (L && h.emit("get", "data", arguments, this), E.data);
                if (
                  (arguments.length
                    ? (F = i.call(u, this, arguments))
                    : (F = a.call(u, this)),
                  hasOwnProperty.call(E, "data"))
                )
                  throw e("Circular invocation", "CIRCULAR_INVOCATION");
                return ((E.data = F), j && h.emit("set", "data", null, F), F);
              })
            : (x = function (F) {
                var U,
                  k = arguments,
                  Y;
                if (
                  (B && (k = B(arguments)),
                  (Y = String(k[0])),
                  hasOwnProperty.call(E, Y))
                )
                  return (L && h.emit("get", Y, k, this), E[Y]);
                if (
                  (k.length === 1
                    ? (U = a.call(u, this, k[0]))
                    : (U = i.call(u, this, k)),
                  hasOwnProperty.call(E, Y))
                )
                  throw e("Circular invocation", "CIRCULAR_INVOCATION");
                return ((E[Y] = U), j && h.emit("set", Y, null, U), U);
              }),
        (h = {
          original: u,
          memoized: x,
          profileName: p.profileName,
          get: function (F) {
            return (B && (F = B(F)), m ? m(F) : String(F[0]));
          },
          has: function (F) {
            return hasOwnProperty.call(E, F);
          },
          delete: function (F) {
            var U;
            hasOwnProperty.call(E, F) &&
              (g && g(F), (U = E[F]), delete E[F], H && h.emit("delete", F, U));
          },
          clear: function () {
            var F = E;
            (N && N(), (E = c(null)), h.emit("clear", F));
          },
          on: function (F, U) {
            return (
              F === "get"
                ? (L = !0)
                : F === "set"
                  ? (j = !0)
                  : F === "delete" && (H = !0),
              f.call(this, F, U)
            );
          },
          emit: d,
          updateEnv: function () {
            u = h.original;
          },
        }),
        m
          ? (O = t(function (F) {
              var U,
                k = arguments;
              (B && (k = B(k)), (U = m(k)), U !== null && h.delete(U));
            }, T))
          : _ === 0
            ? (O = function () {
                return h.delete("data");
              })
            : (O = function (F) {
                return (B && (F = B(arguments)[0]), h.delete(F));
              }),
        (I = t(function () {
          var F,
            U = arguments;
          return _ === 0
            ? E.data
            : (B && (U = B(U)), m ? (F = m(U)) : (F = String(U[0])), E[F]);
        })),
        (b = t(function () {
          var F,
            U = arguments;
          return _ === 0
            ? h.has("data")
            : (B && (U = B(U)),
              m ? (F = m(U)) : (F = String(U[0])),
              F === null ? !1 : h.has(F));
        })),
        l(x, {
          __memoized__: n(!0),
          delete: n(O),
          clear: n(h.clear),
          _get: n(I),
          _has: n(b),
        }),
        h
      );
    }),
    R_
  );
}
var N_, lC;
function IX() {
  if (lC) return N_;
  lC = 1;
  var e = ir(),
    t = xl(),
    n = ho(),
    r = bX(),
    o = lL();
  return (
    (N_ = function s(i) {
      var a, c, l;
      if ((e(i), (a = Object(arguments[1])), a.async && a.promise))
        throw new Error(
          "Options 'async' and 'promise' cannot be used together",
        );
      return hasOwnProperty.call(i, "__memoized__") && !a.force
        ? i
        : ((c = o(a.length, i.length, a.async && n.async)),
          (l = r(i, c, a)),
          t(n, function (f, d) {
            a[d] && f(a[d], l, a);
          }),
          s.__profiler__ && s.__profiler__(l),
          l.updateEnv(),
          l.memoized);
    }),
    N_
  );
}
var y_, dC;
function PX() {
  return (
    dC ||
      ((dC = 1),
      (y_ = function (e) {
        var t,
          n,
          r = e.length;
        if (!r) return "";
        for (t = String(e[(n = 0)]); --r; ) t += "" + e[++n];
        return t;
      })),
    y_
  );
}
var O_, fC;
function MX() {
  return (
    fC ||
      ((fC = 1),
      (O_ = function (e) {
        return e
          ? function (t) {
              for (var n = String(t[0]), r = 0, o = e; --o; ) n += "" + t[++r];
              return n;
            }
          : function () {
              return "";
            };
      })),
    O_
  );
}
var C_, _C;
function vX() {
  return (
    _C ||
      ((_C = 1),
      (C_ = function () {
        var e = Number.isNaN;
        return typeof e != "function" ? !1 : !e({}) && e(NaN) && !e(34);
      })),
    C_
  );
}
var b_, pC;
function LX() {
  return (
    pC ||
      ((pC = 1),
      (b_ = function (e) {
        return e !== e;
      })),
    b_
  );
}
var I_, EC;
function DX() {
  return (EC || ((EC = 1), (I_ = vX()() ? Number.isNaN : LX())), I_);
}
var P_, hC;
function _h() {
  if (hC) return P_;
  hC = 1;
  var e = DX(),
    t = Eo(),
    n = rs(),
    r = Array.prototype.indexOf,
    o = Object.prototype.hasOwnProperty,
    s = Math.abs,
    i = Math.floor;
  return (
    (P_ = function (a) {
      var c, l, f, d;
      if (!e(a)) return r.apply(this, arguments);
      for (
        l = t(n(this).length),
          f = arguments[1],
          isNaN(f)
            ? (f = 0)
            : f >= 0
              ? (f = i(f))
              : (f = t(this.length) - i(s(f))),
          c = f;
        c < l;
        ++c
      )
        if (o.call(this, c) && ((d = this[c]), e(d))) return c;
      return -1;
    }),
    P_
  );
}
var M_, TC;
function wX() {
  if (TC) return M_;
  TC = 1;
  var e = _h(),
    t = Object.create;
  return (
    (M_ = function () {
      var n = 0,
        r = [],
        o = t(null);
      return {
        get: function (s) {
          var i = 0,
            a = r,
            c,
            l = s.length;
          if (l === 0) return a[l] || null;
          if ((a = a[l])) {
            for (; i < l - 1; ) {
              if (((c = e.call(a[0], s[i])), c === -1)) return null;
              ((a = a[1][c]), ++i);
            }
            return (
              (c = e.call(a[0], s[i])),
              c === -1 ? null : a[1][c] || null
            );
          }
          return null;
        },
        set: function (s) {
          var i = 0,
            a = r,
            c,
            l = s.length;
          if (l === 0) a[l] = ++n;
          else {
            for (a[l] || (a[l] = [[], []]), a = a[l]; i < l - 1; )
              ((c = e.call(a[0], s[i])),
                c === -1 && ((c = a[0].push(s[i]) - 1), a[1].push([[], []])),
                (a = a[1][c]),
                ++i);
            ((c = e.call(a[0], s[i])),
              c === -1 && (c = a[0].push(s[i]) - 1),
              (a[1][c] = ++n));
          }
          return ((o[n] = s), n);
        },
        delete: function (s) {
          var i = 0,
            a = r,
            c,
            l = o[s],
            f = l.length,
            d = [];
          if (f === 0) delete a[f];
          else if ((a = a[f])) {
            for (; i < f - 1; ) {
              if (((c = e.call(a[0], l[i])), c === -1)) return;
              (d.push(a, c), (a = a[1][c]), ++i);
            }
            if (((c = e.call(a[0], l[i])), c === -1)) return;
            for (
              s = a[1][c], a[0].splice(c, 1), a[1].splice(c, 1);
              !a[0].length && d.length;
            )
              ((c = d.pop()),
                (a = d.pop()),
                a[0].splice(c, 1),
                a[1].splice(c, 1));
          }
          delete o[s];
        },
        clear: function () {
          ((r = []), (o = t(null)));
        },
      };
    }),
    M_
  );
}
var v_, SC;
function UX() {
  if (SC) return v_;
  SC = 1;
  var e = _h();
  return (
    (v_ = function () {
      var t = 0,
        n = [],
        r = [];
      return {
        get: function (o) {
          var s = e.call(n, o[0]);
          return s === -1 ? null : r[s];
        },
        set: function (o) {
          return (n.push(o[0]), r.push(++t), t);
        },
        delete: function (o) {
          var s = e.call(r, o);
          s !== -1 && (n.splice(s, 1), r.splice(s, 1));
        },
        clear: function () {
          ((n = []), (r = []));
        },
      };
    }),
    v_
  );
}
var L_, mC;
function kX() {
  if (mC) return L_;
  mC = 1;
  var e = _h(),
    t = Object.create;
  return (
    (L_ = function (n) {
      var r = 0,
        o = [[], []],
        s = t(null);
      return {
        get: function (i) {
          for (var a = 0, c = o, l; a < n - 1; ) {
            if (((l = e.call(c[0], i[a])), l === -1)) return null;
            ((c = c[1][l]), ++a);
          }
          return ((l = e.call(c[0], i[a])), l === -1 ? null : c[1][l] || null);
        },
        set: function (i) {
          for (var a = 0, c = o, l; a < n - 1; )
            ((l = e.call(c[0], i[a])),
              l === -1 && ((l = c[0].push(i[a]) - 1), c[1].push([[], []])),
              (c = c[1][l]),
              ++a);
          return (
            (l = e.call(c[0], i[a])),
            l === -1 && (l = c[0].push(i[a]) - 1),
            (c[1][l] = ++r),
            (s[r] = i),
            r
          );
        },
        delete: function (i) {
          for (var a = 0, c = o, l, f = [], d = s[i]; a < n - 1; ) {
            if (((l = e.call(c[0], d[a])), l === -1)) return;
            (f.push(c, l), (c = c[1][l]), ++a);
          }
          if (((l = e.call(c[0], d[a])), l !== -1)) {
            for (
              i = c[1][l], c[0].splice(l, 1), c[1].splice(l, 1);
              !c[0].length && f.length;
            )
              ((l = f.pop()),
                (c = f.pop()),
                c[0].splice(l, 1),
                c[1].splice(l, 1));
            delete s[i];
          }
        },
        clear: function () {
          ((o = [[], []]), (s = t(null)));
        },
      };
    }),
    L_
  );
}
var AC = {},
  D_,
  gC;
function hL() {
  if (gC) return D_;
  gC = 1;
  var e = ir(),
    t = xl(),
    n = Function.prototype.call;
  return (
    (D_ = function (r, o) {
      var s = {},
        i = arguments[2];
      return (
        e(o),
        t(r, function (a, c, l, f) {
          s[c] = n.call(o, i, a, c, l, f);
        }),
        s
      );
    }),
    D_
  );
}
var w_, RC;
function ph() {
  if (RC) return w_;
  RC = 1;
  var e = function (n) {
      if (typeof n != "function") throw new TypeError(n + " is not a function");
      return n;
    },
    t = function (n) {
      var r = document.createTextNode(""),
        o,
        s,
        i = 0;
      return (
        new n(function () {
          var a;
          if (o) s && (o = s.concat(o));
          else {
            if (!s) return;
            o = s;
          }
          if (((s = o), (o = null), typeof s == "function")) {
            ((a = s), (s = null), a());
            return;
          }
          for (r.data = i = ++i % 2; s; )
            ((a = s.shift()), s.length || (s = null), a());
        }).observe(r, {
          characterData: !0,
        }),
        function (a) {
          if ((e(a), o)) {
            typeof o == "function" ? (o = [o, a]) : o.push(a);
            return;
          }
          ((o = a), (r.data = i = ++i % 2));
        }
      );
    };
  return (
    (w_ = (function () {
      if (
        typeof process == "object" &&
        process &&
        typeof process.nextTick == "function"
      )
        return process.nextTick;
      if (typeof queueMicrotask == "function")
        return function (n) {
          queueMicrotask(e(n));
        };
      if (typeof document == "object" && document) {
        if (typeof MutationObserver == "function") return t(MutationObserver);
        if (typeof WebKitMutationObserver == "function")
          return t(WebKitMutationObserver);
      }
      return typeof setImmediate == "function"
        ? function (n) {
            setImmediate(e(n));
          }
        : typeof setTimeout == "function" || typeof setTimeout == "object"
          ? function (n) {
              setTimeout(e(n), 0);
            }
          : null;
    })()),
    w_
  );
}
var NC;
function GX() {
  if (NC) return AC;
  NC = 1;
  var e = fh(),
    t = hL(),
    n = fL(),
    r = _L(),
    o = ph(),
    s = Array.prototype.slice,
    i = Function.prototype.apply,
    a = Object.create;
  return (
    (ho().async = function (c, l) {
      var f = a(null),
        d = a(null),
        u = l.memoized,
        _ = l.original,
        p,
        E,
        h;
      l.memoized = r(function (T) {
        var m = arguments,
          A = m[m.length - 1];
        return (
          typeof A == "function" && ((p = A), (m = s.call(m, 0, -1))),
          u.apply((E = this), (h = m))
        );
      }, u);
      try {
        n(l.memoized, u);
      } catch {}
      (l.on("get", function (T) {
        var m, A, g;
        if (p) {
          if (f[T]) {
            (typeof f[T] == "function" ? (f[T] = [f[T], p]) : f[T].push(p),
              (p = null));
            return;
          }
          ((m = p),
            (A = E),
            (g = h),
            (p = E = h = null),
            o(function () {
              var N;
              hasOwnProperty.call(d, T)
                ? ((N = d[T]),
                  l.emit("getasync", T, g, A),
                  i.call(m, N.context, N.args))
                : ((p = m), (E = A), (h = g), u.apply(A, g));
            }));
        }
      }),
        (l.original = function () {
          var T, m, A, g;
          return p
            ? ((T = e(arguments)),
              (m = function N(O) {
                var I,
                  b,
                  w = N.id;
                if (w == null) {
                  o(i.bind(N, this, arguments));
                  return;
                }
                if ((delete N.id, (I = f[w]), delete f[w], !!I))
                  return (
                    (b = e(arguments)),
                    l.has(w) &&
                      (O
                        ? l.delete(w)
                        : ((d[w] = {
                            context: this,
                            args: b,
                          }),
                          l.emit(
                            "setasync",
                            w,
                            typeof I == "function" ? 1 : I.length,
                          ))),
                    typeof I == "function"
                      ? (g = i.call(I, this, b))
                      : I.forEach(function (L) {
                          g = i.call(L, this, b);
                        }, this),
                    g
                  );
              }),
              (A = p),
              (p = E = h = null),
              T.push(m),
              (g = i.call(_, this, T)),
              (m.cb = A),
              (p = m),
              g)
            : i.call(_, this, arguments);
        }),
        l.on("set", function (T) {
          if (!p) {
            l.delete(T);
            return;
          }
          (f[T]
            ? typeof f[T] == "function"
              ? (f[T] = [f[T], p.cb])
              : f[T].push(p.cb)
            : (f[T] = p.cb),
            delete p.cb,
            (p.id = T),
            (p = null));
        }),
        l.on("delete", function (T) {
          var m;
          hasOwnProperty.call(f, T) ||
            (d[T] &&
              ((m = d[T]),
              delete d[T],
              l.emit("deleteasync", T, s.call(m.args, 1))));
        }),
        l.on("clear", function () {
          var T = d;
          ((d = a(null)),
            l.emit(
              "clearasync",
              t(T, function (m) {
                return s.call(m.args, 1);
              }),
            ));
        }));
    }),
    AC
  );
}
var yC = {},
  U_,
  OC;
function VX() {
  if (OC) return U_;
  OC = 1;
  var e = Array.prototype.forEach,
    t = Object.create;
  return (
    (U_ = function (n) {
      var r = t(null);
      return (
        e.call(arguments, function (o) {
          r[o] = !0;
        }),
        r
      );
    }),
    U_
  );
}
var k_, CC;
function TL() {
  return (
    CC ||
      ((CC = 1),
      (k_ = function (e) {
        return typeof e == "function";
      })),
    k_
  );
}
var G_, bC;
function xX() {
  if (bC) return G_;
  bC = 1;
  var e = TL();
  return (
    (G_ = function (t) {
      try {
        return t && e(t.toString) ? t.toString() : String(t);
      } catch {
        throw new TypeError("Passed argument cannot be stringifed");
      }
    }),
    G_
  );
}
var V_, IC;
function $X() {
  if (IC) return V_;
  IC = 1;
  var e = rs(),
    t = xX();
  return (
    (V_ = function (n) {
      return t(e(n));
    }),
    V_
  );
}
var x_, PC;
function BX() {
  if (PC) return x_;
  PC = 1;
  var e = TL();
  return (
    (x_ = function (t) {
      try {
        return t && e(t.toString) ? t.toString() : String(t);
      } catch {
        return "<Non-coercible to string value>";
      }
    }),
    x_
  );
}
var $_, MC;
function HX() {
  if (MC) return $_;
  MC = 1;
  var e = BX(),
    t = /[\n\r\u2028\u2029]/g;
  return (
    ($_ = function (n) {
      var r = e(n);
      return (
        r.length > 100 && (r = r.slice(0, 99) + ""),
        (r = r.replace(t, function (o) {
          return JSON.stringify(o).slice(1, -1);
        })),
        r
      );
    }),
    $_
  );
}
var Kc = {
    exports: {},
  },
  vC;
function SL() {
  if (vC) return Kc.exports;
  ((vC = 1), (Kc.exports = e), (Kc.exports.default = e));
  function e(t) {
    return (
      !!t &&
      (typeof t == "object" || typeof t == "function") &&
      typeof t.then == "function"
    );
  }
  return Kc.exports;
}
var LC;
function FX() {
  if (LC) return yC;
  LC = 1;
  var e = hL(),
    t = VX(),
    n = $X(),
    r = HX(),
    o = SL(),
    s = ph(),
    i = Object.create,
    a = t("then", "then:finally", "done", "done:finally");
  return (
    (ho().promise = function (c, l) {
      var f = i(null),
        d = i(null),
        u = i(null);
      if (c === !0) c = null;
      else if (((c = n(c)), !a[c]))
        throw new TypeError("'" + r(c) + "' is not valid promise mode");
      (l.on("set", function (_, p, E) {
        var h = !1;
        if (!o(E)) {
          ((d[_] = E), l.emit("setasync", _, 1));
          return;
        }
        ((f[_] = 1), (u[_] = E));
        var T = function (N) {
            var O = f[_];
            if (h)
              throw new Error(`Memoizee error: Detected unordered then|done & finally resolution, which in turn makes proper detection of success/failure impossible (when in 'done:finally' mode)
Consider to rely on 'then' or 'done' mode instead.`);
            O && (delete f[_], (d[_] = N), l.emit("setasync", _, O));
          },
          m = function () {
            ((h = !0), f[_] && (delete f[_], delete u[_], l.delete(_)));
          },
          A = c;
        if ((A || (A = "then"), A === "then")) {
          var g = function () {
            s(m);
          };
          ((E = E.then(function (N) {
            s(T.bind(this, N));
          }, g)),
            typeof E.finally == "function" && E.finally(g));
        } else if (A === "done") {
          if (typeof E.done != "function")
            throw new Error(
              "Memoizee error: Retrieved promise does not implement 'done' in 'done' mode",
            );
          E.done(T, m);
        } else if (A === "done:finally") {
          if (typeof E.done != "function")
            throw new Error(
              "Memoizee error: Retrieved promise does not implement 'done' in 'done:finally' mode",
            );
          if (typeof E.finally != "function")
            throw new Error(
              "Memoizee error: Retrieved promise does not implement 'finally' in 'done:finally' mode",
            );
          (E.done(T), E.finally(m));
        }
      }),
        l.on("get", function (_, p, E) {
          var h;
          if (f[_]) {
            ++f[_];
            return;
          }
          h = u[_];
          var T = function () {
            l.emit("getasync", _, p, E);
          };
          o(h)
            ? typeof h.done == "function"
              ? h.done(T)
              : h.then(function () {
                  s(T);
                })
            : T();
        }),
        l.on("delete", function (_) {
          if ((delete u[_], f[_])) {
            delete f[_];
            return;
          }
          if (hasOwnProperty.call(d, _)) {
            var p = d[_];
            (delete d[_], l.emit("deleteasync", _, [p]));
          }
        }),
        l.on("clear", function () {
          var _ = d;
          ((d = i(null)),
            (f = i(null)),
            (u = i(null)),
            l.emit(
              "clearasync",
              e(_, function (p) {
                return [p];
              }),
            ));
        }));
    }),
    yC
  );
}
var DC = {},
  wC;
function YX() {
  if (wC) return DC;
  wC = 1;
  var e = ir(),
    t = xl(),
    n = ho(),
    r = Function.prototype.apply;
  return (
    (n.dispose = function (o, s, i) {
      var a;
      if ((e(o), (i.async && n.async) || (i.promise && n.promise))) {
        (s.on(
          "deleteasync",
          (a = function (c, l) {
            r.call(o, null, l);
          }),
        ),
          s.on("clearasync", function (c) {
            t(c, function (l, f) {
              a(f, l);
            });
          }));
        return;
      }
      (s.on(
        "delete",
        (a = function (c, l) {
          o(l);
        }),
      ),
        s.on("clear", function (c) {
          t(c, function (l, f) {
            a(f, l);
          });
        }));
    }),
    DC
  );
}
var UC = {},
  B_,
  kC;
function jX() {
  return (kC || ((kC = 1), (B_ = 2147483647)), B_);
}
var H_, GC;
function qX() {
  if (GC) return H_;
  GC = 1;
  var e = Eo(),
    t = jX();
  return (
    (H_ = function (n) {
      if (((n = e(n)), n > t))
        throw new TypeError(n + " exceeds maximum possible timeout");
      return n;
    }),
    H_
  );
}
var VC;
function WX() {
  if (VC) return UC;
  VC = 1;
  var e = fh(),
    t = xl(),
    n = ph(),
    r = SL(),
    o = qX(),
    s = ho(),
    i = Function.prototype,
    a = Math.max,
    c = Math.min,
    l = Object.create;
  return (
    (s.maxAge = function (f, d, u) {
      var _, p, E, h;
      ((f = o(f)),
        f &&
          ((_ = l(null)),
          (p = (u.async && s.async) || (u.promise && s.promise) ? "async" : ""),
          d.on("set" + p, function (T) {
            ((_[T] = setTimeout(function () {
              d.delete(T);
            }, f)),
              typeof _[T].unref == "function" && _[T].unref(),
              h &&
                (h[T] && h[T] !== "nextTick" && clearTimeout(h[T]),
                (h[T] = setTimeout(function () {
                  delete h[T];
                }, E)),
                typeof h[T].unref == "function" && h[T].unref()));
          }),
          d.on("delete" + p, function (T) {
            (clearTimeout(_[T]),
              delete _[T],
              h && (h[T] !== "nextTick" && clearTimeout(h[T]), delete h[T]));
          }),
          u.preFetch &&
            (u.preFetch === !0 || isNaN(u.preFetch)
              ? (E = 0.333)
              : (E = a(c(Number(u.preFetch), 1), 0)),
            E &&
              ((h = {}),
              (E = (1 - E) * f),
              d.on("get" + p, function (T, m, A) {
                h[T] ||
                  ((h[T] = "nextTick"),
                  n(function () {
                    var g;
                    h[T] === "nextTick" &&
                      (delete h[T],
                      d.delete(T),
                      u.async && ((m = e(m)), m.push(i)),
                      (g = d.memoized.apply(A, m)),
                      u.promise &&
                        r(g) &&
                        (typeof g.done == "function"
                          ? g.done(i, i)
                          : g.then(i, i)));
                  }));
              }))),
          d.on("clear" + p, function () {
            (t(_, function (T) {
              clearTimeout(T);
            }),
              (_ = {}),
              h &&
                (t(h, function (T) {
                  T !== "nextTick" && clearTimeout(T);
                }),
                (h = {})));
          })));
    }),
    UC
  );
}
var xC = {},
  F_,
  $C;
function KX() {
  if ($C) return F_;
  $C = 1;
  var e = Eo(),
    t = Object.create,
    n = Object.prototype.hasOwnProperty;
  return (
    (F_ = function (r) {
      var o = 0,
        s = 1,
        i = t(null),
        a = t(null),
        c = 0,
        l;
      return (
        (r = e(r)),
        {
          hit: function (f) {
            var d = a[f],
              u = ++c;
            if (((i[u] = f), (a[f] = u), !d))
              return (++o, o <= r ? void 0 : ((f = i[s]), l(f), f));
            if ((delete i[d], s === d)) for (; !n.call(i, ++s); );
          },
          delete: (l = function (f) {
            var d = a[f];
            if (d && (delete i[d], delete a[f], --o, s === d)) {
              if (!o) {
                ((c = 0), (s = 1));
                return;
              }
              for (; !n.call(i, ++s); );
            }
          }),
          clear: function () {
            ((o = 0), (s = 1), (i = t(null)), (a = t(null)), (c = 0));
          },
        }
      );
    }),
    F_
  );
}
var BC;
function zX() {
  if (BC) return xC;
  BC = 1;
  var e = Eo(),
    t = KX(),
    n = ho();
  return (
    (n.max = function (r, o, s) {
      var i, a, c;
      ((r = e(r)),
        r &&
          ((a = t(r)),
          (i = (s.async && n.async) || (s.promise && n.promise) ? "async" : ""),
          o.on(
            "set" + i,
            (c = function (l) {
              ((l = a.hit(l)), l !== void 0 && o.delete(l));
            }),
          ),
          o.on("get" + i, c),
          o.on("delete" + i, a.delete),
          o.on("clear" + i, a.clear)));
    }),
    xC
  );
}
var HC = {},
  FC;
function ZX() {
  if (FC) return HC;
  FC = 1;
  var e = To(),
    t = ho(),
    n = Object.create,
    r = Object.defineProperties;
  return (
    (t.refCounter = function (o, s, i) {
      var a, c;
      ((a = n(null)),
        (c = (i.async && t.async) || (i.promise && t.promise) ? "async" : ""),
        s.on("set" + c, function (l, f) {
          a[l] = f || 1;
        }),
        s.on("get" + c, function (l) {
          ++a[l];
        }),
        s.on("delete" + c, function (l) {
          delete a[l];
        }),
        s.on("clear" + c, function () {
          a = {};
        }),
        r(s.memoized, {
          deleteRef: e(function () {
            var l = s.get(arguments);
            return l === null || !a[l] ? null : --a[l] ? !1 : (s.delete(l), !0);
          }),
          getRefCount: e(function () {
            var l = s.get(arguments);
            return l === null || !a[l] ? 0 : a[l];
          }),
        }));
    }),
    HC
  );
}
var Y_, YC;
function XX() {
  if (YC) return Y_;
  YC = 1;
  var e = uL(),
    t = lL(),
    n = IX();
  return (
    (Y_ = function (r) {
      var o = e(arguments[1]),
        s;
      return (
        o.normalizer ||
          ((s = o.length = t(o.length, r.length, o.async)),
          s !== 0 &&
            (o.primitive
              ? s === !1
                ? (o.normalizer = PX())
                : s > 1 && (o.normalizer = MX()(s))
              : s === !1
                ? (o.normalizer = wX()())
                : s === 1
                  ? (o.normalizer = UX()())
                  : (o.normalizer = kX()(s)))),
        o.async && GX(),
        o.promise && FX(),
        o.dispose && YX(),
        o.maxAge && WX(),
        o.max && zX(),
        o.refCounter && ZX(),
        n(r, o)
      );
    }),
    Y_
  );
}
var QX = XX();
const lc = Qu(QX);
class JX {
  constructor(t) {
    ((this.i = 0),
      (this.string = t),
      (this.whitespace = ` 	\r
`),
      (this.quotes = `'"`),
      (this.escapes = "\\"),
      (this.escapedQuotes = '"'),
      (this.ansiCQuotes = !0),
      (this.localeQuotes = !0),
      (this.debug = !1));
  }
  readChar() {
    return this.string.charAt(this.i++);
  }
  processEscapes(t, n, r) {
    if (!r && !this.escapedQuotes.includes(n)) return t;
    const o = "[" + this.escapes.replace(/(.)/g, "\\$1") + "]";
    if (!r && this.escapedQuotes.includes(n)) {
      const s = new RegExp(o + "(" + o + "|\\" + n + ")", "g");
      return t.replace(s, "$1");
    }
    if (r) {
      const s = {
          "([\\\\'\"?])": (a) => a,
          a: () => "\x07",
          b: () => "\b",
          "e|E": () => "\x1B",
          f: () => "\f",
          n: () => `
`,
          r: () => "\r",
          t: () => "	",
          v: () => "\v",
          "([0-7]{1,3})": (a) => String.fromCharCode(parseInt(a, 8)),
          "x([0-9a-fA-F]{1,2})": (a) => String.fromCharCode(parseInt(a, 16)),
          "u([0-9a-fA-F]{1,4})": (a) => String.fromCharCode(parseInt(a, 16)),
          "U([0-9a-fA-F]{1,8})": (a) => String.fromCharCode(parseInt(a, 16)),
          "c(.)": (a) =>
            a === "?"
              ? ""
              : a === "@"
                ? "\0"
                : String.fromCharCode(a.charCodeAt(0) & 31),
        },
        i = new RegExp(o + "(" + Object.keys(s).join("|") + ")", "g");
      return t.replace(i, function (a, c) {
        for (const l in s) {
          const f = new RegExp("^" + l + "$").exec(c);
          if (f !== null) return s[l].apply(null, f.slice(1));
        }
      });
    }
  }
  *[Symbol.iterator]() {
    let t = !1,
      n = !1,
      r = !1,
      o = -2,
      s;
    for (
      this.debug && console.log("full input:", ">" + this.string + "<");
      ;
    ) {
      const i = this.i,
        a = this.readChar();
      if (
        (this.debug &&
          console.log(
            "position:",
            i,
            "input:",
            ">" + a + "<",
            "accumulated:",
            s,
            "inQuote:",
            t,
            "inDollarQuote:",
            n,
            "lastDollar:",
            o,
            "escaped:",
            r,
          ),
        a === "")
      ) {
        if (t) throw new Error("Got EOF while in a quoted string");
        if (r) throw new Error("Got EOF while in an escape sequence");
        s !== void 0 && (yield s);
        return;
      }
      if (r) {
        (a ===
          `
` || (t ? (s = (s || "") + r + a) : (s = (s || "") + a)),
          (r = !1));
        continue;
      }
      if (
        this.escapes.includes(a) &&
        (!t || n !== !1 || this.escapedQuotes.includes(t))
      ) {
        r = a;
        continue;
      }
      if (t !== !1) {
        if (a === t) {
          ((s = this.processEscapes(s, t, n === "'")), (t = !1), (n = !1));
          continue;
        }
        s = (s || "") + a;
        continue;
      }
      if (this.quotes.includes(a)) {
        ((t = a),
          o === i - 1 &&
            ((a === "'" && !this.ansiCQuotes) ||
              (a === '"' && !this.localeQuotes) ||
              (n = a)),
          (s = s || ""),
          n !== !1 && (s = s.slice(0, -1)));
        continue;
      }
      if ((t === !1 && a === "$" && (o = i), this.whitespace.includes(a))) {
        (s !== void 0 && (yield s), (s = void 0));
        continue;
      }
      s = (s || "") + a;
    }
  }
}
function eQ(e) {
  return Array.from(new JX(e));
}
function It(e) {
  return e === ""
    ? "''"
    : /[^\w@%\-+=:,./]/.test(e)
      ? ("'" + e.replace(/('+)/g, `'"$1"'`) + "'").replace(/^''|''$/g, "")
      : e;
}
function tQ(e) {
  if (!Array.isArray(e)) throw new TypeError("args should be an array");
  return e.map(It).join(" ");
}
function nQ(e) {
  if (!e.startsWith("["))
    return {
      loggerName: null,
      message: e,
    };
  const t = e.indexOf("]");
  if (t === -1)
    return {
      loggerName: null,
      message: e,
    };
  if (e[t + 1] !== " ")
    return {
      loggerName: null,
      message: e,
    };
  const n = e.slice(1, t).trim();
  if (!n)
    return {
      loggerName: null,
      message: e,
    };
  const r = e.slice(t + 2);
  return {
    loggerName: n,
    message: r,
  };
}
class mL {
  buffer = [];
  maxBufferSize = 500;
  hasLoggedDroppedLogMessage = !1;
  push(t) {
    if (this.buffer.length >= this.maxBufferSize) {
      this.hasLoggedDroppedLogMessage ||
        ((this.hasLoggedDroppedLogMessage = !0),
        this.buffer.push({
          level: "warning",
          message:
            "Dropped buffered log message after maxBufferSize was reached",
          args: [],
        }));
      return;
    }
    this.buffer.push(t);
  }
  createLogMethod(t) {
    return (n, ...r) => {
      this.push({
        level: t,
        message: n,
        args: r,
      });
    };
  }
  trace = this.createLogMethod("trace");
  debug = this.createLogMethod("debug");
  info = this.createLogMethod("info");
  warning = this.createLogMethod("warning");
  error = this.createLogMethod("error");
  log = (t, n, ...r) => {
    this.push({
      level: t,
      message: n,
      args: r,
    });
  };
  flushTo(t) {
    for (const n of this.buffer) t.log(n.level, n.message, ...n.args);
    this.buffer.length = 0;
  }
  dispose() {
    this.buffer = [];
  }
}
let nu = new mL(),
  jC = !1;
function rQ(e) {
  if (jC && process.env.NODE_ENV !== "test")
    throw new Error("Logger already set");
  ((jC = !0), nu instanceof mL && nu.flushTo(e), (nu = e));
}
function dc() {
  return nu;
}
function Bl(e) {
  const t = `[${e}] `,
    n = (o, s, ...i) => {
      dc().log(o, `${t}${s}`, ...i);
    },
    r =
      (o) =>
      (s, ...i) => {
        n(o, s, ...i);
      };
  return {
    trace: r("trace"),
    debug: r("debug"),
    info: r("info"),
    warning: r("warning"),
    error: r("error"),
    log: (o, s, ...i) => {
      n(o, s, ...i);
    },
    dispose: () => {
      dc().dispose();
    },
  };
}
function xt(e) {
  let t = null;
  return () => (t || (t = Bl(e)), t);
}
function AL(e) {
  const t = Date.now(),
    n = Bl(e),
    r = (o, ...s) => [`[${((Date.now() - t) / 1e3).toFixed(3)}] ${o}`, ...s];
  return {
    trace: (o, ...s) => {
      n.trace(...r(o, ...s));
    },
    debug: (o, ...s) => {
      n.debug(...r(o, ...s));
    },
    info: (o, ...s) => {
      n.info(...r(o, ...s));
    },
    warning: (o, ...s) => {
      n.warning(...r(o, ...s));
    },
    error: (o, ...s) => {
      n.error(...r(o, ...s));
    },
    log: (o, s, ...i) => {
      n.log(o, ...r(s, ...i));
    },
    dispose: () => {
      n.dispose();
    },
  };
}
var Mn = {},
  qC;
function oQ() {
  if (qC) return Mn;
  qC = 1;
  var e =
    (Mn && Mn.__importDefault) ||
    function (d) {
      return d && d.__esModule
        ? d
        : {
            default: d,
          };
    };
  (Object.defineProperty(Mn, "__esModule", {
    value: !0,
  }),
    (Mn.RateLimit = Mn.Sema = void 0));
  const t = e(events);
  function n(d, u, _, p, E) {
    for (let h = 0; h < E; ++h) ((_[h + p] = d[h + u]), (d[h + u] = void 0));
  }
  function r(d) {
    return (
      (d = d >>> 0),
      (d = d - 1),
      (d = d | (d >> 1)),
      (d = d | (d >> 2)),
      (d = d | (d >> 4)),
      (d = d | (d >> 8)),
      (d = d | (d >> 16)),
      d + 1
    );
  }
  function o(d) {
    return r(Math.min(Math.max(16, d), 1073741824));
  }
  class s {
    constructor(u) {
      ((this._capacity = o(u)),
        (this._length = 0),
        (this._front = 0),
        (this.arr = []));
    }
    push(u) {
      const _ = this._length;
      this.checkCapacity(_ + 1);
      const p = (this._front + _) & (this._capacity - 1);
      return ((this.arr[p] = u), (this._length = _ + 1), _ + 1);
    }
    pop() {
      const u = this._length;
      if (u === 0) return;
      const _ = (this._front + u - 1) & (this._capacity - 1),
        p = this.arr[_];
      return ((this.arr[_] = void 0), (this._length = u - 1), p);
    }
    shift() {
      const u = this._length;
      if (u === 0) return;
      const _ = this._front,
        p = this.arr[_];
      return (
        (this.arr[_] = void 0),
        (this._front = (_ + 1) & (this._capacity - 1)),
        (this._length = u - 1),
        p
      );
    }
    get length() {
      return this._length;
    }
    checkCapacity(u) {
      this._capacity < u && this.resizeTo(o(this._capacity * 1.5 + 16));
    }
    resizeTo(u) {
      const _ = this._capacity;
      this._capacity = u;
      const p = this._front,
        E = this._length;
      if (p + E > _) {
        const h = (p + E) & (_ - 1);
        n(this.arr, 0, this.arr, _, h);
      }
    }
  }
  class i extends t.default {}
  function a(d) {
    return typeof d == "function";
  }
  function c() {
    return "1";
  }
  class l {
    constructor(
      u,
      { initFn: _ = c, pauseFn: p, resumeFn: E, capacity: h = 10 } = {},
    ) {
      if (a(p) !== a(E))
        throw new Error("pauseFn and resumeFn must be both set for pausing");
      ((this.nrTokens = u),
        (this.free = new s(u)),
        (this.waiting = new s(h)),
        (this.releaseEmitter = new i()),
        (this.noTokens = _ === c),
        (this.pauseFn = p),
        (this.resumeFn = E),
        (this.paused = !1),
        this.releaseEmitter.on("release", (T) => {
          const m = this.waiting.shift();
          m
            ? m.resolve(T)
            : (this.resumeFn &&
                this.paused &&
                ((this.paused = !1), this.resumeFn()),
              this.free.push(T));
        }));
      for (let T = 0; T < u; T++) this.free.push(_());
    }
    tryAcquire() {
      return this.free.pop();
    }
    async acquire() {
      let u = this.tryAcquire();
      return u !== void 0
        ? u
        : new Promise((_, p) => {
            (this.pauseFn &&
              !this.paused &&
              ((this.paused = !0), this.pauseFn()),
              this.waiting.push({
                resolve: _,
                reject: p,
              }));
          });
    }
    release(u) {
      this.releaseEmitter.emit("release", this.noTokens ? "1" : u);
    }
    drain() {
      const u = new Array(this.nrTokens);
      for (let _ = 0; _ < this.nrTokens; _++) u[_] = this.acquire();
      return Promise.all(u);
    }
    nrWaiting() {
      return this.waiting.length;
    }
  }
  Mn.Sema = l;
  function f(d, { timeUnit: u = 1e3, uniformDistribution: _ = !1 } = {}) {
    const p = new l(_ ? 1 : d),
      E = _ ? u / d : u;
    return async function () {
      (await p.acquire(), setTimeout(() => p.release(), E));
    };
  }
  return ((Mn.RateLimit = f), Mn);
}
var gL = oQ();
class RL {
  constructor(t, n = [], r = [], o) {
    ((this.child = t),
      (this.stdoutChunks = n),
      (this.stderrChunks = r),
      (this.promise = o.then(
        ({ code: s, signal: i }) => ({
          type: "resolve",
          code: s,
          signal: i,
        }),
        (s) => ({
          type: "reject",
          error: s,
        }),
      )));
  }
  result = null;
  promise;
  check() {
    return this.wait().then(({ stdout: t, stderr: n, code: r, signal: o }) => {
      if (r === 0)
        return {
          stdout: t,
          stderr: n,
        };
      throw new Error(`process exited with code ${r}, signal ${o}`);
    });
  }
  wait() {
    return this.promise.then((t) => {
      switch (t.type) {
        case "resolve": {
          const { code: n, signal: r } = t;
          return {
            stdout: Buffer.concat(this.stdoutChunks).toString("utf8"),
            stderr: Buffer.concat(this.stderrChunks).toString("utf8"),
            code: n,
            signal: r,
          };
        }
        case "reject":
          throw t.error;
      }
    });
  }
  getStdout() {
    return Buffer.concat(this.stdoutChunks);
  }
  getStderr() {
    return Buffer.concat(this.stderrChunks);
  }
  getExitCode() {
    return this.result?.type === "resolve" ? this.result.code : null;
  }
  isDone() {
    return this.result != null;
  }
  kill() {
    this.child.kill();
  }
}
const sQ = {
  startSpan: (e, t) => t(),
};
let NL = sQ;
function iQ(e) {
  NL = e;
}
function aQ() {
  return NL;
}
function Eh(e, t) {
  return aQ().startSpan(e, t);
}
let $u;
function cQ(e) {
  if ($u) throw new Error("shouldSpawnInsideWsl already set");
  $u = e;
}
function uQ() {
  if (!$u) {
    if (process.env.NODE_ENV === "test" || process.env.VITEST != null)
      return !1;
    throw new Error("shouldSpawnInsideWsl not set");
  }
  return $u();
}
function lQ() {
  const e = dc(),
    t = dQ(e);
  if (!t) return;
  if (pQ(t)) return Vp(t);
  if (_Q(t)) return Vp(EQ(t));
  const n = fQ(t, e);
  if (n) return n;
  e.warning(
    `[resolveCodexHomeFromWsl] Unable to translate Linux path (${ot(t)}) to a Windows path`,
  );
}
function dQ(e) {
  return yL(
    ["/usr/bin/env", "bash", "-lc", 'printf %s "${CODEX_HOME:-$HOME/.codex}"'],
    "readCodexHomePathFromWslEnv",
    e,
  );
}
function fQ(e, t) {
  const n = yL(
    ["wslpath", "-w", e],
    `resolveCodexHomeFromWsl:wslpath(${e})`,
    t,
  );
  return n ? Vp(n) : void 0;
}
function yL(e, t, n) {
  try {
    const r = childProcess.spawnSync("wsl.exe", e, {
      encoding: "utf8",
      windowsHide: !0,
    });
    if (r.error) {
      n.debug(`[${t}] command error (${ot(r.error)})`);
      return;
    }
    if (r.status !== 0) {
      n.debug(
        `[${t}] non-zero exit (${ot(r.status)}): ${ot(r.stderr?.toString() ?? "")}`,
      );
      return;
    }
    const o = r.stdout?.toString().trim();
    if (!o) {
      n.warning(`[${t}] command returned empty output`);
      return;
    }
    return o;
  } catch (r) {
    n.warning(`[${t}] unexpected error (${ot(r)})`);
    return;
  }
}
function Vp(e) {
  return e.replace(/\//g, "\\");
}
function _Q(e) {
  return /^\/mnt\/[a-zA-Z]\//.test(e) ? !0 : /^\\{1,2}mnt\\[a-zA-Z]\\/.test(e);
}
function pQ(e) {
  return !!(/^[a-zA-Z]:[\\/]/.test(e) || /^\\\\/.test(e));
}
function EQ(e) {
  const t = e.match(/^\/mnt\/([a-zA-Z])\/(.*)$/);
  if (t) {
    const o = t[1].toUpperCase(),
      s = t[2].replace(/\//g, "\\");
    return `${o}:\\${s}`;
  }
  const n = e.match(/^\\{1,2}[Mm][Nn][Tt]\\([a-zA-Z])\\(.*)$/i);
  if (n) {
    const o = n[1].toUpperCase(),
      s = n[2].replace(/[\\/]/g, "\\");
    return `${o}:\\${s}`;
  }
  const r = e.match(/^C:\\mnt\\c(.*)$/i);
  return r
    ? `C:\\${r[1].replace(/^([\\/])+/, "").replace(/[\\/]/g, "\\")}`
    : e.replace(/\//g, "\\");
}
function OL(e) {
  if (/^(\\\\|\/\/)(wsl\$|wsl\.localhost)/i.test(e)) {
    const r = e
      .replace(/^((\\\\|\/\/)(wsl\$|wsl\.localhost)[\\/]+)/i, "")
      .split(/[\\/]/);
    r.shift();
    const o = r.join("/").replace(/\\/g, "/");
    return o.length === 0 ? "/" : o.startsWith("/") ? o : `/${o}`;
  }
  if (e.startsWith("/")) return e;
  const t = e.match(/^([a-zA-Z]):[\\/](.*)$/);
  if (t) {
    const n = t[1].toLowerCase(),
      r = t[2].replace(/\\/g, "/");
    return `/mnt/${n}/${r}`;
  }
  return e.replace(/\\/g, "/");
}
const CL = xt("spawn-async");
function bL(e) {
  const t = e[0] ?? "process";
  return t === "git" && e[1]
    ? {
        op: "git.exec",
        name: `git ${e[1]}`,
      }
    : {
        op: "process.exec",
        name: t,
      };
}
function IL({
  args: e,
  cwd: t,
  env: n,
  signal: r,
  stdoutChunkHandler: o,
  stderrChunkHandler: s,
  onExitHandler: i,
}) {
  if (uQ())
    return (
      CL().info("Spawning process inside WSL"),
      hQ(e, t, n ? TQ(n) : void 0, r, o, s)
    );
  const a = e[0],
    c = e.slice(1),
    l = {
      cwd: t,
      env: {
        ...process.env,
        ...n,
      },
      stdio: ["ignore", "pipe", "pipe"],
    },
    f = childProcess.spawn(a, c, l),
    d = [],
    u = [],
    _ = new Promise((E, h) => {
      const T = PL(f, r);
      (f.stdout?.on("data", (m) => {
        (d.push(m), o?.(m));
      }),
        f.stderr?.on("data", (m) => {
          (u.push(m), s?.(m));
        }),
        f.on("close", (m, A) => {
          (i?.(),
            T?.(),
            E({
              code: m,
              signal: A,
            }));
        }),
        f.on("error", (m) => {
          (i?.(), T?.(), h(m));
        }));
    }),
    p = bL(e);
  return new RL(
    f,
    d,
    u,
    Eh(p, () => _),
  );
}
function hQ(e, t, n, r, o, s) {
  const i = t ? OL(t) : ".",
    a = ["RUST_LOG=warn"];
  n && a.push(...SQ(n));
  const c = ["-d", "Ubuntu"];
  (c.push("--cd", i), c.push("--exec", "/usr/bin/env", ...a, ...e));
  const l = {
    env: {
      ...process.env,
    },
    stdio: ["ignore", "pipe", "pipe"],
  };
  CL().debug("Spawning process inside WSL: wsl.exe %s", c.join(" "));
  const f = childProcess.spawn("wsl.exe", c, l),
    d = [],
    u = [],
    _ = new Promise((E, h) => {
      const T = PL(f, r);
      (f.stdout?.on("data", (m) => {
        (d.push(m), o?.(m));
      }),
        f.stderr?.on("data", (m) => {
          (u.push(m), s?.(m));
        }),
        f.on("close", (m, A) => {
          (T?.(),
            E({
              code: m,
              signal: A,
            }));
        }),
        f.on("error", (m) => {
          (T?.(), h(m));
        }));
    }),
    p = bL(e);
  return new RL(
    f,
    d,
    u,
    Eh(p, () => _),
  );
}
function PL(e, t) {
  if (!t) return;
  const n = () => {
    e.kill();
  };
  return (
    t.addEventListener("abort", n),
    t.aborted && n(),
    () => {
      t.removeEventListener("abort", n);
    }
  );
}
function TQ(e) {
  const t = {};
  for (const [n, r] of Object.entries(e))
    r != null && process.env[n] !== r && (t[n] = r);
  return t;
}
function SQ(e) {
  const t = [];
  for (const [n, r] of Object.entries(e)) {
    const o = mQ(r) ? OL(r) : r;
    t.push(`${n}=${o}`);
  }
  return t;
}
function mQ(e) {
  return e.includes(";")
    ? !1
    : !!(
        /^(?:[a-zA-Z]:[\\/]|\\\\|\/\/)/.test(e) ||
        /^(\\\\|\/\/)(wsl\$|wsl\.localhost)[\\/]/i.test(e)
      );
}
const AQ = 4,
  gQ = 1e3,
  j_ = new Map(),
  q_ = xt("spawn-remote-async");
function RQ(e) {
  return (j_.has(e) || j_.set(e, new gL.Sema(AQ)), j_.get(e));
}
class NQ {
  constructor(t, n) {
    ((this.semaphore = t), (this.timeout = n));
  }
  releaseTimeout = null;
  released = !1;
  async acquire() {
    (await this.semaphore.acquire(),
      (this.releaseTimeout = setTimeout(() => {
        this.release();
      }, this.timeout)));
  }
  release() {
    this.released ||
      ((this.released = !0),
      this.releaseTimeout && clearTimeout(this.releaseTimeout),
      this.semaphore.release());
  }
}
async function ar({
  hostConfig: e,
  args: t,
  env: n,
  signal: r,
  timeoutMs: o,
  noConcurrencyLimit: s,
  stdoutChunkHandler: i,
  stderrChunkHandler: a,
}) {
  const c = n ? Object.entries(n).map(([p, E]) => `${p}=${E}`) : [],
    l = [...e.terminal_command, "--", ...c, ...t];
  let f = null;
  if (!s) {
    const p = RQ(e.id);
    ((f = new NQ(p, gQ)), await f.acquire());
  }
  let d = !1,
    u = null;
  const _ = IL({
    args: l,
    signal: r,
    stdoutChunkHandler: i,
    stderrChunkHandler: a,
    onExitHandler: () => {
      ((d = !0), u && clearTimeout(u), f && f.release());
    },
  });
  return (
    o != null &&
      ((u = setTimeout(() => {
        _.kill();
      }, o)),
      d && u && (clearTimeout(u), (u = null))),
    _
  );
}
async function vn({ hostConfig: e, args: t, errorOnNonZeroExitCode: n = !0 }) {
  const r = crypto.randomUUID().slice(0, 8);
  q_().debug(`[${r}] Spawning process with args: ${t.join(" ")}`);
  const o = await ar({
      hostConfig: e,
      args: t,
    }),
    { stdout: s, stderr: i, code: a } = await o.wait();
  if (a !== 0) {
    if ((q_().debug(`[${r}] Process errored with code ${a} stderr=${i}`), n))
      throw new Error(`Process errored with code ${a} stderr=${i}`);
  } else q_().debug(`[${r}] Process exited successfully with code ${a}`);
  return {
    stdout: s,
    stderr: i,
    code: a,
  };
}
const yQ = 6e4,
  OQ = 60 * yQ,
  hh = 24 * OQ;
function CQ(e) {
  const { preferWsl: t = !1 } = e,
    n = dc();
  if (t && process.platform === "win32") {
    const r = lQ();
    if (r) return r;
    n.info(
      "[resolveCodexHome] Falling back to host home directory because WSL CODEX_HOME could not be resolved",
    );
  }
  return process.env.CODEX_HOME ?? Fb.join(Dt.homedir(), ".codex");
}
const bQ = lc(
  async (e) => {
    const t = typeof e == "string" ? PQ(e) : e;
    return IQ(t);
  },
  {
    length: 1,
    normalizer: ([e]) => (typeof e == "string" ? e : e.id),
    promise: !0,
    maxAge: hh,
  },
);
async function IQ(e) {
  const t = dc(),
    r = [
      "sh",
      "-lc",
      It(
        'if [ -n "$CODEX_HOME" ]; then printf "%s" "$CODEX_HOME"; else printf "%s" "$HOME/.codex"; fi',
      ),
    ];
  let o,
    s = !1;
  const i = setTimeout(() => {
    ((s = !0), o?.kill());
  }, 1e4);
  try {
    o = await ar({
      hostConfig: e,
      args: r,
    });
    const { stdout: a, stderr: c, code: l } = await o.wait();
    if ((clearTimeout(i), s))
      throw (
        t.warning("[resolveRemoteSshCodexHome] timed out"),
        new Error("resolveRemoteSshCodexHome timed out")
      );
    if (l !== 0)
      throw new Error(`[resolveRemoteSshCodexHome] failed (${l}): ${c || a}`);
    return a.trim();
  } catch (a) {
    throw (
      clearTimeout(i),
      t.warning(`[resolveRemoteSshCodexHome] error: ${ot(a)}`),
      a
    );
  }
}
function PQ(e) {
  return {
    id: e,
    display_name: e,
    kind: "ssh",
    codex_cli_command: [],
    terminal_command: eQ(e),
  };
}
const cr = {
  async readFile(e, t) {
    if (Ue(t)) {
      const { stdout: n } = await vn({
        hostConfig: t,
        args: ["cat", e],
      });
      return n;
    }
    return fs.promises.readFile(e, "utf-8");
  },
  async readFileBase64(e, t) {
    if (Ue(t)) {
      const { stdout: n } = await vn({
        hostConfig: t,
        args: ["base64", e],
      });
      return Buffer.from(n, "base64");
    }
    return fs.promises.readFile(e, "base64");
  },
  async writeFile(e, t, n) {
    if (Ue(n)) {
      await vn({
        hostConfig: n,
        args: [
          "sh",
          "-c",
          It(`cat > ${e} << "EOF"
${t}
EOF`),
        ],
      });
      return;
    }
    await fs.promises.writeFile(e, t, "utf8");
  },
  async mkdir(e, t = {}, n) {
    if (Ue(n)) {
      const r = ["mkdir"];
      (t.recursive !== !1 && r.push("-p"),
        r.push(e),
        await vn({
          hostConfig: n,
          args: r,
        }));
      return;
    }
    await fs.promises.mkdir(e, {
      recursive: t.recursive ?? !0,
    });
  },
  async stat(e, t) {
    if (!Ue(t)) return fs.promises.stat(e);
    const { stdout: n, code: r } = await vn({
      hostConfig: t,
      args: [
        "sh",
        "-c",
        It(
          'if [ -d "$1" ]; then echo "dir"; elif [ -f "$1" ]; then echo "file"; elif [ -L "$1" ]; then echo "link"; else exit 1; fi',
        ),
        "sh",
        e,
      ],
      errorOnNonZeroExitCode: !1,
    });
    if (r === 1) throw new Error(`File not found: ${e}`);
    const o = n.trim();
    return {
      isDirectory: () => o === "dir",
      isFile: () => o === "file" || o === "link",
    };
  },
  async readdir(e, t) {
    if (Ue(t)) {
      const { stdout: n } = await vn({
        hostConfig: t,
        args: ["sh", "-c", It('ls -A "$1"'), "sh", e],
      });
      return n
        .split(/\r?\n/)
        .map((r) => r.trim())
        .filter((r) => r.length > 0);
    }
    return fs.promises.readdir(e);
  },
  async rm(e, t = {}, n) {
    if (Ue(n)) {
      const r = ["rm"];
      (t.recursive !== !1 && r.push("-r"),
        t.force !== !1 && r.push("-f"),
        r.push(e),
        await vn({
          hostConfig: n,
          args: r,
        }));
      return;
    }
    await fs.promises.rm(e, {
      recursive: t.recursive ?? !0,
      force: t.force ?? !0,
    });
  },
  async copyFile(e, t, n) {
    if (Ue(n)) {
      await vn({
        hostConfig: n,
        args: ["cp", e, t],
      });
      return;
    }
    await fs.promises.copyFile(e, t);
  },
  async cp(e, t, n = {}, r) {
    if (Ue(r)) {
      const o = ["cp"];
      (n.recursive && o.push("-R"),
        o.push(e, t),
        await vn({
          hostConfig: r,
          args: o,
        }));
      return;
    }
    await fs.promises.cp(e, t, {
      recursive: n.recursive ?? !1,
    });
  },
};
function ln(e) {
  return Ue(e) ? path2.posix : path2;
}
class MQ {
  handlers = new Set();
  subscribe(t) {
    return (
      this.handlers.add(t),
      {
        dispose: () => {
          this.handlers.delete(t);
        },
      }
    );
  }
  emit(t, n = Date.now()) {
    for (const r of this.handlers)
      r({
        type: t,
        at: n,
      });
  }
}
const vQ = ["IN_PROGRESS", "PENDING_REVIEW"],
  LQ = ["IN_PROGRESS", "PENDING_REVIEW", "ACCEPTED", "ARCHIVED"],
  ML = (e) => `(${e.map((t) => `'${t}'`).join(", ")})`;
ML(vQ);
ML(LQ);
var xp = ["MO", "TU", "WE", "TH", "FR", "SA", "SU"],
  gt = (function () {
    function e(t, n) {
      if (n === 0) throw new Error("Can't create weekday with n == 0");
      ((this.weekday = t), (this.n = n));
    }
    return (
      (e.fromStr = function (t) {
        return new e(xp.indexOf(t));
      }),
      (e.prototype.nth = function (t) {
        return this.n === t ? this : new e(this.weekday, t);
      }),
      (e.prototype.equals = function (t) {
        return this.weekday === t.weekday && this.n === t.n;
      }),
      (e.prototype.toString = function () {
        var t = xp[this.weekday];
        return (
          this.n && (t = (this.n > 0 ? "+" : "") + String(this.n) + t),
          t
        );
      }),
      (e.prototype.getJsWeekday = function () {
        return this.weekday === 6 ? 0 : this.weekday + 1;
      }),
      e
    );
  })(),
  ze = function (e) {
    return e != null;
  },
  pn = function (e) {
    return typeof e == "number";
  },
  WC = function (e) {
    return typeof e == "string" && xp.includes(e);
  },
  kt = Array.isArray,
  yn = function (e, t) {
    (t === void 0 && (t = e), arguments.length === 1 && ((t = e), (e = 0)));
    for (var n = [], r = e; r < t; r++) n.push(r);
    return n;
  },
  Ce = function (e, t) {
    var n = 0,
      r = [];
    if (kt(e)) for (; n < t; n++) r[n] = [].concat(e);
    else for (; n < t; n++) r[n] = e;
    return r;
  },
  DQ = function (e) {
    return kt(e) ? e : [e];
  };
function mo(e, t, n) {
  n === void 0 && (n = " ");
  var r = String(e);
  return (
    (t = t >> 0),
    r.length > t
      ? String(r)
      : ((t = t - r.length),
        t > n.length && (n += Ce(n, t / n.length)),
        n.slice(0, t) + String(r))
  );
}
var wQ = function (e, t, n) {
    var r = e.split(t);
    return n ? r.slice(0, n).concat([r.slice(n).join(t)]) : r;
  },
  Ht = function (e, t) {
    var n = e % t;
    return n * t < 0 ? n + t : n;
  },
  W_ = function (e, t) {
    return {
      div: Math.floor(e / t),
      mod: Ht(e, t),
    };
  },
  Tn = function (e) {
    return !ze(e) || e.length === 0;
  },
  rt = function (e) {
    return !Tn(e);
  },
  we = function (e, t) {
    return rt(e) && e.indexOf(t) !== -1;
  },
  io = function (e, t, n, r, o, s) {
    return (
      r === void 0 && (r = 0),
      o === void 0 && (o = 0),
      s === void 0 && (s = 0),
      new Date(Date.UTC(e, t - 1, n, r, o, s))
    );
  },
  UQ = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
  vL = 1e3 * 60 * 60 * 24,
  LL = 9999,
  DL = io(1970, 1, 1),
  kQ = [6, 0, 1, 2, 3, 4, 5],
  Za = function (e) {
    return (e % 4 === 0 && e % 100 !== 0) || e % 400 === 0;
  },
  wL = function (e) {
    return e instanceof Date;
  },
  ja = function (e) {
    return wL(e) && !isNaN(e.getTime());
  },
  GQ = function (e, t) {
    var n = e.getTime(),
      r = t.getTime(),
      o = n - r;
    return Math.round(o / vL);
  },
  $p = function (e) {
    return GQ(e, DL);
  },
  UL = function (e) {
    return new Date(DL.getTime() + e * vL);
  },
  VQ = function (e) {
    var t = e.getUTCMonth();
    return t === 1 && Za(e.getUTCFullYear()) ? 29 : UQ[t];
  },
  Ho = function (e) {
    return kQ[e.getUTCDay()];
  },
  KC = function (e, t) {
    var n = io(e, t + 1, 1);
    return [Ho(n), VQ(n)];
  },
  kL = function (e, t) {
    return (
      (t = t || e),
      new Date(
        Date.UTC(
          e.getUTCFullYear(),
          e.getUTCMonth(),
          e.getUTCDate(),
          t.getHours(),
          t.getMinutes(),
          t.getSeconds(),
          t.getMilliseconds(),
        ),
      )
    );
  },
  Bp = function (e) {
    var t = new Date(e.getTime());
    return t;
  },
  zC = function (e) {
    for (var t = [], n = 0; n < e.length; n++) t.push(Bp(e[n]));
    return t;
  },
  fc = function (e) {
    e.sort(function (t, n) {
      return t.getTime() - n.getTime();
    });
  },
  Th = function (e, t) {
    t === void 0 && (t = !0);
    var n = new Date(e);
    return [
      mo(n.getUTCFullYear().toString(), 4, "0"),
      mo(n.getUTCMonth() + 1, 2, "0"),
      mo(n.getUTCDate(), 2, "0"),
      "T",
      mo(n.getUTCHours(), 2, "0"),
      mo(n.getUTCMinutes(), 2, "0"),
      mo(n.getUTCSeconds(), 2, "0"),
      t ? "Z" : "",
    ].join("");
  },
  Sh = function (e) {
    var t = /^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z?)?$/,
      n = t.exec(e);
    if (!n) throw new Error("Invalid UNTIL value: ".concat(e));
    return new Date(
      Date.UTC(
        parseInt(n[1], 10),
        parseInt(n[2], 10) - 1,
        parseInt(n[3], 10),
        parseInt(n[5], 10) || 0,
        parseInt(n[6], 10) || 0,
        parseInt(n[7], 10) || 0,
      ),
    );
  },
  ZC = function (e, t) {
    var n = e.toLocaleString("sv-SE", {
      timeZone: t,
    });
    return n.replace(" ", "T") + "Z";
  },
  xQ = function (e, t) {
    var n = Intl.DateTimeFormat().resolvedOptions().timeZone,
      r = new Date(ZC(e, n)),
      o = new Date(ZC(e, t ?? "UTC")),
      s = o.getTime() - r.getTime();
    return new Date(e.getTime() - s);
  },
  Co = (function () {
    function e(t, n) {
      ((this.minDate = null),
        (this.maxDate = null),
        (this._result = []),
        (this.total = 0),
        (this.method = t),
        (this.args = n),
        t === "between"
          ? ((this.maxDate = n.inc
              ? n.before
              : new Date(n.before.getTime() - 1)),
            (this.minDate = n.inc ? n.after : new Date(n.after.getTime() + 1)))
          : t === "before"
            ? (this.maxDate = n.inc ? n.dt : new Date(n.dt.getTime() - 1))
            : t === "after" &&
              (this.minDate = n.inc ? n.dt : new Date(n.dt.getTime() + 1)));
    }
    return (
      (e.prototype.accept = function (t) {
        ++this.total;
        var n = this.minDate && t < this.minDate,
          r = this.maxDate && t > this.maxDate;
        if (this.method === "between") {
          if (n) return !0;
          if (r) return !1;
        } else if (this.method === "before") {
          if (r) return !1;
        } else if (this.method === "after") return n ? !0 : (this.add(t), !1);
        return this.add(t);
      }),
      (e.prototype.add = function (t) {
        return (this._result.push(t), !0);
      }),
      (e.prototype.getValue = function () {
        var t = this._result;
        switch (this.method) {
          case "all":
          case "between":
            return t;
          case "before":
          case "after":
          default:
            return t.length ? t[t.length - 1] : null;
        }
      }),
      (e.prototype.clone = function () {
        return new e(this.method, this.args);
      }),
      e
    );
  })(),
  K_ = {
    exports: {},
  },
  XC;
function $Q() {
  return (
    XC ||
      ((XC = 1),
      (function (e) {
        var t,
          n,
          r,
          o,
          s,
          i,
          a,
          c,
          l,
          f,
          d,
          u,
          _,
          p,
          E,
          h,
          T,
          m,
          A,
          g,
          N,
          O,
          I,
          b,
          w,
          L,
          j,
          H,
          x,
          B,
          F,
          U;
        (function (k) {
          var Y =
            typeof iu == "object"
              ? iu
              : typeof self == "object"
                ? self
                : typeof this == "object"
                  ? this
                  : {};
          k(oe(Y, oe(e.exports)));
          function oe(ae, ne) {
            return (
              ae !== Y &&
                (typeof Object.create == "function"
                  ? Object.defineProperty(ae, "__esModule", {
                      value: !0,
                    })
                  : (ae.__esModule = !0)),
              function (P, M) {
                return (ae[P] = ne ? ne(P, M) : M);
              }
            );
          }
        })(function (k) {
          var Y =
            Object.setPrototypeOf ||
            ({
              __proto__: [],
            } instanceof Array &&
              function (P, M) {
                P.__proto__ = M;
              }) ||
            function (P, M) {
              for (var G in M)
                Object.prototype.hasOwnProperty.call(M, G) && (P[G] = M[G]);
            };
          ((t = function (P, M) {
            if (typeof M != "function" && M !== null)
              throw new TypeError(
                "Class extends value " +
                  String(M) +
                  " is not a constructor or null",
              );
            Y(P, M);
            function G() {
              this.constructor = P;
            }
            P.prototype =
              M === null
                ? Object.create(M)
                : ((G.prototype = M.prototype), new G());
          }),
            (n =
              Object.assign ||
              function (P) {
                for (var M, G = 1, V = arguments.length; G < V; G++) {
                  M = arguments[G];
                  for (var K in M)
                    Object.prototype.hasOwnProperty.call(M, K) && (P[K] = M[K]);
                }
                return P;
              }),
            (r = function (P, M) {
              var G = {};
              for (var V in P)
                Object.prototype.hasOwnProperty.call(P, V) &&
                  M.indexOf(V) < 0 &&
                  (G[V] = P[V]);
              if (
                P != null &&
                typeof Object.getOwnPropertySymbols == "function"
              )
                for (
                  var K = 0, V = Object.getOwnPropertySymbols(P);
                  K < V.length;
                  K++
                )
                  M.indexOf(V[K]) < 0 &&
                    Object.prototype.propertyIsEnumerable.call(P, V[K]) &&
                    (G[V[K]] = P[V[K]]);
              return G;
            }),
            (o = function (P, M, G, V) {
              var K = arguments.length,
                X =
                  K < 3
                    ? M
                    : V === null
                      ? (V = Object.getOwnPropertyDescriptor(M, G))
                      : V,
                v;
              if (
                typeof Reflect == "object" &&
                typeof Reflect.decorate == "function"
              )
                X = Reflect.decorate(P, M, G, V);
              else
                for (var D = P.length - 1; D >= 0; D--)
                  (v = P[D]) &&
                    (X = (K < 3 ? v(X) : K > 3 ? v(M, G, X) : v(M, G)) || X);
              return (K > 3 && X && Object.defineProperty(M, G, X), X);
            }),
            (s = function (P, M) {
              return function (G, V) {
                M(G, V, P);
              };
            }),
            (i = function (P, M, G, V, K, X) {
              function v(De) {
                if (De !== void 0 && typeof De != "function")
                  throw new TypeError("Function expected");
                return De;
              }
              for (
                var D = V.kind,
                  z = D === "getter" ? "get" : D === "setter" ? "set" : "value",
                  q = !M && P ? (V.static ? P : P.prototype) : null,
                  ee =
                    M || (q ? Object.getOwnPropertyDescriptor(q, V.name) : {}),
                  te,
                  _e = !1,
                  se = G.length - 1;
                se >= 0;
                se--
              ) {
                var ue = {};
                for (var Te in V) ue[Te] = Te === "access" ? {} : V[Te];
                for (var Te in V.access) ue.access[Te] = V.access[Te];
                ue.addInitializer = function (De) {
                  if (_e)
                    throw new TypeError(
                      "Cannot add initializers after decoration has completed",
                    );
                  X.push(v(De || null));
                };
                var ve = (0, G[se])(
                  D === "accessor"
                    ? {
                        get: ee.get,
                        set: ee.set,
                      }
                    : ee[z],
                  ue,
                );
                if (D === "accessor") {
                  if (ve === void 0) continue;
                  if (ve === null || typeof ve != "object")
                    throw new TypeError("Object expected");
                  ((te = v(ve.get)) && (ee.get = te),
                    (te = v(ve.set)) && (ee.set = te),
                    (te = v(ve.init)) && K.unshift(te));
                } else
                  (te = v(ve)) &&
                    (D === "field" ? K.unshift(te) : (ee[z] = te));
              }
              (q && Object.defineProperty(q, V.name, ee), (_e = !0));
            }),
            (a = function (P, M, G) {
              for (var V = arguments.length > 2, K = 0; K < M.length; K++)
                G = V ? M[K].call(P, G) : M[K].call(P);
              return V ? G : void 0;
            }),
            (c = function (P) {
              return typeof P == "symbol" ? P : "".concat(P);
            }),
            (l = function (P, M, G) {
              return (
                typeof M == "symbol" &&
                  (M = M.description ? "[".concat(M.description, "]") : ""),
                Object.defineProperty(P, "name", {
                  configurable: !0,
                  value: G ? "".concat(G, " ", M) : M,
                })
              );
            }),
            (f = function (P, M) {
              if (
                typeof Reflect == "object" &&
                typeof Reflect.metadata == "function"
              )
                return Reflect.metadata(P, M);
            }),
            (d = function (P, M, G, V) {
              function K(X) {
                return X instanceof G
                  ? X
                  : new G(function (v) {
                      v(X);
                    });
              }
              return new (G || (G = Promise))(function (X, v) {
                function D(ee) {
                  try {
                    q(V.next(ee));
                  } catch (te) {
                    v(te);
                  }
                }
                function z(ee) {
                  try {
                    q(V.throw(ee));
                  } catch (te) {
                    v(te);
                  }
                }
                function q(ee) {
                  ee.done ? X(ee.value) : K(ee.value).then(D, z);
                }
                q((V = V.apply(P, M || [])).next());
              });
            }),
            (u = function (P, M) {
              var G = {
                  label: 0,
                  sent: function () {
                    if (X[0] & 1) throw X[1];
                    return X[1];
                  },
                  trys: [],
                  ops: [],
                },
                V,
                K,
                X,
                v = Object.create(
                  (typeof Iterator == "function" ? Iterator : Object).prototype,
                );
              return (
                (v.next = D(0)),
                (v.throw = D(1)),
                (v.return = D(2)),
                typeof Symbol == "function" &&
                  (v[Symbol.iterator] = function () {
                    return this;
                  }),
                v
              );
              function D(q) {
                return function (ee) {
                  return z([q, ee]);
                };
              }
              function z(q) {
                if (V) throw new TypeError("Generator is already executing.");
                for (; v && ((v = 0), q[0] && (G = 0)), G; )
                  try {
                    if (
                      ((V = 1),
                      K &&
                        (X =
                          q[0] & 2
                            ? K.return
                            : q[0]
                              ? K.throw || ((X = K.return) && X.call(K), 0)
                              : K.next) &&
                        !(X = X.call(K, q[1])).done)
                    )
                      return X;
                    switch (((K = 0), X && (q = [q[0] & 2, X.value]), q[0])) {
                      case 0:
                      case 1:
                        X = q;
                        break;
                      case 4:
                        return (
                          G.label++,
                          {
                            value: q[1],
                            done: !1,
                          }
                        );
                      case 5:
                        (G.label++, (K = q[1]), (q = [0]));
                        continue;
                      case 7:
                        ((q = G.ops.pop()), G.trys.pop());
                        continue;
                      default:
                        if (
                          ((X = G.trys),
                          !(X = X.length > 0 && X[X.length - 1]) &&
                            (q[0] === 6 || q[0] === 2))
                        ) {
                          G = 0;
                          continue;
                        }
                        if (
                          q[0] === 3 &&
                          (!X || (q[1] > X[0] && q[1] < X[3]))
                        ) {
                          G.label = q[1];
                          break;
                        }
                        if (q[0] === 6 && G.label < X[1]) {
                          ((G.label = X[1]), (X = q));
                          break;
                        }
                        if (X && G.label < X[2]) {
                          ((G.label = X[2]), G.ops.push(q));
                          break;
                        }
                        (X[2] && G.ops.pop(), G.trys.pop());
                        continue;
                    }
                    q = M.call(P, G);
                  } catch (ee) {
                    ((q = [6, ee]), (K = 0));
                  } finally {
                    V = X = 0;
                  }
                if (q[0] & 5) throw q[1];
                return {
                  value: q[0] ? q[1] : void 0,
                  done: !0,
                };
              }
            }),
            (_ = function (P, M) {
              for (var G in P)
                G !== "default" &&
                  !Object.prototype.hasOwnProperty.call(M, G) &&
                  x(M, P, G);
            }),
            (x = Object.create
              ? function (P, M, G, V) {
                  V === void 0 && (V = G);
                  var K = Object.getOwnPropertyDescriptor(M, G);
                  ((!K ||
                    ("get" in K
                      ? !M.__esModule
                      : K.writable || K.configurable)) &&
                    (K = {
                      enumerable: !0,
                      get: function () {
                        return M[G];
                      },
                    }),
                    Object.defineProperty(P, V, K));
                }
              : function (P, M, G, V) {
                  (V === void 0 && (V = G), (P[V] = M[G]));
                }),
            (p = function (P) {
              var M = typeof Symbol == "function" && Symbol.iterator,
                G = M && P[M],
                V = 0;
              if (G) return G.call(P);
              if (P && typeof P.length == "number")
                return {
                  next: function () {
                    return (
                      P && V >= P.length && (P = void 0),
                      {
                        value: P && P[V++],
                        done: !P,
                      }
                    );
                  },
                };
              throw new TypeError(
                M
                  ? "Object is not iterable."
                  : "Symbol.iterator is not defined.",
              );
            }),
            (E = function (P, M) {
              var G = typeof Symbol == "function" && P[Symbol.iterator];
              if (!G) return P;
              var V = G.call(P),
                K,
                X = [],
                v;
              try {
                for (; (M === void 0 || M-- > 0) && !(K = V.next()).done; )
                  X.push(K.value);
              } catch (D) {
                v = {
                  error: D,
                };
              } finally {
                try {
                  K && !K.done && (G = V.return) && G.call(V);
                } finally {
                  if (v) throw v.error;
                }
              }
              return X;
            }),
            (h = function () {
              for (var P = [], M = 0; M < arguments.length; M++)
                P = P.concat(E(arguments[M]));
              return P;
            }),
            (T = function () {
              for (var P = 0, M = 0, G = arguments.length; M < G; M++)
                P += arguments[M].length;
              for (var V = Array(P), K = 0, M = 0; M < G; M++)
                for (var X = arguments[M], v = 0, D = X.length; v < D; v++, K++)
                  V[K] = X[v];
              return V;
            }),
            (m = function (P, M, G) {
              if (G || arguments.length === 2)
                for (var V = 0, K = M.length, X; V < K; V++)
                  (X || !(V in M)) &&
                    (X || (X = Array.prototype.slice.call(M, 0, V)),
                    (X[V] = M[V]));
              return P.concat(X || Array.prototype.slice.call(M));
            }),
            (A = function (P) {
              return this instanceof A ? ((this.v = P), this) : new A(P);
            }),
            (g = function (P, M, G) {
              if (!Symbol.asyncIterator)
                throw new TypeError("Symbol.asyncIterator is not defined.");
              var V = G.apply(P, M || []),
                K,
                X = [];
              return (
                (K = Object.create(
                  (typeof AsyncIterator == "function" ? AsyncIterator : Object)
                    .prototype,
                )),
                D("next"),
                D("throw"),
                D("return", v),
                (K[Symbol.asyncIterator] = function () {
                  return this;
                }),
                K
              );
              function v(se) {
                return function (ue) {
                  return Promise.resolve(ue).then(se, te);
                };
              }
              function D(se, ue) {
                V[se] &&
                  ((K[se] = function (Te) {
                    return new Promise(function (ve, De) {
                      X.push([se, Te, ve, De]) > 1 || z(se, Te);
                    });
                  }),
                  ue && (K[se] = ue(K[se])));
              }
              function z(se, ue) {
                try {
                  q(V[se](ue));
                } catch (Te) {
                  _e(X[0][3], Te);
                }
              }
              function q(se) {
                se.value instanceof A
                  ? Promise.resolve(se.value.v).then(ee, te)
                  : _e(X[0][2], se);
              }
              function ee(se) {
                z("next", se);
              }
              function te(se) {
                z("throw", se);
              }
              function _e(se, ue) {
                (se(ue), X.shift(), X.length && z(X[0][0], X[0][1]));
              }
            }),
            (N = function (P) {
              var M, G;
              return (
                (M = {}),
                V("next"),
                V("throw", function (K) {
                  throw K;
                }),
                V("return"),
                (M[Symbol.iterator] = function () {
                  return this;
                }),
                M
              );
              function V(K, X) {
                M[K] = P[K]
                  ? function (v) {
                      return (G = !G)
                        ? {
                            value: A(P[K](v)),
                            done: !1,
                          }
                        : X
                          ? X(v)
                          : v;
                    }
                  : X;
              }
            }),
            (O = function (P) {
              if (!Symbol.asyncIterator)
                throw new TypeError("Symbol.asyncIterator is not defined.");
              var M = P[Symbol.asyncIterator],
                G;
              return M
                ? M.call(P)
                : ((P = typeof p == "function" ? p(P) : P[Symbol.iterator]()),
                  (G = {}),
                  V("next"),
                  V("throw"),
                  V("return"),
                  (G[Symbol.asyncIterator] = function () {
                    return this;
                  }),
                  G);
              function V(X) {
                G[X] =
                  P[X] &&
                  function (v) {
                    return new Promise(function (D, z) {
                      ((v = P[X](v)), K(D, z, v.done, v.value));
                    });
                  };
              }
              function K(X, v, D, z) {
                Promise.resolve(z).then(function (q) {
                  X({
                    value: q,
                    done: D,
                  });
                }, v);
              }
            }),
            (I = function (P, M) {
              return (
                Object.defineProperty
                  ? Object.defineProperty(P, "raw", {
                      value: M,
                    })
                  : (P.raw = M),
                P
              );
            }));
          var oe = Object.create
              ? function (P, M) {
                  Object.defineProperty(P, "default", {
                    enumerable: !0,
                    value: M,
                  });
                }
              : function (P, M) {
                  P.default = M;
                },
            ae = function (P) {
              return (
                (ae =
                  Object.getOwnPropertyNames ||
                  function (M) {
                    var G = [];
                    for (var V in M)
                      Object.prototype.hasOwnProperty.call(M, V) &&
                        (G[G.length] = V);
                    return G;
                  }),
                ae(P)
              );
            };
          ((b = function (P) {
            if (P && P.__esModule) return P;
            var M = {};
            if (P != null)
              for (var G = ae(P), V = 0; V < G.length; V++)
                G[V] !== "default" && x(M, P, G[V]);
            return (oe(M, P), M);
          }),
            (w = function (P) {
              return P && P.__esModule
                ? P
                : {
                    default: P,
                  };
            }),
            (L = function (P, M, G, V) {
              if (G === "a" && !V)
                throw new TypeError(
                  "Private accessor was defined without a getter",
                );
              if (typeof M == "function" ? P !== M || !V : !M.has(P))
                throw new TypeError(
                  "Cannot read private member from an object whose class did not declare it",
                );
              return G === "m"
                ? V
                : G === "a"
                  ? V.call(P)
                  : V
                    ? V.value
                    : M.get(P);
            }),
            (j = function (P, M, G, V, K) {
              if (V === "m")
                throw new TypeError("Private method is not writable");
              if (V === "a" && !K)
                throw new TypeError(
                  "Private accessor was defined without a setter",
                );
              if (typeof M == "function" ? P !== M || !K : !M.has(P))
                throw new TypeError(
                  "Cannot write private member to an object whose class did not declare it",
                );
              return (
                V === "a" ? K.call(P, G) : K ? (K.value = G) : M.set(P, G),
                G
              );
            }),
            (H = function (P, M) {
              if (
                M === null ||
                (typeof M != "object" && typeof M != "function")
              )
                throw new TypeError("Cannot use 'in' operator on non-object");
              return typeof P == "function" ? M === P : P.has(M);
            }),
            (B = function (P, M, G) {
              if (M != null) {
                if (typeof M != "object" && typeof M != "function")
                  throw new TypeError("Object expected.");
                var V, K;
                if (G) {
                  if (!Symbol.asyncDispose)
                    throw new TypeError("Symbol.asyncDispose is not defined.");
                  V = M[Symbol.asyncDispose];
                }
                if (V === void 0) {
                  if (!Symbol.dispose)
                    throw new TypeError("Symbol.dispose is not defined.");
                  ((V = M[Symbol.dispose]), G && (K = V));
                }
                if (typeof V != "function")
                  throw new TypeError("Object not disposable.");
                (K &&
                  (V = function () {
                    try {
                      K.call(this);
                    } catch (X) {
                      return Promise.reject(X);
                    }
                  }),
                  P.stack.push({
                    value: M,
                    dispose: V,
                    async: G,
                  }));
              } else
                G &&
                  P.stack.push({
                    async: !0,
                  });
              return M;
            }));
          var ne =
            typeof SuppressedError == "function"
              ? SuppressedError
              : function (P, M, G) {
                  var V = new Error(G);
                  return (
                    (V.name = "SuppressedError"),
                    (V.error = P),
                    (V.suppressed = M),
                    V
                  );
                };
          ((F = function (P) {
            function M(X) {
              ((P.error = P.hasError
                ? new ne(X, P.error, "An error was suppressed during disposal.")
                : X),
                (P.hasError = !0));
            }
            var G,
              V = 0;
            function K() {
              for (; (G = P.stack.pop()); )
                try {
                  if (!G.async && V === 1)
                    return (
                      (V = 0),
                      P.stack.push(G),
                      Promise.resolve().then(K)
                    );
                  if (G.dispose) {
                    var X = G.dispose.call(G.value);
                    if (G.async)
                      return (
                        (V |= 2),
                        Promise.resolve(X).then(K, function (v) {
                          return (M(v), K());
                        })
                      );
                  } else V |= 1;
                } catch (v) {
                  M(v);
                }
              if (V === 1)
                return P.hasError ? Promise.reject(P.error) : Promise.resolve();
              if (P.hasError) throw P.error;
            }
            return K();
          }),
            (U = function (P, M) {
              return typeof P == "string" && /^\.\.?\//.test(P)
                ? P.replace(
                    /\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i,
                    function (G, V, K, X, v) {
                      return V
                        ? M
                          ? ".jsx"
                          : ".js"
                        : K && (!X || !v)
                          ? G
                          : K + X + "." + v.toLowerCase() + "js";
                    },
                  )
                : P;
            }),
            k("__extends", t),
            k("__assign", n),
            k("__rest", r),
            k("__decorate", o),
            k("__param", s),
            k("__esDecorate", i),
            k("__runInitializers", a),
            k("__propKey", c),
            k("__setFunctionName", l),
            k("__metadata", f),
            k("__awaiter", d),
            k("__generator", u),
            k("__exportStar", _),
            k("__createBinding", x),
            k("__values", p),
            k("__read", E),
            k("__spread", h),
            k("__spreadArrays", T),
            k("__spreadArray", m),
            k("__await", A),
            k("__asyncGenerator", g),
            k("__asyncDelegator", N),
            k("__asyncValues", O),
            k("__makeTemplateObject", I),
            k("__importStar", b),
            k("__importDefault", w),
            k("__classPrivateFieldGet", L),
            k("__classPrivateFieldSet", j),
            k("__classPrivateFieldIn", H),
            k("__addDisposableResource", B),
            k("__disposeResources", F),
            k("__rewriteRelativeImportExtension", U));
        });
      })(K_)),
    K_.exports
  );
}
var BQ = $Q();
const HQ = Qu(BQ),
  {
    __extends: mh,
    __assign: an,
    __rest: X8,
    __decorate: Q8,
    __param: J8,
    __esDecorate: e7,
    __runInitializers: t7,
    __propKey: n7,
    __setFunctionName: r7,
    __metadata: o7,
    __awaiter: s7,
    __generator: i7,
    __exportStar: a7,
    __createBinding: c7,
    __values: u7,
    __read: l7,
    __spread: d7,
    __spreadArrays: f7,
    __spreadArray: J,
    __await: _7,
    __asyncGenerator: p7,
    __asyncDelegator: E7,
    __asyncValues: h7,
    __makeTemplateObject: T7,
    __importStar: S7,
    __importDefault: m7,
    __classPrivateFieldGet: A7,
    __classPrivateFieldSet: g7,
    __classPrivateFieldIn: R7,
    __addDisposableResource: N7,
    __disposeResources: y7,
    __rewriteRelativeImportExtension: O7,
  } = HQ;
var QC = (function (e) {
    mh(t, e);
    function t(n, r, o) {
      var s = e.call(this, n, r) || this;
      return ((s.iterator = o), s);
    }
    return (
      (t.prototype.add = function (n) {
        return this.iterator(n, this._result.length)
          ? (this._result.push(n), !0)
          : !1;
      }),
      t
    );
  })(Co),
  Bu = {
    dayNames: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
    ],
    monthNames: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December",
    ],
    tokens: {
      SKIP: /^[ \r\n\t]+|^\.$/,
      number: /^[1-9][0-9]*/,
      numberAsText: /^(one|two|three)/i,
      every: /^every/i,
      "day(s)": /^days?/i,
      "weekday(s)": /^weekdays?/i,
      "week(s)": /^weeks?/i,
      "hour(s)": /^hours?/i,
      "minute(s)": /^minutes?/i,
      "month(s)": /^months?/i,
      "year(s)": /^years?/i,
      on: /^(on|in)/i,
      at: /^(at)/i,
      the: /^the/i,
      first: /^first/i,
      second: /^second/i,
      third: /^third/i,
      nth: /^([1-9][0-9]*)(\.|th|nd|rd|st)/i,
      last: /^last/i,
      for: /^for/i,
      "time(s)": /^times?/i,
      until: /^(un)?til/i,
      monday: /^mo(n(day)?)?/i,
      tuesday: /^tu(e(s(day)?)?)?/i,
      wednesday: /^we(d(n(esday)?)?)?/i,
      thursday: /^th(u(r(sday)?)?)?/i,
      friday: /^fr(i(day)?)?/i,
      saturday: /^sa(t(urday)?)?/i,
      sunday: /^su(n(day)?)?/i,
      january: /^jan(uary)?/i,
      february: /^feb(ruary)?/i,
      march: /^mar(ch)?/i,
      april: /^apr(il)?/i,
      may: /^may/i,
      june: /^june?/i,
      july: /^july?/i,
      august: /^aug(ust)?/i,
      september: /^sep(t(ember)?)?/i,
      october: /^oct(ober)?/i,
      november: /^nov(ember)?/i,
      december: /^dec(ember)?/i,
      comma: /^(,\s*|(and|or)\s*)+/i,
    },
  },
  JC = function (e, t) {
    return e.indexOf(t) !== -1;
  },
  FQ = function (e) {
    return e.toString();
  },
  YQ = function (e, t, n) {
    return "".concat(t, " ").concat(n, ", ").concat(e);
  },
  Yn = (function () {
    function e(t, n, r, o) {
      if (
        (n === void 0 && (n = FQ),
        r === void 0 && (r = Bu),
        o === void 0 && (o = YQ),
        (this.text = []),
        (this.language = r || Bu),
        (this.gettext = n),
        (this.dateFormatter = o),
        (this.rrule = t),
        (this.options = t.options),
        (this.origOptions = t.origOptions),
        this.origOptions.bymonthday)
      ) {
        var s = [].concat(this.options.bymonthday),
          i = [].concat(this.options.bynmonthday);
        (s.sort(function (f, d) {
          return f - d;
        }),
          i.sort(function (f, d) {
            return d - f;
          }),
          (this.bymonthday = s.concat(i)),
          this.bymonthday.length || (this.bymonthday = null));
      }
      if (ze(this.origOptions.byweekday)) {
        var a = kt(this.origOptions.byweekday)
            ? this.origOptions.byweekday
            : [this.origOptions.byweekday],
          c = String(a);
        this.byweekday = {
          allWeeks: a.filter(function (f) {
            return !f.n;
          }),
          someWeeks: a.filter(function (f) {
            return !!f.n;
          }),
          isWeekdays:
            c.indexOf("MO") !== -1 &&
            c.indexOf("TU") !== -1 &&
            c.indexOf("WE") !== -1 &&
            c.indexOf("TH") !== -1 &&
            c.indexOf("FR") !== -1 &&
            c.indexOf("SA") === -1 &&
            c.indexOf("SU") === -1,
          isEveryDay:
            c.indexOf("MO") !== -1 &&
            c.indexOf("TU") !== -1 &&
            c.indexOf("WE") !== -1 &&
            c.indexOf("TH") !== -1 &&
            c.indexOf("FR") !== -1 &&
            c.indexOf("SA") !== -1 &&
            c.indexOf("SU") !== -1,
        };
        var l = function (f, d) {
          return f.weekday - d.weekday;
        };
        (this.byweekday.allWeeks.sort(l),
          this.byweekday.someWeeks.sort(l),
          this.byweekday.allWeeks.length || (this.byweekday.allWeeks = null),
          this.byweekday.someWeeks.length || (this.byweekday.someWeeks = null));
      } else this.byweekday = null;
    }
    return (
      (e.isFullyConvertible = function (t) {
        var n = !0;
        if (
          !(t.options.freq in e.IMPLEMENTED) ||
          (t.origOptions.until && t.origOptions.count)
        )
          return !1;
        for (var r in t.origOptions) {
          if (JC(["dtstart", "tzid", "wkst", "freq"], r)) return !0;
          if (!JC(e.IMPLEMENTED[t.options.freq], r)) return !1;
        }
        return n;
      }),
      (e.prototype.isFullyConvertible = function () {
        return e.isFullyConvertible(this.rrule);
      }),
      (e.prototype.toString = function () {
        var t = this.gettext;
        if (!(this.options.freq in e.IMPLEMENTED))
          return t("RRule error: Unable to fully convert this rrule to text");
        if (
          ((this.text = [t("every")]),
          this[pe.FREQUENCIES[this.options.freq]](),
          this.options.until)
        ) {
          this.add(t("until"));
          var n = this.options.until;
          this.add(
            this.dateFormatter(
              n.getUTCFullYear(),
              this.language.monthNames[n.getUTCMonth()],
              n.getUTCDate(),
            ),
          );
        } else
          this.options.count &&
            this.add(t("for"))
              .add(this.options.count.toString())
              .add(this.plural(this.options.count) ? t("times") : t("time"));
        return (
          this.isFullyConvertible() || this.add(t("(~ approximate)")),
          this.text.join("")
        );
      }),
      (e.prototype.HOURLY = function () {
        var t = this.gettext;
        (this.options.interval !== 1 &&
          this.add(this.options.interval.toString()),
          this.add(
            this.plural(this.options.interval) ? t("hours") : t("hour"),
          ));
      }),
      (e.prototype.MINUTELY = function () {
        var t = this.gettext;
        (this.options.interval !== 1 &&
          this.add(this.options.interval.toString()),
          this.add(
            this.plural(this.options.interval) ? t("minutes") : t("minute"),
          ));
      }),
      (e.prototype.DAILY = function () {
        var t = this.gettext;
        (this.options.interval !== 1 &&
          this.add(this.options.interval.toString()),
          this.byweekday && this.byweekday.isWeekdays
            ? this.add(
                this.plural(this.options.interval)
                  ? t("weekdays")
                  : t("weekday"),
              )
            : this.add(
                this.plural(this.options.interval) ? t("days") : t("day"),
              ),
          this.origOptions.bymonth && (this.add(t("in")), this._bymonth()),
          this.bymonthday
            ? this._bymonthday()
            : this.byweekday
              ? this._byweekday()
              : this.origOptions.byhour && this._byhour());
      }),
      (e.prototype.WEEKLY = function () {
        var t = this.gettext;
        (this.options.interval !== 1 &&
          this.add(this.options.interval.toString()).add(
            this.plural(this.options.interval) ? t("weeks") : t("week"),
          ),
          this.byweekday && this.byweekday.isWeekdays
            ? this.options.interval === 1
              ? this.add(
                  this.plural(this.options.interval)
                    ? t("weekdays")
                    : t("weekday"),
                )
              : this.add(t("on")).add(t("weekdays"))
            : this.byweekday && this.byweekday.isEveryDay
              ? this.add(
                  this.plural(this.options.interval) ? t("days") : t("day"),
                )
              : (this.options.interval === 1 && this.add(t("week")),
                this.origOptions.bymonth &&
                  (this.add(t("in")), this._bymonth()),
                this.bymonthday
                  ? this._bymonthday()
                  : this.byweekday && this._byweekday(),
                this.origOptions.byhour && this._byhour()));
      }),
      (e.prototype.MONTHLY = function () {
        var t = this.gettext;
        (this.origOptions.bymonth
          ? (this.options.interval !== 1 &&
              (this.add(this.options.interval.toString()).add(t("months")),
              this.plural(this.options.interval) && this.add(t("in"))),
            this._bymonth())
          : (this.options.interval !== 1 &&
              this.add(this.options.interval.toString()),
            this.add(
              this.plural(this.options.interval) ? t("months") : t("month"),
            )),
          this.bymonthday
            ? this._bymonthday()
            : this.byweekday && this.byweekday.isWeekdays
              ? this.add(t("on")).add(t("weekdays"))
              : this.byweekday && this._byweekday());
      }),
      (e.prototype.YEARLY = function () {
        var t = this.gettext;
        (this.origOptions.bymonth
          ? (this.options.interval !== 1 &&
              (this.add(this.options.interval.toString()),
              this.add(t("years"))),
            this._bymonth())
          : (this.options.interval !== 1 &&
              this.add(this.options.interval.toString()),
            this.add(
              this.plural(this.options.interval) ? t("years") : t("year"),
            )),
          this.bymonthday
            ? this._bymonthday()
            : this.byweekday && this._byweekday(),
          this.options.byyearday &&
            this.add(t("on the"))
              .add(this.list(this.options.byyearday, this.nth, t("and")))
              .add(t("day")),
          this.options.byweekno &&
            this.add(t("in"))
              .add(
                this.plural(this.options.byweekno.length)
                  ? t("weeks")
                  : t("week"),
              )
              .add(this.list(this.options.byweekno, void 0, t("and"))));
      }),
      (e.prototype._bymonthday = function () {
        var t = this.gettext;
        this.byweekday && this.byweekday.allWeeks
          ? this.add(t("on"))
              .add(
                this.list(this.byweekday.allWeeks, this.weekdaytext, t("or")),
              )
              .add(t("the"))
              .add(this.list(this.bymonthday, this.nth, t("or")))
          : this.add(t("on the")).add(
              this.list(this.bymonthday, this.nth, t("and")),
            );
      }),
      (e.prototype._byweekday = function () {
        var t = this.gettext;
        (this.byweekday.allWeeks &&
          !this.byweekday.isWeekdays &&
          this.add(t("on")).add(
            this.list(this.byweekday.allWeeks, this.weekdaytext),
          ),
          this.byweekday.someWeeks &&
            (this.byweekday.allWeeks && this.add(t("and")),
            this.add(t("on the")).add(
              this.list(this.byweekday.someWeeks, this.weekdaytext, t("and")),
            )));
      }),
      (e.prototype._byhour = function () {
        var t = this.gettext;
        this.add(t("at")).add(
          this.list(this.origOptions.byhour, void 0, t("and")),
        );
      }),
      (e.prototype._bymonth = function () {
        this.add(
          this.list(this.options.bymonth, this.monthtext, this.gettext("and")),
        );
      }),
      (e.prototype.nth = function (t) {
        t = parseInt(t.toString(), 10);
        var n,
          r = this.gettext;
        if (t === -1) return r("last");
        var o = Math.abs(t);
        switch (o) {
          case 1:
          case 21:
          case 31:
            n = o + r("st");
            break;
          case 2:
          case 22:
            n = o + r("nd");
            break;
          case 3:
          case 23:
            n = o + r("rd");
            break;
          default:
            n = o + r("th");
        }
        return t < 0 ? n + " " + r("last") : n;
      }),
      (e.prototype.monthtext = function (t) {
        return this.language.monthNames[t - 1];
      }),
      (e.prototype.weekdaytext = function (t) {
        var n = pn(t) ? (t + 1) % 7 : t.getJsWeekday();
        return (t.n ? this.nth(t.n) + " " : "") + this.language.dayNames[n];
      }),
      (e.prototype.plural = function (t) {
        return t % 100 !== 1;
      }),
      (e.prototype.add = function (t) {
        return (this.text.push(" "), this.text.push(t), this);
      }),
      (e.prototype.list = function (t, n, r, o) {
        var s = this;
        (o === void 0 && (o = ","), kt(t) || (t = [t]));
        var i = function (c, l, f) {
          for (var d = "", u = 0; u < c.length; u++)
            (u !== 0 &&
              (u === c.length - 1 ? (d += " " + f + " ") : (d += l + " ")),
              (d += c[u]));
          return d;
        };
        n =
          n ||
          function (c) {
            return c.toString();
          };
        var a = function (c) {
          return n && n.call(s, c);
        };
        return r ? i(t.map(a), o, r) : t.map(a).join(o + " ");
      }),
      e
    );
  })(),
  jQ = (function () {
    function e(t) {
      ((this.done = !0), (this.rules = t));
    }
    return (
      (e.prototype.start = function (t) {
        return ((this.text = t), (this.done = !1), this.nextSymbol());
      }),
      (e.prototype.isDone = function () {
        return this.done && this.symbol === null;
      }),
      (e.prototype.nextSymbol = function () {
        var t, n;
        ((this.symbol = null), (this.value = null));
        do {
          if (this.done) return !1;
          var r = void 0;
          t = null;
          for (var o in this.rules) {
            r = this.rules[o];
            var s = r.exec(this.text);
            s &&
              (t === null || s[0].length > t[0].length) &&
              ((t = s), (n = o));
          }
          if (
            (t != null &&
              ((this.text = this.text.substr(t[0].length)),
              this.text === "" && (this.done = !0)),
            t == null)
          ) {
            ((this.done = !0), (this.symbol = null), (this.value = null));
            return;
          }
        } while (n === "SKIP");
        return ((this.symbol = n), (this.value = t), !0);
      }),
      (e.prototype.accept = function (t) {
        if (this.symbol === t) {
          if (this.value) {
            var n = this.value;
            return (this.nextSymbol(), n);
          }
          return (this.nextSymbol(), !0);
        }
        return !1;
      }),
      (e.prototype.acceptNumber = function () {
        return this.accept("number");
      }),
      (e.prototype.expect = function (t) {
        if (this.accept(t)) return !0;
        throw new Error("expected " + t + " but found " + this.symbol);
      }),
      e
    );
  })();
function GL(e, t) {
  t === void 0 && (t = Bu);
  var n = {},
    r = new jQ(t.tokens);
  if (!r.start(e)) return null;
  return (o(), n);
  function o() {
    r.expect("every");
    var u = r.acceptNumber();
    if ((u && (n.interval = parseInt(u[0], 10)), r.isDone()))
      throw new Error("Unexpected end");
    switch (r.symbol) {
      case "day(s)":
        ((n.freq = pe.DAILY), r.nextSymbol() && (i(), d()));
        break;
      case "weekday(s)":
        ((n.freq = pe.WEEKLY),
          (n.byweekday = [pe.MO, pe.TU, pe.WE, pe.TH, pe.FR]),
          r.nextSymbol(),
          i(),
          d());
        break;
      case "week(s)":
        ((n.freq = pe.WEEKLY), r.nextSymbol() && (s(), i(), d()));
        break;
      case "hour(s)":
        ((n.freq = pe.HOURLY), r.nextSymbol() && (s(), d()));
        break;
      case "minute(s)":
        ((n.freq = pe.MINUTELY), r.nextSymbol() && (s(), d()));
        break;
      case "month(s)":
        ((n.freq = pe.MONTHLY), r.nextSymbol() && (s(), d()));
        break;
      case "year(s)":
        ((n.freq = pe.YEARLY), r.nextSymbol() && (s(), d()));
        break;
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        n.freq = pe.WEEKLY;
        var _ = r.symbol.substr(0, 2).toUpperCase();
        if (((n.byweekday = [pe[_]]), !r.nextSymbol())) return;
        for (; r.accept("comma"); ) {
          if (r.isDone()) throw new Error("Unexpected end");
          var p = c();
          if (!p)
            throw new Error(
              "Unexpected symbol " + r.symbol + ", expected weekday",
            );
          (n.byweekday.push(pe[p]), r.nextSymbol());
        }
        (i(), f(), d());
        break;
      case "january":
      case "february":
      case "march":
      case "april":
      case "may":
      case "june":
      case "july":
      case "august":
      case "september":
      case "october":
      case "november":
      case "december":
        if (((n.freq = pe.YEARLY), (n.bymonth = [a()]), !r.nextSymbol()))
          return;
        for (; r.accept("comma"); ) {
          if (r.isDone()) throw new Error("Unexpected end");
          var E = a();
          if (!E)
            throw new Error(
              "Unexpected symbol " + r.symbol + ", expected month",
            );
          (n.bymonth.push(E), r.nextSymbol());
        }
        (s(), d());
        break;
      default:
        throw new Error("Unknown symbol");
    }
  }
  function s() {
    var u = r.accept("on"),
      _ = r.accept("the");
    if (u || _)
      do {
        var p = l(),
          E = c(),
          h = a();
        if (p)
          E
            ? (r.nextSymbol(),
              n.byweekday || (n.byweekday = []),
              n.byweekday.push(pe[E].nth(p)))
            : (n.bymonthday || (n.bymonthday = []),
              n.bymonthday.push(p),
              r.accept("day(s)"));
        else if (E)
          (r.nextSymbol(),
            n.byweekday || (n.byweekday = []),
            n.byweekday.push(pe[E]));
        else if (r.symbol === "weekday(s)")
          (r.nextSymbol(),
            n.byweekday || (n.byweekday = [pe.MO, pe.TU, pe.WE, pe.TH, pe.FR]));
        else if (r.symbol === "week(s)") {
          r.nextSymbol();
          var T = r.acceptNumber();
          if (!T)
            throw new Error(
              "Unexpected symbol " + r.symbol + ", expected week number",
            );
          for (n.byweekno = [parseInt(T[0], 10)]; r.accept("comma"); ) {
            if (((T = r.acceptNumber()), !T))
              throw new Error(
                "Unexpected symbol " + r.symbol + "; expected monthday",
              );
            n.byweekno.push(parseInt(T[0], 10));
          }
        } else if (h)
          (r.nextSymbol(), n.bymonth || (n.bymonth = []), n.bymonth.push(h));
        else return;
      } while (r.accept("comma") || r.accept("the") || r.accept("on"));
  }
  function i() {
    var u = r.accept("at");
    if (u)
      do {
        var _ = r.acceptNumber();
        if (!_)
          throw new Error("Unexpected symbol " + r.symbol + ", expected hour");
        for (n.byhour = [parseInt(_[0], 10)]; r.accept("comma"); ) {
          if (((_ = r.acceptNumber()), !_))
            throw new Error(
              "Unexpected symbol " + r.symbol + "; expected hour",
            );
          n.byhour.push(parseInt(_[0], 10));
        }
      } while (r.accept("comma") || r.accept("at"));
  }
  function a() {
    switch (r.symbol) {
      case "january":
        return 1;
      case "february":
        return 2;
      case "march":
        return 3;
      case "april":
        return 4;
      case "may":
        return 5;
      case "june":
        return 6;
      case "july":
        return 7;
      case "august":
        return 8;
      case "september":
        return 9;
      case "october":
        return 10;
      case "november":
        return 11;
      case "december":
        return 12;
      default:
        return !1;
    }
  }
  function c() {
    switch (r.symbol) {
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        return r.symbol.substr(0, 2).toUpperCase();
      default:
        return !1;
    }
  }
  function l() {
    switch (r.symbol) {
      case "last":
        return (r.nextSymbol(), -1);
      case "first":
        return (r.nextSymbol(), 1);
      case "second":
        return (r.nextSymbol(), r.accept("last") ? -2 : 2);
      case "third":
        return (r.nextSymbol(), r.accept("last") ? -3 : 3);
      case "nth":
        var u = parseInt(r.value[1], 10);
        if (u < -366 || u > 366) throw new Error("Nth out of range: " + u);
        return (r.nextSymbol(), r.accept("last") ? -u : u);
      default:
        return !1;
    }
  }
  function f() {
    (r.accept("on"), r.accept("the"));
    var u = l();
    if (u)
      for (n.bymonthday = [u], r.nextSymbol(); r.accept("comma"); ) {
        if (((u = l()), !u))
          throw new Error(
            "Unexpected symbol " + r.symbol + "; expected monthday",
          );
        (n.bymonthday.push(u), r.nextSymbol());
      }
  }
  function d() {
    if (r.symbol === "until") {
      var u = Date.parse(r.text);
      if (!u) throw new Error("Cannot parse until date:" + r.text);
      n.until = new Date(u);
    } else
      r.accept("for") &&
        ((n.count = parseInt(r.value[0], 10)), r.expect("number"));
  }
}
var be;
(function (e) {
  ((e[(e.YEARLY = 0)] = "YEARLY"),
    (e[(e.MONTHLY = 1)] = "MONTHLY"),
    (e[(e.WEEKLY = 2)] = "WEEKLY"),
    (e[(e.DAILY = 3)] = "DAILY"),
    (e[(e.HOURLY = 4)] = "HOURLY"),
    (e[(e.MINUTELY = 5)] = "MINUTELY"),
    (e[(e.SECONDLY = 6)] = "SECONDLY"));
})(be || (be = {}));
function Ah(e) {
  return e < be.HOURLY;
}
var qQ = function (e, t) {
    return (t === void 0 && (t = Bu), new pe(GL(e, t) || void 0));
  },
  os = ["count", "until", "interval", "byweekday", "bymonthday", "bymonth"];
Yn.IMPLEMENTED = [];
Yn.IMPLEMENTED[be.HOURLY] = os;
Yn.IMPLEMENTED[be.MINUTELY] = os;
Yn.IMPLEMENTED[be.DAILY] = ["byhour"].concat(os);
Yn.IMPLEMENTED[be.WEEKLY] = os;
Yn.IMPLEMENTED[be.MONTHLY] = os;
Yn.IMPLEMENTED[be.YEARLY] = ["byweekno", "byyearday"].concat(os);
var WQ = function (e, t, n, r) {
    return new Yn(e, t, n, r).toString();
  },
  KQ = Yn.isFullyConvertible,
  Hu = (function () {
    function e(t, n, r, o) {
      ((this.hour = t),
        (this.minute = n),
        (this.second = r),
        (this.millisecond = o || 0));
    }
    return (
      (e.prototype.getHours = function () {
        return this.hour;
      }),
      (e.prototype.getMinutes = function () {
        return this.minute;
      }),
      (e.prototype.getSeconds = function () {
        return this.second;
      }),
      (e.prototype.getMilliseconds = function () {
        return this.millisecond;
      }),
      (e.prototype.getTime = function () {
        return (
          (this.hour * 60 * 60 + this.minute * 60 + this.second) * 1e3 +
          this.millisecond
        );
      }),
      e
    );
  })(),
  zQ = (function (e) {
    mh(t, e);
    function t(n, r, o, s, i, a, c) {
      var l = e.call(this, s, i, a, c) || this;
      return ((l.year = n), (l.month = r), (l.day = o), l);
    }
    return (
      (t.fromDate = function (n) {
        return new this(
          n.getUTCFullYear(),
          n.getUTCMonth() + 1,
          n.getUTCDate(),
          n.getUTCHours(),
          n.getUTCMinutes(),
          n.getUTCSeconds(),
          n.valueOf() % 1e3,
        );
      }),
      (t.prototype.getWeekday = function () {
        return Ho(new Date(this.getTime()));
      }),
      (t.prototype.getTime = function () {
        return new Date(
          Date.UTC(
            this.year,
            this.month - 1,
            this.day,
            this.hour,
            this.minute,
            this.second,
            this.millisecond,
          ),
        ).getTime();
      }),
      (t.prototype.getDay = function () {
        return this.day;
      }),
      (t.prototype.getMonth = function () {
        return this.month;
      }),
      (t.prototype.getYear = function () {
        return this.year;
      }),
      (t.prototype.addYears = function (n) {
        this.year += n;
      }),
      (t.prototype.addMonths = function (n) {
        if (((this.month += n), this.month > 12)) {
          var r = Math.floor(this.month / 12),
            o = Ht(this.month, 12);
          ((this.month = o),
            (this.year += r),
            this.month === 0 && ((this.month = 12), --this.year));
        }
      }),
      (t.prototype.addWeekly = function (n, r) {
        (r > this.getWeekday()
          ? (this.day += -(this.getWeekday() + 1 + (6 - r)) + n * 7)
          : (this.day += -(this.getWeekday() - r) + n * 7),
          this.fixDay());
      }),
      (t.prototype.addDaily = function (n) {
        ((this.day += n), this.fixDay());
      }),
      (t.prototype.addHours = function (n, r, o) {
        for (r && (this.hour += Math.floor((23 - this.hour) / n) * n); ; ) {
          this.hour += n;
          var s = W_(this.hour, 24),
            i = s.div,
            a = s.mod;
          if (
            (i && ((this.hour = a), this.addDaily(i)),
            Tn(o) || we(o, this.hour))
          )
            break;
        }
      }),
      (t.prototype.addMinutes = function (n, r, o, s) {
        for (
          r &&
          (this.minute +=
            Math.floor((1439 - (this.hour * 60 + this.minute)) / n) * n);
          ;
        ) {
          this.minute += n;
          var i = W_(this.minute, 60),
            a = i.div,
            c = i.mod;
          if (
            (a && ((this.minute = c), this.addHours(a, !1, o)),
            (Tn(o) || we(o, this.hour)) && (Tn(s) || we(s, this.minute)))
          )
            break;
        }
      }),
      (t.prototype.addSeconds = function (n, r, o, s, i) {
        for (
          r &&
          (this.second +=
            Math.floor(
              (86399 - (this.hour * 3600 + this.minute * 60 + this.second)) / n,
            ) * n);
          ;
        ) {
          this.second += n;
          var a = W_(this.second, 60),
            c = a.div,
            l = a.mod;
          if (
            (c && ((this.second = l), this.addMinutes(c, !1, o, s)),
            (Tn(o) || we(o, this.hour)) &&
              (Tn(s) || we(s, this.minute)) &&
              (Tn(i) || we(i, this.second)))
          )
            break;
        }
      }),
      (t.prototype.fixDay = function () {
        if (!(this.day <= 28)) {
          var n = KC(this.year, this.month - 1)[1];
          if (!(this.day <= n))
            for (; this.day > n; ) {
              if (
                ((this.day -= n),
                ++this.month,
                this.month === 13 &&
                  ((this.month = 1), ++this.year, this.year > LL))
              )
                return;
              n = KC(this.year, this.month - 1)[1];
            }
        }
      }),
      (t.prototype.add = function (n, r) {
        var o = n.freq,
          s = n.interval,
          i = n.wkst,
          a = n.byhour,
          c = n.byminute,
          l = n.bysecond;
        switch (o) {
          case be.YEARLY:
            return this.addYears(s);
          case be.MONTHLY:
            return this.addMonths(s);
          case be.WEEKLY:
            return this.addWeekly(s, i);
          case be.DAILY:
            return this.addDaily(s);
          case be.HOURLY:
            return this.addHours(s, r, a);
          case be.MINUTELY:
            return this.addMinutes(s, r, a, c);
          case be.SECONDLY:
            return this.addSeconds(s, r, a, c, l);
        }
      }),
      t
    );
  })(Hu);
function VL(e) {
  for (var t = [], n = Object.keys(e), r = 0, o = n; r < o.length; r++) {
    var s = o[r];
    (we(O5, s) || t.push(s), wL(e[s]) && !ja(e[s]) && t.push(s));
  }
  if (t.length) throw new Error("Invalid options: " + t.join(", "));
  return an({}, e);
}
function ZQ(e) {
  var t = an(an({}, gh), VL(e));
  if (
    (ze(t.byeaster) && (t.freq = pe.YEARLY),
    !(ze(t.freq) && pe.FREQUENCIES[t.freq]))
  )
    throw new Error("Invalid frequency: ".concat(t.freq, " ").concat(e.freq));
  if (
    (t.dtstart || (t.dtstart = new Date(new Date().setMilliseconds(0))),
    ze(t.wkst)
      ? pn(t.wkst) || (t.wkst = t.wkst.weekday)
      : (t.wkst = pe.MO.weekday),
    ze(t.bysetpos))
  ) {
    pn(t.bysetpos) && (t.bysetpos = [t.bysetpos]);
    for (var n = 0; n < t.bysetpos.length; n++) {
      var r = t.bysetpos[n];
      if (r === 0 || !(r >= -366 && r <= 366))
        throw new Error(
          "bysetpos must be between 1 and 366, or between -366 and -1",
        );
    }
  }
  if (
    !(
      t.byweekno ||
      rt(t.byweekno) ||
      rt(t.byyearday) ||
      t.bymonthday ||
      rt(t.bymonthday) ||
      ze(t.byweekday) ||
      ze(t.byeaster)
    )
  )
    switch (t.freq) {
      case pe.YEARLY:
        (t.bymonth || (t.bymonth = t.dtstart.getUTCMonth() + 1),
          (t.bymonthday = t.dtstart.getUTCDate()));
        break;
      case pe.MONTHLY:
        t.bymonthday = t.dtstart.getUTCDate();
        break;
      case pe.WEEKLY:
        t.byweekday = [Ho(t.dtstart)];
        break;
    }
  if (
    (ze(t.bymonth) && !kt(t.bymonth) && (t.bymonth = [t.bymonth]),
    ze(t.byyearday) &&
      !kt(t.byyearday) &&
      pn(t.byyearday) &&
      (t.byyearday = [t.byyearday]),
    !ze(t.bymonthday))
  )
    ((t.bymonthday = []), (t.bynmonthday = []));
  else if (kt(t.bymonthday)) {
    for (var o = [], s = [], n = 0; n < t.bymonthday.length; n++) {
      var r = t.bymonthday[n];
      r > 0 ? o.push(r) : r < 0 && s.push(r);
    }
    ((t.bymonthday = o), (t.bynmonthday = s));
  } else
    t.bymonthday < 0
      ? ((t.bynmonthday = [t.bymonthday]), (t.bymonthday = []))
      : ((t.bynmonthday = []), (t.bymonthday = [t.bymonthday]));
  if (
    (ze(t.byweekno) && !kt(t.byweekno) && (t.byweekno = [t.byweekno]),
    !ze(t.byweekday))
  )
    t.bynweekday = null;
  else if (pn(t.byweekday))
    ((t.byweekday = [t.byweekday]), (t.bynweekday = null));
  else if (WC(t.byweekday))
    ((t.byweekday = [gt.fromStr(t.byweekday).weekday]), (t.bynweekday = null));
  else if (t.byweekday instanceof gt)
    !t.byweekday.n || t.freq > pe.MONTHLY
      ? ((t.byweekday = [t.byweekday.weekday]), (t.bynweekday = null))
      : ((t.bynweekday = [[t.byweekday.weekday, t.byweekday.n]]),
        (t.byweekday = null));
  else {
    for (var i = [], a = [], n = 0; n < t.byweekday.length; n++) {
      var c = t.byweekday[n];
      if (pn(c)) {
        i.push(c);
        continue;
      } else if (WC(c)) {
        i.push(gt.fromStr(c).weekday);
        continue;
      }
      !c.n || t.freq > pe.MONTHLY
        ? i.push(c.weekday)
        : a.push([c.weekday, c.n]);
    }
    ((t.byweekday = rt(i) ? i : null), (t.bynweekday = rt(a) ? a : null));
  }
  return (
    ze(t.byhour)
      ? pn(t.byhour) && (t.byhour = [t.byhour])
      : (t.byhour = t.freq < pe.HOURLY ? [t.dtstart.getUTCHours()] : null),
    ze(t.byminute)
      ? pn(t.byminute) && (t.byminute = [t.byminute])
      : (t.byminute =
          t.freq < pe.MINUTELY ? [t.dtstart.getUTCMinutes()] : null),
    ze(t.bysecond)
      ? pn(t.bysecond) && (t.bysecond = [t.bysecond])
      : (t.bysecond =
          t.freq < pe.SECONDLY ? [t.dtstart.getUTCSeconds()] : null),
    {
      parsedOptions: t,
    }
  );
}
function XQ(e) {
  var t = e.dtstart.getTime() % 1e3;
  if (!Ah(e.freq)) return [];
  var n = [];
  return (
    e.byhour.forEach(function (r) {
      e.byminute.forEach(function (o) {
        e.bysecond.forEach(function (s) {
          n.push(new Hu(r, o, s, t));
        });
      });
    }),
    n
  );
}
function Hp(e) {
  var t = e
    .split(
      `
`,
    )
    .map(QQ)
    .filter(function (n) {
      return n !== null;
    });
  return an(an({}, t[0]), t[1]);
}
function Fu(e) {
  var t = {},
    n = /DTSTART(?:;TZID=([^:=]+?))?(?::|=)([^;\s]+)/i.exec(e);
  if (!n) return t;
  var r = n[1],
    o = n[2];
  return (r && (t.tzid = r), (t.dtstart = Sh(o)), t);
}
function QQ(e) {
  if (((e = e.replace(/^\s+|\s+$/, "")), !e.length)) return null;
  var t = /^([A-Z]+?)[:;]/.exec(e.toUpperCase());
  if (!t) return eb(e);
  var n = t[1];
  switch (n.toUpperCase()) {
    case "RRULE":
    case "EXRULE":
      return eb(e);
    case "DTSTART":
      return Fu(e);
    default:
      throw new Error("Unsupported RFC prop ".concat(n, " in ").concat(e));
  }
}
function eb(e) {
  var t = e.replace(/^RRULE:/i, ""),
    n = Fu(t),
    r = e.replace(/^(?:RRULE|EXRULE):/i, "").split(";");
  return (
    r.forEach(function (o) {
      var s = o.split("="),
        i = s[0],
        a = s[1];
      switch (i.toUpperCase()) {
        case "FREQ":
          n.freq = be[a.toUpperCase()];
          break;
        case "WKST":
          n.wkst = rn[a.toUpperCase()];
          break;
        case "COUNT":
        case "INTERVAL":
        case "BYSETPOS":
        case "BYMONTH":
        case "BYMONTHDAY":
        case "BYYEARDAY":
        case "BYWEEKNO":
        case "BYHOUR":
        case "BYMINUTE":
        case "BYSECOND":
          var c = JQ(a),
            l = i.toLowerCase();
          n[l] = c;
          break;
        case "BYWEEKDAY":
        case "BYDAY":
          n.byweekday = e5(a);
          break;
        case "DTSTART":
        case "TZID":
          var f = Fu(e);
          ((n.tzid = f.tzid), (n.dtstart = f.dtstart));
          break;
        case "UNTIL":
          n.until = Sh(a);
          break;
        case "BYEASTER":
          n.byeaster = Number(a);
          break;
        default:
          throw new Error("Unknown RRULE property '" + i + "'");
      }
    }),
    n
  );
}
function JQ(e) {
  if (e.indexOf(",") !== -1) {
    var t = e.split(",");
    return t.map(tb);
  }
  return tb(e);
}
function tb(e) {
  return /^[+-]?\d+$/.test(e) ? Number(e) : e;
}
function e5(e) {
  var t = e.split(",");
  return t.map(function (n) {
    if (n.length === 2) return rn[n];
    var r = n.match(/^([+-]?\d{1,2})([A-Z]{2})$/);
    if (!r || r.length < 3)
      throw new SyntaxError("Invalid weekday string: ".concat(n));
    var o = Number(r[1]),
      s = r[2],
      i = rn[s].weekday;
    return new gt(i, o);
  });
}
var Yu = (function () {
  function e(t, n) {
    if (isNaN(t.getTime()))
      throw new RangeError("Invalid date passed to DateWithZone");
    ((this.date = t), (this.tzid = n));
  }
  return (
    Object.defineProperty(e.prototype, "isUTC", {
      get: function () {
        return !this.tzid || this.tzid.toUpperCase() === "UTC";
      },
      enumerable: !1,
      configurable: !0,
    }),
    (e.prototype.toString = function () {
      var t = Th(this.date.getTime(), this.isUTC);
      return this.isUTC
        ? ":".concat(t)
        : ";TZID=".concat(this.tzid, ":").concat(t);
    }),
    (e.prototype.getTime = function () {
      return this.date.getTime();
    }),
    (e.prototype.rezonedDate = function () {
      return this.isUTC ? this.date : xQ(this.date, this.tzid);
    }),
    e
  );
})();
function Fp(e) {
  for (
    var t = [], n = "", r = Object.keys(e), o = Object.keys(gh), s = 0;
    s < r.length;
    s++
  )
    if (r[s] !== "tzid" && we(o, r[s])) {
      var i = r[s].toUpperCase(),
        a = e[r[s]],
        c = "";
      if (!(!ze(a) || (kt(a) && !a.length))) {
        switch (i) {
          case "FREQ":
            c = pe.FREQUENCIES[e.freq];
            break;
          case "WKST":
            pn(a) ? (c = new gt(a).toString()) : (c = a.toString());
            break;
          case "BYWEEKDAY":
            ((i = "BYDAY"),
              (c = DQ(a)
                .map(function (_) {
                  return _ instanceof gt
                    ? _
                    : kt(_)
                      ? new gt(_[0], _[1])
                      : new gt(_);
                })
                .toString()));
            break;
          case "DTSTART":
            n = t5(a, e.tzid);
            break;
          case "UNTIL":
            c = Th(a, !e.tzid);
            break;
          default:
            if (kt(a)) {
              for (var l = [], f = 0; f < a.length; f++) l[f] = String(a[f]);
              c = l.toString();
            } else c = String(a);
        }
        c && t.push([i, c]);
      }
    }
  var d = t
      .map(function (_) {
        var p = _[0],
          E = _[1];
        return "".concat(p, "=").concat(E.toString());
      })
      .join(";"),
    u = "";
  return (
    d !== "" && (u = "RRULE:".concat(d)),
    [n, u].filter(function (_) {
      return !!_;
    }).join(`
`)
  );
}
function t5(e, t) {
  return e ? "DTSTART" + new Yu(new Date(e), t).toString() : "";
}
function n5(e, t) {
  return Array.isArray(e)
    ? !Array.isArray(t) || e.length !== t.length
      ? !1
      : e.every(function (n, r) {
          return n.getTime() === t[r].getTime();
        })
    : e instanceof Date
      ? t instanceof Date && e.getTime() === t.getTime()
      : e === t;
}
var r5 = (function () {
    function e() {
      ((this.all = !1),
        (this.before = []),
        (this.after = []),
        (this.between = []));
    }
    return (
      (e.prototype._cacheAdd = function (t, n, r) {
        (n && (n = n instanceof Date ? Bp(n) : zC(n)),
          t === "all" ? (this.all = n) : ((r._value = n), this[t].push(r)));
      }),
      (e.prototype._cacheGet = function (t, n) {
        var r = !1,
          o = n ? Object.keys(n) : [],
          s = function (f) {
            for (var d = 0; d < o.length; d++) {
              var u = o[d];
              if (!n5(n[u], f[u])) return !0;
            }
            return !1;
          },
          i = this[t];
        if (t === "all") r = this.all;
        else if (kt(i))
          for (var a = 0; a < i.length; a++) {
            var c = i[a];
            if (!(o.length && s(c))) {
              r = c._value;
              break;
            }
          }
        if (!r && this.all) {
          for (
            var l = new Co(t, n), a = 0;
            a < this.all.length && l.accept(this.all[a]);
            a++
          );
          ((r = l.getValue()), this._cacheAdd(t, r, n));
        }
        return kt(r) ? zC(r) : r instanceof Date ? Bp(r) : r;
      }),
      e
    );
  })(),
  o5 = J(
    J(
      J(
        J(
          J(
            J(
              J(
                J(
                  J(
                    J(
                      J(J(J([], Ce(1, 31), !0), Ce(2, 28), !0), Ce(3, 31), !0),
                      Ce(4, 30),
                      !0,
                    ),
                    Ce(5, 31),
                    !0,
                  ),
                  Ce(6, 30),
                  !0,
                ),
                Ce(7, 31),
                !0,
              ),
              Ce(8, 31),
              !0,
            ),
            Ce(9, 30),
            !0,
          ),
          Ce(10, 31),
          !0,
        ),
        Ce(11, 30),
        !0,
      ),
      Ce(12, 31),
      !0,
    ),
    Ce(1, 7),
    !0,
  ),
  s5 = J(
    J(
      J(
        J(
          J(
            J(
              J(
                J(
                  J(
                    J(
                      J(J(J([], Ce(1, 31), !0), Ce(2, 29), !0), Ce(3, 31), !0),
                      Ce(4, 30),
                      !0,
                    ),
                    Ce(5, 31),
                    !0,
                  ),
                  Ce(6, 30),
                  !0,
                ),
                Ce(7, 31),
                !0,
              ),
              Ce(8, 31),
              !0,
            ),
            Ce(9, 30),
            !0,
          ),
          Ce(10, 31),
          !0,
        ),
        Ce(11, 30),
        !0,
      ),
      Ce(12, 31),
      !0,
    ),
    Ce(1, 7),
    !0,
  ),
  i5 = yn(1, 29),
  a5 = yn(1, 30),
  Xn = yn(1, 31),
  ut = yn(1, 32),
  c5 = J(
    J(
      J(
        J(
          J(
            J(
              J(
                J(
                  J(J(J(J(J([], ut, !0), a5, !0), ut, !0), Xn, !0), ut, !0),
                  Xn,
                  !0,
                ),
                ut,
                !0,
              ),
              ut,
              !0,
            ),
            Xn,
            !0,
          ),
          ut,
          !0,
        ),
        Xn,
        !0,
      ),
      ut,
      !0,
    ),
    ut.slice(0, 7),
    !0,
  ),
  u5 = J(
    J(
      J(
        J(
          J(
            J(
              J(
                J(
                  J(J(J(J(J([], ut, !0), i5, !0), ut, !0), Xn, !0), ut, !0),
                  Xn,
                  !0,
                ),
                ut,
                !0,
              ),
              ut,
              !0,
            ),
            Xn,
            !0,
          ),
          ut,
          !0,
        ),
        Xn,
        !0,
      ),
      ut,
      !0,
    ),
    ut.slice(0, 7),
    !0,
  ),
  l5 = yn(-28, 0),
  d5 = yn(-29, 0),
  Qn = yn(-30, 0),
  lt = yn(-31, 0),
  f5 = J(
    J(
      J(
        J(
          J(
            J(
              J(
                J(
                  J(J(J(J(J([], lt, !0), d5, !0), lt, !0), Qn, !0), lt, !0),
                  Qn,
                  !0,
                ),
                lt,
                !0,
              ),
              lt,
              !0,
            ),
            Qn,
            !0,
          ),
          lt,
          !0,
        ),
        Qn,
        !0,
      ),
      lt,
      !0,
    ),
    lt.slice(0, 7),
    !0,
  ),
  _5 = J(
    J(
      J(
        J(
          J(
            J(
              J(
                J(
                  J(J(J(J(J([], lt, !0), l5, !0), lt, !0), Qn, !0), lt, !0),
                  Qn,
                  !0,
                ),
                lt,
                !0,
              ),
              lt,
              !0,
            ),
            Qn,
            !0,
          ),
          lt,
          !0,
        ),
        Qn,
        !0,
      ),
      lt,
      !0,
    ),
    lt.slice(0, 7),
    !0,
  ),
  p5 = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366],
  E5 = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365],
  nb = (function () {
    for (var e = [], t = 0; t < 55; t++) e = e.concat(yn(7));
    return e;
  })();
function h5(e, t) {
  var n = io(e, 1, 1),
    r = Za(e) ? 366 : 365,
    o = Za(e + 1) ? 366 : 365,
    s = $p(n),
    i = Ho(n),
    a = an(
      an(
        {
          yearlen: r,
          nextyearlen: o,
          yearordinal: s,
          yearweekday: i,
        },
        T5(e),
      ),
      {
        wnomask: null,
      },
    );
  if (Tn(t.byweekno)) return a;
  a.wnomask = Ce(0, r + 7);
  var c,
    l,
    f = (c = Ht(7 - i + t.wkst, 7));
  f >= 4 ? ((f = 0), (l = a.yearlen + Ht(i - t.wkst, 7))) : (l = r - f);
  for (
    var d = Math.floor(l / 7), u = Ht(l, 7), _ = Math.floor(d + u / 4), p = 0;
    p < t.byweekno.length;
    p++
  ) {
    var E = t.byweekno[p];
    if ((E < 0 && (E += _ + 1), E > 0 && E <= _)) {
      var h = void 0;
      E > 1 ? ((h = f + (E - 1) * 7), f !== c && (h -= 7 - c)) : (h = f);
      for (
        var T = 0;
        T < 7 && ((a.wnomask[h] = 1), h++, a.wdaymask[h] !== t.wkst);
        T++
      );
    }
  }
  if (we(t.byweekno, 1)) {
    var h = f + _ * 7;
    if ((f !== c && (h -= 7 - c), h < r))
      for (
        var p = 0;
        p < 7 && ((a.wnomask[h] = 1), (h += 1), a.wdaymask[h] !== t.wkst);
        p++
      );
  }
  if (f) {
    var m = void 0;
    if (we(t.byweekno, -1)) m = -1;
    else {
      var A = Ho(io(e - 1, 1, 1)),
        g = Ht(7 - A.valueOf() + t.wkst, 7),
        N = Za(e - 1) ? 366 : 365,
        O = void 0;
      (g >= 4 ? ((g = 0), (O = N + Ht(A - t.wkst, 7))) : (O = r - f),
        (m = Math.floor(52 + Ht(O, 7) / 4)));
    }
    if (we(t.byweekno, m)) for (var h = 0; h < f; h++) a.wnomask[h] = 1;
  }
  return a;
}
function T5(e) {
  var t = Za(e) ? 366 : 365,
    n = io(e, 1, 1),
    r = Ho(n);
  return t === 365
    ? {
        mmask: o5,
        mdaymask: u5,
        nmdaymask: _5,
        wdaymask: nb.slice(r),
        mrange: E5,
      }
    : {
        mmask: s5,
        mdaymask: c5,
        nmdaymask: f5,
        wdaymask: nb.slice(r),
        mrange: p5,
      };
}
function S5(e, t, n, r, o, s) {
  var i = {
      lastyear: e,
      lastmonth: t,
      nwdaymask: [],
    },
    a = [];
  if (s.freq === pe.YEARLY) {
    if (Tn(s.bymonth)) a = [[0, n]];
    else
      for (var c = 0; c < s.bymonth.length; c++)
        ((t = s.bymonth[c]), a.push(r.slice(t - 1, t + 1)));
  } else s.freq === pe.MONTHLY && (a = [r.slice(t - 1, t + 1)]);
  if (Tn(a)) return i;
  i.nwdaymask = Ce(0, n);
  for (var c = 0; c < a.length; c++)
    for (
      var l = a[c], f = l[0], d = l[1] - 1, u = 0;
      u < s.bynweekday.length;
      u++
    ) {
      var _ = void 0,
        p = s.bynweekday[u],
        E = p[0],
        h = p[1];
      (h < 0
        ? ((_ = d + (h + 1) * 7), (_ -= Ht(o[_] - E, 7)))
        : ((_ = f + (h - 1) * 7), (_ += Ht(7 - o[_] + E, 7))),
        f <= _ && _ <= d && (i.nwdaymask[_] = 1));
    }
  return i;
}
function m5(e, t) {
  t === void 0 && (t = 0);
  var n = e % 19,
    r = Math.floor(e / 100),
    o = e % 100,
    s = Math.floor(r / 4),
    i = r % 4,
    a = Math.floor((r + 8) / 25),
    c = Math.floor((r - a + 1) / 3),
    l = Math.floor(19 * n + r - s - c + 15) % 30,
    f = Math.floor(o / 4),
    d = o % 4,
    u = Math.floor(32 + 2 * i + 2 * f - l - d) % 7,
    _ = Math.floor((n + 11 * l + 22 * u) / 451),
    p = Math.floor((l + u - 7 * _ + 114) / 31),
    E = ((l + u - 7 * _ + 114) % 31) + 1,
    h = Date.UTC(e, p - 1, E + t),
    T = Date.UTC(e, 0, 1);
  return [Math.ceil((h - T) / (1e3 * 60 * 60 * 24))];
}
var A5 = (function () {
  function e(t) {
    this.options = t;
  }
  return (
    (e.prototype.rebuild = function (t, n) {
      var r = this.options;
      if (
        (t !== this.lastyear && (this.yearinfo = h5(t, r)),
        rt(r.bynweekday) && (n !== this.lastmonth || t !== this.lastyear))
      ) {
        var o = this.yearinfo,
          s = o.yearlen,
          i = o.mrange,
          a = o.wdaymask;
        this.monthinfo = S5(t, n, s, i, a, r);
      }
      ze(r.byeaster) && (this.eastermask = m5(t, r.byeaster));
    }),
    Object.defineProperty(e.prototype, "lastyear", {
      get: function () {
        return this.monthinfo ? this.monthinfo.lastyear : null;
      },
      enumerable: !1,
      configurable: !0,
    }),
    Object.defineProperty(e.prototype, "lastmonth", {
      get: function () {
        return this.monthinfo ? this.monthinfo.lastmonth : null;
      },
      enumerable: !1,
      configurable: !0,
    }),
    Object.defineProperty(e.prototype, "yearlen", {
      get: function () {
        return this.yearinfo.yearlen;
      },
      enumerable: !1,
      configurable: !0,
    }),
    Object.defineProperty(e.prototype, "yearordinal", {
      get: function () {
        return this.yearinfo.yearordinal;
      },
      enumerable: !1,
      configurable: !0,
    }),
    Object.defineProperty(e.prototype, "mrange", {
      get: function () {
        return this.yearinfo.mrange;
      },
      enumerable: !1,
      configurable: !0,
    }),
    Object.defineProperty(e.prototype, "wdaymask", {
      get: function () {
        return this.yearinfo.wdaymask;
      },
      enumerable: !1,
      configurable: !0,
    }),
    Object.defineProperty(e.prototype, "mmask", {
      get: function () {
        return this.yearinfo.mmask;
      },
      enumerable: !1,
      configurable: !0,
    }),
    Object.defineProperty(e.prototype, "wnomask", {
      get: function () {
        return this.yearinfo.wnomask;
      },
      enumerable: !1,
      configurable: !0,
    }),
    Object.defineProperty(e.prototype, "nwdaymask", {
      get: function () {
        return this.monthinfo ? this.monthinfo.nwdaymask : [];
      },
      enumerable: !1,
      configurable: !0,
    }),
    Object.defineProperty(e.prototype, "nextyearlen", {
      get: function () {
        return this.yearinfo.nextyearlen;
      },
      enumerable: !1,
      configurable: !0,
    }),
    Object.defineProperty(e.prototype, "mdaymask", {
      get: function () {
        return this.yearinfo.mdaymask;
      },
      enumerable: !1,
      configurable: !0,
    }),
    Object.defineProperty(e.prototype, "nmdaymask", {
      get: function () {
        return this.yearinfo.nmdaymask;
      },
      enumerable: !1,
      configurable: !0,
    }),
    (e.prototype.ydayset = function () {
      return [yn(this.yearlen), 0, this.yearlen];
    }),
    (e.prototype.mdayset = function (t, n) {
      for (
        var r = this.mrange[n - 1],
          o = this.mrange[n],
          s = Ce(null, this.yearlen),
          i = r;
        i < o;
        i++
      )
        s[i] = i;
      return [s, r, o];
    }),
    (e.prototype.wdayset = function (t, n, r) {
      for (
        var o = Ce(null, this.yearlen + 7),
          s = $p(io(t, n, r)) - this.yearordinal,
          i = s,
          a = 0;
        a < 7 && ((o[s] = s), ++s, this.wdaymask[s] !== this.options.wkst);
        a++
      );
      return [o, i, s];
    }),
    (e.prototype.ddayset = function (t, n, r) {
      var o = Ce(null, this.yearlen),
        s = $p(io(t, n, r)) - this.yearordinal;
      return ((o[s] = s), [o, s, s + 1]);
    }),
    (e.prototype.htimeset = function (t, n, r, o) {
      var s = this,
        i = [];
      return (
        this.options.byminute.forEach(function (a) {
          i = i.concat(s.mtimeset(t, a, r, o));
        }),
        fc(i),
        i
      );
    }),
    (e.prototype.mtimeset = function (t, n, r, o) {
      var s = this.options.bysecond.map(function (i) {
        return new Hu(t, n, i, o);
      });
      return (fc(s), s);
    }),
    (e.prototype.stimeset = function (t, n, r, o) {
      return [new Hu(t, n, r, o)];
    }),
    (e.prototype.getdayset = function (t) {
      switch (t) {
        case be.YEARLY:
          return this.ydayset.bind(this);
        case be.MONTHLY:
          return this.mdayset.bind(this);
        case be.WEEKLY:
          return this.wdayset.bind(this);
        case be.DAILY:
          return this.ddayset.bind(this);
        default:
          return this.ddayset.bind(this);
      }
    }),
    (e.prototype.gettimeset = function (t) {
      switch (t) {
        case be.HOURLY:
          return this.htimeset.bind(this);
        case be.MINUTELY:
          return this.mtimeset.bind(this);
        case be.SECONDLY:
          return this.stimeset.bind(this);
      }
    }),
    e
  );
})();
function g5(e, t, n, r, o, s) {
  for (var i = [], a = 0; a < e.length; a++) {
    var c = void 0,
      l = void 0,
      f = e[a];
    f < 0
      ? ((c = Math.floor(f / t.length)), (l = Ht(f, t.length)))
      : ((c = Math.floor((f - 1) / t.length)), (l = Ht(f - 1, t.length)));
    for (var d = [], u = n; u < r; u++) {
      var _ = s[u];
      ze(_) && d.push(_);
    }
    var p = void 0;
    c < 0 ? (p = d.slice(c)[0]) : (p = d[c]);
    var E = t[l],
      h = UL(o.yearordinal + p),
      T = kL(h, E);
    we(i, T) || i.push(T);
  }
  return (fc(i), i);
}
function xL(e, t) {
  var n = t.dtstart,
    r = t.freq,
    o = t.interval,
    s = t.until,
    i = t.bysetpos,
    a = t.count;
  if (a === 0 || o === 0) return Ln(e);
  var c = zQ.fromDate(n),
    l = new A5(t);
  l.rebuild(c.year, c.month);
  for (var f = y5(l, c, t); ; ) {
    var d = l.getdayset(r)(c.year, c.month, c.day),
      u = d[0],
      _ = d[1],
      p = d[2],
      E = N5(u, _, p, l, t);
    if (rt(i))
      for (var h = g5(i, f, _, p, l, u), T = 0; T < h.length; T++) {
        var m = h[T];
        if (s && m > s) return Ln(e);
        if (m >= n) {
          var A = rb(m, t);
          if (!e.accept(A) || (a && (--a, !a))) return Ln(e);
        }
      }
    else
      for (var T = _; T < p; T++) {
        var g = u[T];
        if (ze(g))
          for (var N = UL(l.yearordinal + g), O = 0; O < f.length; O++) {
            var I = f[O],
              m = kL(N, I);
            if (s && m > s) return Ln(e);
            if (m >= n) {
              var A = rb(m, t);
              if (!e.accept(A) || (a && (--a, !a))) return Ln(e);
            }
          }
      }
    if (t.interval === 0 || (c.add(t, E), c.year > LL)) return Ln(e);
    (Ah(r) || (f = l.gettimeset(r)(c.hour, c.minute, c.second, 0)),
      l.rebuild(c.year, c.month));
  }
}
function R5(e, t, n) {
  var r = n.bymonth,
    o = n.byweekno,
    s = n.byweekday,
    i = n.byeaster,
    a = n.bymonthday,
    c = n.bynmonthday,
    l = n.byyearday;
  return (
    (rt(r) && !we(r, e.mmask[t])) ||
    (rt(o) && !e.wnomask[t]) ||
    (rt(s) && !we(s, e.wdaymask[t])) ||
    (rt(e.nwdaymask) && !e.nwdaymask[t]) ||
    (i !== null && !we(e.eastermask, t)) ||
    ((rt(a) || rt(c)) && !we(a, e.mdaymask[t]) && !we(c, e.nmdaymask[t])) ||
    (rt(l) &&
      ((t < e.yearlen && !we(l, t + 1) && !we(l, -e.yearlen + t)) ||
        (t >= e.yearlen &&
          !we(l, t + 1 - e.yearlen) &&
          !we(l, -e.nextyearlen + t - e.yearlen))))
  );
}
function rb(e, t) {
  return new Yu(e, t.tzid).rezonedDate();
}
function Ln(e) {
  return e.getValue();
}
function N5(e, t, n, r, o) {
  for (var s = !1, i = t; i < n; i++) {
    var a = e[i];
    ((s = R5(r, a, o)), s && (e[a] = null));
  }
  return s;
}
function y5(e, t, n) {
  var r = n.freq,
    o = n.byhour,
    s = n.byminute,
    i = n.bysecond;
  return Ah(r)
    ? XQ(n)
    : (r >= pe.HOURLY && rt(o) && !we(o, t.hour)) ||
        (r >= pe.MINUTELY && rt(s) && !we(s, t.minute)) ||
        (r >= pe.SECONDLY && rt(i) && !we(i, t.second))
      ? []
      : e.gettimeset(r)(t.hour, t.minute, t.second, t.millisecond);
}
var rn = {
    MO: new gt(0),
    TU: new gt(1),
    WE: new gt(2),
    TH: new gt(3),
    FR: new gt(4),
    SA: new gt(5),
    SU: new gt(6),
  },
  gh = {
    freq: be.YEARLY,
    dtstart: null,
    interval: 1,
    wkst: rn.MO,
    count: null,
    until: null,
    tzid: null,
    bysetpos: null,
    bymonth: null,
    bymonthday: null,
    bynmonthday: null,
    byyearday: null,
    byweekno: null,
    byweekday: null,
    bynweekday: null,
    byhour: null,
    byminute: null,
    bysecond: null,
    byeaster: null,
  },
  O5 = Object.keys(gh),
  pe = (function () {
    function e(t, n) {
      (t === void 0 && (t = {}),
        n === void 0 && (n = !1),
        (this._cache = n ? null : new r5()),
        (this.origOptions = VL(t)));
      var r = ZQ(t).parsedOptions;
      this.options = r;
    }
    return (
      (e.parseText = function (t, n) {
        return GL(t, n);
      }),
      (e.fromText = function (t, n) {
        return qQ(t, n);
      }),
      (e.fromString = function (t) {
        return new e(e.parseString(t) || void 0);
      }),
      (e.prototype._iter = function (t) {
        return xL(t, this.options);
      }),
      (e.prototype._cacheGet = function (t, n) {
        return this._cache ? this._cache._cacheGet(t, n) : !1;
      }),
      (e.prototype._cacheAdd = function (t, n, r) {
        if (this._cache) return this._cache._cacheAdd(t, n, r);
      }),
      (e.prototype.all = function (t) {
        if (t) return this._iter(new QC("all", {}, t));
        var n = this._cacheGet("all");
        return (
          n === !1 &&
            ((n = this._iter(new Co("all", {}))), this._cacheAdd("all", n)),
          n
        );
      }),
      (e.prototype.between = function (t, n, r, o) {
        if ((r === void 0 && (r = !1), !ja(t) || !ja(n)))
          throw new Error("Invalid date passed in to RRule.between");
        var s = {
          before: n,
          after: t,
          inc: r,
        };
        if (o) return this._iter(new QC("between", s, o));
        var i = this._cacheGet("between", s);
        return (
          i === !1 &&
            ((i = this._iter(new Co("between", s))),
            this._cacheAdd("between", i, s)),
          i
        );
      }),
      (e.prototype.before = function (t, n) {
        if ((n === void 0 && (n = !1), !ja(t)))
          throw new Error("Invalid date passed in to RRule.before");
        var r = {
            dt: t,
            inc: n,
          },
          o = this._cacheGet("before", r);
        return (
          o === !1 &&
            ((o = this._iter(new Co("before", r))),
            this._cacheAdd("before", o, r)),
          o
        );
      }),
      (e.prototype.after = function (t, n) {
        if ((n === void 0 && (n = !1), !ja(t)))
          throw new Error("Invalid date passed in to RRule.after");
        var r = {
            dt: t,
            inc: n,
          },
          o = this._cacheGet("after", r);
        return (
          o === !1 &&
            ((o = this._iter(new Co("after", r))),
            this._cacheAdd("after", o, r)),
          o
        );
      }),
      (e.prototype.count = function () {
        return this.all().length;
      }),
      (e.prototype.toString = function () {
        return Fp(this.origOptions);
      }),
      (e.prototype.toText = function (t, n, r) {
        return WQ(this, t, n, r);
      }),
      (e.prototype.isFullyConvertibleToText = function () {
        return KQ(this);
      }),
      (e.prototype.clone = function () {
        return new e(this.origOptions);
      }),
      (e.FREQUENCIES = [
        "YEARLY",
        "MONTHLY",
        "WEEKLY",
        "DAILY",
        "HOURLY",
        "MINUTELY",
        "SECONDLY",
      ]),
      (e.YEARLY = be.YEARLY),
      (e.MONTHLY = be.MONTHLY),
      (e.WEEKLY = be.WEEKLY),
      (e.DAILY = be.DAILY),
      (e.HOURLY = be.HOURLY),
      (e.MINUTELY = be.MINUTELY),
      (e.SECONDLY = be.SECONDLY),
      (e.MO = rn.MO),
      (e.TU = rn.TU),
      (e.WE = rn.WE),
      (e.TH = rn.TH),
      (e.FR = rn.FR),
      (e.SA = rn.SA),
      (e.SU = rn.SU),
      (e.parseString = Hp),
      (e.optionsToString = Fp),
      e
    );
  })();
function C5(e, t, n, r, o, s) {
  var i = {},
    a = e.accept;
  function c(u, _) {
    n.forEach(function (p) {
      p.between(u, _, !0).forEach(function (E) {
        i[Number(E)] = !0;
      });
    });
  }
  (o.forEach(function (u) {
    var _ = new Yu(u, s).rezonedDate();
    i[Number(_)] = !0;
  }),
    (e.accept = function (u) {
      var _ = Number(u);
      return isNaN(_)
        ? a.call(this, u)
        : !i[_] && (c(new Date(_ - 1), new Date(_ + 1)), !i[_])
          ? ((i[_] = !0), a.call(this, u))
          : !0;
    }),
    e.method === "between" &&
      (c(e.args.after, e.args.before),
      (e.accept = function (u) {
        var _ = Number(u);
        return i[_] ? !0 : ((i[_] = !0), a.call(this, u));
      })));
  for (var l = 0; l < r.length; l++) {
    var f = new Yu(r[l], s).rezonedDate();
    if (!e.accept(new Date(f.getTime()))) break;
  }
  t.forEach(function (u) {
    xL(e, u.options);
  });
  var d = e._result;
  switch ((fc(d), e.method)) {
    case "all":
    case "between":
      return d;
    case "before":
      return (d.length && d[d.length - 1]) || null;
    case "after":
    default:
      return (d.length && d[0]) || null;
  }
}
var ob = {
  dtstart: null,
  cache: !1,
  unfold: !1,
  forceset: !1,
  compatible: !1,
  tzid: null,
};
function b5(e, t) {
  var n = [],
    r = [],
    o = [],
    s = [],
    i = Fu(e),
    a = i.dtstart,
    c = i.tzid,
    l = L5(e, t.unfold);
  return (
    l.forEach(function (f) {
      var d;
      if (f) {
        var u = v5(f),
          _ = u.name,
          p = u.parms,
          E = u.value;
        switch (_.toUpperCase()) {
          case "RRULE":
            if (p.length)
              throw new Error("unsupported RRULE parm: ".concat(p.join(",")));
            n.push(Hp(f));
            break;
          case "RDATE":
            var h =
                (d = /RDATE(?:;TZID=([^:=]+))?/i.exec(f)) !== null &&
                d !== void 0
                  ? d
                  : [],
              T = h[1];
            (T && !c && (c = T), (r = r.concat(ib(E, p))));
            break;
          case "EXRULE":
            if (p.length)
              throw new Error("unsupported EXRULE parm: ".concat(p.join(",")));
            o.push(Hp(E));
            break;
          case "EXDATE":
            s = s.concat(ib(E, p));
            break;
          case "DTSTART":
            break;
          default:
            throw new Error("unsupported property: " + _);
        }
      }
    }),
    {
      dtstart: a,
      tzid: c,
      rrulevals: n,
      rdatevals: r,
      exrulevals: o,
      exdatevals: s,
    }
  );
}
function I5(e, t) {
  var n = b5(e, t),
    r = n.rrulevals,
    o = n.rdatevals,
    s = n.exrulevals,
    i = n.exdatevals,
    a = n.dtstart,
    c = n.tzid,
    l = t.cache === !1;
  if (
    (t.compatible && ((t.forceset = !0), (t.unfold = !0)),
    t.forceset || r.length > 1 || o.length || s.length || i.length)
  ) {
    var f = new w5(l);
    return (
      f.dtstart(a),
      f.tzid(c || void 0),
      r.forEach(function (u) {
        f.rrule(new pe(z_(u, a, c), l));
      }),
      o.forEach(function (u) {
        f.rdate(u);
      }),
      s.forEach(function (u) {
        f.exrule(new pe(z_(u, a, c), l));
      }),
      i.forEach(function (u) {
        f.exdate(u);
      }),
      t.compatible && t.dtstart && f.rdate(a),
      f
    );
  }
  var d = r[0] || {};
  return new pe(z_(d, d.dtstart || t.dtstart || a, d.tzid || t.tzid || c), l);
}
function sb(e, t) {
  return (t === void 0 && (t = {}), I5(e, P5(t)));
}
function z_(e, t, n) {
  return an(an({}, e), {
    dtstart: t,
    tzid: n,
  });
}
function P5(e) {
  var t = [],
    n = Object.keys(e),
    r = Object.keys(ob);
  if (
    (n.forEach(function (o) {
      we(r, o) || t.push(o);
    }),
    t.length)
  )
    throw new Error("Invalid options: " + t.join(", "));
  return an(an({}, ob), e);
}
function M5(e) {
  if (e.indexOf(":") === -1)
    return {
      name: "RRULE",
      value: e,
    };
  var t = wQ(e, ":", 1),
    n = t[0],
    r = t[1];
  return {
    name: n,
    value: r,
  };
}
function v5(e) {
  var t = M5(e),
    n = t.name,
    r = t.value,
    o = n.split(";");
  if (!o) throw new Error("empty property name");
  return {
    name: o[0].toUpperCase(),
    parms: o.slice(1),
    value: r,
  };
}
function L5(e, t) {
  if ((t === void 0 && (t = !1), (e = e && e.trim()), !e))
    throw new Error("Invalid empty string");
  if (!t) return e.split(/\s/);
  for (
    var n = e.split(`
`),
      r = 0;
    r < n.length;
  ) {
    var o = (n[r] = n[r].replace(/\s+$/g, ""));
    o
      ? r > 0 && o[0] === " "
        ? ((n[r - 1] += o.slice(1)), n.splice(r, 1))
        : (r += 1)
      : n.splice(r, 1);
  }
  return n;
}
function D5(e) {
  e.forEach(function (t) {
    if (!/(VALUE=DATE(-TIME)?)|(TZID=)/.test(t))
      throw new Error("unsupported RDATE/EXDATE parm: " + t);
  });
}
function ib(e, t) {
  return (
    D5(t),
    e.split(",").map(function (n) {
      return Sh(n);
    })
  );
}
function ab(e) {
  var t = this;
  return function (n) {
    if ((n !== void 0 && (t["_".concat(e)] = n), t["_".concat(e)] !== void 0))
      return t["_".concat(e)];
    for (var r = 0; r < t._rrule.length; r++) {
      var o = t._rrule[r].origOptions[e];
      if (o) return o;
    }
  };
}
var w5 = (function (e) {
  mh(t, e);
  function t(n) {
    n === void 0 && (n = !1);
    var r = e.call(this, {}, n) || this;
    return (
      (r.dtstart = ab.apply(r, ["dtstart"])),
      (r.tzid = ab.apply(r, ["tzid"])),
      (r._rrule = []),
      (r._rdate = []),
      (r._exrule = []),
      (r._exdate = []),
      r
    );
  }
  return (
    (t.prototype._iter = function (n) {
      return C5(
        n,
        this._rrule,
        this._exrule,
        this._rdate,
        this._exdate,
        this.tzid(),
      );
    }),
    (t.prototype.rrule = function (n) {
      cb(n, this._rrule);
    }),
    (t.prototype.exrule = function (n) {
      cb(n, this._exrule);
    }),
    (t.prototype.rdate = function (n) {
      ub(n, this._rdate);
    }),
    (t.prototype.exdate = function (n) {
      ub(n, this._exdate);
    }),
    (t.prototype.rrules = function () {
      return this._rrule.map(function (n) {
        return sb(n.toString());
      });
    }),
    (t.prototype.exrules = function () {
      return this._exrule.map(function (n) {
        return sb(n.toString());
      });
    }),
    (t.prototype.rdates = function () {
      return this._rdate.map(function (n) {
        return new Date(n.getTime());
      });
    }),
    (t.prototype.exdates = function () {
      return this._exdate.map(function (n) {
        return new Date(n.getTime());
      });
    }),
    (t.prototype.valueOf = function () {
      var n = [];
      return (
        !this._rrule.length &&
          this._dtstart &&
          (n = n.concat(
            Fp({
              dtstart: this._dtstart,
            }),
          )),
        this._rrule.forEach(function (r) {
          n = n.concat(
            r.toString().split(`
`),
          );
        }),
        this._exrule.forEach(function (r) {
          n = n.concat(
            r
              .toString()
              .split(
                `
`,
              )
              .map(function (o) {
                return o.replace(/^RRULE:/, "EXRULE:");
              })
              .filter(function (o) {
                return !/^DTSTART/.test(o);
              }),
          );
        }),
        this._rdate.length && n.push(lb("RDATE", this._rdate, this.tzid())),
        this._exdate.length && n.push(lb("EXDATE", this._exdate, this.tzid())),
        n
      );
    }),
    (t.prototype.toString = function () {
      return this.valueOf().join(`
`);
    }),
    (t.prototype.clone = function () {
      var n = new t(!!this._cache);
      return (
        this._rrule.forEach(function (r) {
          return n.rrule(r.clone());
        }),
        this._exrule.forEach(function (r) {
          return n.exrule(r.clone());
        }),
        this._rdate.forEach(function (r) {
          return n.rdate(new Date(r.getTime()));
        }),
        this._exdate.forEach(function (r) {
          return n.exdate(new Date(r.getTime()));
        }),
        n
      );
    }),
    t
  );
})(pe);
function cb(e, t) {
  if (!(e instanceof pe))
    throw new TypeError(String(e) + " is not RRule instance");
  we(t.map(String), String(e)) || t.push(e);
}
function ub(e, t) {
  if (!(e instanceof Date))
    throw new TypeError(String(e) + " is not Date instance");
  we(t.map(Number), Number(e)) || (t.push(e), fc(t));
}
function lb(e, t, n) {
  var r = !n || n.toUpperCase() === "UTC",
    o = r ? "".concat(e, ":") : "".concat(e, ";TZID=").concat(n, ":"),
    s = t
      .map(function (i) {
        return Th(i.valueOf(), r);
      })
      .join(",");
  return "".concat(o).concat(s);
} /*!
 * Copyright (c) Squirrel Chat et al., All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its contributors
 *    may be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
function U5(e, t) {
  let n = e.slice(0, t).split(/\r\n|\n|\r/g);
  return [n.length, n.pop().length + 1];
}
function k5(e, t, n) {
  let r = e.split(/\r\n|\n|\r/g),
    o = "",
    s = (Math.log10(t + 1) | 0) + 1;
  for (let i = t - 1; i <= t + 1; i++) {
    let a = r[i - 1];
    a &&
      ((o += i.toString().padEnd(s, " ")),
      (o += ":  "),
      (o += a),
      (o += `
`),
      i === t &&
        ((o += " ".repeat(s + n + 2)),
        (o += `^
`)));
  }
  return o;
}
class ge extends Error {
  line;
  column;
  codeblock;
  constructor(t, n) {
    const [r, o] = U5(n.toml, n.ptr),
      s = k5(n.toml, r, o);
    (super(
      `Invalid TOML document: ${t}

${s}`,
      n,
    ),
      (this.line = r),
      (this.column = o),
      (this.codeblock = s));
  }
} /*!
 * Copyright (c) Squirrel Chat et al., All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its contributors
 *    may be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
function G5(e, t) {
  let n = 0;
  for (; e[t - ++n] === "\\"; );
  return --n && n % 2;
}
function ju(e, t = 0, n = e.length) {
  let r = e.indexOf(
    `
`,
    t,
  );
  return (e[r - 1] === "\r" && r--, r <= n ? r : -1);
}
function Rh(e, t) {
  for (let n = t; n < e.length; n++) {
    let r = e[n];
    if (
      r ===
      `
`
    )
      return n;
    if (
      r === "\r" &&
      e[n + 1] ===
        `
`
    )
      return n + 1;
    if ((r < " " && r !== "	") || r === "")
      throw new ge("control characters are not allowed in comments", {
        toml: e,
        ptr: t,
      });
  }
  return e.length;
}
function xn(e, t, n, r) {
  let o;
  for (
    ;
    (o = e[t]) === " " ||
    o === "	" ||
    (!n &&
      (o ===
        `
` ||
        (o === "\r" &&
          e[t + 1] ===
            `
`)));
  )
    t++;
  return r || o !== "#" ? t : xn(e, Rh(e, t), n);
}
function db(e, t, n, r, o = !1) {
  if (!r) return ((t = ju(e, t)), t < 0 ? e.length : t);
  for (let s = t; s < e.length; s++) {
    let i = e[s];
    if (i === "#") s = ju(e, s);
    else {
      if (i === n) return s + 1;
      if (
        i === r ||
        (o &&
          (i ===
            `
` ||
            (i === "\r" &&
              e[s + 1] ===
                `
`)))
      )
        return s;
    }
  }
  throw new ge("cannot find end of structure", {
    toml: e,
    ptr: t,
  });
}
function $L(e, t) {
  let n = e[t],
    r = n === e[t + 1] && e[t + 1] === e[t + 2] ? e.slice(t, t + 3) : n;
  t += r.length - 1;
  do t = e.indexOf(r, ++t);
  while (t > -1 && n !== "'" && G5(e, t));
  return (
    t > -1 &&
      ((t += r.length), r.length > 1 && (e[t] === n && t++, e[t] === n && t++)),
    t
  );
} /*!
 * Copyright (c) Squirrel Chat et al., All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its contributors
 *    may be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
let V5 =
  /^(\d{4}-\d{2}-\d{2})?[T ]?(?:(\d{2}):\d{2}:\d{2}(?:\.\d+)?)?(Z|[-+]\d{2}:\d{2})?$/i;
class bo extends Date {
  #e = !1;
  #t = !1;
  #r = null;
  constructor(t) {
    let n = !0,
      r = !0,
      o = "Z";
    if (typeof t == "string") {
      let s = t.match(V5);
      s
        ? (s[1] || ((n = !1), (t = `0000-01-01T${t}`)),
          (r = !!s[2]),
          r && t[10] === " " && (t = t.replace(" ", "T")),
          s[2] && +s[2] > 23
            ? (t = "")
            : ((o = s[3] || null),
              (t = t.toUpperCase()),
              !o && r && (t += "Z")))
        : (t = "");
    }
    (super(t),
      isNaN(this.getTime()) || ((this.#e = n), (this.#t = r), (this.#r = o)));
  }
  isDateTime() {
    return this.#e && this.#t;
  }
  isLocal() {
    return !this.#e || !this.#t || !this.#r;
  }
  isDate() {
    return this.#e && !this.#t;
  }
  isTime() {
    return this.#t && !this.#e;
  }
  isValid() {
    return this.#e || this.#t;
  }
  toISOString() {
    let t = super.toISOString();
    if (this.isDate()) return t.slice(0, 10);
    if (this.isTime()) return t.slice(11, 23);
    if (this.#r === null) return t.slice(0, -1);
    if (this.#r === "Z") return t;
    let n = +this.#r.slice(1, 3) * 60 + +this.#r.slice(4, 6);
    return (
      (n = this.#r[0] === "-" ? n : -n),
      new Date(this.getTime() - n * 6e4).toISOString().slice(0, -1) + this.#r
    );
  }
  static wrapAsOffsetDateTime(t, n = "Z") {
    let r = new bo(t);
    return ((r.#r = n), r);
  }
  static wrapAsLocalDateTime(t) {
    let n = new bo(t);
    return ((n.#r = null), n);
  }
  static wrapAsLocalDate(t) {
    let n = new bo(t);
    return ((n.#t = !1), (n.#r = null), n);
  }
  static wrapAsLocalTime(t) {
    let n = new bo(t);
    return ((n.#e = !1), (n.#r = null), n);
  }
} /*!
 * Copyright (c) Squirrel Chat et al., All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its contributors
 *    may be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
let x5 = /^((0x[0-9a-fA-F](_?[0-9a-fA-F])*)|(([+-]|0[ob])?\d(_?\d)*))$/,
  $5 = /^[+-]?\d(_?\d)*(\.\d(_?\d)*)?([eE][+-]?\d(_?\d)*)?$/,
  B5 = /^[+-]?0[0-9_]/,
  H5 = /^[0-9a-f]{4,8}$/i,
  fb = {
    b: "\b",
    t: "	",
    n: `
`,
    f: "\f",
    r: "\r",
    '"': '"',
    "\\": "\\",
  };
function BL(e, t = 0, n = e.length) {
  let r = e[t] === "'",
    o = e[t++] === e[t] && e[t] === e[t + 1];
  o &&
    ((n -= 2),
    e[(t += 2)] === "\r" && t++,
    e[t] ===
      `
` && t++);
  let s = 0,
    i,
    a = "",
    c = t;
  for (; t < n - 1; ) {
    let l = e[t++];
    if (
      l ===
        `
` ||
      (l === "\r" &&
        e[t] ===
          `
`)
    ) {
      if (!o)
        throw new ge("newlines are not allowed in strings", {
          toml: e,
          ptr: t - 1,
        });
    } else if ((l < " " && l !== "	") || l === "")
      throw new ge("control characters are not allowed in strings", {
        toml: e,
        ptr: t - 1,
      });
    if (i) {
      if (((i = !1), l === "u" || l === "U")) {
        let f = e.slice(t, (t += l === "u" ? 4 : 8));
        if (!H5.test(f))
          throw new ge("invalid unicode escape", {
            toml: e,
            ptr: s,
          });
        try {
          a += String.fromCodePoint(parseInt(f, 16));
        } catch {
          throw new ge("invalid unicode escape", {
            toml: e,
            ptr: s,
          });
        }
      } else if (
        o &&
        (l ===
          `
` ||
          l === " " ||
          l === "	" ||
          l === "\r")
      ) {
        if (
          ((t = xn(e, t - 1, !0)),
          e[t] !==
            `
` && e[t] !== "\r")
        )
          throw new ge(
            "invalid escape: only line-ending whitespace may be escaped",
            {
              toml: e,
              ptr: s,
            },
          );
        t = xn(e, t);
      } else if (l in fb) a += fb[l];
      else
        throw new ge("unrecognized escape sequence", {
          toml: e,
          ptr: s,
        });
      c = t;
    } else !r && l === "\\" && ((s = t - 1), (i = !0), (a += e.slice(c, s)));
  }
  return a + e.slice(c, n - 1);
}
function F5(e, t, n, r) {
  if (e === "true") return !0;
  if (e === "false") return !1;
  if (e === "-inf") return -1 / 0;
  if (e === "inf" || e === "+inf") return 1 / 0;
  if (e === "nan" || e === "+nan" || e === "-nan") return NaN;
  if (e === "-0") return r ? 0n : 0;
  let o = x5.test(e);
  if (o || $5.test(e)) {
    if (B5.test(e))
      throw new ge("leading zeroes are not allowed", {
        toml: t,
        ptr: n,
      });
    e = e.replace(/_/g, "");
    let i = +e;
    if (isNaN(i))
      throw new ge("invalid number", {
        toml: t,
        ptr: n,
      });
    if (o) {
      if ((o = !Number.isSafeInteger(i)) && !r)
        throw new ge("integer value cannot be represented losslessly", {
          toml: t,
          ptr: n,
        });
      (o || r === !0) && (i = BigInt(e));
    }
    return i;
  }
  const s = new bo(e);
  if (!s.isValid())
    throw new ge("invalid value", {
      toml: t,
      ptr: n,
    });
  return s;
} /*!
 * Copyright (c) Squirrel Chat et al., All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its contributors
 *    may be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
function Y5(e, t, n, r) {
  let o = e.slice(t, n),
    s = o.indexOf("#");
  s > -1 && (Rh(e, s), (o = o.slice(0, s)));
  let i = o.trimEnd();
  if (!r) {
    let a = o.indexOf(
      `
`,
      i.length,
    );
    if (a > -1)
      throw new ge("newlines are not allowed in inline tables", {
        toml: e,
        ptr: t + a,
      });
  }
  return [i, s];
}
function Nh(e, t, n, r, o) {
  if (r === 0)
    throw new ge("document contains excessively nested structures. aborting.", {
      toml: e,
      ptr: t,
    });
  let s = e[t];
  if (s === "[" || s === "{") {
    let [c, l] = s === "[" ? W5(e, t, r, o) : q5(e, t, r, o),
      f = n ? db(e, l, ",", n) : l;
    if (l - f && n === "}") {
      let d = ju(e, l, f);
      if (d > -1)
        throw new ge("newlines are not allowed in inline tables", {
          toml: e,
          ptr: d,
        });
    }
    return [c, f];
  }
  let i;
  if (s === '"' || s === "'") {
    i = $L(e, t);
    let c = BL(e, t, i);
    if (n) {
      if (
        ((i = xn(e, i, n !== "]")),
        e[i] &&
          e[i] !== "," &&
          e[i] !== n &&
          e[i] !==
            `
` &&
          e[i] !== "\r")
      )
        throw new ge("unexpected character encountered", {
          toml: e,
          ptr: i,
        });
      i += +(e[i] === ",");
    }
    return [c, i];
  }
  i = db(e, t, ",", n);
  let a = Y5(e, t, i - +(e[i - 1] === ","), n === "]");
  if (!a[0])
    throw new ge("incomplete key-value declaration: no value specified", {
      toml: e,
      ptr: t,
    });
  return (
    n && a[1] > -1 && ((i = xn(e, t + a[1])), (i += +(e[i] === ","))),
    [F5(a[0], e, t, o), i]
  );
} /*!
 * Copyright (c) Squirrel Chat et al., All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its contributors
 *    may be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
let j5 = /^[a-zA-Z0-9-_]+[ \t]*$/;
function Yp(e, t, n = "=") {
  let r = t - 1,
    o = [],
    s = e.indexOf(n, t);
  if (s < 0)
    throw new ge("incomplete key-value: cannot find end of key", {
      toml: e,
      ptr: t,
    });
  do {
    let i = e[(t = ++r)];
    if (i !== " " && i !== "	")
      if (i === '"' || i === "'") {
        if (i === e[t + 1] && i === e[t + 2])
          throw new ge("multiline strings are not allowed in keys", {
            toml: e,
            ptr: t,
          });
        let a = $L(e, t);
        if (a < 0)
          throw new ge("unfinished string encountered", {
            toml: e,
            ptr: t,
          });
        r = e.indexOf(".", a);
        let c = e.slice(a, r < 0 || r > s ? s : r),
          l = ju(c);
        if (l > -1)
          throw new ge("newlines are not allowed in keys", {
            toml: e,
            ptr: t + r + l,
          });
        if (c.trimStart())
          throw new ge("found extra tokens after the string part", {
            toml: e,
            ptr: a,
          });
        if (s < a && ((s = e.indexOf(n, a)), s < 0))
          throw new ge("incomplete key-value: cannot find end of key", {
            toml: e,
            ptr: t,
          });
        o.push(BL(e, t, a));
      } else {
        r = e.indexOf(".", t);
        let a = e.slice(t, r < 0 || r > s ? s : r);
        if (!j5.test(a))
          throw new ge(
            "only letter, numbers, dashes and underscores are allowed in keys",
            {
              toml: e,
              ptr: t,
            },
          );
        o.push(a.trimEnd());
      }
  } while (r + 1 && r < s);
  return [o, xn(e, s + 1, !0, !0)];
}
function q5(e, t, n, r) {
  let o = {},
    s = new Set(),
    i,
    a = 0;
  for (t++; (i = e[t++]) !== "}" && i; ) {
    let c = {
      toml: e,
      ptr: t - 1,
    };
    if (
      i ===
      `
`
    )
      throw new ge("newlines are not allowed in inline tables", c);
    if (i === "#") throw new ge("inline tables cannot contain comments", c);
    if (i === ",") throw new ge("expected key-value, found comma", c);
    if (i !== " " && i !== "	") {
      let l,
        f = o,
        d = !1,
        [u, _] = Yp(e, t - 1);
      for (let h = 0; h < u.length; h++) {
        if (
          (h && (f = d ? f[l] : (f[l] = {})),
          (l = u[h]),
          (d = Object.hasOwn(f, l)) && (typeof f[l] != "object" || s.has(f[l])))
        )
          throw new ge("trying to redefine an already defined value", {
            toml: e,
            ptr: t,
          });
        !d &&
          l === "__proto__" &&
          Object.defineProperty(f, l, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
          });
      }
      if (d)
        throw new ge("trying to redefine an already defined value", {
          toml: e,
          ptr: t,
        });
      let [p, E] = Nh(e, _, "}", n - 1, r);
      (s.add(p), (f[l] = p), (t = E), (a = e[t - 1] === "," ? t - 1 : 0));
    }
  }
  if (a)
    throw new ge("trailing commas are not allowed in inline tables", {
      toml: e,
      ptr: a,
    });
  if (!i)
    throw new ge("unfinished table encountered", {
      toml: e,
      ptr: t,
    });
  return [o, t];
}
function W5(e, t, n, r) {
  let o = [],
    s;
  for (t++; (s = e[t++]) !== "]" && s; ) {
    if (s === ",")
      throw new ge("expected value, found comma", {
        toml: e,
        ptr: t - 1,
      });
    if (s === "#") t = Rh(e, t);
    else if (
      s !== " " &&
      s !== "	" &&
      s !==
        `
` &&
      s !== "\r"
    ) {
      let i = Nh(e, t - 1, "]", n - 1, r);
      (o.push(i[0]), (t = i[1]));
    }
  }
  if (!s)
    throw new ge("unfinished array encountered", {
      toml: e,
      ptr: t,
    });
  return [o, t];
} /*!
 * Copyright (c) Squirrel Chat et al., All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its contributors
 *    may be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
function _b(e, t, n, r) {
  let o = t,
    s = n,
    i,
    a = !1,
    c;
  for (let l = 0; l < e.length; l++) {
    if (l) {
      if (
        ((o = a ? o[i] : (o[i] = {})),
        (s = (c = s[i]).c),
        r === 0 && (c.t === 1 || c.t === 2))
      )
        return null;
      if (c.t === 2) {
        let f = o.length - 1;
        ((o = o[f]), (s = s[f].c));
      }
    }
    if (((i = e[l]), (a = Object.hasOwn(o, i)) && s[i]?.t === 0 && s[i]?.d))
      return null;
    a ||
      (i === "__proto__" &&
        (Object.defineProperty(o, i, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
        }),
        Object.defineProperty(s, i, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })),
      (s[i] = {
        t: l < e.length - 1 && r === 2 ? 3 : r,
        d: !1,
        i: 0,
        c: {},
      }));
  }
  if (
    ((c = s[i]),
    (c.t !== r && !(r === 1 && c.t === 3)) ||
      (r === 2 &&
        (c.d || ((c.d = !0), (o[i] = [])),
        o[i].push((o = {})),
        (c.c[c.i++] = c =
          {
            t: 1,
            d: !1,
            i: 0,
            c: {},
          })),
      c.d))
  )
    return null;
  if (((c.d = !0), r === 1)) o = a ? o[i] : (o[i] = {});
  else if (r === 0 && a) return null;
  return [i, o, c.c];
}
function K5(e, { maxDepth: t = 1e3, integersAsBigInt: n } = {}) {
  let r = {},
    o = {},
    s = r,
    i = o;
  for (let a = xn(e, 0); a < e.length; ) {
    if (e[a] === "[") {
      let c = e[++a] === "[",
        l = Yp(e, (a += +c), "]");
      if (c) {
        if (e[l[1] - 1] !== "]")
          throw new ge("expected end of table declaration", {
            toml: e,
            ptr: l[1] - 1,
          });
        l[1]++;
      }
      let f = _b(l[0], r, o, c ? 2 : 1);
      if (!f)
        throw new ge("trying to redefine an already defined table or value", {
          toml: e,
          ptr: a,
        });
      ((i = f[2]), (s = f[1]), (a = l[1]));
    } else {
      let c = Yp(e, a),
        l = _b(c[0], s, i, 0);
      if (!l)
        throw new ge("trying to redefine an already defined table or value", {
          toml: e,
          ptr: a,
        });
      let f = Nh(e, c[1], void 0, t, n);
      ((l[1][l[0]] = f[0]), (a = f[1]));
    }
    if (
      ((a = xn(e, a, !0)),
      e[a] &&
        e[a] !==
          `
` &&
        e[a] !== "\r")
    )
      throw new ge(
        "each key-value declaration must be followed by an end-of-line",
        {
          toml: e,
          ptr: a,
        },
      );
    a = xn(e, a);
  }
  return r;
}
function z5(e, t, n) {
  const r = nQ(t),
    o = {
      message: r.message,
      status: Z5(e),
      source: n.source,
      service: n.source,
      env: n.env,
      date: Date.now(),
      logger: {
        name: r.loggerName ?? "app",
      },
      "codex.app_session_id": n.codexAppSessionId,
      usr: n.userInfo,
    };
  return (X5(o, n.buildInfo), o);
}
function Z5(e) {
  switch (e) {
    case "trace":
    case "debug":
      return "debug";
    case "info":
      return "info";
    case "warning":
      return "warn";
    case "error":
      return "error";
  }
}
function X5(e, t) {
  (Z_(e, "build_number", t.buildNumber),
    Z_(e, "version", t.version),
    Z_(e, "app_version", t.version));
}
function Z_(e, t, n) {
  n != null && (e[t] = n);
}
const Q5 = 5e3,
  J5 = 50,
  e6 = 64e3;
class t6 {
  onFlush;
  flushIntervalMs;
  maxBatchSize;
  maxBatchBytes;
  buffer = [];
  bufferBytes = 0;
  flushTimeout = null;
  constructor(t) {
    ((this.onFlush = t.onFlush),
      (this.flushIntervalMs = t.flushIntervalMs ?? Q5),
      (this.maxBatchSize = t.maxBatchSize ?? J5),
      (this.maxBatchBytes = t.maxBatchBytes ?? e6));
  }
  enqueue(t) {
    if (
      (this.buffer.push(t),
      (this.bufferBytes += t.length),
      this.buffer.length >= this.maxBatchSize ||
        this.bufferBytes >= this.maxBatchBytes)
    ) {
      this.flush();
      return;
    }
    this.scheduleFlush();
  }
  flushNow() {
    this.flush();
  }
  scheduleFlush() {
    this.flushTimeout == null &&
      (this.flushTimeout = setTimeout(() => {
        this.flush();
      }, this.flushIntervalMs));
  }
  flush() {
    if (this.buffer.length === 0) {
      this.clearFlushTimeout();
      return;
    }
    const t = this.buffer.splice(0, this.buffer.length);
    ((this.bufferBytes = 0), this.clearFlushTimeout(), this.onFlush(t));
  }
  clearFlushTimeout() {
    this.flushTimeout != null &&
      (clearTimeout(this.flushTimeout), (this.flushTimeout = null));
  }
}
const n6 = "https://chat.openai.com/ces/v1/telemetry/intake",
  r6 = "dummy-token",
  o6 = "browser",
  s6 = 2e3,
  i6 = 3e4,
  a6 = 5;
class c6 {
  options;
  reportFailure;
  batcher;
  queue = [];
  inFlightSend = null;
  retryTimeout = null;
  retryAttempts = 0;
  disabled = !1;
  reportedDisabledReason = !1;
  fetchImpl;
  userInfo = null;
  constructor(t) {
    ((this.options = t),
      (this.reportFailure = t.reportFailure),
      (this.fetchImpl = t.fetchImpl ?? fetch),
      (this.batcher = new t6({
        onFlush: (n) => this.enqueueBatch(n),
      })));
  }
  setUserInfo(t) {
    this.userInfo = t;
  }
  log(t, n) {
    const r = z5(t, n, {
      buildInfo: this.options.buildInfo,
      userInfo: this.userInfo,
      codexAppSessionId: this.options.codexAppSessionId,
      source: this.options.source,
      env: this.options.env,
    });
    this.batcher.enqueue(JSON.stringify(r));
  }
  flushNow() {
    (this.batcher.flushNow(), this.drainQueue());
  }
  enqueueBatch(t) {
    this.disabled ||
      (t.length !== 0 &&
        (this.queue.push({
          requestId: crypto.randomUUID(),
          events: t,
        }),
        this.drainQueue()));
  }
  async drainQueue() {
    if (this.disabled) {
      this.queue.length = 0;
      return;
    }
    if (this.inFlightSend != null || this.retryTimeout != null) return;
    const t = this.queue[0];
    if (t == null) return;
    const n = t.events.join(`
`);
    this.inFlightSend = (async () => {
      try {
        (await this.send(n, t.requestId),
          this.queue.shift(),
          (this.retryAttempts = 0));
      } catch {
        if (this.disabled) {
          this.queue.length = 0;
          return;
        }
        this.scheduleRetry();
      } finally {
        ((this.inFlightSend = null), this.drainQueue());
      }
    })();
  }
  scheduleRetry() {
    if (this.retryTimeout != null) return;
    if (this.retryAttempts >= a6) {
      (this.queue.shift(), (this.retryAttempts = 0), this.drainQueue());
      return;
    }
    this.retryAttempts += 1;
    const t = Math.min(i6, s6 * Math.pow(2, this.retryAttempts - 1));
    this.retryTimeout = setTimeout(() => {
      ((this.retryTimeout = null), this.drainQueue());
    }, t);
  }
  disableWithFailure(t) {
    ((this.disabled = !0),
      !this.reportedDisabledReason &&
        ((this.reportedDisabledReason = !0), this.reportFailure(t)));
  }
  async send(t, n) {
    const r = u6(n),
      o = await this.fetchImpl(r, {
        method: "POST",
        headers: {
          "content-type": "text/plain",
          "x-request-id": n,
        },
        body: Buffer.from(t),
      });
    if (!o.ok) {
      const s = await o.text();
      if (o.status >= 400 && o.status < 500)
        return (
          (o.status === 401 || o.status === 403) &&
            this.disableWithFailure({
              type: "disabled",
              reason: "invalid_client_token",
              status: o.status,
              body: s,
            }),
          o.status
        );
      throw new Error(`[datadog] non-2xx response (${o.status})`);
    }
    return o.status;
  }
}
function u6(e) {
  const n = `/api/v2/logs?${new URLSearchParams({
    ddsource: "browser",
    "dd-api-key": r6,
    "dd-evp-origin": o6,
    "dd-request-id": e,
  }).toString()}`;
  return `${n6}?ddforward=${encodeURIComponent(n)}`;
}
function X_(e, t) {
  let n = null,
    r = null;
  const o = (...s) => {
    ((r = s),
      n && clearTimeout(n),
      (n = setTimeout(() => {
        n = null;
        const i = r;
        ((r = null), i && e(...i));
      }, t)));
  };
  return (
    (o.cancel = () => {
      (n && (clearTimeout(n), (n = null)), (r = null));
    }),
    o
  );
}
function l6(e) {
  const t = (n, r, o) => {
    const s = typeof n == "string" ? new Error(n) : n;
    try {
      e(s, r, o);
    } catch {}
  };
  return {
    report: t,
    reportNonFatal: (n, r) => t(n, "non-fatal", r),
    reportFatal: (n, r) => t(n, "fatal", r),
  };
}
async function d6(e, t) {
  let n;
  try {
    const o = await cr.readFile(e, t);
    ((n = K5(o)), (n = f6(n)));
  } catch (o) {
    return {
      configPath: e,
      cwdRelativeToGitRoot: e,
      type: "error",
      error: new Error(
        `Failed to parse environment config at ${e}: ${String(o)}`,
      ),
    };
  }
  const r = G9.safeParse(n);
  return r.success
    ? {
        configPath: e,
        cwdRelativeToGitRoot: await h6(e, t),
        type: "success",
        environment: p6(r.data),
      }
    : {
        configPath: e,
        cwdRelativeToGitRoot: e,
        type: "error",
        error: new Error(
          `Invalid environment config at ${e}: ${r.error.toString()}`,
        ),
      };
}
function f6(e) {
  return !HL(e) || !Array.isArray(e.actions)
    ? e
    : {
        ...e,
        actions: e.actions.filter((t) => _6(t)),
      };
}
function _6(e) {
  return !HL(e) || typeof e.name != "string" || typeof e.command != "string"
    ? !1
    : e.name.trim().length > 0 && e.command.trim().length > 0;
}
function HL(e) {
  return typeof e == "object" && e != null && !Array.isArray(e);
}
function p6(e) {
  return {
    ...e,
    name: e.name.trim(),
    setup: E6(e.setup),
    actions: e.actions
      ? e.actions.map((t) => ({
          ...t,
          name: t.name.trim(),
          command: t.command.trim(),
        }))
      : void 0,
  };
}
function E6(e) {
  return {
    ...e,
    script: e.script.trim(),
    darwin: e.darwin
      ? {
          script: e.darwin.script.trim(),
        }
      : void 0,
    linux: e.linux
      ? {
          script: e.linux.script.trim(),
        }
      : void 0,
    win32: e.win32
      ? {
          script: e.win32.script.trim(),
        }
      : void 0,
  };
}
async function h6(e, t) {
  const n = ln(t),
    r = await T6(e, t);
  let o = r;
  for (; o !== n.dirname(o) && !(await FL(o, t)); ) o = n.dirname(o);
  const s = n.relative(o, r);
  return s === "" ? "." : s;
}
async function FL(e, t) {
  const n = ln(t);
  try {
    const r = await cr.stat(n.join(e, ".git"), t);
    return r.isDirectory() || r.isFile();
  } catch {
    return !1;
  }
}
async function T6(e, t) {
  const n = ln(t);
  let r = n.dirname(e);
  for (; r !== n.dirname(r); ) {
    if (await S6(r, t)) return r;
    if (await FL(r, t)) return r;
    r = n.dirname(r);
  }
  return e;
}
async function S6(e, t) {
  const n = ln(t);
  try {
    const r = await cr.stat(n.join(e, ".codex"), t);
    return r.isDirectory() || r.isFile();
  } catch {
    return !1;
  }
}
const Q_ = xt("git");
async function re(e, t, n, r = {}) {
  const {
      env: o,
      signal: s,
      timeoutMs: i,
      onStdoutRaw: a,
      onStderrRaw: c,
      maxOutputBytes: l,
      trim: f = !0,
      allowedNonZeroExitCodes: d,
    } = r,
    u = {
      GIT_TERMINAL_PROMPT: "0",
      ...o,
    },
    _ = A6(e, t, n),
    p = tQ(_),
    E = m6(t);
  if (s && s.aborted)
    return {
      command: p,
      success: !1,
      code: null,
      stdout: "",
      stderr: "git process aborted",
    };
  let h = !1,
    T = !1,
    m,
    A = 0;
  const g = crypto.randomUUID().slice(0, 8);
  let N,
    O = "",
    I = "",
    b = null;
  const w = (H, x) => {
    ((A += x.length),
      l != null &&
        A > l &&
        m == null &&
        ((m = {
          stream: H,
          limitBytes: l,
        }),
        Q_().warning(`[${g}] output limit exceeded: ${H} ${A} > ${l}`),
        N.kill()),
      H === "stdout" ? a?.(x) : c?.(x));
  };
  try {
    if (Ue(n)) {
      const H = It(p);
      N = await ar({
        hostConfig: n,
        args: ["bash", "-lc", H],
        env: u,
        stdoutChunkHandler: (x) => w("stdout", x),
        stderrChunkHandler: (x) => w("stderr", x),
      });
    } else
      N = IL({
        args: _,
        cwd: e,
        env: {
          ...process.env,
          ...u,
        },
        stdoutChunkHandler: (H) => w("stdout", H),
        stderrChunkHandler: (H) => w("stderr", H),
      });
  } catch (H) {
    Q_().warning(`[${g}] failed to start git process (${E}, error=${ot(H)})`);
    const x = H instanceof Error ? H.message : "Failed to start git process";
    return {
      command: p,
      success: !1,
      code: null,
      stdout: "",
      stderr: x,
    };
  }
  const L = () => {
    ((T = !0), N.kill());
  };
  s && (s.addEventListener("abort", L), s.aborted && L());
  const j =
    i != null
      ? setTimeout(() => {
          ((h = !0), N.kill());
        }, i)
      : null;
  try {
    const { stdout: H, stderr: x, code: B } = await N.wait();
    if (
      ((O = f ? H.trim() : H),
      (I = f ? x.trim() : x),
      (b = B),
      j && clearTimeout(j),
      s && s.removeEventListener("abort", L),
      T)
    )
      return {
        command: p,
        success: !1,
        code: b,
        stdout: O,
        stderr: I
          ? `${I}
git process aborted`
          : "git process aborted",
        outputLimitExceeded: m,
        process: N,
      };
    const F =
      m == null &&
      b != null &&
      (b === 0 || (Array.isArray(d) && d.includes(b)));
    return (
      F ||
        Q_().warning(
          `[${g}] encountered an error running git command (${E}, code=${b}, stderr=${ot(I)})`,
        ),
      {
        command: p,
        success: F,
        code: b,
        stdout: O,
        stderr: h ? `${I}git process timed out after ${i}ms` : I,
        outputLimitExceeded: m,
        process: N,
      }
    );
  } catch (H) {
    (j && clearTimeout(j), s && s.removeEventListener("abort", L));
    const x = H instanceof Error ? H.message : String(H);
    return {
      command: p,
      success: !1,
      code: b,
      stdout: N?.getStdout().toString("utf8") ?? O,
      stderr: N?.getStderr().toString("utf8") ?? (x ? `${I}${x}` : I),
      outputLimitExceeded: m,
      process: N,
    };
  }
}
function m6(e) {
  return `subcommand=${e[0] ?? "<none>"},args=${e.length}`;
}
function A6(e, t, n) {
  return Ue(n)
    ? ["git", "--no-optional-locks", "-C", e, ...t]
    : ["git", "--no-optional-locks", ...t];
}
async function YL(e, t = null) {
  const n = ln(t),
    { success: r, stdout: o } = await re(e, ["rev-parse", "--git-dir"], t, {
      allowedNonZeroExitCodes: [128],
    });
  return !r || !o ? null : n.isAbsolute(o) ? o : n.resolve(e, o);
}
async function g6(e, t) {
  if (t)
    try {
      const n = posix.join(t, qL);
      if ((await fs.promises.stat(n)).isFile()) return !0;
    } catch {}
  return R6(e);
}
async function R6(e) {
  try {
    const t = await fs.promises.stat(e);
    return t.birthtimeMs > 0 ? t.birthtimeMs < N6 : !0;
  } catch {
    return !1;
  }
}
async function jL(e, t = null) {
  try {
    const n = ln(t),
      r = await YL(e, t);
    if (!r)
      return {
        success: !1,
        error: new Error("Failed to resolve worktree git directory"),
      };
    const o = n.join(r, qL);
    return (
      await cr.writeFile(o, "", t),
      {
        success: !0,
      }
    );
  } catch (n) {
    return {
      success: !1,
      error: n instanceof Error ? n : new Error("Failed to mark worktree"),
    };
  }
}
const qL = "codex-managed",
  N6 = new Date("2026-01-29T00:00:00").getTime();
function Fo(e) {
  return e?.outputLimitExceeded
    ? {
        type: "diff-too-large",
        limitBytes: e.outputLimitExceeded.limitBytes,
      }
    : {
        type: "unknown",
      };
}
const Io = 5 * 1024 * 1024,
  Xa = "origin",
  y6 = [
    "-c",
    "diff.mnemonicPrefix=false",
    "-c",
    "diff.noprefix=false",
    "-c",
    "core.quotePath=false",
  ],
  O6 = [
    "diff",
    "--no-ext-diff",
    "--no-textconv",
    "--color=never",
    "--src-prefix=a/",
    "--dst-prefix=b/",
  ];
async function $n(e, t, n, r = {}) {
  return re(e, [...y6, ...O6, ...(r.binary ? ["--binary"] : []), ...t], n, {
    ...r,
  });
}
const C6 = 8;
async function WL(e, t, n, r) {
  if (!t.success)
    return {
      success: !1,
      error: {
        type: "unknown",
      },
    };
  const o = new AbortController(),
    s = () => {
      o.abort();
    };
  (r?.addEventListener("abort", s), r?.aborted && s());
  const i = t.paths,
    a = [],
    c = Array.from(
      {
        length: i.length,
      },
      () => {},
    );
  let l = 0,
    f = 0,
    d = !1,
    u = null;
  const _ = (A) => {
      d || ((d = !0), (u = A), o.abort());
    },
    p = (A) => {
      A.trim().length === 0 || d || a.push(A);
    },
    E = () => {
      if (!d)
        for (; f < c.length; ) {
          const A = c[f];
          if (A === void 0) return;
          if (((f += 1), !(A == null || A.trim().length === 0) && (p(A), d)))
            return;
        }
    },
    h = () => {
      if (d || l >= i.length) return null;
      const A = i[l],
        g = l;
      return (
        (l += 1),
        {
          index: g,
          path: A,
        }
      );
    },
    T = async () => {
      if (d) return;
      const A = h();
      if (A == null) return;
      const g = await $n(e, ["--no-index", "--", "/dev/null", A.path], n, {
        trim: !1,
        allowedNonZeroExitCodes: [0, 1],
        signal: o.signal,
      });
      if (g.outputLimitExceeded) {
        _(Fo(g));
        return;
      }
      if (!g.success) {
        _(Fo(g));
        return;
      }
      ((c[A.index] = g.stdout.trim().length > 0 ? g.stdout : null),
        E(),
        await T());
    },
    m = Math.min(C6, i.length);
  try {
    await Promise.all(
      Array.from(
        {
          length: m,
        },
        () => T(),
      ),
    );
  } finally {
    r?.removeEventListener("abort", s);
  }
  return u
    ? {
        success: !1,
        error: u,
      }
    : {
        success: !0,
        sections: a,
      };
}
async function jp(e, t, n, { includePaths: r } = {}) {
  const o = await t.getWorktreeRepository(e, n);
  if (!o)
    return {
      type: "error",
      error: {
        type: "unknown",
      },
    };
  const s = await o.getUntrackedPaths(r),
    i = await WL(e, s, n);
  return i.success
    ? {
        type: "success",
        unifiedDiff:
          i.sections.length > 0
            ? i.sections.map((c) => b6(c)).join(`
`)
            : "",
      }
    : {
        type: "error",
        error: i.error,
      };
}
function b6(e) {
  return e.replace(/[\r\n]+$/, "");
}
async function Hl(e, t, n) {
  const { success: r, stdout: o } = await re(e, ["rev-parse", "--git-dir"], t, {
    signal: n,
  });
  return !r || !o ? null : path2.isAbsolute(o) ? o : path2.join(e, o);
}
const I6 = xt("git");
async function yh(e, t, n) {
  if (!Ue(t) && !fs.existsSync(e))
    throw new Error(`ENOENT: path does not exist: ${e}`);
  const {
    success: r,
    stdout: o,
    stderr: s,
    code: i,
  } = await re(e, ["rev-parse", "--show-toplevel"], t, {
    allowedNonZeroExitCodes: [128],
    signal: n,
  });
  if (r && o) return o;
  if (i === 128 && s.toLowerCase().includes("not a git repository"))
    return null;
  throw (
    I6().debug(
      `[getGitRoot] failed to resolve git root: ${s || o || "Unknown error"}`,
    ),
    new Error(`Failed to resolve git root: ${s || o || "Unknown error"}`)
  );
}
const J_ = xt("git");
async function KL(e, t, n) {
  const r = await Hl(e, t, n);
  if (!r)
    return {
      type: "error",
      error: {
        type: "unknown",
      },
    };
  let o = null;
  try {
    o = await fs.promises.mkdtemp(path2.join(os2.tmpdir(), "codex-git-index"));
    const s = path2.join(r, "index"),
      i = path2.join(o, "index");
    await fs.promises.copyFile(s, i).catch((f) => {
      if (f.code !== "ENOENT") throw f;
    });
    const a = {
      GIT_INDEX_FILE: i,
    };
    if (
      !(
        await re(e, ["add", "-u"], t, {
          env: a,
          signal: n,
        })
      ).success
    )
      return (
        J_().warning("Failed to stage uncommitted diff"),
        {
          type: "error",
          error: {
            type: "unknown",
          },
        }
      );
    const l = await $n(e, ["--cached"], t, {
      trim: !1,
      allowedNonZeroExitCodes: [0, 1],
      env: a,
      signal: n,
    });
    return l.outputLimitExceeded || !l.success
      ? (J_().warning("Failed to collect uncommitted diff"),
        {
          type: "error",
          error: Fo(l),
        })
      : {
          type: "success",
          unifiedDiff: l.stdout,
        };
  } catch (s) {
    return (
      J_().error(`failed to collect tracked uncommitted diff (${ot(s)})`),
      {
        type: "error",
        error: {
          type: "unknown",
        },
      }
    );
  } finally {
    o &&
      (await fs.promises.rm(o, {
        recursive: !0,
        force: !0,
      }));
  }
}
async function P6(e, t, n, r) {
  const o = await yh(e, n, r),
    [s, i] = await Promise.all([
      KL(e, n, r),
      o
        ? jp(o, t, n)
        : Promise.resolve({
            type: "error",
            error: {
              type: "unknown",
            },
          }),
    ]);
  return s.type !== "success" || i.type !== "success"
    ? {
        type: "error",
        error: {
          type: "unknown",
        },
      }
    : {
        type: "success",
        unifiedDiff: M6([s.unifiedDiff, i.unifiedDiff]),
      };
}
function M6(e) {
  const t = e.map((r) => v6(r)).filter((r) => r.length > 0);
  if (t.length === 0) return "";
  const n = t.join(`
`);
  return n.endsWith(`
`)
    ? n
    : `${n}
`;
}
function v6(e) {
  return e.replace(/[\r\n]+$/, "");
}
async function Yo(e, t, n) {
  const { success: r, stdout: o } = await re(
    e,
    ["rev-parse", "--abbrev-ref", "HEAD"],
    t,
    {
      signal: n,
    },
  );
  if (r && o && o !== "HEAD") return o;
  const s = await re(e, ["symbolic-ref", "--quiet", "--short", "HEAD"], t, {
    signal: n,
  });
  return s.success && s.stdout ? s.stdout : null;
}
async function zL(e, t = Xa, n, r) {
  const o = await re(
    e,
    ["symbolic-ref", "--quiet", `refs/remotes/${t}/HEAD`],
    n,
    {
      signal: r,
    },
  );
  if (o.success && o.stdout) {
    const a = o.stdout.split("/");
    return a[a.length - 1] ?? null;
  }
  const s = await re(e, ["remote", "show", t], n, {
    timeoutMs: 1e4,
    signal: r,
  });
  if (!s.success || !s.stdout) return null;
  const i = /HEAD branch:\s*(.+)/.exec(s.stdout);
  return i ? i[1].trim() : null;
}
async function ZL(e, t, n, r, o) {
  const s = await re(
    e,
    ["rev-list", "--left-right", "--count", `${t}...${n}`],
    r,
    {
      allowedNonZeroExitCodes: [128, 1],
      signal: o,
    },
  );
  if (!s.success || !s.stdout) return null;
  const i = L6(s.stdout);
  if (!i) return null;
  let a = "equal";
  return (
    i.leftAhead > 0 && i.rightAhead > 0
      ? (a = "diverged")
      : i.leftAhead > 0
        ? (a = "left-ahead")
        : i.rightAhead > 0 && (a = "right-ahead"),
    {
      leftAhead: i.leftAhead,
      rightAhead: i.rightAhead,
      state: a,
    }
  );
}
function L6(e) {
  const t = e.trim();
  if (!t) return null;
  const n = t.split(/\s+/);
  if (n.length < 2) return null;
  const r = Number.parseInt(n[0] ?? "", 10),
    o = Number.parseInt(n[1] ?? "", 10);
  return !Number.isFinite(r) || !Number.isFinite(o)
    ? null
    : {
        leftAhead: r,
        rightAhead: o,
      };
}
async function D6(e, t, n, r) {
  const o = await re(
    e,
    ["rev-parse", "--abbrev-ref", "--symbolic-full-name", `${t}@{u}`],
    n,
    {
      allowedNonZeroExitCodes: [128, 1],
      signal: r,
    },
  );
  return o.success && o.stdout ? o.stdout : null;
}
async function w6(e, t, n, r, o) {
  const s = async (f) => {
      const d = await D6(e, f, r, o);
      return d && (await ZL(e, f, d, r, o))?.state === "right-ahead" ? d : f;
    },
    i = async () =>
      t.type === "branch"
        ? s(t.branchName)
        : ((await Yo(e, r, o)) ?? (await zL(e, Xa, r, o)) ?? "HEAD"),
    a = async () => {
      if (t.type !== "working-tree") return null;
      const f = await P6(e, n, r, o);
      return f.type === "error" ? null : f.unifiedDiff;
    },
    [c, l] = await Promise.all([i(), a()]);
  return {
    startingRef: c,
    startingDiff: l,
  };
}
function U6(e) {
  return e?.id ?? "local";
}
const pb = xt("git"),
  k6 = 3,
  Eb = new Map();
function G6(e) {
  const t = U6(e),
    n = Eb.get(t);
  if (n) return n;
  const r = new gL.Sema(k6);
  return (Eb.set(t, r), r);
}
async function qu(e, t, n = !1, r) {
  const o = G6(t);
  await o.acquire();
  try {
    const s = ["worktree", "remove"];
    (n && s.push("--force"),
      s.push(e),
      ((
        await re(e, s, t, {
          signal: r,
        })
      ).success ||
        n) &&
        (await V6(e)));
  } finally {
    o.release();
  }
}
async function V6(e) {
  try {
    await fs.promises.rm(e, {
      recursive: !0,
      force: !0,
    });
  } catch (t) {
    pb().warning(`Failed to remove worktree directory (${ot(t)})`);
  }
  try {
    const t = path2.dirname(e);
    if (t === e) return;
    (await fs.promises.readdir(t)).length === 0 &&
      (await fs.promises.rm(t, {
        recursive: !0,
        force: !0,
      }));
  } catch (t) {
    pb().warning(`Failed to remove worktree parent directory (${ot(t)})`);
  }
}
function x6(e, t) {
  return [e, t].filter((r) => r.length > 0).join(`
`);
}
function Jn({
  command: e,
  stdout: t,
  stderr: n,
  fallbackOutput: r = t || n || "An unknown error occurred",
}) {
  const o = x6(t, n) || r;
  return {
    command: e,
    output: o,
  };
}
async function XL(
  e,
  t,
  n,
  { preferWslPaths: r = !1, convertWindowsPathToWslPath: o = void 0 } = {},
) {
  const s = Ue(n),
    i = s ? path2.posix.join(e, "index") : path2.join(e, "index");
  if (s) {
    const c = `cp ${It(t)} ${It(i)}`;
    await (
      await ar({
        hostConfig: n,
        args: [`sh -lc ${It(c)}`],
      })
    ).check();
  } else await fs.promises.copyFile(t, i);
  let a = i;
  return (r && o && (a = o(i)), a);
}
async function Oh(e, t, n, r) {
  const { success: o, stdout: s } = await re(
    e,
    ["rev-parse", "--git-path", t],
    n,
    {
      signal: r,
    },
  );
  if (!o || !s) return null;
  if (path2.isAbsolute(s)) return s;
  if (s.startsWith(".git/")) return path2.join(e, s);
  const i = await Hl(e, n, r);
  return i ? path2.join(i, s) : null;
}
async function Ch(e, t) {
  return Oh(e, "index", t);
}
function Wu(e) {
  return e.split(/[/\\]+/).join("/");
}
function QL(e, t, n) {
  const r = $6(t, n),
    o = B6(e, r);
  return o ? Wu(o) : n;
}
function $6(e, t) {
  return path2.isAbsolute(t) ? t : path2.resolve(e, t);
}
function B6(e, t) {
  const n = path2.relative(e, t);
  return n === "" || n.startsWith("..") || path2.isAbsolute(n) ? null : n;
}
function H6(e, t) {
  const n = new Set(),
    r = new Set(),
    o = new Set();
  let s = null;
  const i = [e, t].filter(Boolean).join(`
`),
    a = (F, U) => {
      const k = (U ?? "").trim();
      if (!k) return;
      const Y = k.charAt(0),
        oe = k.charAt(k.length - 1);
      let ae = k;
      ((Y === "'" || Y === '"') &&
        oe === Y &&
        k.length >= 2 &&
        (ae = k.slice(1, -1)),
        ae && F.add(ae));
    },
    c = (F, U) => {
      for (const k of U) if (F[k]) return F[k];
    },
    l =
      /^(?:Applied patch(?: to)?\s+(?:(["'])(?<qpath>.+?)\1|(?<path>.+?))\s+cleanly\.?)$/i,
    f =
      /^(?:Applied patch(?: to)?\s+(?:(["'])(?<qpath>.+?)\1|(?<path>.+?))\s+with conflicts\.?)$/i,
    d =
      /^(?:Applying patch\s+(?:(["'])(?<qpath>.+?)\1|(?<path>.+?))\s+with\s+\d+\s+rejects?\.{0,3})$/i,
    u = /^(?:Checking patch\s+(?:(["'])(?<qpath>.+?)\1|(?<path>.+?))\.\.\.)$/i,
    _ =
      /^(?:Performing three-way merge|Falling back to three-way merge)\.\.\.$/i,
    p = /^Failed to perform three-way merge\.\.\.$/i,
    E = /^Falling back to direct application\.\.\.$/i,
    h = /^U\s+(?<path>.+)$/,
    T = /^error:\s+patch failed:\s+(?<path>.+?)(?::\d+)?(?:\s|$)/i,
    m = /^error:\s+(?<path>.+?):\s+patch does not apply$/i,
    A =
      /^(?:error: )?repository lacks the necessary blob to (?:perform|fall back on) 3-?way merge\.?$/i,
    g = /^error:\s+(?<path>.+?):\s+does not match index\b/i,
    N = /^error:\s+(?<path>.+?):\s+does not exist in index\b/i,
    O =
      /^error:\s+(?<path>.+?)\s+already exists in (?:the )?working directory\b/i,
    I = /^error:\s+patch failed:\s+(?<path>.+?)\s+File exists/i,
    b = /^error:\s+path\s+(?<path>.+?)\s+has been renamed\/deleted/i,
    w =
      /^error:\s+cannot apply binary patch to\s+['"]?(?<path>.+?)['"]?\s+without full index line$/i,
    L = /^error:\s+binary patch does not apply to\s+['"]?(?<path>.+?)['"]?$/i,
    j =
      /^error:\s+binary patch to\s+['"]?(?<path>.+?)['"]?\s+creates incorrect result\b/i,
    H =
      /^error:\s+cannot read the current contents of\s+['"]?(?<path>.+?)['"]?$/i,
    x = /^Skipped patch\s+['"]?(?<path>.+?)['"]\.$/i,
    B =
      /^warning:\s*Cannot merge binary files:\s+(?<path>.+?)\s+\(ours\s+vs\.\s+theirs\)/i;
  for (const F of i.split(/\r?\n/)) {
    const U = F.trim();
    if (!U) continue;
    let k;
    if ((k = U.match(l))) {
      const Y = c(k.groups ?? {}, ["qpath", "path"]);
      (a(n, Y), (s = Y ?? s), o.delete(Y ?? ""), r.delete(Y ?? ""));
      continue;
    }
    if ((k = U.match(f))) {
      const Y = c(k.groups ?? {}, ["qpath", "path"]);
      (a(o, Y), (s = Y ?? s), n.delete(Y ?? ""), r.delete(Y ?? ""));
      continue;
    }
    if ((k = U.match(d))) {
      const Y = c(k.groups ?? {}, ["qpath", "path"]);
      (a(o, Y), (s = Y ?? s), n.delete(Y ?? ""), r.delete(Y ?? ""));
      continue;
    }
    if ((k = U.match(h))) {
      (a(o, k.groups?.path),
        (s = k.groups?.path ?? s),
        n.delete(k.groups?.path ?? ""),
        r.delete(k.groups?.path ?? ""));
      continue;
    }
    if ((k = U.match(u))) {
      s = c(k.groups ?? {}, ["qpath", "path"]) ?? s;
      continue;
    }
    if ((k = U.match(T)) || (k = U.match(m))) {
      (a(r, k.groups?.path), (s = k.groups?.path ?? s));
      continue;
    }
    if (!(_.test(U) || E.test(U))) {
      if (p.test(U)) {
        s && (a(r, s), n.delete(s), o.delete(s));
        continue;
      }
      if (A.test(U)) {
        s && (a(r, s), n.delete(s), o.delete(s));
        continue;
      }
      if (
        (k = U.match(g)) ||
        (k = U.match(N)) ||
        (k = U.match(O)) ||
        (k = U.match(I)) ||
        (k = U.match(b)) ||
        (k = U.match(w)) ||
        (k = U.match(L)) ||
        (k = U.match(j)) ||
        (k = U.match(H)) ||
        (k = U.match(x))
      ) {
        (a(r, k.groups?.path),
          (s = k.groups?.path ?? s),
          n.delete(k.groups?.path ?? ""),
          o.delete(k.groups?.path ?? ""));
        continue;
      }
      if ((k = U.match(B))) {
        (a(o, k.groups?.path),
          (s = k.groups?.path ?? s),
          n.delete(k.groups?.path ?? ""),
          r.delete(k.groups?.path ?? ""));
        continue;
      }
    }
  }
  for (const F of o) (n.delete(F), r.delete(F));
  for (const F of n) r.delete(F);
  return {
    appliedPaths: Array.from(n).sort(),
    skippedPaths: Array.from(r).sort(),
    conflictedPaths: Array.from(o).sort(),
  };
}
function JL(e) {
  const t = new Set(),
    n = /^diff --git a\/(.*?) b\/(.*)$/gm;
  let r;
  for (; (r = n.exec(e)) != null; ) {
    const [o, s, i] = r;
    (s && s !== "/dev/null" && t.add(s), i && i !== "/dev/null" && t.add(i));
  }
  return Array.from(t);
}
async function eD(
  e,
  t,
  n,
  {
    preferWslPaths: r = !1,
    convertWindowsPathToWslPath: o,
    convertWslPathToWindowsPath: s,
    signal: i,
  } = {},
) {
  const {
      cwd: a,
      env: c,
      diff: l,
      revert: f,
      target: d = "unstaged",
      allowBinary: u,
    } = e,
    _ = Bl("applyPatch"),
    E = (await t.getWorktreeRepository(a, n))?.root;
  if (!E) throw new Error(`${a} is not a git repository`);
  if (i?.aborted)
    return {
      status: "error",
      appliedPaths: [],
      skippedPaths: [],
      conflictedPaths: [],
    };
  const h = await Y6({
    hostConfig: n,
    signal: i,
  });
  let T = ln(n).join(h, "patch.diff");
  (await j6(T, l, {
    hostConfig: n,
    signal: i,
  }),
    r && o && (T = o(T)));
  try {
    let m = c;
    if (f && d === "unstaged") {
      const L = await Ch(E, n);
      if (!L)
        _.warning(
          "[applyPatch] Unable to resolve git index path; applying without temp index",
        );
      else {
        const j = await XL(h, L, n, {
          preferWslPaths: r,
          convertWindowsPathToWslPath: o,
        });
        ((m = {
          ...c,
          GIT_INDEX_FILE: j,
        }),
          await F6(E, l, n, {
            preferWslPaths: r,
            convertWslPathToWindowsPath: s,
            env: {
              ...c,
              GIT_INDEX_FILE: j,
            },
            signal: i,
          }));
      }
    }
    const A = ["apply"];
    (f && A.push("-R"),
      u && A.push("--binary"),
      A.push("--3way"),
      d === "staged"
        ? A.push("--cached")
        : d === "staged-and-unstaged" && A.push("--index"),
      A.push(T));
    const {
        code: g,
        stdout: N,
        stderr: O,
      } = await re(E, A, n, {
        env: m,
        signal: i,
        allowedNonZeroExitCodes: [1],
      }),
      { appliedPaths: I, skippedPaths: b, conflictedPaths: w } = H6(N, O);
    return (
      _.debug("ApplyPatch result metadata", {
        revert: f,
        target: d,
        code: g,
        stdoutLength: N.length,
        stderrLength: O.length,
        appliedCount: I.length,
        skippedCount: b.length,
        conflictedCount: w.length,
      }),
      {
        status:
          i?.aborted || g == null
            ? "error"
            : g === 0
              ? "success"
              : g === 1
                ? "partial-success"
                : "error",
        appliedPaths: I,
        skippedPaths: b,
        conflictedPaths: w,
        execOutput: Jn({
          command: A.join(" "),
          stdout: N,
          stderr: O,
        }),
      }
    );
  } finally {
    await q6(h, {
      hostConfig: n,
    });
  }
}
async function F6(
  e,
  t,
  n,
  { preferWslPaths: r, convertWslPathToWindowsPath: o, env: s, signal: i },
) {
  const a = JL(t);
  if (a.length === 0) return;
  const c = [],
    l = ln(n);
  if (
    (await Promise.all(
      a.map(async (f) => {
        const d = QL(e, e, f);
        let u = l.join(e, d);
        (r && o && (u = o(u)),
          (await W6(u, {
            hostConfig: n,
            signal: i,
          })) && c.push(d));
      }),
    ),
    c.length !== 0)
  ) {
    if (i?.aborted) throw new Error("Apply patch canceled");
    await re(e, ["--no-optional-locks", "add", "--", ...c], n, {
      env: s,
      signal: i,
    });
  }
}
async function Fl(e, t, { input: n, signal: r, timeoutMs: o = 1e4 } = {}) {
  if (!Ue(e)) throw new Error("runSshCommand requires a remote host config");
  const s = `sh -lc ${It(t)}`,
    [i, ...a] = e.terminal_command;
  if (!i) throw new Error("remote host config missing terminal command");
  const c = [...a, "-o", "BatchMode=yes", "-o", "ConnectTimeout=10", s],
    l = childProcess2.spawn(i, c, {
      stdio: ["pipe", "pipe", "pipe"],
    });
  (n != null && l.stdin?.write(n), l.stdin?.end());
  let f = !1;
  const d = setTimeout(() => {
      ((f = !0), l.kill());
    }, o),
    u = () => {
      l.kill();
    };
  r && r.addEventListener("abort", u);
  const _ = [],
    p = [];
  (l.stdout?.on("data", (m) => _.push(m)),
    l.stderr?.on("data", (m) => p.push(m)));
  const { code: E } = await new Promise((m) => {
    (l.on("close", (A) =>
      m({
        code: A,
      }),
    ),
      l.on("error", () =>
        m({
          code: null,
        }),
      ));
  });
  (clearTimeout(d), r && r.removeEventListener("abort", u));
  const h = Buffer.concat(_).toString("utf8"),
    T = Buffer.concat(p).toString("utf8");
  return f
    ? {
        code: null,
        stdout: h,
        stderr: `${T}ssh command timed out`,
      }
    : {
        code: E,
        stdout: h,
        stderr: T,
      };
}
async function Y6({ hostConfig: e, signal: t }) {
  if (!Ue(e)) return fs.promises.mkdtemp(Fb.join(os2.tmpdir(), "codex-apply-"));
  const {
    code: n,
    stdout: r,
    stderr: o,
  } = await Fl(e, 'mktemp -d "${TMPDIR:-/tmp}/codex-apply-XXXXXX"', {
    signal: t,
  });
  if (n !== 0 || !r.trim())
    throw new Error(`failed to create remote temp dir: ${o || r}`.trim());
  return r.trim();
}
async function j6(e, t, { hostConfig: n, signal: r }) {
  if (!Ue(n)) {
    await fs.promises.writeFile(e, t);
    return;
  }
  const o = `cat > ${It(e)}`,
    { code: s, stderr: i } = await Fl(n, o, {
      input: t,
      signal: r,
    });
  if (s !== 0) throw new Error(`failed to write remote file: ${i}`);
}
async function q6(e, { hostConfig: t }) {
  if (!Ue(t)) {
    await fs.promises.rm(e, {
      recursive: !0,
      force: !0,
    });
    return;
  }
  await Fl(t, `rm -rf ${It(e)}`);
}
async function W6(e, { hostConfig: t, signal: n }) {
  if (!Ue(t))
    try {
      return (await fs.promises.access(e), !0);
    } catch {
      return !1;
    }
  const { code: r } = await Fl(t, `test -e ${It(e)}`, {
    signal: n,
  });
  return r === 0;
}
const hb = xt("git");
async function K6(e, t, n, r, o, s) {
  try {
    const i = await z6(e, t, n, r, o, s);
    if (!i.success)
      try {
        await qu(t, o, !0);
      } catch (a) {
        hb().warning(`Failed to cleanup worktree (${ot(a)})`);
      }
    return i;
  } catch (i) {
    try {
      await qu(t, o, !0);
    } catch (a) {
      hb().warning(`Failed to cleanup worktree (${ot(a)})`);
    }
    return {
      success: !1,
      error: Z6(i),
    };
  }
}
async function z6(e, t, n, r, o, s) {
  const i = s?.onLog,
    a = s?.signal;
  if (a && a.aborted)
    return {
      success: !1,
      error: new Error("Operation canceled"),
    };
  const { startingRef: c, startingDiff: l } = await w6(e, n, r, o, a);
  if (a && a.aborted)
    return {
      success: !1,
      error: new Error("Operation canceled"),
    };
  const d = await re(e, ["worktree", "add", "--detach", t, c], o, {
    onStdoutRaw: i ? (_) => i("stdout", _) : void 0,
    onStderrRaw: i ? (_) => i("stderr", _) : void 0,
    signal: a,
  });
  if (!d.success)
    return {
      success: !1,
      error: new Error(`git worktree add failed: ${d.stderr || d.stdout}`),
    };
  if (a && a.aborted)
    return {
      success: !1,
      error: new Error("Operation canceled"),
    };
  const u = await jL(t, o);
  if (!u.success) return u;
  if (l) {
    i?.(
      "info",
      buffer.Buffer.from(
        `[info] Applying working tree diff to new worktree
`,
        "utf8",
      ),
    );
    const _ = await eD(
      {
        cwd: t,
        diff: l,
        revert: !1,
      },
      r,
      o,
      {
        signal: a,
      },
    );
    if (_.status !== "success") {
      const p = `git apply failed: applied:${_.appliedPaths.length} skipped:${_.skippedPaths.length} conflicted:${_.conflictedPaths.length}`;
      return (
        i?.(
          "info",
          buffer.Buffer.from(
            `${p}
`,
            "utf8",
          ),
        ),
        {
          success: !1,
          error: new Error(p),
        }
      );
    }
  }
  return {
    success: !0,
  };
}
function Z6(e) {
  return e instanceof Error ? e : new Error(String(e));
}
function tD() {
  return path2.join(CQ({}), "worktrees");
}
const Tb = xt("git");
async function X6(e, t, n, r, o = tD()) {
  const i = (await t.getWorktreeRepository(n, r))?.root;
  if (!i)
    return (
      Tb().error(
        "[createWorktreePath] failed to resolve git root for workspace",
      ),
      {
        success: !1,
      }
    );
  let a = path2.join,
    c = path2.relative,
    l = o;
  if (Ue(r)) {
    const E = await bQ(r);
    if (!E)
      return (
        Tb().error("[createWorktreePath] failed to resolve remote codex home"),
        {
          success: !1,
        }
      );
    ((a = path2.posix.join),
      (c = path2.posix.relative),
      (l = a(E, "worktrees")));
  }
  const f = crypto.randomUUID().split("-")[0].slice(0, 4),
    d = path2.basename(e),
    u = a(l, f, d),
    _ = c(i, n),
    p = a(u, _);
  return {
    success: !0,
    worktreeGitRoot: u,
    worktreeWorkspaceRoot: p,
  };
}
async function nD(e, t, n) {
  const r = await re(e, ["remote"], t, {
    signal: n,
  });
  if (!r.success || !r.stdout) return [];
  const o = r.stdout
    .split(
      `
`,
    )
    .map((s) => s.trim())
    .filter((s) => s.length > 0);
  return o.includes(Xa) && o.length > 1
    ? [Xa, ...o.filter((s) => s !== Xa)]
    : o;
}
async function Qa(e, t, n) {
  const r = await nD(e, t, n);
  if (r.length === 0) return null;
  for (const o of r) {
    const s = await zL(e, o, t, n);
    if (s)
      return {
        remote: o,
        branch: s,
      };
  }
  return null;
}
async function rD(e, t, n, r) {
  const o = await re(e, ["rev-parse", `${t}^{tree}`], n, {
    allowedNonZeroExitCodes: [128],
    signal: r,
  });
  if (!o.success || !o.stdout)
    throw new Error(o.stderr || o.stdout || "Failed to resolve tree");
  return o.stdout;
}
const Ro = xt("git");
let zc = null;
async function Q6(e, t, n, r) {
  const o = tJ(t.environment.setup, process.platform);
  if (!o || o.length === 0) return null;
  const s = Date.now();
  if (r && r.aborted)
    return {
      cwd: e,
      scriptPath: t.configPath,
      status: "failed",
      startedAt: s,
      finishedAt: Date.now(),
      error: "Setup script canceled",
      log: "",
    };
  let i = null;
  try {
    const a = path2.join(e, t.cwdRelativeToGitRoot);
    i = await fs.promises.mkdtemp(
      path2.join(os2.tmpdir(), "codex-local-environment-"),
    );
    const c = path2.join(i, `${crypto.randomUUID()}-setup_script.sh`),
      l = path2.join(i, `${crypto.randomUUID()}-setup_exit_code.txt`),
      f = o.replace(
        /\r\n/g,
        `
`,
      );
    await fs.promises.writeFile(c, f, {
      mode: 448,
    });
    const d = `bash -xeo pipefail ${JSON.stringify(c)}; echo $? > ${JSON.stringify(l)}`,
      u = await J6(process.platform, process.env),
      _ = childProcess2.spawn("bash", ["-c", d], {
        stdio: ["ignore", "pipe", "pipe"],
        cwd: a,
        env: u,
      }),
      p = new Array(),
      E = new stringDecoder.StringDecoder("utf8"),
      h = new stringDecoder.StringDecoder("utf8");
    let T = "",
      m = "";
    const A = (w, L, j) => {
        n?.(j, w);
        const F = (
            (j === "stdout" ? T : m) + (j === "stdout" ? E : h).write(w)
          ).split(/\r?\n/),
          U = F.pop() ?? "";
        j === "stdout" ? (T = U) : (m = U);
        for (const k of F) k && (p.push(k), L(`[${j}] ${k}`));
      },
      g = () => {
        const w = (L, j) => {
          const B = (L === "stdout" ? T : m) + (L === "stdout" ? E : h).end();
          L === "stdout" ? (T = "") : (m = "");
          for (const F of B.split(/\r?\n/)) F && (p.push(F), j(`[${L}] ${F}`));
        };
        (w("stdout", (L) => Ro().info(L)), w("stderr", (L) => Ro().error(L)));
      };
    (_.stdout?.on("data", (w) => A(w, (L) => Ro().info(L), "stdout")),
      _.stderr?.on("data", (w) => A(w, (L) => Ro().error(L), "stderr")));
    const N = async () => {
        try {
          const w = await fs.promises.readFile(l, "utf8"),
            L = Number.parseInt(w.trim(), 10);
          return Number.isNaN(L) ? null : L;
        } catch {
          return null;
        }
      },
      O = async () => {
        i != null &&
          (await fs.promises.rm(i, {
            recursive: !0,
            force: !0,
          }));
      };
    let I = !1;
    const b = () => {
      ((I = !0), _.kill());
    };
    return (
      r && r.addEventListener("abort", b),
      new Promise((w) => {
        (_.once("error", (L) => {
          (r && r.removeEventListener("abort", b),
            (async () => (
              g(),
              await O(),
              w({
                scriptPath: c,
                cwd: a,
                status: "failed",
                startedAt: s,
                finishedAt: Date.now(),
                error: L?.message ?? "Failed to run setup script",
                log: p.join(`
`),
              })
            ))());
        }),
          _.once("close", (L) => {
            (r && r.removeEventListener("abort", b),
              (async () => {
                const H = (await N()) ?? L;
                (g(), await O());
                let x, B;
                (I
                  ? ((x = "failed"), (B = "Setup script canceled"))
                  : H === 0
                    ? (x = "succeeded")
                    : ((x = "failed"),
                      (B = `worktree_init.sh exited with code ${H ?? "unknown"}`)),
                  w({
                    scriptPath: c,
                    cwd: a,
                    status: x,
                    startedAt: s,
                    finishedAt: Date.now(),
                    error: B,
                    log: p.join(`
`),
                  }));
              })());
          }));
      })
    );
  } catch (a) {
    return (
      i != null &&
        (await fs.promises.rm(i, {
          recursive: !0,
          force: !0,
        })),
      Ro().warning(`[local-environment] setup script failed (${ot(a)})`),
      {
        cwd: e,
        scriptPath: t.configPath,
        status: "failed",
        startedAt: s,
        finishedAt: Date.now(),
        error: String(a),
        log: "",
      }
    );
  }
}
async function J6(e, t, n = eJ) {
  return e === "win32"
    ? Promise.resolve({
        ...t,
      })
    : (zc != null ||
        (zc = (async () => {
          try {
            const r = await n();
            return {
              ...t,
              ...r,
            };
          } catch (r) {
            return (
              Ro().warning(
                `[local-environment] failed to load shell env (${ot(r)})`,
              ),
              {
                ...t,
              }
            );
          }
        })()),
      zc);
}
async function eJ() {
  const { shellEnv: e } = await Promise.resolve().then(() =>
    require("./index-DvdoEcOI.js"),
  );
  return e();
}
function tJ(e, t) {
  if (t === "darwin") {
    const n = e.darwin?.script;
    if (n && n.length > 0) return n;
  }
  if (t === "linux") {
    const n = e.linux?.script;
    if (n && n.length > 0) return n;
  }
  if (t === "win32") {
    const n = e.win32?.script;
    if (n && n.length > 0) return n;
  }
  return e.script;
}
async function oD(e, t, n, r, o, s) {
  const a = ["config", r === "local" ? "--local" : "--worktree", t, n],
    c = await re(e, a, o, {
      signal: s,
    });
  return c.success || r !== "worktree"
    ? c.success
    : !c.stderr.toLowerCase().includes("worktreeconfig") ||
        !(
          await re(e, ["config", "extensions.worktreeConfig", "true"], o, {
            signal: s,
          })
        ).success
      ? !1
      : (
          await re(e, a, o, {
            signal: s,
          })
        ).success;
}
async function nJ(e, t, n, r = "worktree", o) {
  return oD(e, v9, t, r, n, o);
}
const Sb = xt("syncedBranchConfig"),
  sD = "codex-synced-branch.json",
  rJ = sr({
    branch: dt(),
    lastSyncedTreeRef: dt(),
  });
async function iD(e, t, n) {
  const r = await Hl(e, t, n);
  return r ? path2.join(r, sD) : null;
}
function oJ(e) {
  try {
    const t = rJ.safeParse(JSON.parse(e));
    return t.success
      ? t.data
      : (Sb().warning(
          `Invalid synced branch config: ${t.error.message ?? "unknown error"}`,
        ),
        null);
  } catch (t) {
    return (
      Sb().warning(`Failed to parse synced branch config (${ot(t)})`),
      null
    );
  }
}
async function bh(e, t, n) {
  const r = await iD(e, t, n);
  if (!r) return null;
  try {
    const o = await cr.readFile(r, t);
    return oJ(o);
  } catch (o) {
    return (o.code === "ENOENT", null);
  }
}
async function sJ(e, t, n, r) {
  const o = await iD(e, n, r);
  if (!o) throw new Error("No git repository found for synced branch config");
  const s = `${JSON.stringify(t, null, 2)}
`;
  await cr.writeFile(o, s, n);
}
async function iJ(e, t, n, r, o) {
  await sJ(
    e,
    {
      branch: t,
      lastSyncedTreeRef: n,
    },
    r,
    o,
  );
}
async function aJ(e, t, n) {
  return Oh(e, sD, t, n);
}
function cJ(e) {
  return e.startsWith("refs/") ? e : `refs/heads/${e}`;
}
async function uJ({
  gitManager: e,
  workspaceRoot: t,
  startingState: n,
  localEnvironmentConfigPath: r,
  hostConfig: o,
  signal: s,
  onLog: i,
}) {
  if (s?.aborted)
    return {
      success: !1,
      error: new Error("Request canceled"),
    };
  const c = (await e.getWorktreeRepository(t, o))?.root;
  if (!c)
    return {
      success: !1,
      error: new Error("Not a git repository"),
    };
  if (s?.aborted)
    return {
      success: !1,
      error: new Error("Request canceled"),
    };
  const [l, f] = await Promise.all([lJ(c, n, o, s), Qa(c, o, s)]),
    d = f?.branch ?? null,
    u = l != null && l !== d,
    _ = await X6(c, e, t, o);
  if (!_.success)
    return {
      success: !1,
      error: new Error("Failed to compute worktree path"),
    };
  if (s?.aborted)
    return {
      success: !1,
      error: new Error("Request canceled"),
    };
  const { worktreeGitRoot: p, worktreeWorkspaceRoot: E } = _,
    h = await K6(c, p, n, e, o, {
      onLog: i,
      signal: s,
    });
  if (!h.success)
    return {
      success: !1,
      error: h.error,
    };
  if (s?.aborted)
    return {
      success: !1,
      error: new Error("Request canceled"),
    };
  if (u && l) {
    const N = cJ(l),
      O = await rD(c, N, o, s);
    await iJ(p, N, O, o, s);
  }
  if (
    (i?.(
      "info",
      buffer.Buffer.from(
        `Worktree created at ${E}
`,
        "utf8",
      ),
    ),
    (await nJ(E, r ?? L9, o, "worktree", s)) ||
      i?.(
        "stderr",
        buffer.Buffer.from(
          `Failed to store selected environment in git config
`,
          "utf8",
        ),
      ),
    r == null)
  )
    return (
      i?.(
        "info",
        buffer.Buffer.from(
          `No local environment selected
`,
          "utf8",
        ),
      ),
      {
        success: !0,
        worktreeGitRoot: p,
        worktreeWorkspaceRoot: E,
        setupResult: null,
      }
    );
  const A = await d6(r, o);
  if (A.type === "error")
    return (
      i?.(
        "stderr",
        buffer.Buffer.from(
          `${A.error.message}
`,
          "utf8",
        ),
      ),
      {
        success: !1,
        error: A.error,
      }
    );
  i?.(
    "info",
    buffer.Buffer.from(
      `Running setup script ${A.configPath}
`,
      "utf8",
    ),
  );
  const g = await Q6(
    p,
    A,
    (N, O) => {
      i?.(N, O);
    },
    s,
  );
  return s?.aborted
    ? {
        success: !1,
        error: new Error("Request canceled"),
      }
    : g?.status === "failed"
      ? (i?.(
          "stderr",
          buffer.Buffer.from(
            `${g.error ?? "Setup script failed"}
`,
            "utf8",
          ),
        ),
        {
          success: !1,
          error: new Error(g.error ?? "Setup script failed"),
        })
      : (g?.status === "succeeded" &&
          i?.(
            "info",
            buffer.Buffer.from(
              `Setup script completed
`,
              "utf8",
            ),
          ),
        {
          success: !0,
          worktreeGitRoot: p,
          worktreeWorkspaceRoot: E,
          setupResult: g ?? null,
        });
}
async function lJ(e, t, n, r) {
  return t.type === "branch" ? t.branchName : Yo(e, n, r);
}
async function dJ(e, t, n) {
  if (!Ue(t) && !fs.existsSync(e))
    throw new Error(`ENOENT: path does not exist: ${e}`);
  const {
    success: r,
    stdout: o,
    stderr: s,
    code: i,
  } = await re(e, ["rev-parse", "--git-common-dir"], t, {
    signal: n,
  });
  if (r && o) {
    const a = ln(t),
      c = a.isAbsolute(o) ? o : a.resolve(e, o);
    return c;
  }
  if (i === 128 && s.toLowerCase().includes("not a git repository"))
    return null;
  throw new Error(
    `Failed to resolve git common dir: ${s || o || "Unknown error"}`,
  );
}
async function fJ(e, t, n) {
  const r = await re(e, ["status", "--porcelain=v1", "-z"], t, {
    trim: !1,
    signal: n,
  });
  if (!r.success)
    return {
      type: "error",
    };
  let o = 0,
    s = 0,
    i = 0;
  const a = r.stdout;
  let c = 0;
  for (; c < a.length && !(c + 1 >= a.length); ) {
    const l = a[c],
      f = a[c + 1];
    l === "?" && f === "?"
      ? (i += 1)
      : (l !== " " && (o += 1), f !== " " && (s += 1));
    const d = a.indexOf("\0", c);
    if (d === -1) break;
    if (((c = d + 1), l === "R" || l === "C" || f === "R" || f === "C")) {
      const u = a.indexOf("\0", c);
      if (u === -1) break;
      c = u + 1;
    }
  }
  return {
    type: "success",
    stagedCount: o,
    unstagedCount: s,
    untrackedCount: i,
  };
}
async function aD(e, t, n, r) {
  const o = t.trim();
  if (!o) return null;
  const s = async (h) =>
      (
        await re(e, ["rev-parse", "--verify", "--quiet", h], n, {
          signal: r,
        })
      ).success,
    i = [],
    a = new Set(),
    c = async (h) => {
      const T = h?.trim();
      !T || a.has(T) || ((await s(T)) && (i.push(T), a.add(T)));
    },
    l = await re(
      e,
      ["for-each-ref", "--format=%(upstream:short)", `refs/heads/${o}`],
      n,
      {
        signal: r,
      },
    ),
    f = l.success ? l.stdout.trim() : null;
  (await c(f), await c(o));
  const d = await re(e, ["remote"], n, {
    signal: r,
  });
  if (d.success && d.stdout) {
    const h = d.stdout
        .split(
          `
`,
        )
        .map((I) => I.trim())
        .filter((I) => I.length > 0),
      T = new Set(h),
      m = o.indexOf("/"),
      A = m > 0 ? o.slice(0, m) : null,
      g = A != null && T.has(A),
      N = g && m + 1 < o.length ? o.slice(m + 1) : null,
      O = [];
    for (const I of h) {
      if (g && I === A) {
        N && O.push(c(`refs/remotes/${I}/${N}`));
        continue;
      }
      O.push(c(`${I}/${o}`), c(`refs/remotes/${I}/${o}`));
    }
    await Promise.all(O);
  }
  const u = i[0];
  if (!u) return null;
  const { success: _, stdout: p } = await re(e, ["merge-base", "HEAD", u], n, {
    signal: r,
  });
  if (!_ || !p) return null;
  const E = p.trim();
  return E.length > 0 ? E : null;
}
async function _J(e, t, n) {
  const r = await $n(e, [], t, {
    trim: !1,
    allowedNonZeroExitCodes: [0, 1],
    signal: n,
  });
  return r.outputLimitExceeded || !r.success
    ? {
        type: "error",
        error: Fo(r),
      }
    : {
        type: "success",
        unifiedDiff: r.stdout,
      };
}
function cD(e, t, n) {
  const r = Wu(path2.relative(e, t));
  return n.map((o) => {
    const s = Wu(o),
      a = r.length > 0 && (s === r || s.startsWith(`${r}/`)) ? e : t;
    return QL(e, a, o);
  });
}
async function pJ(e, t, n, r, o) {
  const s = await t.getWorktreeRepository(e, n),
    i = s?.root;
  if (!i)
    return {
      stagedChanges: {
        type: "error",
        error: {
          type: "unknown",
        },
      },
      unstagedChanges: {
        type: "error",
        error: {
          type: "unknown",
        },
      },
    };
  const a = o == null ? null : cD(i, e, o);
  if (a != null) {
    if (a.length === 0)
      return {
        stagedChanges: {
          type: "success",
          unifiedDiff: "",
        },
        unstagedChanges: {
          type: "success",
          unifiedDiff: "",
        },
      };
    const f = await s.getUntrackedPaths(a),
      d = new Set(f.paths),
      u = f.success ? a.filter((E) => !d.has(E)) : a;
    if (u.length === 0)
      return {
        stagedChanges: {
          type: "success",
          unifiedDiff: "",
        },
        unstagedChanges: {
          type: "success",
          unifiedDiff: "",
        },
      };
    const [_, p] = await Promise.all([
      $n(i, ["--cached", "--", ...u], n, {
        trim: !1,
        allowedNonZeroExitCodes: [0, 1],
        signal: r,
      }),
      $n(i, ["--", ...u], n, {
        trim: !1,
        allowedNonZeroExitCodes: [0, 1],
        signal: r,
      }),
    ]);
    return {
      stagedChanges: ep(_),
      unstagedChanges: ep(p),
    };
  }
  const [c, l] = await Promise.all([
    $n(i, ["--cached"], n, {
      trim: !1,
      allowedNonZeroExitCodes: [0, 1],
      signal: r,
    }),
    _J(i, n, r),
  ]);
  return {
    stagedChanges: ep(c),
    unstagedChanges: l,
  };
}
function ep(e) {
  return e.outputLimitExceeded || !e.success
    ? {
        type: "error",
        error: Fo(e),
      }
    : {
        type: "success",
        unifiedDiff: e.stdout,
      };
}
async function EJ(e, t, n, r, o) {
  const s = await yh(e, n, r);
  if (!s)
    return {
      untrackedChanges: {
        type: "error",
        error: {
          type: "unknown",
        },
      },
    };
  const i = o == null ? null : cD(s, e, o);
  return i != null && i.length === 0
    ? {
        untrackedChanges: {
          type: "success",
          unifiedDiff: "",
        },
      }
    : i == null
      ? {
          untrackedChanges: await jp(s, t, n),
        }
      : {
          untrackedChanges: await jp(s, t, n, {
            includePaths: i,
          }),
        };
}
async function uD(e, t, n) {
  const r = await re(e, ["worktree", "list", "--porcelain"], t, {
    signal: n,
  });
  if (!r.success)
    throw new Error(
      r.stderr || r.stdout || "Failed to list worktrees for repository",
    );
  return hJ(r.stdout ?? "");
}
function hJ(e) {
  const t = [];
  let n = null;
  const r = e.split(/\r?\n/);
  for (const o of r) {
    const s = o.trim();
    if (s.length === 0) {
      n && (t.push(n), (n = null));
      continue;
    }
    if (s.startsWith("worktree ")) {
      n && t.push(n);
      const i = s.slice(9).trim();
      if (!i) {
        n = null;
        continue;
      }
      n = {
        root: i,
        prunable: !1,
        locked: !1,
        headRef: {
          sha: "",
          type: "detached",
        },
      };
      continue;
    }
    if (n) {
      if (s.startsWith("HEAD ")) {
        const i = s.slice(5).trim();
        n.headRef = {
          sha: i,
          type: "detached",
        };
        continue;
      }
      if (s.startsWith("branch ")) {
        const i = s.slice(7).trim();
        i.startsWith("refs/heads/")
          ? (n.headRef = {
              sha: n.headRef.sha,
              type: "branch",
              string: i.slice(11),
            })
          : (n.headRef = {
              sha: n.headRef.sha,
              type: "branch",
              string: i,
            });
        continue;
      }
      if (s === "detached") {
        n.headRef = {
          sha: n.headRef.sha,
          type: "detached",
        };
        continue;
      }
      if (s.startsWith("prunable")) {
        n.prunable = !0;
        continue;
      }
      s.startsWith("locked") && (n.locked = !0);
    }
  }
  return (n && t.push(n), t);
}
async function TJ({ cwd: e }, t, n) {
  const r = String(e).trim();
  if (!r) throw new Error("Workspace root is required");
  const o = await re(r, ["init"], n);
  if (!o.success)
    throw new Error(o.stderr || o.stdout || "Failed to run git init");
  return (
    t.invalidateStableMetadata(),
    {
      success: !0,
    }
  );
}
async function lD(e, t, n, r) {
  const o = await re(e, ["config", "--get", ...t], n, {
    signal: r,
  });
  return o.success && o.stdout ? o.stdout : null;
}
async function SJ(e, t, n, r, o) {
  const a = await re(
    e,
    ["config", n === "local" ? "--local" : "--worktree", "--get", t],
    r,
    {
      signal: o,
    },
  );
  return a.success && a.stdout ? a.stdout : null;
}
async function mb(e, t, { includePaths: n, signal: r } = {}) {
  const o = ["ls-files", "--others", "--exclude-standard", "-z"];
  n && n.length > 0 && o.push("--", ...n);
  const s = await re(e, o, t, {
    trim: !1,
    signal: r,
  });
  return s.success
    ? {
        success: !0,
        paths:
          s.stdout
            .split("\0")
            .map((a) => a.trim())
            .filter((a) => a.length > 0) ?? [],
        gitRoot: e,
      }
    : {
        success: !1,
        paths: [],
        gitRoot: e,
      };
}
class mJ {
  constructor(t, n) {
    ((this.root = t), (this.hostConfig = n));
  }
  shouldUseSlowUntrackedPathsCache = !1;
  async getConfigValue(t, n) {
    return lD(this.root, [t], this.hostConfig, n);
  }
  async getConfigValueForScope(t, n, r) {
    return SJ(this.root, t, n, this.hostConfig, r);
  }
  async setConfigValueForScope(t, n, r, o) {
    return oD(this.root, t, n, r, this.hostConfig, o);
  }
  getUntrackedPaths = Object.assign(
    async (t) =>
      t != null && t.length > 0
        ? mb(this.root, this.hostConfig, {
            includePaths: t,
          })
        : this.shouldUseSlowUntrackedPathsCache
          ? this.getAllUntrackedPathsSlow()
          : this.getAllUntrackedPathsFast(),
    {
      clear: () => {
        ((this.shouldUseSlowUntrackedPathsCache = !1),
          this.getAllUntrackedPathsFast.clear(),
          this.getAllUntrackedPathsSlow.clear());
      },
      delete: (t) => {
        (t != null && t.length > 0) ||
          (this.getAllUntrackedPathsFast.delete(),
          this.getAllUntrackedPathsSlow.delete());
      },
    },
  );
  fetchAllUntrackedPaths = async () => {
    const t = Date.now(),
      n = await mb(this.root, this.hostConfig),
      r = Date.now() - t;
    return ((this.shouldUseSlowUntrackedPathsCache = r >= 7e3), n);
  };
  getAllUntrackedPathsFast = lc(async () => this.fetchAllUntrackedPaths(), {
    promise: !0,
    maxAge: 1e4,
  });
  getAllUntrackedPathsSlow = lc(async () => this.fetchAllUntrackedPaths(), {
    promise: !0,
    maxAge: 2e4,
  });
}
class AJ {
  constructor(t, n) {
    ((this.commonDir = t), (this.hostConfig = n));
  }
  worktreesByRoot = new Map();
  getCommonDir() {
    return this.commonDir;
  }
  getRepository(t) {
    const n = this.worktreesByRoot.get(t);
    if (n) return n;
    const r = new mJ(t, this.hostConfig);
    return (this.worktreesByRoot.set(t, r), r);
  }
  invalidateUntrackedPathsCache() {
    for (const t of this.worktreesByRoot.values()) t.getUntrackedPaths.clear();
  }
  getOriginUrl = lc(
    async (t) =>
      await lD(this.commonDir, ["remote.origin.url"], this.hostConfig, t),
    {
      length: 0,
      promise: !0,
      maxAge: hh,
    },
  );
}
function tp(e) {
  return e?.id ?? "local";
}
class gJ {
  reposByKey = new Map();
  hasBackgroundedSinceLastForeground = !1;
  constructor(t) {
    t.subscribe((n) => {
      this.handleAppEvent(n);
    });
  }
  async getRepoRepository(t, n) {
    const r = await this.getStableMetadata(t, n);
    return r ? this.getOrCreateRepo(r.commonDir, n) : null;
  }
  async getWorktreeRepository(t, n) {
    const [r, o] = await Promise.all([
      this.getRepoRepository(t, n),
      this.getStableMetadata(t, n),
    ]);
    return !r || !o ? null : r.getRepository(o.root);
  }
  getRepoKey(t, n) {
    return `${tp(n)}|${t}`;
  }
  getOrCreateRepo(t, n) {
    const r = this.getRepoKey(t, n),
      o = this.reposByKey.get(r);
    if (o) return o;
    const s = new AJ(t, n);
    return (this.reposByKey.set(r, s), s);
  }
  invalidateStableMetadata() {
    this.getStableMetadata.clear();
  }
  invalidateUntrackedPathsCache(t = null, n = null) {
    if (t == null) {
      for (const o of this.reposByKey.values())
        o.invalidateUntrackedPathsCache();
      return;
    }
    const r = tp(n);
    for (const [o, s] of this.reposByKey)
      o.startsWith(`${r}|`) && s.invalidateUntrackedPathsCache();
  }
  getStableMetadata = lc(
    async (t, n) => {
      const r = await yh(t, n);
      if (!r) return null;
      const o = await dJ(r, n);
      return o
        ? {
            root: r,
            commonDir: o,
          }
        : null;
    },
    {
      promise: !0,
      maxAge: hh,
      normalizer: ([t, n]) => `${tp(n)}|${t}`,
    },
  );
  handleAppEvent(t) {
    switch (t.type) {
      case "background":
        this.hasBackgroundedSinceLastForeground = !0;
        break;
      case "foreground":
        (this.hasBackgroundedSinceLastForeground &&
          this.invalidateUntrackedPathsCache(null),
          (this.hasBackgroundedSinceLastForeground = !1));
        break;
      case "turnComplete":
        this.invalidateUntrackedPathsCache(null);
        break;
    }
  }
}
async function RJ(e, t) {
  const n = [];
  for (const r of e)
    if (r)
      try {
        (await cr.stat(r, t)).isDirectory() && n.push(r);
      } catch {
        continue;
      }
  return n;
}
async function qp(
  e,
  t,
  n,
  {
    parentSha: r,
    message: o = "Codex changes",
    coAuthor: s = "Codex",
    signal: i,
  } = {},
) {
  const a = ["commit-tree", t];
  (r && a.push("-p", r),
    a.push("-m", o),
    s && a.push("-m", `Co-authored-by: ${s}`));
  const c = await re(e, a, n, {
    signal: i,
  });
  return !c.success || !c.stdout
    ? {
        success: !1,
        error: c,
      }
    : {
        success: !0,
        commitSha: c.stdout,
      };
}
const Ab = 1024;
async function dD({
  gitRoot: e,
  env: t,
  signal: n,
  hostConfig: r,
  untrackedPathsPromise: o,
}) {
  if (!o)
    return re(e, ["add", "-A"], r, {
      env: t,
      signal: n,
    });
  const s = await o;
  if (!s.success)
    return re(e, ["add", "-A"], r, {
      env: t,
      signal: n,
    });
  const i = await re(e, ["add", "-u"], r, {
    env: t,
    signal: n,
  });
  if (!i.success || s.paths.length === 0) return i;
  for (const a of NJ(s.paths))
    if (
      !(
        await re(e, ["add", "--", ...a], r, {
          env: t,
          signal: n,
        })
      ).success
    )
      return re(e, ["add", "-A"], r, {
        env: t,
        signal: n,
      });
  return i;
}
function NJ(e) {
  const t = [];
  for (let n = 0; n < e.length; n += Ab) t.push(e.slice(n, n + Ab));
  return t;
}
const yJ = "GIT_INDEX_FILE";
async function fD(e, t, n) {
  const r = await OJ(n);
  try {
    const o = await XL(r, e, n),
      s = {
        [yJ]: o,
      };
    return await t(s);
  } finally {
    await CJ(r, n);
  }
}
async function OJ(e) {
  if (!Ue(e))
    return fs.promises.mkdtemp(path2.join(os2.tmpdir(), "codex-index-"));
  const t = await ar({
      hostConfig: e,
      args: ["sh", "-lc", 'mktemp -d "${TMPDIR:-/tmp}/codex-index-XXXXXX"'],
      timeoutMs: 1e4,
    }),
    { code: n, stdout: r, stderr: o } = await t.wait();
  if (n !== 0 || !r.trim()) {
    const s = n == null ? `${o}ssh command timed out` : o || r;
    throw new Error(`failed to create remote temp dir: ${s}`.trim());
  }
  return r.trim();
}
async function CJ(e, t) {
  if (!Ue(t)) {
    await fs.promises.rm(e, {
      recursive: !0,
      force: !0,
    });
    return;
  }
  await (
    await ar({
      hostConfig: t,
      args: ["sh", "-lc", `rm -rf ${It(e)}`],
      timeoutMs: 1e4,
    })
  ).wait();
}
async function ru(e, t) {
  const n = t.hostConfig,
    r = await Ch(e, n);
  if (!r) throw new Error("Failed to resolve git index path");
  return fD(
    r,
    async (o) => {
      const s = await dD({
        gitRoot: e,
        env: o,
        signal: t.signal,
        hostConfig: n,
        untrackedPathsPromise: t.untrackedPathsPromise,
      });
      if (!s.success)
        throw new Error(
          s.stderr || s.stdout || "Failed to stage working tree snapshot",
        );
      const i = await re(e, ["write-tree"], n, {
          env: o,
          signal: t.signal,
        }),
        a = i.success ? i.stdout.trim() : null;
      if (a) {
        if (!Nc(a)) throw new Error(`Unexpected tree SHA: ${a}`);
      } else throw new Error("Failed to write working tree snapshot");
      return a;
    },
    n,
  );
}
function Nc(e) {
  return /^[0-9a-f]{7,40}$/i.test(e);
}
const bJ = "refs/codex/snapshots";
async function IJ(e, t, n, r, o) {
  const s = await e.getStableMetadata(t, n);
  if (!s) throw new Error(`Not in a git repository: ${t}`);
  const i = Ph(s.root),
    a = Ih(i),
    c = await e.getWorktreeRepository(t, n);
  if (!c)
    throw new Error("Unable to resolve worktree repository for snapshot.");
  const l = c.getUntrackedPaths(),
    f = await ru(s.root, {
      hostConfig: n,
      signal: o,
      untrackedPathsPromise: l,
    }),
    d = await re(s.root, ["rev-parse", "HEAD"], n, {
      allowedNonZeroExitCodes: [128],
      signal: o,
    }),
    u = d.success && d.stdout ? d.stdout.trim() : null;
  let _ = u;
  if (u) {
    if ((await rD(s.root, u, n, o)).trim() !== f) {
      const h = await qp(s.root, f, n, {
        parentSha: u,
        message: gb(r),
        signal: o,
      });
      if (!h.success) throw new Error("Failed to create synthetic commit");
      _ = h.commitSha.trim();
    }
  } else {
    const E = await qp(s.root, f, n, {
      message: gb(r),
      signal: o,
    });
    if (!E.success) throw new Error("Failed to create synthetic commit");
    _ = E.commitSha.trim();
  }
  if (!_) throw new Error("Failed to compute snapshot commit");
  if (
    !(
      await re(s.root, ["update-ref", a, _], n, {
        env: {
          GIT_TERMINAL_PROMPT: "0",
        },
        signal: o,
      })
    ).success
  )
    throw new Error("Failed to update ref");
  return {
    snapshotRef: a,
    worktreeId: i,
    repoRoot: s.root,
    commonDir: s.commonDir,
    commitSha: _,
  };
}
async function PJ(e, t, n, r, o) {
  const s = n,
    i = Ph(s),
    a = Ih(i),
    c = await RJ(t, r);
  if (c.length === 0)
    throw new Error("No candidate workspace roots exist on disk");
  const l = (
    await Promise.all(
      c.map(async (d) => {
        try {
          return await e.getStableMetadata(d, r);
        } catch {
          return null;
        }
      }),
    )
  ).filter((d) => !!d);
  if (l.length === 0)
    throw new Error("No candidate workspace roots are valid git repositories");
  const f = await Promise.all(
    l.map(async (d) => {
      const u = await re(d.root, ["show-ref", "--verify", "--hash", a], r, {
        allowedNonZeroExitCodes: [128, 1],
        env: {
          GIT_TERMINAL_PROMPT: "0",
        },
        signal: o,
      });
      return {
        metadata: d,
        showRefResult: u,
      };
    }),
  );
  for (const { metadata: d, showRefResult: u } of f)
    if (!(u.code === 128 || u.code === 1)) {
      if (!u.success || !u.stdout)
        throw new Error(
          u.stderr || u.stdout || "Failed to resolve snapshot ref",
        );
      return {
        snapshotRef: a,
        worktreeId: i,
        repoRoot: d.root,
        commonDir: d.commonDir,
        exists: !0,
        commitSha: u.stdout.trim(),
      };
    }
  return {
    snapshotRef: a,
    worktreeId: i,
    exists: !1,
    commitSha: null,
  };
}
async function MJ(e, t, n, r) {
  const o = Ph(t),
    s = Ih(o),
    i = await re(e, ["worktree", "add", "--detach", t, s], n, {
      env: {
        GIT_TERMINAL_PROMPT: "0",
      },
      signal: r,
    });
  if (!i.success)
    throw new Error(i.stderr || i.stdout || "Failed to restore worktree");
  const a = await jL(t, n);
  if (!a.success) {
    try {
      await qu(t, n, !0);
    } catch {
      await fs.promises.rm(t, {
        recursive: !0,
        force: !0,
      });
    }
    throw new Error(a.error.message);
  }
  return !0;
}
function Ih(e) {
  return `${bJ}/${e}`;
}
function Ph(e) {
  return crypto.createHash("sha1").update(e).digest("hex");
}
function gb(e) {
  return `Codex worktree snapshot: ${e}`;
}
const vJ = sr({
  state: dt().optional(),
  number: za().optional(),
  url: dt().optional(),
});
Vl(vJ);
util.promisify(childProcess2.execFile);
const Rb = {
  error: 0,
  warning: 1,
  info: 2,
  debug: 3,
  trace: 4,
};
function LJ(e, t) {
  return Rb[e] <= Rb[t];
}
util.promisify(childProcess2.execFile);
sr({
  title: dt(),
  body: dt(),
});
async function DJ({
  root: e,
  diff: t,
  gitManager: n,
  hostConfig: r,
  signal: o,
  logger: s,
}) {
  const i = await Ch(e, r);
  return i
    ? fD(i, (a) => Nb(e, t, n, r, o, s, a), r)
    : (s &&
        s.warning(
          "Unable to resolve git index path; applying without temp index",
        ),
      Nb(e, t, n, r, o, s));
}
async function Nb(e, t, n, r, o, s, i) {
  return (
    (await wJ(e, t, r, o, i)).success ||
      (s && s.error("Failed to stage target worktree changes")),
    eD(
      {
        cwd: e,
        diff: t,
        allowBinary: !0,
        revert: !1,
        env: i,
      },
      n,
      r,
      {
        signal: o,
      },
    )
  );
}
async function wJ(e, t, n, r, o) {
  const s = JL(t);
  if (s.length === 0)
    return {
      success: !0,
      command: "git add",
      stdout: "",
      stderr: "",
    };
  const i = await UJ(e, s, n);
  return i.length === 0
    ? {
        success: !0,
        command: "git add",
        stdout: "",
        stderr: "",
      }
    : re(e, ["add", "--", ...i], n, {
        env: o,
        signal: r,
      });
}
async function UJ(e, t, n) {
  const r = ln(n),
    o = [];
  return (
    await Promise.all(
      t.map(async (s) => {
        const i = r.join(e, s);
        try {
          (await cr.stat(i, n), o.push(s));
        } catch {
          return;
        }
      }),
    ),
    o
  );
}
async function kJ({
  sourceHeadRef: e,
  sourceTreeRef: t,
  destinationRoot: n,
  destinationHeadRef: r,
  gitManager: o,
  hostConfig: s,
  signal: i,
}) {
  const a = AL("applyChanges"),
    c = await GJ(n, e, r, s, i);
  if (!c)
    return {
      status: "command-error",
    };
  const l = await $n(n, [c, t], s, {
    binary: !0,
    trim: !1,
    allowedNonZeroExitCodes: [0, 1],
    signal: i,
  });
  if (l.outputLimitExceeded || !l.success)
    return {
      status: "command-error",
      execOutput: Jn(l),
    };
  const f = l.stdout;
  if (!f)
    return {
      status: "success",
    };
  const d = await DJ({
    root: n,
    diff: f,
    gitManager: o,
    hostConfig: s,
    signal: i,
    logger: a,
  });
  return d.status === "error"
    ? {
        status: "command-error",
        execOutput: d.execOutput,
      }
    : d.status === "partial-success"
      ? {
          status: "partial-success",
          appliedPaths: d.appliedPaths,
          skippedPaths: d.skippedPaths,
          conflictedPaths: d.conflictedPaths,
        }
      : {
          status: "success",
        };
}
async function GJ(e, t, n, r, o) {
  const s = await re(e, ["merge-base", t, n], r, {
    allowedNonZeroExitCodes: [1],
    signal: o,
  });
  if (!s.success || !s.stdout) return null;
  const i = s.stdout.trim();
  return i ? i : null;
}
function VJ(...e) {
  const t = [],
    n = (r) => {
      const o = r.trim();
      o.length !== 0 && t.push(o);
    };
  for (const r of e) for (const o of r) n(o);
  return t;
}
async function xJ(e, t, n, r, o, s) {
  if (!n || n.trim().length === 0)
    return {
      type: "error",
      error: {
        type: "unknown",
      },
    };
  const i = await $n(t, [n], o, {
    trim: !1,
    allowedNonZeroExitCodes: [0, 1],
    signal: s,
  });
  if (i.outputLimitExceeded || !i.success)
    return {
      type: "error",
      error: Fo(i),
    };
  if (!r.success)
    return {
      type: "error",
      error: {
        type: "unknown",
      },
    };
  const a = await WL(e, r, o, s);
  return a.success
    ? {
        type: "success",
        unifiedDiff: VJ([i.stdout], a.sections).join(`
`),
      }
    : {
        type: "error",
        error: a.error,
      };
}
function Mh(e) {
  return e.startsWith("refs/heads/") ? e.slice(11) : e;
}
async function $J(e, t, n, r) {
  const o = await e.getWorktreeRepository(t, n),
    s = o?.root;
  if (!s)
    return {
      gitRoot: null,
      branch: null,
      baseBranch: null,
      baseBranchRemote: null,
      branchChanges: {
        type: "error",
        error: {
          type: "unknown",
        },
      },
    };
  const [i, a] = await Promise.all([Yo(s, n, r), Qa(s, n, r)]);
  let c = i;
  if (!c) {
    const h = await bh(t, n, r);
    c = h ? Mh(h.branch) : null;
  }
  if (!a)
    return {
      gitRoot: s,
      branch: c,
      baseBranch: null,
      baseBranchRemote: null,
      branchChanges: {
        type: "error",
        error: {
          type: "unknown",
        },
      },
    };
  const { branch: l, remote: f } = a,
    d = l,
    u = d.includes("/") ? d : `${f}/${d}`,
    _ = await aD(s, u, n, r);
  if (!_)
    return {
      gitRoot: s,
      branch: c,
      baseBranch: d,
      baseBranchRemote: f,
      branchChanges: {
        type: "error",
        error: {
          type: "unknown",
        },
      },
    };
  const p = await o.getUntrackedPaths(),
    E = await xJ(s, t, _, p, n, r);
  return {
    gitRoot: s,
    branch: c,
    baseBranch: d,
    baseBranchRemote: f,
    branchChanges: E,
  };
}
const BJ = /^\d{6}-\d{4}-[0-9a-f]{8}$/i,
  HJ = /^[0-9a-f]{4}$/i;
async function FJ() {
  const e = tD();
  let t = [];
  try {
    t = await fs.promises.readdir(e, {
      withFileTypes: !0,
    });
  } catch {
    return [];
  }
  const n = t.filter((i) => i.isDirectory()),
    r = await Promise.all(
      n.map(async (i) => {
        const a = path2.join(e, i.name);
        try {
          const c = await fs.promises.readdir(a, {
            withFileTypes: !0,
          });
          return {
            parentName: i.name,
            parentPath: a,
            worktreeEntries: c,
          };
        } catch {
          return null;
        }
      }),
    ),
    o = [];
  for (const i of r) {
    if (!i) continue;
    const a = HJ.test(i.parentName);
    for (const c of i.worktreeEntries) {
      if (!c.isDirectory() || (!a && !BJ.test(c.name))) continue;
      const l = path2.join(i.parentPath, c.name),
        f = l;
      f &&
        o.push(
          YL(l).then(async (d) =>
            (await g6(l, d))
              ? {
                  dir: f,
                  gitDir: d,
                }
              : null,
          ),
        );
    }
  }
  return (await Promise.all(o)).filter((i) => i != null);
}
const YJ = xt("git");
async function jJ(e, t, n) {
  const r = await Hl(e, t, n);
  if (!r)
    return {
      lastModified: 0,
    };
  const o = path2.join(r, "index");
  try {
    return {
      lastModified: (await fs.promises.stat(o)).mtimeMs,
    };
  } catch (s) {
    return s.code === "ENOENT"
      ? {
          lastModified: 0,
        }
      : (YJ().error(`Failed to read index info for ${o}: ${String(s)}`),
        {
          lastModified: 0,
        });
  }
}
async function yb(e, t, n, r) {
  const { success: o, stdout: s } = await re(
    e,
    [
      "for-each-ref",
      `--count=${t}`,
      "--sort=-committerdate",
      "refs/heads",
      "--format=%(refname:short)",
    ],
    n,
    {
      signal: r,
    },
  );
  return !o || !s
    ? []
    : s
        .split(
          `
`,
        )
        .map((i) => i.trim())
        .filter((i) => i.length > 0);
}
async function qJ(e, t, n) {
  const r = await re(
    e,
    ["config", "--file", ".gitmodules", "--get-regexp", "path"],
    t,
    {
      allowedNonZeroExitCodes: [1],
      signal: n,
    },
  );
  if (!r.success || !r.stdout) return [];
  const o = r.stdout
    .split(
      `
`,
    )
    .map((s) => s.trim())
    .filter((s) => s.length > 0)
    .map((s) => {
      const i = s.split(/\s+/),
        a = i[i.length - 1] ?? "";
      return Wu(a);
    })
    .filter((s) => s.length > 0);
  return Array.from(new Set(o));
}
async function WJ(e, t, n) {
  return {
    trackedChanges: await KL(e, t, n),
  };
}
const KJ = new RegExp("(?<=\\n)"),
  zJ = /^0+$/,
  Ku = 3e4;
async function ZJ(e, { cwd: t, oid: n, path: r, fallbackToDisk: o }, s, i) {
  const a = Ue(s);
  try {
    const c = await e.getStableMetadata(t, s);
    if (!c)
      return {
        type: "error",
        error: {
          type: "unknown",
        },
      };
    const l = String(c.root),
      d = ln(s).join(l, r);
    if (!XJ(n))
      return o
        ? Cb(d, s)
        : {
            type: "error",
            error: {
              type: "not-found",
            },
          };
    const u = await JJ(l, n, s, i, a);
    return u.type === "success"
      ? u
      : o && u.error.type === "not-found"
        ? Cb(d, s)
        : u;
  } catch (c) {
    return c.code === "ENOENT"
      ? {
          type: "error",
          error: {
            type: "not-found",
          },
        }
      : {
          type: "error",
          error: {
            type: "unknown",
          },
        };
  }
}
function _D(e) {
  return (
    e.includes("No such file") ||
    e.includes("cannot open") ||
    e.includes("not found")
  );
}
function Wp(e) {
  const t = e.split(KJ);
  return t.length === 1 && t[0] === "" ? [] : (t.at(-1) === "" && t.pop(), t);
}
function XJ(e) {
  return e ? !zJ.test(e) : !1;
}
function Ob(e) {
  return e.code === 128 ? "not-found" : "unknown";
}
async function QJ(e, t) {
  if (Ue(t)) {
    const {
      stdout: r,
      stderr: o,
      code: s,
    } = await ar({
      hostConfig: t,
      args: ["wc", "-c", e],
      timeoutMs: Ku,
    }).then((c) => c.wait());
    if (s !== 0) {
      if (_D(o)) {
        const c = new Error(`File not found: ${e}`);
        throw ((c.code = "ENOENT"), c);
      }
      throw new Error(`Failed to stat remote file: ${e}`);
    }
    const i = r.trim().split(/\s+/)[0],
      a = Number.parseInt(i ?? "", 10);
    if (Number.isNaN(a)) throw new Error(`Failed to parse file size for ${e}`);
    return a;
  }
  return (await fsPromises.stat(e)).size;
}
async function Cb(e, t) {
  if ((await QJ(e, t)) > Io)
    return {
      type: "error",
      error: {
        type: "too-large",
        limitBytes: Io,
      },
    };
  if (Ue(t)) {
    const {
      stdout: o,
      stderr: s,
      code: i,
    } = await ar({
      hostConfig: t,
      args: ["cat", e],
      timeoutMs: Ku,
    }).then((a) => a.wait());
    return i !== 0
      ? _D(s)
        ? {
            type: "error",
            error: {
              type: "not-found",
            },
          }
        : {
            type: "error",
            error: {
              type: "unknown",
            },
          }
      : {
          type: "success",
          lines: Wp(o),
        };
  }
  const r = await fsPromises.readFile(e, "utf8");
  return {
    type: "success",
    lines: Wp(r),
  };
}
async function JJ(e, t, n, r, o) {
  const s = await re(e, ["cat-file", "-s", t], n, {
    signal: r,
    timeoutMs: o ? Ku : void 0,
  });
  if (!s.success)
    return {
      type: "error",
      error: {
        type: Ob(s),
      },
    };
  const i = Number.parseInt(s.stdout, 10);
  if (!Number.isNaN(i) && i > Io)
    return {
      type: "error",
      error: {
        type: "too-large",
        limitBytes: Io,
      },
    };
  const a = await re(e, ["cat-file", "-p", t], n, {
    maxOutputBytes: Io,
    signal: r,
    timeoutMs: o ? Ku : void 0,
    trim: !1,
  });
  return a.outputLimitExceeded
    ? {
        type: "error",
        error: {
          type: "too-large",
          limitBytes: Io,
        },
      }
    : a.success
      ? {
          type: "success",
          lines: Wp(a.stdout),
        }
      : {
          type: "error",
          error: {
            type: Ob(a),
          },
        };
}
async function vh(e, t, n, r) {
  const o = await re(e, ["rev-parse", t], n, {
      allowedNonZeroExitCodes: [128],
      signal: r,
    }),
    s = o.success ? o.stdout.trim() : null;
  if (s && !Nc(s)) throw new Error(`Unexpected ${t} SHA: ${s}`);
  return s ? s : null;
}
async function pD(e, t, n) {
  const r = await vh(e, "HEAD", t, n);
  if (r && !Nc(r)) throw new Error(`Unexpected HEAD SHA: ${r}`);
  return r ? r : null;
}
async function e8(e, t, n, r) {
  const o = await vh(e, `${t}^{tree}`, n, r);
  if (o && !Nc(o)) throw new Error(`Unexpected ${t} SHA: ${o}`);
  return o ? o : null;
}
const bb = 1024;
async function t8({
  gitRoot: e,
  targetRoot: t,
  branchName: n,
  headCommitSha: r,
  treeSha: o,
  targetCurrentBranch: s,
  hostConfig: i,
  signal: a,
}) {
  const c = AL("syncedBranch.overwrite"),
    l = t ? await pD(t, i, a) : null,
    f = await e8(e, r, i, a);
  if (!f)
    return {
      status: "command-error",
    };
  const u = o && o !== f && (!t || !(!s || s === n));
  let _;
  if (u) {
    const T = await qp(e, o, i, {
      parentSha: r,
      signal: a,
    });
    if (!T.success)
      return {
        status: "command-error",
        execOutput: Jn({
          command: "git commit-tree",
          stdout: "",
          stderr: T.error.stderr,
          fallbackOutput:
            T.error.stderr ||
            T.error.stdout ||
            "Failed to create synthetic commit",
        }),
      };
    _ = T.commitSha;
  } else _ = r;
  const [p, E] = await Promise.all([
      e && _ !== r
        ? await re(e, ["reset", "--hard", _], i, {
            signal: a,
          })
        : null,
      t
        ? await re(t, ["update-ref", s ? `refs/heads/${s}` : "HEAD", _], i, {
            signal: a,
          })
        : e
          ? await re(e, ["branch", "-f", n, _], i, {
              signal: a,
            })
          : null,
    ]),
    h = E && !E.success ? E : p?.success === !1 ? p : null;
  if (h) {
    const T = h.stderr || h.stdout || "Failed to reset branch";
    return {
      status: "command-error",
      execOutput: Jn({
        command: h.command,
        stdout: h.stdout,
        stderr: h.stderr,
        fallbackOutput: T,
      }),
    };
  }
  if (t) {
    const T = await re(t, ["reset", "--mixed", "HEAD"], i, {
      signal: a,
    });
    if (!T.success) {
      const g = T.stderr || T.stdout || "Failed to reset index";
      return {
        status: "command-error",
        execOutput: Jn({
          command: T.command,
          stdout: T.stdout,
          stderr: T.stderr,
          fallbackOutput: g,
        }),
      };
    }
    const m = o ? o : f;
    l &&
      (await r8({
        gitRoot: t,
        baseRef: l,
        treeToRestore: m,
        hostConfig: i,
        signal: a,
        logger: c,
      }));
    const A = await re(
      t,
      ["restore", "--source", m, "--worktree", "--", "."],
      i,
      {
        signal: a,
      },
    );
    if (!A.success) {
      const g = A.stderr || A.stdout || "Failed to restore working tree";
      return {
        status: "command-error",
        execOutput: Jn({
          command: A.command,
          stdout: A.stdout,
          stderr: A.stderr,
          fallbackOutput: g,
        }),
      };
    }
  }
  return (
    c.info("Synced branch applied to branch checkout"),
    {
      status: "success",
    }
  );
}
async function n8(e, t, n, r) {
  let o = null;
  for (const s of o8(t)) {
    const i = await re(e, ["clean", "-fd", "--", ...s], n, {
      signal: r,
    });
    if (!i.success) {
      o = i;
      break;
    }
  }
  return o;
}
async function r8({
  gitRoot: e,
  baseRef: t,
  treeToRestore: n,
  hostConfig: r,
  signal: o,
  logger: s,
}) {
  const i = await re(
    e,
    ["diff", "--name-only", "--diff-filter=D", "--no-renames", t, n],
    r,
    {
      allowedNonZeroExitCodes: [1],
      signal: o,
    },
  );
  if (!i.success) {
    s.warning(
      "Failed to compute deleted paths before cleaning untracked files.",
    );
    return;
  }
  const a =
    i.stdout.length > 0
      ? i.stdout
          .split(
            `
`,
          )
          .map((l) => l.trim())
          .filter((l) => l.length > 0)
      : [];
  if (a.length === 0) return;
  (await n8(e, a, r, o)) &&
    s.warning(
      "Failed to clean untracked files for deleted paths before restore.",
    );
}
function o8(e) {
  const t = [];
  for (let n = 0; n < e.length; n += bb) t.push(e.slice(n, n + bb));
  return t;
}
async function s8(e, t, n) {
  const r = await re(e, ["ls-files", "-u"], t, {
    signal: n,
  });
  return r.success ? r.stdout.trim().length > 0 : !1;
}
async function i8(e, t, n) {
  const r = await bh(e, t, n);
  if (!r)
    return {
      branch: null,
      base: null,
      hasConflicts: !1,
    };
  const o = await s8(e, t, n);
  return {
    branch: Mh(r.branch),
    base: r.lastSyncedTreeRef,
    hasConflicts: o,
  };
}
const ED = {
  filesChanged: 0,
  linesAdded: 0,
  linesRemoved: 0,
};
async function Ib(e, t, n, r, o) {
  const s = await $n(e, ["--numstat", t, n], r, {
    allowedNonZeroExitCodes: [0, 1],
    signal: o,
  });
  return !s.success || !s.stdout ? ED : a8(s.stdout);
}
function a8(e) {
  const t = e.trim();
  if (!t) return ED;
  let n = 0,
    r = 0,
    o = 0;
  for (const s of t.split(/\r?\n/)) {
    const i = s.trim();
    if (!i) continue;
    const [a, c, ...l] = i.split("	");
    !a || !c || l.length === 0 || ((n += 1), (r += Pb(a)), (o += Pb(c)));
  }
  return {
    filesChanged: n,
    linesAdded: r,
    linesRemoved: o,
  };
}
function Pb(e) {
  if (e === "-") return 0;
  const t = Number.parseInt(e, 10);
  return Number.isFinite(t) ? t : 0;
}
async function c8(e, t, n, r) {
  return (
    (await uD(e, n, r)).find((s) =>
      s.headRef.type !== "branch" ? !1 : s.headRef.string === t,
    )?.root ?? null
  );
}
async function u8(e, t, n, r) {
  const o = await vh(e, t, n, r);
  if (o && !Nc(o)) throw new Error(`Unexpected ${t} SHA: ${o}`);
  return o ? o : null;
}
const l8 = xt("git");
async function d8(e, t, n, r) {
  const o = await t.getWorktreeRepository(e, n);
  if (!o)
    throw new Error("Unable to resolve git root for synced branch status.");
  const s = o.root,
    i = o.getUntrackedPaths(),
    a = await bh(e, n, r);
  if (!a)
    throw new Error("No synced branch config found for the current worktree.");
  try {
    const c = Mh(a.branch),
      l = ru(s, {
        hostConfig: n,
        signal: r,
        untrackedPathsPromise: i,
      }),
      [f, d, u, _, p] = await Promise.all([
        c8(s, c, n, r),
        pD(s, n, r),
        l,
        u8(s, a.branch, n, r),
        Yo(s, n, r),
      ]);
    if (p) throw new Error("Worktree has a branch checked out.");
    if (d) {
      if (!_) throw new Error("Unable to resolve synced branch head SHA.");
    } else throw new Error("Unable to resolve worktree head state.");
    const E = f == null ? null : await t.getWorktreeRepository(f, n);
    let h;
    if (!f) h = Promise.resolve(null);
    else if (f === s)
      h = ru(f, {
        hostConfig: n,
        signal: r,
        untrackedPathsPromise: i,
      });
    else if (E)
      h = ru(f, {
        hostConfig: n,
        signal: r,
        untrackedPathsPromise: E.getUntrackedPaths(),
      });
    else
      throw new Error(
        "Unable to resolve repository for synced branch worktree.",
      );
    const T = ZL(s, _, d, n, r),
      [m, A] = await Promise.all([T, h]),
      g = (I) => ({
        leftRef: I,
        rightRef: I,
        filesChanged: 0,
        linesAdded: 0,
        linesRemoved: 0,
      }),
      N = u
        ? {
            ...(await Ib(s, d, u, n, r)),
            leftRef: d,
            rightRef: u,
          }
        : g(d),
      O =
        f && A
          ? {
              ...(await Ib(f, _, A, n, r)),
              leftRef: _,
              rightRef: A,
            }
          : g(_);
    return {
      branch: a.branch,
      worktreeSnapshot: {
        root: s,
        headCommitSha: d,
        workingTreeRef: u ?? void 0,
      },
      branchSnapshot: f
        ? {
            checkedOut: !0,
            snapshot: {
              root: f,
              headCommitSha: _,
              workingTreeRef: A ?? void 0,
            },
          }
        : {
            checkedOut: !1,
            headCommitSha: _,
          },
      localCommitsAhead: m?.leftAhead ?? 0,
      worktreeCommitsAhead: m?.rightAhead ?? 0,
      localUncommittedDiffStats: O,
      worktreeUncommittedDiffStats: N,
    };
  } catch (c) {
    throw (
      l8().warning(`failed to collect synced branch status: ${String(c)}`),
      c
    );
  }
}
class f8 {
  constructor(t) {
    this.emit = t;
  }
}
async function _8(e, t) {
  return Oh(e, "HEAD", t);
}
class p8 {
  constructor(t) {
    ((this.options = t),
      (this.emitHeadChangedDebounced = X_(() => {
        const n = {
          type: "git-repo-changed",
          changeType: "head",
          commonDir: this.options.commonDir,
          root: this.options.root,
        };
        this.options.emit({
          type: "worker-event",
          event: n,
        });
      }, 500)),
      (this.emitRemoteRefsChangedDebounced = X_(() => {
        const n = {
          type: "git-repo-changed",
          changeType: "remote-refs",
          commonDir: this.options.commonDir,
          root: this.options.root,
        };
        this.options.emit({
          type: "worker-event",
          event: n,
        });
      }, 500)),
      (this.emitSyncedBranchChangedDebounced = X_(() => {
        const n = {
          type: "git-repo-changed",
          changeType: "synced-branch",
          commonDir: this.options.commonDir,
          root: this.options.root,
        };
        this.options.emit({
          type: "worker-event",
          event: n,
        });
      }, 500)));
  }
  logger = Bl("git-repo-watcher");
  watchers = [];
  emitHeadChangedDebounced;
  emitRemoteRefsChangedDebounced;
  emitSyncedBranchChangedDebounced;
  async start() {
    this.logger.info("Starting git repo watcher");
    const t = await _8(this.options.root, this.options.hostConfig),
      n = await aJ(this.options.root, this.options.hostConfig);
    (await this.tryWatch(t, this.emitHeadChangedDebounced),
      await this.tryWatch(
        path2.join(this.options.commonDir, "FETCH_HEAD"),
        this.emitRemoteRefsChangedDebounced,
      ),
      await this.tryWatch(
        path2.join(this.options.commonDir, "packed-refs"),
        this.emitRemoteRefsChangedDebounced,
      ),
      await this.tryWatch(n, this.emitSyncedBranchChangedDebounced));
  }
  dispose() {
    (this.watchers.forEach((t) => {
      t.close();
    }),
      (this.watchers.length = 0));
  }
  async tryWatch(t, n) {
    if (t)
      try {
        const r = path2.dirname(t),
          o = path2.basename(t);
        let s = await Mb(t);
        const i = fs.watch(r, (a, c) => {
          (c && c !== o) ||
            Mb(t).then((l) => {
              (a !== "rename" && l === s) || ((s = l), n());
            });
        });
        this.watchers.push(i);
      } catch (r) {
        this.logger.warning(
          `Failed to watch git path (${path2.basename(t)}, ${ot(r)})`,
        );
      }
  }
}
async function Mb(e) {
  try {
    return (await fs.promises.stat(e)).mtimeMs;
  } catch {
    return null;
  }
}
const E8 = xt("git");
class h8 extends f8 {
  constructor(t, n) {
    (super(t), (this.gitManager = n));
  }
  watchesByKey = new Map();
  inFlightRequests = new Map();
  canceledRequests = new Set();
  uncancelableRequestIds = new Set();
  worktreeDeletePromises = new Map();
  async handleRequest(t) {
    const n = new AbortController(),
      r = t.params.hostConfig ?? null,
      o =
        t.method !== "delete-worktree" &&
        t.method !== "invalidate-stable-metadata" &&
        t.method !== "git-init-repo";
    if (o) {
      if (
        (this.inFlightRequests.set(t.id, n), this.canceledRequests.has(t.id))
      ) {
        (this.canceledRequests.delete(t.id),
          n.abort(),
          this.inFlightRequests.delete(t.id));
        return;
      }
    } else
      (this.uncancelableRequestIds.add(t.id),
        this.canceledRequests.delete(t.id));
    let s;
    try {
      switch (t.method) {
        case "stable-metadata": {
          s = await this.handleResolveStableMetadata(t.params, {
            hostConfig: r,
          });
          break;
        }
        case "current-branch": {
          const a = await Yo(t.params.root, r, n.signal);
          s = Oe({
            branch: a,
          });
          break;
        }
        case "upstream-branch": {
          const a = await this.handleUpstreamBranch(t.params, {
            hostConfig: r,
            signal: n.signal,
          });
          s = Oe(a);
          break;
        }
        case "branch-ahead-count": {
          const a = await this.handleBranchAheadCount(t.params, {
            hostConfig: r,
            signal: n.signal,
          });
          s = Oe(a);
          break;
        }
        case "default-branch": {
          s = await this.handleDefaultBranch(t.params, {
            hostConfig: r,
            signal: n.signal,
          });
          break;
        }
        case "base-branch": {
          s = await this.handleBaseBranch(t.params, {
            hostConfig: r,
            signal: n.signal,
          });
          break;
        }
        case "recent-branches": {
          s = await this.handleRecentBranches(t.params, {
            hostConfig: r,
            signal: n.signal,
          });
          break;
        }
        case "branch-changes": {
          const a = await $J(this.gitManager, t.params.cwd, r, n.signal);
          s = Oe(a);
          break;
        }
        case "status-summary": {
          const a = await fJ(String(t.params.cwd), r, n.signal);
          s = Oe(a);
          break;
        }
        case "staged-and-unstaged-changes": {
          const a = await pJ(
            String(t.params.cwd),
            this.gitManager,
            r,
            n.signal,
            t.params.paths,
          );
          s = Oe(a);
          break;
        }
        case "untracked-changes": {
          const a = await EJ(
            String(t.params.cwd),
            this.gitManager,
            r,
            n.signal,
            t.params.paths,
          );
          s = Oe(a);
          break;
        }
        case "synced-branch": {
          const a = await i8(t.params.cwd, r, n.signal);
          s = Oe(a);
          break;
        }
        case "synced-branch-state": {
          const a = await d8(t.params.cwd, this.gitManager, r, n.signal);
          s = Oe(a);
          break;
        }
        case "overwrite-repo": {
          const a = await t8({
            ...t.params,
            hostConfig: r,
            signal: n.signal,
          });
          s = Oe(a);
          break;
        }
        case "invalidate-stable-metadata": {
          (this.gitManager.invalidateStableMetadata(),
            (s = Oe({
              success: !0,
            })));
          break;
        }
        case "git-init-repo": {
          s = Oe(await TJ(t.params, this.gitManager, r));
          break;
        }
        case "tracked-uncommitted-changes": {
          const a = await WJ(t.params.cwd, r, n.signal);
          s = Oe(a);
          break;
        }
        case "submodule-paths": {
          const a = await qJ(t.params.root, r, n.signal);
          s = Oe({
            paths: a,
          });
          break;
        }
        case "cat-file": {
          const a = await ZJ(
            this.gitManager,
            {
              cwd: t.params.cwd,
              oid: t.params.oid,
              path: t.params.path,
              fallbackToDisk: t.params.fallbackToDisk,
            },
            r,
            n.signal,
          );
          s = Oe(a);
          break;
        }
        case "index-info": {
          const a = await jJ(t.params.cwd, r, n.signal);
          s = Oe(a);
          break;
        }
        case "config-value": {
          const a = await this.gitManager.getWorktreeRepository(
              t.params.root,
              r,
            ),
            c = a
              ? await a.getConfigValueForScope(
                  t.params.key,
                  t.params.scope,
                  n.signal,
                )
              : null;
          s = Oe({
            value: c,
          });
          break;
        }
        case "set-config-value": {
          const a = await this.gitManager.getWorktreeRepository(
              t.params.root,
              r,
            ),
            c = a
              ? await a.setConfigValueForScope(
                  t.params.key,
                  t.params.value,
                  t.params.scope,
                  n.signal,
                )
              : !1;
          s = Oe({
            success: c,
          });
          break;
        }
        case "create-worktree": {
          s = await this.handleCreateWorktree(t.params, {
            hostConfig: r,
            signal: n.signal,
          });
          break;
        }
        case "codex-worktree": {
          try {
            const a = await FJ();
            s = Oe({
              worktrees: a,
            });
          } catch (a) {
            const c = a instanceof Error ? a.message : String(a);
            s = Va(c);
          }
          break;
        }
        case "list-worktrees": {
          const a = await uD(t.params.cwd, r, n.signal);
          s = Oe({
            worktrees: a,
          });
          break;
        }
        case "worktree-snapshot-ref": {
          const a = await PJ(
            this.gitManager,
            t.params.candidateRoots,
            t.params.worktreePath,
            r,
            n.signal,
          );
          s = Oe(a);
          break;
        }
        case "restore-worktree": {
          const a = await MJ(
            t.params.repoRoot,
            t.params.worktreePath,
            r,
            n.signal,
          );
          s = Oe({
            success: a,
          });
          break;
        }
        case "delete-worktree": {
          const a = await this.scheduleWorktreeDelete(t.params);
          s = Oe({
            success: a,
          });
          break;
        }
        case "apply-changes": {
          const a = await kJ({
            ...t.params,
            gitManager: this.gitManager,
            hostConfig: r,
            signal: n.signal,
          });
          s = Oe(a);
          break;
        }
        case "commit": {
          const a = await this.gitManager.getWorktreeRepository(
            t.params.cwd,
            r,
          );
          a?.getUntrackedPaths.clear();
          const c = a?.root,
            l = c ?? String(t.params.cwd);
          if (t.params.includeUnstaged) {
            const _ = c
              ? await dD({
                  gitRoot: c,
                  env: process.env,
                  signal: n.signal,
                  hostConfig: r,
                  untrackedPathsPromise: a.getUntrackedPaths(),
                })
              : await re(l, ["add", "-A"], r, {
                  signal: n.signal,
                });
            if (!_.success) {
              const p = _.stderr || _.stdout || "Failed to stage changes";
              s = Oe({
                status: "error",
                error: p,
                execOutput: Jn({
                  command: _.command,
                  stdout: _.stdout,
                  stderr: _.stderr,
                  fallbackOutput: p,
                }),
              });
              break;
            }
          }
          const f = await re(l, ["commit", "-m", t.params.message], r, {
            signal: n.signal,
          });
          if (!f.success) {
            const _ = f.stderr || f.stdout || "Failed to commit changes";
            s = Oe({
              status: "error",
              error: _,
              execOutput: Jn({
                command: f.command,
                stdout: f.stdout,
                stderr: f.stderr,
                fallbackOutput: _,
              }),
            });
            break;
          }
          const d = await re(l, ["rev-parse", "HEAD"], r, {
              signal: n.signal,
            }),
            u = d.success ? d.stdout : null;
          s = Oe({
            status: "success",
            commitSha: u,
          });
          break;
        }
      }
    } catch (a) {
      s = Va(a);
    } finally {
      if (S8(t.method)) {
        const a = T8(t);
        this.gitManager.invalidateUntrackedPathsCache(a, r);
      }
      (o
        ? this.inFlightRequests.delete(t.id)
        : this.uncancelableRequestIds.delete(t.id),
        this.canceledRequests.delete(t.id));
    }
    if (o && n.signal.aborted) return;
    const i = {
      id: t.id,
      method: t.method,
      result: s,
    };
    this.emit({
      type: "worker-response",
      response: i,
    });
  }
  async deleteWorktreeWithLimit(t) {
    try {
      await IJ(this.gitManager, t.worktree, t.hostConfig, t.reason);
    } catch (n) {
      E8().warning(
        `[worktree-snapshot] failed to snapshot worktree (${ot(n)})`,
      );
    }
    return (await qu(t.worktree, t.hostConfig, t.force ?? !1), !0);
  }
  async scheduleWorktreeDelete(t) {
    const r = `${t.hostConfig?.id ?? "local"}|${t.worktree}`,
      o = this.worktreeDeletePromises.get(r);
    if (o) return o;
    const s = this.deleteWorktreeWithLimit(t);
    this.worktreeDeletePromises.set(r, s);
    try {
      return await s;
    } finally {
      this.worktreeDeletePromises.delete(r);
    }
  }
  async handleResolveStableMetadata(t, { hostConfig: n }) {
    const r = await this.gitManager.getStableMetadata(t.cwd, n);
    if (!r) return Va("Not a git repository");
    const o = {
      commonDir: r.commonDir,
      root: r.root,
    };
    return (await this.ensureWatching(o, n), Oe(o));
  }
  async handleUpstreamBranch(t, { hostConfig: n, signal: r }) {
    const o = await Yo(t.root, n, r),
      s = await re(
        t.root,
        ["rev-parse", "--abbrev-ref", "--symbolic-full-name", "@{u}"],
        n,
        {
          signal: r,
          allowedNonZeroExitCodes: [128, 1],
        },
      ),
      i = s.success && s.stdout ? s.stdout : null;
    return i
      ? {
          branch: o,
          upstream: {
            branch: i,
          },
        }
      : {
          branch: o,
          upstream: null,
        };
  }
  async handleBranchAheadCount(t, { hostConfig: n, signal: r }) {
    const o = await Qa(t.root, n, r),
      s = o?.branch ?? null;
    let i = o?.remote ?? null;
    i || (i = (await nD(t.root, n, r))[0] ?? null);
    const a = await re(
        t.root,
        ["rev-parse", "--abbrev-ref", "--symbolic-full-name", "@{u}"],
        n,
        {
          signal: r,
          allowedNonZeroExitCodes: [128, 1],
        },
      ),
      c = a.success && a.stdout ? a.stdout : null,
      l = async () => {
        if (!c) return 0;
        const h = await re(t.root, ["rev-list", "--count", `${c}..HEAD`], n, {
          allowedNonZeroExitCodes: [128, 1],
          signal: r,
        });
        if (h.success && h.stdout) {
          const T = Number.parseInt(h.stdout, 10);
          return Number.isNaN(T) ? 0 : T;
        }
        return 0;
      },
      f = async () => {
        if (!i) return null;
        const h = await re(
          t.root,
          ["rev-list", "--count", "HEAD", "--not", `--remotes=${i}`],
          n,
          {
            allowedNonZeroExitCodes: [128, 1],
            signal: r,
          },
        );
        if (h.success && h.stdout) {
          const T = Number.parseInt(h.stdout, 10);
          return Number.isNaN(T) ? null : T;
        }
        return null;
      },
      d = async () => {
        if (!s) return 0;
        const h = s.includes("/") ? s : i ? `${i}/${s}` : s,
          T = await aD(t.root, h, n, r);
        if (T) {
          const m = await re(t.root, ["rev-list", "--count", `${T}..HEAD`], n, {
            allowedNonZeroExitCodes: [128, 1],
            signal: r,
          });
          if (m.success && m.stdout) {
            const A = Number.parseInt(m.stdout, 10);
            return Number.isNaN(A) ? 0 : A;
          }
        }
        return 0;
      },
      [u, _, p] = await Promise.all([l(), f(), d()]);
    let E = p;
    return (
      _ != null ? (E = _) : c != null && (E = u),
      {
        commitsAhead: E,
      }
    );
  }
  async handleDefaultBranch(t, { hostConfig: n, signal: r }) {
    let s = (await Qa(t.root, n, r))?.branch ?? null;
    return (
      s ||
        (s =
          (await yb(t.root, 10, n, r)).find(
            (a) => a === "main" || a === "master",
          ) ?? null),
      Oe({
        branch: s,
      })
    );
  }
  async handleBaseBranch(t, { hostConfig: n, signal: r }) {
    const o = await Qa(t.root, n, r);
    return Oe({
      local: o?.branch ?? null,
      remote: o?.remote ?? null,
    });
  }
  async handleRecentBranches(t, { hostConfig: n, signal: r }) {
    const o = Math.max(1, Math.min(t.limit ?? 10, 100)),
      s = await yb(t.root, o, n, r);
    return Oe({
      branches: s,
    });
  }
  async handleCreateWorktree(t, { hostConfig: n, signal: r }) {
    const o = this.emit.bind(this),
      s = t.streamId;
    if (!(await this.gitManager.getRepoRepository(t.cwd, n)))
      return Va("Not a git repository (not repo repository)");
    const a = await uJ({
      gitManager: this.gitManager,
      workspaceRoot: t.cwd,
      startingState: t.startingState,
      localEnvironmentConfigPath: t.localEnvironmentConfigPath,
      hostConfig: n,
      signal: r,
      onLog: (c, l) => {
        r.aborted ||
          o({
            type: "worker-event",
            event: {
              type: "create-worktree-stream",
              streamId: s,
              stream: c,
              data: l,
            },
          });
      },
    });
    return a.success
      ? Oe({
          worktreeGitRoot: a.worktreeGitRoot,
          worktreeWorkspaceRoot: a.worktreeWorkspaceRoot,
        })
      : Va(a.error.message);
  }
  getWatchKey(t, n) {
    return `${n?.id ?? "local"}|${t}`;
  }
  async ensureWatching(t, n) {
    const r = this.getWatchKey(t.root, n);
    if (this.watchesByKey.get(r)) return;
    const s = new p8({
      commonDir: t.commonDir,
      root: t.root,
      hostConfig: n,
      emit: this.emit,
    });
    (this.watchesByKey.set(r, s), await s.start());
  }
  handleCancel(t) {
    if (this.uncancelableRequestIds.has(t)) return;
    const n = this.inFlightRequests.get(t);
    if (!n) {
      this.canceledRequests.add(t);
      return;
    }
    (this.inFlightRequests.delete(t), n.abort());
  }
}
function T8(e) {
  return typeof e.params.cwd == "string"
    ? e.params.cwd
    : typeof e.params.root == "string"
      ? e.params.root
      : null;
}
function S8(e) {
  switch (e) {
    case "overwrite-repo":
    case "git-init-repo":
    case "create-worktree":
    case "restore-worktree":
    case "delete-worktree":
    case "apply-changes":
    case "commit":
      return !0;
    case "stable-metadata":
    case "current-branch":
    case "upstream-branch":
    case "branch-ahead-count":
    case "default-branch":
    case "base-branch":
    case "recent-branches":
    case "branch-changes":
    case "status-summary":
    case "staged-and-unstaged-changes":
    case "untracked-changes":
    case "tracked-uncommitted-changes":
    case "submodule-paths":
    case "cat-file":
    case "synced-branch":
    case "synced-branch-state":
    case "index-info":
    case "config-value":
    case "set-config-value":
    case "list-worktrees":
    case "codex-worktree":
    case "worktree-snapshot-ref":
    case "invalidate-stable-metadata":
      return !1;
  }
}
function m8(e, t, n) {
  switch (e) {
    case "git":
      return new h8(n, t);
  }
}
function A8() {
  const e = process.platform,
    t = process.env,
    n = os2.homedir();
  if (e === "darwin")
    return path2.join(n, "Library", "Logs", "com.openai.codex");
  if (e === "win32") {
    const r = t.LOCALAPPDATA ?? path2.join(n, "AppData", "Local");
    return path2.join(r, "Codex", "Logs");
  }
  if (e === "linux") {
    const r = t.XDG_STATE_HOME ?? path2.join(n, ".local", "state");
    return path2.join(r, "codex", "logs");
  }
  return path2.join(n, ".codex", "logs");
}
const vb = 10 * 1024 * 1024,
  Lb = 5,
  Db = 1e4,
  g8 = 1024 * 1024,
  R8 = 15;
function Ja(e) {
  return e.toString().padStart(2, "0");
}
function wb(e, t) {
  const n = t.getUTCFullYear().toString(),
    r = Ja(t.getUTCMonth() + 1),
    o = Ja(t.getUTCDate());
  return path2.join(e, n, r, o);
}
function np(e, t, n, r) {
  return e > 0
    ? e
    : (n(new Error(`[file-logger] invalid ${r}`), {
        [r]: e,
      }),
      t);
}
function Ub(e, t, n, r, o) {
  return `codex-desktop-${e}-${t}-t${n}-i${r}-${Ja(o.getUTCHours())}${Ja(o.getUTCMinutes())}${Ja(o.getUTCSeconds())}`;
}
let kb = 0;
function N8() {
  return ((kb += 1), kb);
}
function y8(e, t, n, r) {
  try {
    const o = new Date(
        Date.UTC(t.getUTCFullYear(), t.getUTCMonth(), t.getUTCDate()),
      ),
      s = new Date(o);
    s.setUTCDate(s.getUTCDate() - (n - 1));
    for (const i of fs.readdirSync(e)) {
      if (!/^\d{4}$/.test(i)) continue;
      const a = Number(i);
      if (!Number.isFinite(a)) continue;
      const c = path2.join(e, i);
      for (const l of fs.readdirSync(c)) {
        if (!/^\d{2}$/.test(l)) continue;
        const f = Number(l);
        if (!Number.isFinite(f) || f < 1 || f > 12) continue;
        const d = path2.join(c, l);
        for (const u of fs.readdirSync(d)) {
          if (!/^\d{2}$/.test(u)) continue;
          const _ = Number(u);
          if (!Number.isFinite(_) || _ < 1 || _ > 31) continue;
          new Date(Date.UTC(a, f - 1, _)) < s &&
            fs.rmSync(path2.join(d, u), {
              recursive: !0,
              force: !0,
            });
        }
        fs.readdirSync(d).length === 0 &&
          fs.rmSync(d, {
            recursive: !0,
            force: !0,
          });
      }
      fs.readdirSync(c).length === 0 &&
        fs.rmSync(c, {
          recursive: !0,
          force: !0,
        });
    }
  } catch (o) {
    r(new Error("[file-logger] failed to prune old logs"), {
      rootDir: e,
      retentionDays: n,
      error: o instanceof Error ? o.message : String(o),
    });
  }
}
function O8(e, t = {}) {
  const n = (A, g) =>
      e.nonFatalReporter.reportNonFatal(A, {
        kind: "file-based-logger",
        extra: g,
      }),
    r = e.rootDir ?? A8(),
    o = t.processId ?? process.pid,
    s = t.threadId ?? workerThreads.threadId ?? 0,
    i = t.instanceId ?? N8(),
    a = e.appSessionId,
    c = t.now ?? (() => new Date()),
    l = e.maxSegmentBytes ?? vb,
    f = e.maxSegments ?? Lb,
    d = e.pendingLineLimit ?? Db,
    u = e.highWaterMarkBytes ?? g8,
    _ = R8,
    p =
      t.createStream ??
      ((A, g) =>
        fs.createWriteStream(A, {
          flags: "w",
          highWaterMark: g,
        })),
    E = np(f, Lb, n, "maxSegments"),
    h = np(l, vb, n, "maxSegmentBytes"),
    T = np(d, Db, n, "pendingLineLimit"),
    m = {
      logLine: () => {},
    };
  try {
    const A = c();
    let g = wb(r, A);
    (fs.mkdirSync(g, {
      recursive: !0,
    }),
      y8(r, A, _, n));
    let N = Ub(a, o, s, i, A);
    const O = (ne) => path2.join(g, `${N}-${ne}.log`);
    let I = !1;
    const b = (ne) => {
        ((I = !0),
          n(new Error("[file-logger] stream error"), {
            error: ne instanceof Error ? ne.message : String(ne),
            rootDir: r,
            appSessionId: a,
            processId: o,
            threadId: s,
            instanceId: i,
          }));
      },
      w = (ne) => (
        ne.on("error", (P) => {
          b(P);
        }),
        ne
      );
    let L = 0,
      j = 0,
      H = w(p(O(L), u)),
      x = [],
      B = 0,
      F = !1,
      U = 0;
    const k = () => {
        const ne = c(),
          P = wb(r, ne);
        P !== g &&
          ((g = P),
          fs.mkdirSync(g, {
            recursive: !0,
          }),
          (N = Ub(a, o, s, i, ne)),
          H.end(),
          (L = 0),
          (j = 0),
          (U = 0),
          (H = w(p(O(L), u))));
      },
      Y = () => {
        (H.end(), (L = (L + 1) % E), (j = 0), (H = w(p(O(L), u))));
      },
      oe = () => {
        if (U === 0) return;
        const ne = `[file-logger] dropped ${U} lines due to backpressure
`;
        (x.push({
          text: ne,
          bytes: Buffer.byteLength(ne),
        }),
          (U = 0));
      },
      ae = () => {
        if (I) {
          ((x = []), (B = 0), (U = 0));
          return;
        }
        if (F) return;
        F = !0;
        let ne = !1;
        try {
          for (; !(B >= x.length && (oe(), B >= x.length)); ) {
            const P = x[B];
            j + P.bytes > h && Y();
            const M = H.write(P.text);
            if (((j += P.bytes), (B += 1), !M)) {
              ((ne = !0),
                H.once("drain", () => {
                  ((F = !1), ae());
                }));
              return;
            }
          }
          ((x = []), (B = 0));
        } catch (P) {
          (n(new Error("[file-logger] write failed"), {
            error: P instanceof Error ? P.message : String(P),
            rootDir: r,
            appSessionId: a,
            processId: o,
            threadId: s,
            instanceId: i,
            maxSegments: E,
            maxSegmentBytes: h,
            pendingLineLimit: T,
          }),
            (x = []),
            (B = 0));
        } finally {
          F && !ne && (F = !1);
        }
      };
    return {
      logLine: (ne) => {
        if (!I)
          try {
            !F && x.length === 0 && k();
            const P = `${ne}
`;
            if (x.length - B >= T) {
              U += 1;
              return;
            }
            (x.push({
              text: P,
              bytes: Buffer.byteLength(P),
            }),
              ae());
          } catch (P) {
            n(new Error("[file-logger] logLine threw"), {
              error: P instanceof Error ? P.message : String(P),
              rootDir: r,
              appSessionId: a,
              processId: o,
              threadId: s,
              instanceId: i,
            });
          }
      },
    };
  } catch {
    return (
      n(new Error("[file-logger] failed to initialize"), {
        rootDir: r,
        appSessionId: a,
        processId: o,
        threadId: s,
        instanceId: i,
      }),
      m
    );
  }
}
const C8 = {
  colors: !1,
  depth: 8,
  maxArrayLength: 100,
};
function b8(...e) {
  return util.formatWithOptions(C8, ...e);
}
function I8(e, t) {
  switch (e) {
    case "error":
      console.error(t);
      break;
    case "warning":
      console.warn(t);
      break;
    case "info":
      console.info(t);
      break;
    case "debug":
      console.debug(t);
      break;
    case "trace":
      console.log(t);
      break;
  }
}
function P8(e, t, n, r) {
  const o = O8({
      appSessionId: n,
      nonFatalReporter: e,
    }),
    s = (c) => {
      const l = new Date().toISOString();
      o.logLine(`${l} ${c}`);
    },
    i =
      (c) =>
      (l, ...f) => {
        if (!LJ(c, r)) return;
        const d = b8(l, ...f);
        (I8(c, d), s(`${c} ${d}`), t.log(c, d));
      },
    a = {
      trace: i("trace"),
      debug: i("debug"),
      info: i("info"),
      warning: i("warning"),
      error: i("error"),
    };
  (rQ({
    trace: a.trace,
    debug: a.debug,
    info: a.info,
    warning: a.warning,
    error: a.error,
    log: (c, l, ...f) => {
      a[c](l, ...f);
    },
    dispose: () => {},
  }),
    cQ(() => !1));
}
const M8 = "app:///";
function v8(e, t) {
  L8(e, t);
}
function L8(e, t) {
  const n = H9(e.buildFlavor),
    r = $9(e.appVersion);
  (gz({
    dsn: V9,
    environment: e.buildFlavor,
    release: r,
    dist: e.buildNumber ?? void 0,
    tracesSampleRate: n,
    integrations: (o) => [
      ...o,
      VV({
        root: t,
        prefix: M8,
      }),
    ],
  }),
    K1("codex_app_session_id", e.codexAppSessionId),
    iQ({
      startSpan: (o, s) => Qo(o, s),
    }));
}
function D8(e, t, n) {
  if (e == null) {
    ug(null);
    return;
  }
  ug({
    id: t ?? void 0,
    email: n ?? void 0,
    auth_method: e,
  });
}
const {
  workerId: _c,
  sentryInitOptions: Po,
  sentryRewriteFramesRoot: w8,
  maxLogLevel: U8,
} = workerThreads.workerData;
v8(Po, w8);
const hD = l6((e, t, n) => {
    xe(e, {
      level: t === "fatal" ? "fatal" : "error",
      tags: n.tags,
      extra: n.extra,
    });
  }),
  TD = new c6({
    source: "codex-desktop",
    env: Po.buildFlavor,
    codexAppSessionId: Po.codexAppSessionId,
    buildInfo: {
      version: Po.appVersion,
      buildNumber: Po.buildNumber,
    },
    reportFailure: (e) => {
      hD.reportNonFatal("Datadog log sink failure", {
        kind: "datadog-log-sink-failure",
        tags: {
          failureType: e.type,
          reason: e.reason,
          workerId: _c,
        },
        extra: {
          failure: e,
        },
      });
    },
  });
P8(hD, TD, Po.codexAppSessionId, U8);
const Lh = workerThreads.parentPort;
if (!Lh) throw new Error("worker-entry must be run in a worker thread");
const SD = new MQ(),
  k8 = new gJ(SD),
  Gb = m8(_c, k8, (e) => {
    const t = {
      ...e,
      workerId: _c,
    };
    Lh.postMessage(t);
  });
Lh.on("message", (e) => {
  if (e.type === "worker-sentry-user-update") {
    D8(e.authMethod, e.userId, e.email);
    const t =
      e.authMethod == null
        ? null
        : {
            id: e.userId ?? void 0,
            email: e.email ?? void 0,
            authMethod: e.authMethod,
          };
    TD.setUserInfo(t);
    return;
  } else if (e.type === "worker-app-event") {
    SD.emit(e.event.type, e.event.at);
    return;
  } else if (e.workerId !== _c) return;
  switch (e.type) {
    case "worker-request": {
      Eh(
        {
          op: "codex.worker.request",
          name: `${_c}.${e.request.method}`,
        },
        () => Gb.handleRequest(e.request),
      );
      return;
    }
    case "worker-request-cancel": {
      Gb.handleCancel(e.id);
      return;
    }
  }
});
exports.commonjsGlobal = iu;
exports.getDefaultExportFromCjs = Qu;
//# sourceMappingURL=worker-C_GFIvBQ.js.map
